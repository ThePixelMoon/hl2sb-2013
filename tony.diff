From 5f95f3c24bb4a784b9d59174319e250a8548a82f Mon Sep 17 00:00:00 2001
From: ThePixelMoon <yourlocalmoon7@gmail.com>
Date: Sun, 28 Sep 2025 18:12:58 +0300
Subject: [PATCH] all: fix hl2mp animstate

---
 src/game/client/c_baseplayer.cpp              |    9 +
 src/game/client/c_te_effect_dispatch.cpp      |    7 +
 src/game/client/c_te_effect_dispatch.h        |    3 +
 src/game/client/client_base.vpc               |    7 +-
 src/game/client/hl2/c_basehlplayer.cpp        |    7 +
 src/game/client/hl2mp/c_hl2mp_player.cpp      |  246 +-
 src/game/client/hl2mp/c_hl2mp_player.h        |   25 +
 src/game/server/baseentity.cpp                |   23 +
 src/game/server/filters.cpp                   |    5 +
 src/game/server/hl2/hl2_player.cpp            |    7 +
 src/game/server/hl2/hl2_player.h              |   15 +-
 src/game/server/hl2mp/grenade_tripmine.cpp    |  137 +
 src/game/server/hl2mp/grenade_tripmine.h      |   28 +
 src/game/server/hl2mp/hl2mp_player.cpp        |  280 +-
 src/game/server/hl2mp/hl2mp_player.h          |   33 +
 src/game/server/physics_impact_damage.cpp     |   63 +
 src/game/server/player.cpp                    |    6 +
 src/game/server/player.h                      |    3 +
 src/game/server/server_base.vpc               |    6 +-
 src/game/shared/basecombatweapon_shared.h     |    5 +
 src/game/shared/gamemovement.cpp              |   17 +
 src/game/shared/hl2mp/hl2mp_player_shared.cpp |   10 +-
 src/game/shared/hl2mp/hl2mp_player_shared.h   |    2 +
 .../shared/hl2mp/hl2mp_playeranimstate.cpp    |  704 ++++
 src/game/shared/hl2mp/hl2mp_playeranimstate.h |   65 +
 src/game/shared/hl2mp/weapon_357.cpp          |   28 +-
 src/game/shared/hl2mp/weapon_ar2.cpp          |   18 +-
 src/game/shared/hl2mp/weapon_ar2.h            |    2 +-
 src/game/shared/hl2mp/weapon_crossbow.cpp     |   57 +-
 src/game/shared/hl2mp/weapon_crowbar.cpp      |   18 +-
 src/game/shared/hl2mp/weapon_crowbar.h        |    2 +-
 src/game/shared/hl2mp/weapon_frag.cpp         |   32 +-
 src/game/shared/hl2mp/weapon_hl2mpbase.cpp    |   14 +
 src/game/shared/hl2mp/weapon_hl2mpbase.h      |    5 +
 .../hl2mp/weapon_hl2mpbase_machinegun.cpp     |    4 +
 .../hl2mp/weapon_hl2mpbasebasebludgeon.cpp    |    4 +
 src/game/shared/hl2mp/weapon_physcannon.cpp   |   54 +-
 src/game/shared/hl2mp/weapon_physcannon.h     |    6 +-
 src/game/shared/hl2mp/weapon_pistol.cpp       |   33 +-
 src/game/shared/hl2mp/weapon_rpg.cpp          |   49 +-
 src/game/shared/hl2mp/weapon_rpg.h            |    7 +-
 src/game/shared/hl2mp/weapon_shotgun.cpp      |   45 +-
 src/game/shared/hl2mp/weapon_slam.cpp         |   81 +-
 src/game/shared/hl2mp/weapon_slam.h           |    4 +-
 src/game/shared/hl2mp/weapon_smg1.cpp         |   31 +-
 src/game/shared/hl2mp/weapon_stunstick.cpp    |   52 +-
 47 files changed, 5933 insertions(+), 37 deletions(-)
 create mode 100644 src/game/shared/hl2mp/hl2mp_playeranimstate.cpp
 create mode 100644 src/game/shared/hl2mp/hl2mp_playeranimstate.h

diff --git a/src/game/client/c_baseplayer.cpp b/src/game/client/c_baseplayer.cpp
index b5ce6728..513de79b 100644
--- a/src/game/client/c_baseplayer.cpp
+++ b/src/game/client/c_baseplayer.cpp
@@ -1905,6 +1905,15 @@ void C_BasePlayer::ThirdPersonSwitch( bool bThirdperson )
 				}
 			}
 		}
+		
+#ifdef HL2SB
+		//Notify weapon.
+		CBaseCombatWeapon *pWeapon = GetActiveWeapon();
+		if ( pWeapon )
+		{
+			pWeapon->ThirdPersonSwitch( bThirdperson );
+		}
+#endif// HL2SB
 	}
 }
 
diff --git a/src/game/client/c_te_effect_dispatch.cpp b/src/game/client/c_te_effect_dispatch.cpp
index c44718d7..16f17f56 100644
--- a/src/game/client/c_te_effect_dispatch.cpp
+++ b/src/game/client/c_te_effect_dispatch.cpp
@@ -184,6 +184,13 @@ void DispatchEffect( const char *pName, const CEffectData &data, C_RecipientFilt
 	te->DispatchEffect( filter, 0.0, data.m_vOrigin, pName, data );
 }
 
+#ifdef HL2SB
+void DispatchEffect( const char *pName, const CEffectData &data, IRecipientFilter &filter )
+{
+	te->DispatchEffect( filter, 0.0, data.m_vOrigin, pName, data );
+}
+#endif // HL2SB
+
 //-----------------------------------------------------------------------------
 // Playback
 //-----------------------------------------------------------------------------
diff --git a/src/game/client/c_te_effect_dispatch.h b/src/game/client/c_te_effect_dispatch.h
index 98be4eef..897d5eb5 100644
--- a/src/game/client/c_te_effect_dispatch.h
+++ b/src/game/client/c_te_effect_dispatch.h
@@ -43,5 +43,8 @@ class CClientEffectRegistration
 void DispatchEffectToCallback( const char *pEffectName, const CEffectData &m_EffectData );
 void DispatchEffect( const char *pName, const CEffectData &data );
 void DispatchEffect( const char *pName, const CEffectData &data, C_RecipientFilter &filter );
+#ifdef HL2SB
+void DispatchEffect( const char *pName, const CEffectData &data, IRecipientFilter &filter );
+#endif // HL2SB
 
 #endif // C_TE_EFFECT_DISPATCH_H
diff --git a/src/game/client/hl2/c_basehlplayer.cpp b/src/game/client/hl2/c_basehlplayer.cpp
index 52b223ce..d6d5741b 100644
--- a/src/game/client/hl2/c_basehlplayer.cpp
+++ b/src/game/client/hl2/c_basehlplayer.cpp
@@ -71,6 +71,13 @@ void CC_DropPrimary( void )
 
 static ConCommand dropprimary("dropprimary", CC_DropPrimary, "dropprimary: Drops the primary weapon of the player.");
 
+#ifdef HL2SB
+// link to the correct class.
+#if !defined ( HL2MP )
+LINK_ENTITY_TO_CLASS( player, C_BaseHLPlayer );
+#endif
+#endif // HL2SB
+
 //-----------------------------------------------------------------------------
 // Constructor
 //-----------------------------------------------------------------------------
diff --git a/src/game/client/hl2mp/c_hl2mp_player.cpp b/src/game/client/hl2mp/c_hl2mp_player.cpp
index 367a6163..45b881fe 100644
--- a/src/game/client/hl2mp/c_hl2mp_player.cpp
+++ b/src/game/client/hl2mp/c_hl2mp_player.cpp
@@ -14,6 +14,11 @@
 #include "iviewrender_beams.h"			// flashlight beam
 #include "r_efx.h"
 #include "dlight.h"
+#ifdef HL2SB
+#include "c_basetempentity.h"
+#include "prediction.h"
+#include "bone_setup.h"
+#endif // HL2SB
 
 // Don't alias here
 #if defined( CHL2MP_Player )
@@ -26,8 +31,55 @@
 
 ConVar sv_infinite_aux_power( "sv_infinite_aux_power", "0", FCVAR_CHEAT | FCVAR_REPLICATED );
 
+#ifdef HL2SB
+#define CYCLELATCH_TOLERANCE		0.15f
+#endif // HL2SB
+
 LINK_ENTITY_TO_CLASS( player, C_HL2MP_Player );
 
+#ifdef HL2SB
+BEGIN_RECV_TABLE_NOBASE( C_HL2MP_Player, DT_HL2MPLocalPlayerExclusive )
+	RecvPropVector( RECVINFO_NAME( m_vecNetworkOrigin, m_vecOrigin ) ),
+	RecvPropFloat( RECVINFO( m_angEyeAngles[0] ) ),
+//	RecvPropFloat( RECVINFO( m_angEyeAngles[1] ) ),
+END_RECV_TABLE()
+
+BEGIN_RECV_TABLE_NOBASE( C_HL2MP_Player, DT_HL2MPNonLocalPlayerExclusive )
+	RecvPropVector( RECVINFO_NAME( m_vecNetworkOrigin, m_vecOrigin ) ),
+	RecvPropFloat( RECVINFO( m_angEyeAngles[0] ) ),
+	RecvPropFloat( RECVINFO( m_angEyeAngles[1] ) ),
+
+	RecvPropInt( RECVINFO( m_cycleLatch ), 0, &C_HL2MP_Player::RecvProxy_CycleLatch ),
+END_RECV_TABLE()
+
+IMPLEMENT_CLIENTCLASS_DT(C_HL2MP_Player, DT_HL2MP_Player, CHL2MP_Player)
+
+	RecvPropDataTable( "hl2mplocaldata", 0, 0, &REFERENCE_RECV_TABLE(DT_HL2MPLocalPlayerExclusive) ),
+	RecvPropDataTable( "hl2mpnonlocaldata", 0, 0, &REFERENCE_RECV_TABLE(DT_HL2MPNonLocalPlayerExclusive) ),
+	RecvPropEHandle( RECVINFO( m_hRagdoll ) ),
+	RecvPropInt( RECVINFO( m_iSpawnInterpCounter ) ),
+	RecvPropInt( RECVINFO( m_iPlayerSoundType) ),
+
+	RecvPropBool( RECVINFO( m_fIsWalking ) ),
+END_RECV_TABLE()
+
+BEGIN_PREDICTION_DATA( C_HL2MP_Player )
+	DEFINE_PRED_FIELD( m_flCycle, FIELD_FLOAT, FTYPEDESC_OVERRIDE | FTYPEDESC_PRIVATE | FTYPEDESC_NOERRORCHECK ),
+	DEFINE_PRED_FIELD( m_fIsWalking, FIELD_BOOLEAN, FTYPEDESC_INSENDTABLE ),
+	DEFINE_PRED_FIELD( m_nSequence, FIELD_INTEGER, FTYPEDESC_OVERRIDE | FTYPEDESC_PRIVATE | FTYPEDESC_NOERRORCHECK ),
+	DEFINE_PRED_FIELD( m_flPlaybackRate, FIELD_FLOAT, FTYPEDESC_OVERRIDE | FTYPEDESC_PRIVATE | FTYPEDESC_NOERRORCHECK ),
+	DEFINE_PRED_ARRAY_TOL( m_flEncodedController, FIELD_FLOAT, MAXSTUDIOBONECTRLS, FTYPEDESC_OVERRIDE | FTYPEDESC_PRIVATE, 0.02f ),
+	DEFINE_PRED_FIELD( m_nNewSequenceParity, FIELD_INTEGER, FTYPEDESC_OVERRIDE | FTYPEDESC_PRIVATE | FTYPEDESC_NOERRORCHECK ),
+
+	// misyl: Ammo is server side entities in HL2MP. Not catastrophic to error about.
+	// Just let the server stomp all over us.
+	//
+	// There is 1 instance in which is can be a runaway pred error, and that is if you have eg. ar2
+	// with just altfire ammo, and get new ammo and we force reload. But the additional pred error sorts that out itself
+	// without this for every pickup which is 1000% more common.
+	DEFINE_PRED_ARRAY( m_iAmmo, FIELD_INTEGER, MAX_AMMO_TYPES, FTYPEDESC_INSENDTABLE | FTYPEDESC_OVERRIDE | FTYPEDESC_NOERRORCHECK ),
+END_PREDICTION_DATA()
+#else
 // specific to the local player
 BEGIN_RECV_TABLE_NOBASE( C_HL2MP_Player, DT_HL2MPLocalPlayerExclusive )
 	RecvPropVectorXY( RECVINFO_NAME( m_vecNetworkOrigin, m_vecOrigin ) ),
@@ -68,6 +120,7 @@ BEGIN_PREDICTION_DATA( C_HL2MP_Player )
 	// without this for every pickup which is 1000% more common.
 	DEFINE_PRED_ARRAY( m_iAmmo, FIELD_INTEGER, MAX_AMMO_TYPES, FTYPEDESC_INSENDTABLE | FTYPEDESC_OVERRIDE | FTYPEDESC_NOERRORCHECK ),
 END_PREDICTION_DATA()
+#endif // HL2SB
 
 ConVar hl2_walkspeed( "hl2_walkspeed", "150", FCVAR_REPLICATED );
 ConVar hl2_normspeed( "hl2_normspeed", "190", FCVAR_REPLICATED );
@@ -100,6 +153,22 @@ void SpawnBlood (Vector vecSpot, const Vector &vecDir, int bloodColor, float flD
 #endif
 CSuitPowerDevice SuitDeviceBreather( bits_SUIT_DEVICE_BREATHER, 6.7f );		// 100 units in 15 seconds (plus three padded seconds)
 
+#ifdef HL2SB
+C_HL2MP_Player::C_HL2MP_Player() : m_iv_angEyeAngles( "C_HL2MP_Player::m_iv_angEyeAngles" )
+{
+	m_iIDEntIndex = 0;
+	m_iSpawnInterpCounterCache = 0;
+
+	AddVar( &m_angEyeAngles, &m_iv_angEyeAngles, LATCH_SIMULATION_VAR );
+
+	m_PlayerAnimState = CreateHL2MPPlayerAnimState( this );
+	m_blinkTimer.Invalidate();
+
+	m_pFlashlightBeam = NULL;
+
+	m_flServerCycle = -1.0f;
+}
+#else
 C_HL2MP_Player::C_HL2MP_Player() : m_PlayerAnimState( this ), m_iv_angEyeAngles( "C_HL2MP_Player::m_iv_angEyeAngles" )
 {
 	m_iIDEntIndex = 0;
@@ -116,10 +185,14 @@ C_HL2MP_Player::C_HL2MP_Player() : m_PlayerAnimState( this ), m_iv_angEyeAngles(
 
 	SuitPower_Initialize();
 }
+#endif
 
 C_HL2MP_Player::~C_HL2MP_Player( void )
 {
 	ReleaseFlashlight();
+#ifdef HL2SB
+	m_PlayerAnimState->Release();
+#endif // HL2SB
 }
 
 int C_HL2MP_Player::GetIDTarget() const
@@ -220,6 +293,14 @@ CStudioHdr *C_HL2MP_Player::OnNewModel( void )
 	
 	Initialize( );
 
+#ifdef HL2SB
+	// Reset the players animation states, gestures
+	if ( m_PlayerAnimState )
+	{
+		m_PlayerAnimState->OnNewModel();
+	}
+#endif // HL2SB
+
 	return hdr;
 }
 
@@ -362,6 +443,7 @@ void C_HL2MP_Player::DoImpactEffect( trace_t &tr, int nDamageType )
 
 void C_HL2MP_Player::PreThink( void )
 {
+#ifndef HL2SB
 	QAngle vTempAngles = GetLocalAngles();
 
 	if ( GetLocalPlayer() == this )
@@ -379,6 +461,7 @@ void C_HL2MP_Player::PreThink( void )
 	}
 
 	SetLocalAngles( vTempAngles );
+#endif // !HL2SB
 
 	BaseClass::PreThink();
 }
@@ -577,12 +660,14 @@ void C_HL2MP_Player::AddEntity( void )
 {
 	BaseClass::AddEntity();
 
+#ifndef HL2SB
 	QAngle vTempAngles = GetLocalAngles();
 	vTempAngles[PITCH] = m_angEyeAngles[PITCH];
 
 	SetLocalAngles( vTempAngles );
 		
 	m_PlayerAnimState.Update();
+#endif // !HL2SB
 
 	// Zero out model pitch, blending takes care of all of it.
 	SetLocalAnglesDim( X_INDEX, 0 );
@@ -679,7 +764,11 @@ const QAngle& C_HL2MP_Player::GetRenderAngles()
 	}
 	else
 	{
+#ifdef HL2SB
+		return m_PlayerAnimState->GetRenderAngles();
+#else
 		return m_PlayerAnimState.GetRenderAngles();
+#endif // HL2SB
 	}
 }
 
@@ -738,6 +827,21 @@ void C_HL2MP_Player::PostDataUpdate( DataUpdateType_t updateType )
 	BaseClass::PostDataUpdate( updateType );
 }
 
+#ifdef HL2SB
+void C_HL2MP_Player::RecvProxy_CycleLatch( const CRecvProxyData *pData, void *pStruct, void *pOut )
+{
+	C_HL2MP_Player* pPlayer = static_cast<C_HL2MP_Player*>( pStruct );
+
+	float flServerCycle = (float)pData->m_Value.m_Int / 16.0f;
+	float flCurCycle = pPlayer->GetCycle();
+	// The cycle is way out of sync.
+	if ( fabs( flCurCycle - flServerCycle ) > CYCLELATCH_TOLERANCE )
+	{
+		pPlayer->SetServerIntendedCycle( flServerCycle );
+	}
+}
+#endif // HL2SB
+
 void C_HL2MP_Player::ReleaseFlashlight( void )
 {
 	if( m_pFlashlightBeam )
@@ -1216,6 +1320,145 @@ void C_HL2MPRagdoll::SetupWeights( const matrix3x4_t *pBoneToWorld, int nFlexWei
 	}
 }
 
+#ifdef HL2SB
+void C_HL2MP_Player::UpdateClientSideAnimation()
+{
+	m_PlayerAnimState->Update( EyeAngles()[YAW], EyeAngles()[PITCH] );
+
+	BaseClass::UpdateClientSideAnimation();
+}
+
+// -------------------------------------------------------------------------------- //
+// Player animation event. Sent to the client when a player fires, jumps, reloads, etc..
+// -------------------------------------------------------------------------------- //
+
+class C_TEPlayerAnimEvent : public C_BaseTempEntity
+{
+public:
+	DECLARE_CLASS( C_TEPlayerAnimEvent, C_BaseTempEntity );
+	DECLARE_CLIENTCLASS();
+
+	virtual void PostDataUpdate( DataUpdateType_t updateType )
+	{
+		// Create the effect.
+		C_HL2MP_Player *pPlayer = dynamic_cast< C_HL2MP_Player* >( m_hPlayer.Get() );
+		if ( pPlayer && !pPlayer->IsDormant() )
+		{
+			pPlayer->DoAnimationEvent( (PlayerAnimEvent_t)m_iEvent.Get(), m_nData );
+		}	
+	}
+
+public:
+	CNetworkHandle( CBasePlayer, m_hPlayer );
+	CNetworkVar( int, m_iEvent );
+	CNetworkVar( int, m_nData );
+};
+
+IMPLEMENT_CLIENTCLASS_EVENT( C_TEPlayerAnimEvent, DT_TEPlayerAnimEvent, CTEPlayerAnimEvent );
+
+BEGIN_RECV_TABLE_NOBASE( C_TEPlayerAnimEvent, DT_TEPlayerAnimEvent )
+	RecvPropEHandle( RECVINFO( m_hPlayer ) ),
+	RecvPropInt( RECVINFO( m_iEvent ) ),
+	RecvPropInt( RECVINFO( m_nData ) )
+END_RECV_TABLE()
+
+void C_HL2MP_Player::DoAnimationEvent( PlayerAnimEvent_t event, int nData )
+{
+	if ( IsLocalPlayer() )
+	{
+		if ( ( prediction->InPrediction() && !prediction->IsFirstTimePredicted() ) )
+			return;
+	}
+
+	MDLCACHE_CRITICAL_SECTION();
+	m_PlayerAnimState->DoAnimationEvent( event, nData );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void C_HL2MP_Player::CalculateIKLocks( float currentTime )
+{
+	if (!m_pIk) 
+		return;
+
+	int targetCount = m_pIk->m_target.Count();
+	if ( targetCount == 0 )
+		return;
+
+	// In TF, we might be attaching a player's view to a walking model that's using IK. If we are, it can
+	// get in here during the view setup code, and it's not normally supposed to be able to access the spatial
+	// partition that early in the rendering loop. So we allow access right here for that special case.
+	SpatialPartitionListMask_t curSuppressed = partition->GetSuppressedLists();
+	partition->SuppressLists( PARTITION_ALL_CLIENT_EDICTS, false );
+	CBaseEntity::PushEnableAbsRecomputations( false );
+
+	for (int i = 0; i < targetCount; i++)
+	{
+		trace_t trace;
+		CIKTarget *pTarget = &m_pIk->m_target[i];
+
+		if (!pTarget->IsActive())
+			continue;
+
+		switch( pTarget->type)
+		{
+		case IK_GROUND:
+			{
+				pTarget->SetPos( Vector( pTarget->est.pos.x, pTarget->est.pos.y, GetRenderOrigin().z ));
+				pTarget->SetAngles( GetRenderAngles() );
+			}
+			break;
+
+		case IK_ATTACHMENT:
+			{
+				C_BaseEntity *pEntity = NULL;
+				float flDist = pTarget->est.radius;
+
+				// FIXME: make entity finding sticky!
+				// FIXME: what should the radius check be?
+				for ( CEntitySphereQuery sphere( pTarget->est.pos, 64 ); ( pEntity = sphere.GetCurrentEntity() ) != NULL; sphere.NextEntity() )
+				{
+					C_BaseAnimating *pAnim = pEntity->GetBaseAnimating( );
+					if (!pAnim)
+						continue;
+
+					int iAttachment = pAnim->LookupAttachment( pTarget->offset.pAttachmentName );
+					if (iAttachment <= 0)
+						continue;
+
+					Vector origin;
+					QAngle angles;
+					pAnim->GetAttachment( iAttachment, origin, angles );
+
+					// debugoverlay->AddBoxOverlay( origin, Vector( -1, -1, -1 ), Vector( 1, 1, 1 ), QAngle( 0, 0, 0 ), 255, 0, 0, 0, 0 );
+
+					float d = (pTarget->est.pos - origin).Length();
+
+					if ( d >= flDist)
+						continue;
+
+					flDist = d;
+					pTarget->SetPos( origin );
+					pTarget->SetAngles( angles );
+					// debugoverlay->AddBoxOverlay( pTarget->est.pos, Vector( -pTarget->est.radius, -pTarget->est.radius, -pTarget->est.radius ), Vector( pTarget->est.radius, pTarget->est.radius, pTarget->est.radius), QAngle( 0, 0, 0 ), 0, 255, 0, 0, 0 );
+				}
+
+				if (flDist >= pTarget->est.radius)
+				{
+					// debugoverlay->AddBoxOverlay( pTarget->est.pos, Vector( -pTarget->est.radius, -pTarget->est.radius, -pTarget->est.radius ), Vector( pTarget->est.radius, pTarget->est.radius, pTarget->est.radius), QAngle( 0, 0, 0 ), 0, 0, 255, 0, 0 );
+					// no solution, disable ik rule
+					pTarget->IKFailed( );
+				}
+			}
+			break;
+		}
+	}
+
+	CBaseEntity::PopEnableAbsRecomputations();
+	partition->SuppressLists( curSuppressed, true );
+}
+#else
 void C_HL2MP_Player::PostThink( void )
 {
 	BaseClass::PostThink();
@@ -1227,4 +1470,5 @@ void C_HL2MP_Player::PostThink( void )
 	{
 		SetCollisionBounds( VEC_CROUCH_TRACE_MIN, VEC_CROUCH_TRACE_MAX );
 	}
-}
\ No newline at end of file
+}
+#endif
\ No newline at end of file
diff --git a/src/game/client/hl2mp/c_hl2mp_player.h b/src/game/client/hl2mp/c_hl2mp_player.h
index bac7584d..aee6b121 100644
--- a/src/game/client/hl2mp/c_hl2mp_player.h
+++ b/src/game/client/hl2mp/c_hl2mp_player.h
@@ -9,7 +9,11 @@
 #define HL2MP_PLAYER_H
 #pragma once
 
+#ifdef HL2SB
+#include "hl2mp_playeranimstate.h"
+#else
 class C_HL2MP_Player;
+#endif // HL2SB
 #include "c_basehlplayer.h"
 #include "hl2mp_player_shared.h"
 #include "beamdraw.h"
@@ -60,7 +64,9 @@ class C_HL2MP_Player : public C_BaseHLPlayer
 	virtual int DrawModel( int flags );
 	virtual void AddEntity( void );
 
+#ifndef HL2SB
 	QAngle GetAnimEyeAngles( void ) { return m_angEyeAngles; }
+#endif // !HL2SB
 	Vector GetAttackSpread( CBaseCombatWeapon *pWeapon, CBaseEntity *pTarget = NULL );
 
 
@@ -118,13 +124,28 @@ class C_HL2MP_Player : public C_BaseHLPlayer
 	void StopWalking( void );
 	bool IsWalking( void ) { return m_fIsWalking; }
 
+#ifdef HL2SB
+	virtual void					UpdateClientSideAnimation();
+	void DoAnimationEvent( PlayerAnimEvent_t event, int nData = 0 );
+	virtual void CalculateIKLocks( float currentTime );
+
+	static void RecvProxy_CycleLatch( const CRecvProxyData *pData, void *pStruct, void *pOut );
+
+	virtual float GetServerIntendedCycle() { return m_flServerCycle; }
+	virtual void SetServerIntendedCycle( float cycle ) { m_flServerCycle = cycle; }
+#else
 	virtual void PostThink( void );
+#endif // HL2SB
 
 private:
 	
 	C_HL2MP_Player( const C_HL2MP_Player & );
 
+#ifdef HL2SB
+	CHL2MPPlayerAnimState *m_PlayerAnimState;
+#else
 	CPlayerAnimState m_PlayerAnimState;
+#endif // HL2SB
 
 	QAngle	m_angEyeAngles;
 
@@ -161,6 +182,10 @@ class C_HL2MP_Player : public C_BaseHLPlayer
 	CNetworkVar( HL2MPPlayerState, m_iPlayerState );	
 
 	bool m_fIsWalking = false;
+#ifdef HL2SB
+	int m_cycleLatch; // The animation cycle goes out of sync very easily. Mostly from the player entering/exiting PVS. Server will frequently update us with a new one.
+	float m_flServerCycle;
+#endif // HL2SB
 };
 
 inline C_HL2MP_Player *ToHL2MPPlayer( CBaseEntity *pEntity )
diff --git a/src/game/server/baseentity.cpp b/src/game/server/baseentity.cpp
index 7a5eeb6a..d31fb629 100644
--- a/src/game/server/baseentity.cpp
+++ b/src/game/server/baseentity.cpp
@@ -1841,7 +1841,30 @@ int CBaseEntity::VPhysicsTakeDamage( const CTakeDamageInfo &info )
 		if ( gameFlags & FVPHYSICS_PLAYER_HELD )
 		{
 			// if the player is holding the object, use it's real mass (player holding reduced the mass)
+#ifdef HL2SB
+			CBasePlayer *pPlayer = NULL;
+
+			if ( gpGlobals->maxClients == 1 )
+			{
+				pPlayer = UTIL_GetLocalPlayer();
+			}
+			else
+			{
+				// See which MP player is holding the physics object and then use that player to get the real mass of the object.
+				// This is ugly but better than having linkage between an object and its "holding" player.
+				for ( int i = 1; i <= gpGlobals->maxClients; i++ )
+				{
+					CBasePlayer *tempPlayer = UTIL_PlayerByIndex( i );
+					if ( tempPlayer && (tempPlayer->GetHeldObject() == this ) )
+					{
+						pPlayer = tempPlayer;
+						break;
+					}
+				}
+			}
+#else
 			CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif // HL2SB
 			if ( pPlayer )
 			{
 				float mass = pPlayer->GetHeldObjectMass( VPhysicsGetObject() );
diff --git a/src/game/server/filters.cpp b/src/game/server/filters.cpp
index 6179254d..1e64791d 100644
--- a/src/game/server/filters.cpp
+++ b/src/game/server/filters.cpp
@@ -372,7 +372,12 @@ class FilterDamageType : public CBaseFilter
 
 	bool PassesDamageFilterImpl(const CTakeDamageInfo &info)
 	{
+#ifdef HL2SB
+		//Tony; these are bitflags. check them as so.
+		return ((info.GetDamageType() & m_iDamageType) == m_iDamageType);
+#else
 	 	return info.GetDamageType() == m_iDamageType;
+#endif // HL2SB
 	}
 
 	int m_iDamageType;
diff --git a/src/game/server/hl2/hl2_player.cpp b/src/game/server/hl2/hl2_player.cpp
index 7eecff65..b12b8ecc 100644
--- a/src/game/server/hl2/hl2_player.cpp
+++ b/src/game/server/hl2/hl2_player.cpp
@@ -3189,6 +3189,13 @@ float CHL2_Player::GetHeldObjectMass( IPhysicsObject *pHeldObject )
 	return mass;
 }
 
+#ifdef HL2SB
+CBaseEntity	*CHL2_Player::GetHeldObject( void )
+{
+	return PhysCannonGetHeldEntity( GetActiveWeapon() );
+}
+#endif // HL2SB
+
 //-----------------------------------------------------------------------------
 // Purpose: Force the player to drop any physics objects he's carrying
 //-----------------------------------------------------------------------------
diff --git a/src/game/server/hl2/hl2_player.h b/src/game/server/hl2/hl2_player.h
index fb838793..78fe2ee3 100644
--- a/src/game/server/hl2/hl2_player.h
+++ b/src/game/server/hl2/hl2_player.h
@@ -15,6 +15,14 @@
 #include "simtimer.h"
 #include "soundenvelope.h"
 
+// In HL2MP we need to inherit from  BaseMultiplayerPlayer!
+#if defined ( HL2MP ) && defined ( HL2SB )
+#include "basemultiplayerplayer.h"
+#define BASEPLAYERCLASS CBaseMultiplayerPlayer
+#else
+#define BASEPLAYERCLASS CBasePlayer
+#endif
+
 class CAI_Squad;
 class CPropCombineBall;
 
@@ -75,10 +83,10 @@ class CSuitPowerDevice
 //=============================================================================
 // >> HL2_PLAYER
 //=============================================================================
-class CHL2_Player : public CBasePlayer
+class CHL2_Player : public BASEPLAYERCLASS
 {
 public:
-	DECLARE_CLASS( CHL2_Player, CBasePlayer );
+	DECLARE_CLASS( CHL2_Player, BASEPLAYERCLASS );
 
 	CHL2_Player();
 	~CHL2_Player( void );
@@ -242,6 +250,9 @@ class CHL2_Player : public CBasePlayer
 	virtual	bool		IsHoldingEntity( CBaseEntity *pEnt );
 	virtual void		ForceDropOfCarriedPhysObjects( CBaseEntity *pOnlyIfHoldindThis );
 	virtual float		GetHeldObjectMass( IPhysicsObject *pHeldObject );
+#ifdef HL2SB
+	virtual CBaseEntity	*GetHeldObject( void );
+#endif // HL2SB
 
 	virtual bool		IsFollowingPhysics( void ) { return (m_afPhysicsFlags & PFLAG_ONBARNACLE) > 0; }
 	void				InputForceDropPhysObjects( inputdata_t &data );
diff --git a/src/game/server/hl2mp/grenade_tripmine.cpp b/src/game/server/hl2mp/grenade_tripmine.cpp
index e14a929d..11663472 100644
--- a/src/game/server/hl2mp/grenade_tripmine.cpp
+++ b/src/game/server/hl2mp/grenade_tripmine.cpp
@@ -8,7 +8,11 @@
 #include "cbase.h"
 #include "beam_shared.h"
 #include "shake.h"
+#ifdef HL2SB
+#include "hl2mp/grenade_tripmine.h" // Load the hl2mp header!!
+#else
 #include "grenade_tripmine.h"
+#endif // HL2SB
 #include "vstdlib/random.h"
 #include "engine/IEngineSound.h"
 #include "explode.h"
@@ -49,8 +53,28 @@ CTripmineGrenade::CTripmineGrenade()
 	m_vecEnd.Init();
 	m_posOwner.Init();
 	m_angleOwner.Init();
+
+#ifdef HL2SB
+	m_pConstraint = NULL;
+	m_bAttached = false;
+	m_hAttachEntity = NULL;
+#endif // HL2SB
 }
 
+#ifdef HL2SB
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+CTripmineGrenade::~CTripmineGrenade( void )
+{
+	if (m_pConstraint)
+	{
+		physenv->DestroyConstraint(m_pConstraint);
+		m_pConstraint = NULL;
+	}
+}
+#endif // HL2SB
+
 void CTripmineGrenade::Spawn( void )
 {
 	Precache( );
@@ -117,10 +141,20 @@ void CTripmineGrenade::PowerupThink( void  )
 {
 	if (gpGlobals->curtime > m_flPowerUp)
 	{
+#ifdef HL2SB
+		m_flPowerUp = 0;
+#endif // HL2SB
 		MakeBeam( );
 		RemoveSolidFlags( FSOLID_NOT_SOLID );
 		m_bIsLive			= true;
 
+#ifdef HL2SB
+		// The moment it's live, then do this - incase the attach entity moves between placing it, and activation
+		// use the absorigin of what we're attaching to for the check, if it moves - we blow up.
+		if ( m_bAttached && m_hAttachEntity.Get() != NULL )
+			m_vAttachedPosition = m_hAttachEntity.Get()->GetAbsOrigin();
+#endif // HL2SB
+
 		// play enabled sound
 		EmitSound( "TripmineGrenade.Activate" );
 	}
@@ -219,12 +253,32 @@ void CTripmineGrenade::BeamBreakThink( void  )
 	CBaseEntity *pEntity = tr.m_pEnt;
 	CBaseCombatCharacter *pBCC  = ToBaseCombatCharacter( pEntity );
 
+#ifdef HL2SB
+	bool bAttachMoved = false;
+	if ( m_bAttached && m_hAttachEntity.Get() != NULL )
+	{
+		if ( m_hAttachEntity.Get()->GetAbsOrigin() != m_vAttachedPosition )
+			bAttachMoved = true;
+	}
+
+	// Also blow up if the attached entity goes away, ie: a crate
+	if (pBCC || fabs( m_flBeamLength - tr.fraction ) > 0.001 || ( m_bAttached && m_hAttachEntity.Get() == NULL) || bAttachMoved )
+	{
+		m_iHealth = 0;
+		if (m_pConstraint)
+			m_pConstraint->Deactivate();
+
+		Event_Killed( CTakeDamageInfo( (CBaseEntity*)m_hOwner, this, 100, GIB_NORMAL ) );
+		return;
+	}
+#else
 	if (pBCC || fabs( m_flBeamLength - tr.fraction ) > 0.001)
 	{
 		m_iHealth = 0;
 		Event_Killed( CTakeDamageInfo( (CBaseEntity*)m_hOwner, this, 100, GIB_NORMAL ) );
 		return;
 	}
+#endif // HL2SB
 
 	SetNextThink( gpGlobals->curtime + 0.05f );
 }
@@ -245,6 +299,25 @@ int CTripmineGrenade::OnTakeDamage_Alive( const CTakeDamageInfo &info )
 }
 #endif
 
+#ifdef HL2SB
+int CTripmineGrenade::OnTakeDamage( const CTakeDamageInfo &info )
+{
+	if ( m_iHealth < 0 )
+		return 0;	//already dead.
+
+	if ( gpGlobals->curtime > m_flPowerUp )
+	{
+		m_iHealth -= info.GetDamage();
+
+		if ( m_iHealth <= 0 )
+			Event_Killed( info );
+
+		return info.GetDamage();
+	}
+	return 0;
+}
+#endif // HL2SB
+
 //-----------------------------------------------------------------------------
 // Purpose:
 // Input  :
@@ -254,6 +327,11 @@ void CTripmineGrenade::Event_Killed( const CTakeDamageInfo &info )
 {
 	m_takedamage		= DAMAGE_NO;
 
+#ifdef HL2SB
+	if (m_pConstraint)
+		m_pConstraint->Deactivate();
+#endif // HL2SB
+
 	SetThink( &CTripmineGrenade::DelayDeathThink );
 	SetNextThink( gpGlobals->curtime + 0.25 );
 
@@ -274,3 +352,62 @@ void CTripmineGrenade::DelayDeathThink( void )
 	UTIL_Remove( this );
 }
 
+#ifdef HL2SB
+bool CTripmineGrenade::MakeConstraint( CBaseEntity *pObject )
+{
+	IPhysicsObject *cMinePhysics = VPhysicsGetObject();
+
+	Assert( cMinePhysics );
+
+	IPhysicsObject *pAttached = pObject->VPhysicsGetObject();
+	if ( !cMinePhysics || !pAttached )
+		return false;
+
+	// constraining to the world means object 1 is fixed
+	if ( pAttached == g_PhysWorldObject )
+		PhysSetGameFlags( cMinePhysics, FVPHYSICS_CONSTRAINT_STATIC );
+
+	IPhysicsConstraintGroup *pGroup = NULL;
+
+	constraint_fixedparams_t fixed;
+	fixed.Defaults();
+	fixed.InitWithCurrentObjectState( cMinePhysics, pAttached );
+	fixed.constraint.Defaults();
+
+	m_pConstraint = physenv->CreateFixedConstraint( cMinePhysics, pAttached, pGroup, fixed );
+
+	if (!m_pConstraint)
+		return false;
+
+	m_pConstraint->SetGameData( (void *)this );
+
+	return true;
+}
+
+void CTripmineGrenade::AttachToEntity(CBaseEntity *pOther)
+{
+	if (!pOther)
+		return;
+
+	if ( !VPhysicsGetObject() )
+		return;
+
+	m_bAttached			= true;
+	m_hAttachEntity		= pOther;
+
+	SetMoveType			( MOVETYPE_NONE );
+
+	if (pOther->GetSolid() == SOLID_VPHYSICS && pOther->VPhysicsGetObject() != NULL )
+	{
+		SetSolid(SOLID_BBOX); //Tony; switch to bbox solid instead of vphysics, because we've made the physics object non-solid
+		MakeConstraint(pOther);
+		SetMoveType		( MOVETYPE_VPHYSICS ); // use vphysics while constrained!!
+	}
+	//if it isnt vphysics or bsp, use SetParent to follow it.
+	else if (pOther->GetSolid() != SOLID_BSP)
+	{
+		SetSolid(SOLID_BBOX); //Tony; switch to bbox solid instead of vphysics, because we've made the physics object non-solid
+		SetParent( m_hAttachEntity.Get() );
+	}
+}
+#endif // HL2SB
diff --git a/src/game/server/hl2mp/grenade_tripmine.h b/src/game/server/hl2mp/grenade_tripmine.h
index e1887096..11752629 100644
--- a/src/game/server/hl2mp/grenade_tripmine.h
+++ b/src/game/server/hl2mp/grenade_tripmine.h
@@ -15,6 +15,10 @@
 
 class CBeam;
 
+#ifdef HL2SB
+// for constraints
+#include "vphysics/constraints.h"
+#endif // HL2SB
 
 class CTripmineGrenade : public CBaseGrenade
 {
@@ -22,12 +26,19 @@ class CTripmineGrenade : public CBaseGrenade
 	DECLARE_CLASS( CTripmineGrenade, CBaseGrenade );
 
 	CTripmineGrenade();
+#ifdef HL2SB
+	~CTripmineGrenade();
+#endif // HL2SB
+
 	void Spawn( void );
 	void Precache( void );
 
 #if 0 // FIXME: OnTakeDamage_Alive() is no longer called now that base grenade derives from CBaseAnimating
 	int OnTakeDamage_Alive( const CTakeDamageInfo &info );
 #endif	
+#ifdef HL2SB
+	virtual int OnTakeDamage( const CTakeDamageInfo &info );
+#endif // HL2SB
 	void WarningThink( void );
 	void PowerupThink( void );
 	void BeamBreakThink( void );
@@ -37,8 +48,18 @@ class CTripmineGrenade : public CBaseGrenade
 	void MakeBeam( void );
 	void KillBeam( void );
 
+#ifdef HL2SB
+	// Added to create a constraint
+	void AttachToEntity( CBaseEntity *pOther );
+	bool MakeConstraint( CBaseEntity *pOther );
+#endif // HL2SB
+
 public:
 	EHANDLE		m_hOwner;
+#ifdef HL2SB
+	// Added for following
+	EHANDLE		m_hAttachEntity;
+#endif // HL2SB
 
 private:
 	float		m_flPowerUp;
@@ -50,6 +71,13 @@ class CTripmineGrenade : public CBaseGrenade
 	Vector		m_posOwner;
 	Vector		m_angleOwner;
 
+#ifdef HL2SB
+	// signifies if we're attached to something, and need to update slightly differently.
+	bool		m_bAttached;
+	IPhysicsConstraint	*m_pConstraint;
+	Vector		m_vAttachedPosition;	// if the attached position changes, we need to detonate
+#endif // HL2SB
+
 	DECLARE_DATADESC();
 };
 
diff --git a/src/game/server/hl2mp/hl2mp_player.cpp b/src/game/server/hl2mp/hl2mp_player.cpp
index 9457928a..7eddc213 100644
--- a/src/game/server/hl2mp/hl2mp_player.cpp
+++ b/src/game/server/hl2mp/hl2mp_player.cpp
@@ -22,12 +22,21 @@
 #include "gamestats.h"
 #include "ammodef.h"
 #include "NextBot.h"
+#ifdef HL2SB
+#include "tier0/vprof.h"
+#include "bone_setup.h"
+#endif // HL2SB
 
 #include "engine/IEngineSound.h"
 #include "SoundEmitterSystem/isoundemittersystembase.h"
 
 #include "ilagcompensationmanager.h"
 
+#ifdef HL2SB
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+#endif // HL2SB
+
 int g_iLastCitizenModel = 0;
 int g_iLastCombineModel = 0;
 
@@ -39,6 +48,10 @@ ConVar hl2mp_spawn_frag_fallback_radius( "hl2mp_spawn_frag_fallback_radius", "48
 
 #define HL2MP_COMMAND_MAX_RATE 0.3
 
+#ifdef HL2SB
+#define CYCLELATCH_UPDATE_INTERVAL	0.2f
+#endif // HL2SB
+
 void DropPrimedFragGrenade( CHL2MP_Player *pPlayer, CBaseCombatWeapon *pGrenade );
 
 LINK_ENTITY_TO_CLASS( player, CHL2MP_Player );
@@ -46,6 +59,63 @@ LINK_ENTITY_TO_CLASS( player, CHL2MP_Player );
 LINK_ENTITY_TO_CLASS( info_player_combine, CPointEntity );
 LINK_ENTITY_TO_CLASS( info_player_rebel, CPointEntity );
 
+#ifdef HL2SB
+extern void SendProxy_Origin( const SendProp *pProp, const void *pStruct, const void *pData, DVariant *pOut, int iElement, int objectID );
+
+BEGIN_SEND_TABLE_NOBASE( CHL2MP_Player, DT_HL2MPLocalPlayerExclusive )
+	// send a hi-res origin to the local player for use in prediction
+	SendPropVector	(SENDINFO(m_vecOrigin), -1,  SPROP_NOSCALE|SPROP_CHANGES_OFTEN, 0.0f, HIGH_DEFAULT, SendProxy_Origin ),
+	SendPropFloat( SENDINFO_VECTORELEM(m_angEyeAngles, 0), 8, SPROP_CHANGES_OFTEN, -90.0f, 90.0f ),
+//	SendPropAngle( SENDINFO_VECTORELEM(m_angEyeAngles, 1), 10, SPROP_CHANGES_OFTEN ),
+END_SEND_TABLE()
+
+BEGIN_SEND_TABLE_NOBASE( CHL2MP_Player, DT_HL2MPNonLocalPlayerExclusive )
+	// send a lo-res origin to other players
+	SendPropVector	(SENDINFO(m_vecOrigin), -1,  SPROP_COORD_MP_LOWPRECISION|SPROP_CHANGES_OFTEN, 0.0f, HIGH_DEFAULT, SendProxy_Origin ),
+	SendPropFloat( SENDINFO_VECTORELEM(m_angEyeAngles, 0), 8, SPROP_CHANGES_OFTEN, -90.0f, 90.0f ),
+	SendPropAngle( SENDINFO_VECTORELEM(m_angEyeAngles, 1), 10, SPROP_CHANGES_OFTEN ),
+	// Only need to latch cycle for other players
+	// If you increase the number of bits networked, make sure to also modify the code below and in the client class.
+	SendPropInt( SENDINFO( m_cycleLatch ), 4, SPROP_UNSIGNED ),
+END_SEND_TABLE()
+
+IMPLEMENT_SERVERCLASS_ST(CHL2MP_Player, DT_HL2MP_Player)
+	SendPropExclude( "DT_BaseAnimating", "m_flPoseParameter" ),
+	SendPropExclude( "DT_BaseAnimating", "m_flPlaybackRate" ),	
+	SendPropExclude( "DT_BaseAnimating", "m_nSequence" ),
+	SendPropExclude( "DT_BaseEntity", "m_angRotation" ),
+	SendPropExclude( "DT_BaseAnimatingOverlay", "overlay_vars" ),
+
+	SendPropExclude( "DT_BaseEntity", "m_vecOrigin" ),
+
+	// misyl:
+	// m_flMaxspeed is fully predicted by the client and the client's
+	// maxspeed is sent in the user message.
+	// Other games like DOD, etc don't use this var at all and just fully
+	// predict in GameMovement, but the HL2 codebase doesn't do that and modifies this
+	// on the player.
+	// So, just never send it, and don't predict it on the client either.
+	SendPropExclude( "DT_BasePlayer", "m_flMaxspeed" ),
+
+	// playeranimstate and clientside animation takes care of these on the client
+	SendPropExclude( "DT_ServerAnimationData" , "m_flCycle" ),	
+	SendPropExclude( "DT_AnimTimeMustBeFirst" , "m_flAnimTime" ),
+
+	SendPropExclude( "DT_BaseFlex", "m_flexWeight" ),
+	SendPropExclude( "DT_BaseFlex", "m_blinktoggle" ),
+	SendPropExclude( "DT_BaseFlex", "m_viewtarget" ),
+
+	// Data that only gets sent to the local player.
+	SendPropDataTable( "hl2mplocaldata", 0, &REFERENCE_SEND_TABLE(DT_HL2MPLocalPlayerExclusive), SendProxy_SendLocalDataTable ),
+	// Data that gets sent to all other players
+	SendPropDataTable( "hl2mpnonlocaldata", 0, &REFERENCE_SEND_TABLE(DT_HL2MPNonLocalPlayerExclusive), SendProxy_SendNonLocalDataTable ),
+
+	SendPropEHandle( SENDINFO( m_hRagdoll ) ),
+	SendPropInt( SENDINFO( m_iSpawnInterpCounter), 4 ),
+	SendPropInt( SENDINFO( m_iPlayerSoundType), 3 ),
+
+END_SEND_TABLE()
+#else
 // specific to the local player
 BEGIN_SEND_TABLE_NOBASE( CHL2MP_Player, DT_HL2MPLocalPlayerExclusive )
 	// send a hi-res origin to the local player for use in prediction
@@ -97,6 +167,7 @@ IMPLEMENT_SERVERCLASS_ST(CHL2MP_Player, DT_HL2MP_Player)
 //	SendPropExclude( "DT_ServerAnimationData" , "m_flCycle" ),	
 //	SendPropExclude( "DT_AnimTimeMustBeFirst" , "m_flAnimTime" ),	
 END_SEND_TABLE()
+#endif
 
 BEGIN_DATADESC( CHL2MP_Player )
 END_DATADESC()
@@ -140,6 +211,38 @@ const char *g_ppszRandomCombineModels[] =
 
 #pragma warning( disable : 4355 )
 
+#ifdef HL2SB
+CHL2MP_Player::CHL2MP_Player()
+{
+	//Tony; create our player animation state.
+	m_PlayerAnimState = CreateHL2MPPlayerAnimState( this );
+	UseClientSideAnimation();
+
+	m_angEyeAngles.Init();
+
+	m_iLastWeaponFireUsercmd = 0;
+
+	m_flNextModelChangeTime = 0.0f;
+	m_flNextTeamChangeTime = 0.0f;
+
+	m_iSpawnInterpCounter = 0;
+
+    m_bEnterObserver = false;
+	m_bReady = false;
+
+	m_cycleLatch = 0;
+	m_cycleLatchTimer.Invalidate();
+
+	BaseClass::ChangeTeam( 0 );
+	
+//	UseClientSideAnimation();
+}
+
+CHL2MP_Player::~CHL2MP_Player( void )
+{
+	m_PlayerAnimState->Release();
+}
+#else
 CHL2MP_Player::CHL2MP_Player() : m_PlayerAnimState( this )
 {
 	m_angEyeAngles.Init();
@@ -163,6 +266,7 @@ CHL2MP_Player::~CHL2MP_Player( void )
 {
 
 }
+#endif // HL2SB
 
 void CHL2MP_Player::UpdateOnRemove( void )
 {
@@ -349,8 +453,10 @@ void CHL2MP_Player::Spawn(void)
 		GiveDefaultItems();
 	}
 
+#ifndef HL2SB
 	SetNumAnimOverlays( 3 );
 	ResetAnimation();
+#endif // !HL2SB
 
 	m_nRenderFX = kRenderNormal;
 
@@ -376,6 +482,13 @@ void CHL2MP_Player::Spawn(void)
 	SetPlayerUnderwater(false);
 
 	m_bReady = false;
+
+#ifdef HL2SB
+	m_cycleLatchTimer.Start( CYCLELATCH_UPDATE_INTERVAL );
+
+	//Tony; do the spawn animevent
+	DoAnimationEvent( PLAYERANIMEVENT_SPAWN );
+#endif // HL2SB
 }
 
 bool CHL2MP_Player::ValidatePlayerModel( const char *pModel )
@@ -555,6 +668,7 @@ void CHL2MP_Player::SetupPlayerSoundsByModel( const char *pModelName )
 	}
 }
 
+#ifndef HL2SB
 void CHL2MP_Player::ResetAnimation( void )
 {
 	if ( IsAlive() )
@@ -574,22 +688,25 @@ void CHL2MP_Player::ResetAnimation( void )
 			SetAnimation( PLAYER_IDLE );
 	}
 }
-
+#endif // !HL2SB
 
 bool CHL2MP_Player::Weapon_Switch( CBaseCombatWeapon *pWeapon, int viewmodelindex )
 {
 	bool bRet = BaseClass::Weapon_Switch( pWeapon, viewmodelindex );
 
+#ifndef HL2SB
 	if ( bRet == true )
 	{
 		ResetAnimation();
 	}
+#endif // !HL2SB
 
 	return bRet;
 }
 
 void CHL2MP_Player::PreThink( void )
 {
+#ifndef HL2SB
 	QAngle vOldAngles = GetLocalAngles();
 	QAngle vTempAngles = GetLocalAngles();
 
@@ -601,15 +718,156 @@ void CHL2MP_Player::PreThink( void )
 	}
 
 	SetLocalAngles( vTempAngles );
+#endif // !HL2SB
 
 	BaseClass::PreThink();
 	State_PreThink();
 
 	//Reset bullet force accumulator, only lasts one frame
 	m_vecTotalBulletForce = vec3_origin;
+#ifndef HL2SB
 	SetLocalAngles( vOldAngles );
+#endif // !HL2SB
 }
 
+#ifdef HL2SB
+//-----------------------------------------------------------------------------
+// Purpose: multiplayer does not do autoaiming.
+//-----------------------------------------------------------------------------
+Vector CHL2MP_Player::GetAutoaimVector( float flScale )
+{
+	//No Autoaim
+	Vector	forward;
+	AngleVectors( EyeAngles() + m_Local.m_vecPunchAngle, &forward );
+	return	forward;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Do nothing multiplayer_animstate takes care of animation.
+// Input  : playerAnim - 
+//-----------------------------------------------------------------------------
+void CHL2MP_Player::SetAnimation( PLAYER_ANIM playerAnim )
+{
+	return;
+}
+
+// -------------------------------------------------------------------------------- //
+// Player animation event. Sent to the client when a player fires, jumps, reloads, etc..
+// -------------------------------------------------------------------------------- //
+class CTEPlayerAnimEvent : public CBaseTempEntity
+{
+public:
+	DECLARE_CLASS( CTEPlayerAnimEvent, CBaseTempEntity );
+	DECLARE_SERVERCLASS();
+
+	CTEPlayerAnimEvent( const char *name ) : CBaseTempEntity( name )
+	{
+	}
+
+	CNetworkHandle( CBasePlayer, m_hPlayer );
+	CNetworkVar( int, m_iEvent );
+	CNetworkVar( int, m_nData );
+};
+
+IMPLEMENT_SERVERCLASS_ST_NOBASE( CTEPlayerAnimEvent, DT_TEPlayerAnimEvent )
+	SendPropEHandle( SENDINFO( m_hPlayer ) ),
+	SendPropInt( SENDINFO( m_iEvent ), Q_log2( PLAYERANIMEVENT_COUNT ), SPROP_UNSIGNED ),
+	SendPropInt( SENDINFO( m_nData ), 32 )
+END_SEND_TABLE()
+
+static CTEPlayerAnimEvent g_TEPlayerAnimEvent( "PlayerAnimEvent" );
+
+void TE_PlayerAnimEvent( CBasePlayer *pPlayer, PlayerAnimEvent_t event, int nData )
+{
+	CPVSFilter filter( (const Vector&)pPlayer->EyePosition() );
+
+	//Tony; use prediction rules.
+	filter.UsePredictionRules();
+
+	g_TEPlayerAnimEvent.m_hPlayer = pPlayer;
+	g_TEPlayerAnimEvent.m_iEvent = event;
+	g_TEPlayerAnimEvent.m_nData = nData;
+	g_TEPlayerAnimEvent.Create( filter, 0 );
+}
+
+
+void CHL2MP_Player::DoAnimationEvent( PlayerAnimEvent_t event, int nData )
+{
+	m_PlayerAnimState->DoAnimationEvent( event, nData );
+	TE_PlayerAnimEvent( this, event, nData );	// Send to any clients who can see this guy.
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Override setup bones so that is uses the render angles from
+//			the HL2MP animation state to setup the hitboxes.
+//-----------------------------------------------------------------------------
+void CHL2MP_Player::SetupBones( matrix3x4_t *pBoneToWorld, int boneMask )
+{
+	VPROF_BUDGET( "CHL2MP_Player::SetupBones", VPROF_BUDGETGROUP_SERVER_ANIM );
+
+	// Get the studio header.
+	Assert( GetModelPtr() );
+	CStudioHdr *pStudioHdr = GetModelPtr( );
+	if ( !pStudioHdr )
+		return;
+
+	Vector pos[MAXSTUDIOBONES];
+	Quaternion q[MAXSTUDIOBONES];
+
+	// Adjust hit boxes based on IK driven offset.
+	Vector adjOrigin = GetAbsOrigin() + Vector( 0, 0, m_flEstIkOffset );
+
+	// FIXME: pass this into Studio_BuildMatrices to skip transforms
+	CBoneBitList boneComputed;
+	if ( m_pIk )
+	{
+		m_iIKCounter++;
+		m_pIk->Init( pStudioHdr, GetAbsAngles(), adjOrigin, gpGlobals->curtime, m_iIKCounter, boneMask );
+		GetSkeleton( pStudioHdr, pos, q, boneMask );
+
+		m_pIk->UpdateTargets( pos, q, pBoneToWorld, boneComputed );
+		CalculateIKLocks( gpGlobals->curtime );
+		m_pIk->SolveDependencies( pos, q, pBoneToWorld, boneComputed );
+	}
+	else
+	{
+		GetSkeleton( pStudioHdr, pos, q, boneMask );
+	}
+
+	CBaseAnimating *pParent = dynamic_cast< CBaseAnimating* >( GetMoveParent() );
+	if ( pParent )
+	{
+		// We're doing bone merging, so do special stuff here.
+		CBoneCache *pParentCache = pParent->GetBoneCache();
+		if ( pParentCache )
+		{
+			BuildMatricesWithBoneMerge( 
+				pStudioHdr, 
+				m_PlayerAnimState->GetRenderAngles(),
+				adjOrigin, 
+				pos, 
+				q, 
+				pBoneToWorld, 
+				pParent, 
+				pParentCache );
+
+			return;
+		}
+	}
+
+	Studio_BuildMatrices( 
+		pStudioHdr, 
+		m_PlayerAnimState->GetRenderAngles(),
+		adjOrigin, 
+		pos, 
+		q, 
+		-1,
+		GetModelScale(), // Scaling
+		pBoneToWorld,
+		boneMask );
+}
+#endif // HL2SB
+
 void CHL2MP_Player::PostThink( void )
 {
 	BaseClass::PostThink();
@@ -619,14 +877,29 @@ void CHL2MP_Player::PostThink( void )
 		SetCollisionBounds( VEC_CROUCH_TRACE_MIN, VEC_CROUCH_TRACE_MAX );
 	}
 
+#ifndef HL2SB
 	m_PlayerAnimState.Update();
 
 	// Store the eye angles pitch so the client can compute its animation state correctly.
 	m_angEyeAngles = EyeAngles();
+#endif // !HL2SB
 
 	QAngle angles = GetLocalAngles();
 	angles[PITCH] = 0;
 	SetLocalAngles( angles );
+
+#ifdef HL2SB
+	// Store the eye angles pitch so the client can compute its animation state correctly.
+	m_angEyeAngles = EyeAngles();
+	m_PlayerAnimState->Update( m_angEyeAngles[YAW], m_angEyeAngles[PITCH] );
+
+	if ( IsAlive() && m_cycleLatchTimer.IsElapsed() )
+	{
+		m_cycleLatchTimer.Start( CYCLELATCH_UPDATE_INTERVAL );
+		// Compress the cycle into 4 bits. Can represent 0.0625 in steps which is enough.
+		m_cycleLatch.GetForModify() = 16 * GetCycle();
+	}
+#endif // HL2SB
 }
 
 void CHL2MP_Player::PlayerDeathThink()
@@ -735,6 +1008,7 @@ Activity CHL2MP_Player::TranslateTeamActivity( Activity ActToTranslate )
 
 extern ConVar hl2_normspeed;
 
+#ifndef HL2SB
 // Set the activity based on an event or current state
 void CHL2MP_Player::SetAnimation( PLAYER_ANIM playerAnim )
 {
@@ -900,7 +1174,7 @@ void CHL2MP_Player::SetAnimation( PLAYER_ANIM playerAnim )
 	ResetSequence( animDesired );
 	SetCycle( 0 );
 }
-
+#endif // !HL2SB
 
 extern int	gEvilImpulse101;
 //-----------------------------------------------------------------------------
@@ -1302,7 +1576,9 @@ void CHL2MP_Player::Event_Killed( const CTakeDamageInfo &info )
 	CTakeDamageInfo subinfo = info;
 	subinfo.SetDamageForce( m_vecTotalBulletForce );
 
+#ifndef HL2SB
 	SetNumAnimOverlays( 0 );
+#endif // !HL2SB
 
 	// Note: since we're dead, it won't draw us on the client, but we don't set EF_NODRAW
 	// because we still want to transmit to the clients in our PVS.
diff --git a/src/game/server/hl2mp/hl2mp_player.h b/src/game/server/hl2mp/hl2mp_player.h
index 5fad2386..e9329188 100644
--- a/src/game/server/hl2mp/hl2mp_player.h
+++ b/src/game/server/hl2mp/hl2mp_player.h
@@ -16,6 +16,9 @@ class CHL2MP_Player;
 #include "hl2_player.h"
 #include "simtimer.h"
 #include "soundenvelope.h"
+#ifdef HL2SB
+#include "hl2mp_playeranimstate.h"
+#endif // HL2SB
 #include "hl2mp_player_shared.h"
 #include "hl2mp_gamerules.h"
 #include "utldict.h"
@@ -52,13 +55,22 @@ class CHL2MP_Player : public CHL2_Player
 	DECLARE_SERVERCLASS();
 	DECLARE_DATADESC();
 	DECLARE_ENT_SCRIPTDESC();
+#ifdef HL2SB
+	DECLARE_PREDICTABLE();
+
+	// This passes the event to the client's and server's CHL2MPPlayerAnimState.
+	void			DoAnimationEvent( PlayerAnimEvent_t event, int nData = 0 );
+	void			SetupBones( matrix3x4_t *pBoneToWorld, int boneMask );
+#endif // HL2SB
 
 	virtual void Precache( void );
 	virtual void Spawn( void );
 	virtual void PostThink( void );
 	virtual void PreThink( void );
 	virtual void PlayerDeathThink( void );
+#ifndef HL2SB
 	virtual void SetAnimation( PLAYER_ANIM playerAnim );
+#endif // !HL2SB
 	virtual bool HandleCommand_JoinTeam( int team );
 	virtual bool ClientCommand( const CCommand &args );
 	virtual void CreateViewModel( int viewmodelindex = 0 );
@@ -84,9 +96,14 @@ class CHL2MP_Player : public CHL2_Player
 	void	PrecacheFootStepSounds( void );
 	bool	ValidatePlayerModel( const char *pModel );
 
+#ifndef HL2SB
 	QAngle GetAnimEyeAngles( void ) { return m_angEyeAngles.Get(); }
+#endif // !HL2SB
 
 	Vector GetAttackSpread( CBaseCombatWeapon *pWeapon, CBaseEntity *pTarget = NULL );
+#ifdef HL2SB
+	virtual Vector GetAutoaimVector( float flDelta );
+#endif // HL2SB
 
 	void CheatImpulseCommands( int iImpulse );
 	void CreateRagdollEntity( void );
@@ -95,7 +112,12 @@ class CHL2MP_Player : public CHL2_Player
 
 	void NoteWeaponFired( void );
 
+#ifdef HL2SB
+	void SetAnimation( PLAYER_ANIM playerAnim );
+#else
 	void ResetAnimation( void );
+#endif // HL2SB
+
 	void SetPlayerModel( void );
 	void SetPlayerTeamModel( void );
 	Activity TranslateTeamActivity( Activity ActToTranslate );
@@ -146,7 +168,13 @@ class CHL2MP_Player : public CHL2_Player
 private:
 
 	CNetworkQAngle( m_angEyeAngles );
+#ifndef HL2SB
 	CPlayerAnimState   m_PlayerAnimState;
+#endif // !HL2SB
+
+#ifdef HL2SB
+	CHL2MPPlayerAnimState *m_PlayerAnimState;
+#endif // HL2SB
 
 	int m_iLastWeaponFireUsercmd;
 	int m_iModelType;
@@ -168,6 +196,11 @@ class CHL2MP_Player : public CHL2_Player
 
     bool m_bEnterObserver;
 	bool m_bReady;
+
+#ifdef HL2SB
+	CNetworkVar( int, m_cycleLatch ); // Network the cycle to clients periodically
+	CountdownTimer m_cycleLatchTimer;
+#endif // HL2SB
 };
 
 inline CHL2MP_Player *ToHL2MPPlayer( CBaseEntity *pEntity )
diff --git a/src/game/server/physics_impact_damage.cpp b/src/game/server/physics_impact_damage.cpp
index 164568e2..2a02a136 100644
--- a/src/game/server/physics_impact_damage.cpp
+++ b/src/game/server/physics_impact_damage.cpp
@@ -335,6 +335,35 @@ float CalculatePhysicsImpactDamage( int index, gamevcollisionevent_t *pEvent, co
 
 	if ( pEvent->pObjects[otherIndex]->GetGameFlags() & FVPHYSICS_PLAYER_HELD )
 	{
+#ifdef HL2SB
+		// if the player is holding the object, use its real mass (player holding reduced the mass)
+
+		CBasePlayer *pPlayer = NULL;
+
+		if ( gpGlobals->maxClients == 1 )
+		{
+			pPlayer = UTIL_GetLocalPlayer();
+		}
+		else
+		{
+			// See which MP player is holding the physics object and then use that player to get the real mass of the object.
+			// This is ugly but better than having linkage between an object and its "holding" player.
+			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
+			{
+				CBasePlayer *tempPlayer = UTIL_PlayerByIndex( i );
+				if ( tempPlayer && pEvent->pEntities[index] == tempPlayer->GetHeldObject() )
+				{
+					pPlayer = tempPlayer;
+					break;
+				}
+			}
+		}
+
+		if ( pPlayer )
+		{
+			otherMass = pPlayer->GetHeldObjectMass( pEvent->pObjects[otherIndex] );
+		}
+#else
 		if ( gpGlobals->maxClients == 1 )
 		{
 			// if the player is holding the object, use it's real mass (player holding reduced the mass)
@@ -344,6 +373,7 @@ float CalculatePhysicsImpactDamage( int index, gamevcollisionevent_t *pEvent, co
 				otherMass = pPlayer->GetHeldObjectMass( pEvent->pObjects[otherIndex] );
 			}
 		}
+#endif // HL2SB
 	}
 
 	// NOTE: sum the mass of each object in this system for the purpose of damage
@@ -438,6 +468,38 @@ float CalculatePhysicsImpactDamage( int index, gamevcollisionevent_t *pEvent, co
 	}
 	else if ( pEvent->pObjects[index]->GetGameFlags() & FVPHYSICS_PLAYER_HELD )
 	{
+#ifdef HL2SB
+		// if the player is holding the object, use it's real mass (player holding reduced the mass)
+
+		CBasePlayer *pPlayer = NULL;
+		if ( gpGlobals->maxClients == 1 )
+		{
+			pPlayer = UTIL_GetLocalPlayer();
+		}
+		else
+		{
+			// See which MP player is holding the physics object and then use that player to get the real mass of the object.
+			// This is ugly but better than having linkage between an object and its "holding" player.
+			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
+			{
+				CBasePlayer *tempPlayer = UTIL_PlayerByIndex( i );
+				if ( tempPlayer && pEvent->pEntities[index] == tempPlayer->GetHeldObject() )
+				{
+					pPlayer = tempPlayer;
+					break;
+				}
+			}
+		}
+
+		if ( pPlayer )
+		{
+			float mass = pPlayer->GetHeldObjectMass( pEvent->pObjects[index] );
+			if ( mass > 0 )
+			{
+				invMass = 1.0f / mass;
+			}
+		}
+#else
 		if ( gpGlobals->maxClients == 1 )
 		{
 			// if the player is holding the object, use it's real mass (player holding reduced the mass)
@@ -451,6 +513,7 @@ float CalculatePhysicsImpactDamage( int index, gamevcollisionevent_t *pEvent, co
 				}
 			}
 		}
+#endif // HL2SB
 	}
 
 	eliminatedEnergy *= invMass * energyScale;
diff --git a/src/game/server/player.cpp b/src/game/server/player.cpp
index b8a0519d..24f7cba3 100644
--- a/src/game/server/player.cpp
+++ b/src/game/server/player.cpp
@@ -2890,6 +2890,12 @@ float CBasePlayer::GetHeldObjectMass( IPhysicsObject *pHeldObject )
 	return 0;
 }
 
+#ifdef HL2SB
+CBaseEntity	*CBasePlayer::GetHeldObject( void )
+{
+	return NULL;
+}
+#endif // HL2SB
 
 //-----------------------------------------------------------------------------
 // Purpose:	Server side of jumping rules.  Most jumping logic is already
diff --git a/src/game/server/player.h b/src/game/server/player.h
index 902e0e62..6c37a175 100644
--- a/src/game/server/player.h
+++ b/src/game/server/player.h
@@ -568,6 +568,9 @@ class CBasePlayer : public CBaseCombatCharacter
 	virtual void			PickupObject( CBaseEntity *pObject, bool bLimitMassAndSize = true ) {}
 	virtual void			ForceDropOfCarriedPhysObjects( CBaseEntity *pOnlyIfHoldindThis = NULL ) {}
 	virtual float			GetHeldObjectMass( IPhysicsObject *pHeldObject );
+#ifdef HL2SB
+	virtual CBaseEntity		*GetHeldObject( void );
+#endif // HL2SB
 
 	void					CheckSuitUpdate();
 	void					SetSuitUpdate(const char *name, int fgroup, int iNoRepeat);
diff --git a/src/game/shared/basecombatweapon_shared.h b/src/game/shared/basecombatweapon_shared.h
index 4ca7cd03..da4bbc3a 100644
--- a/src/game/shared/basecombatweapon_shared.h
+++ b/src/game/shared/basecombatweapon_shared.h
@@ -521,6 +521,11 @@ class CBaseCombatWeapon : public BASECOMBATWEAPON_DERIVED_FROM
 	bool					WantsToOverrideViewmodelAttachments( void ) { return false; }
 #endif
 
+#ifdef HL2SB
+	//Tony; notifications of any third person switches.
+	virtual void			ThirdPersonSwitch( bool bThirdPerson ) {};
+#endif // HL2SB
+
 #endif // End client-only methods
 
 	virtual bool			CanLower( void ) { return false; }
diff --git a/src/game/shared/gamemovement.cpp b/src/game/shared/gamemovement.cpp
index 19fd739b..909d0d59 100644
--- a/src/game/shared/gamemovement.cpp
+++ b/src/game/shared/gamemovement.cpp
@@ -17,6 +17,15 @@
 #ifdef CLIENT_DLL
 #include "prediction.h"
 #endif
+#ifdef HL2SB
+	#ifdef HL2MP
+		#ifdef GAME_DLL
+			#include "hl2mp_player.h"
+		#else
+			#include "c_hl2mp_player.h"
+		#endif
+	#endif
+#endif
 
 #if defined(HL2_DLL) || defined(HL2_CLIENT_DLL)
 	#include "hl_movedata.h"
@@ -2419,7 +2428,15 @@ bool CGameMovement::CheckJumpButton( void )
 	
 	player->PlayStepSound( (Vector &)mv->GetAbsOrigin(), player->m_pSurfaceData, 1.0, true );
 	
+#ifndef HL2SB
 	MoveHelper()->PlayerSetAnimation( PLAYER_JUMP );
+#else
+	#ifdef HL2MP
+		CHL2MP_Player *pPlayer = ToHL2MPPlayer( player );
+		if ( pPlayer )
+			pPlayer->DoAnimationEvent( PLAYERANIMEVENT_JUMP );
+	#endif
+#endif
 
 	float flGroundFactor = 1.0f;
 	if (player->m_pSurfaceData)
diff --git a/src/game/shared/hl2mp/hl2mp_player_shared.cpp b/src/game/shared/hl2mp/hl2mp_player_shared.cpp
index 503d498c..f952438f 100644
--- a/src/game/shared/hl2mp/hl2mp_player_shared.cpp
+++ b/src/game/shared/hl2mp/hl2mp_player_shared.cpp
@@ -18,6 +18,11 @@
 #include "engine/IEngineSound.h"
 #include "SoundEmitterSystem/isoundemittersystembase.h"
 
+#ifdef HL2SB
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+#endif // HL2SB
+
 extern ConVar sv_footsteps;
 
 const char *g_ppszPlayerSoundPrefixNames[PLAYER_SOUNDS_MAX] =
@@ -121,7 +126,7 @@ void CHL2MP_Player::PlayStepSound( Vector &vecOrigin, surfacedata_t *psurface, f
 	EmitSound( filter, entindex(), ep );
 }
 
-
+#ifndef HL2SB
 //==========================
 // ANIMATION CODE
 //==========================
@@ -574,4 +579,5 @@ void CPlayerAnimState::GetOuterAbsVelocity( Vector& vel )
 #else
 	vel = GetOuter()->GetAbsVelocity();
 #endif
-}
\ No newline at end of file
+}
+#endif // !HL2SB
diff --git a/src/game/shared/hl2mp/hl2mp_player_shared.h b/src/game/shared/hl2mp/hl2mp_player_shared.h
index 3aee9237..c5fdc933 100644
--- a/src/game/shared/hl2mp/hl2mp_player_shared.h
+++ b/src/game/shared/hl2mp/hl2mp_player_shared.h
@@ -34,6 +34,7 @@ enum HL2MPPlayerState
 #define CHL2MP_Player C_HL2MP_Player
 #endif
 
+#ifndef HL2SB
 class CPlayerAnimState
 {
 public:
@@ -93,5 +94,6 @@ class CPlayerAnimState
 
 	float				m_flTurnCorrectionTime;
 };
+#endif // !HL2SB
 
 #endif //HL2MP_PLAYER_SHARED_h
diff --git a/src/game/shared/hl2mp/hl2mp_playeranimstate.cpp b/src/game/shared/hl2mp/hl2mp_playeranimstate.cpp
new file mode 100644
index 00000000..23698233
--- /dev/null
+++ b/src/game/shared/hl2mp/hl2mp_playeranimstate.cpp
@@ -0,0 +1,704 @@
+//========= Copyright Valve Corporation, All rights reserved. ============//
+#include "cbase.h"
+#include "base_playeranimstate.h"
+#include "tier0/vprof.h"
+#include "animation.h"
+#include "studio.h"
+#include "apparent_velocity_helper.h"
+#include "utldict.h"
+
+#include "hl2mp_playeranimstate.h"
+#include "base_playeranimstate.h"
+#include "datacache/imdlcache.h"
+
+#ifdef CLIENT_DLL
+#include "c_hl2mp_player.h"
+#else
+#include "hl2mp_player.h"
+#endif
+
+#define HL2MP_RUN_SPEED				320.0f
+#define HL2MP_WALK_SPEED			75.0f
+#define HL2MP_CROUCHWALK_SPEED		110.0f
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : *pPlayer - 
+// Output : CMultiPlayerAnimState*
+//-----------------------------------------------------------------------------
+CHL2MPPlayerAnimState* CreateHL2MPPlayerAnimState( CHL2MP_Player *pPlayer )
+{
+	MDLCACHE_CRITICAL_SECTION();
+
+	// Setup the movement data.
+	MultiPlayerMovementData_t movementData;
+	movementData.m_flBodyYawRate = 720.0f;
+	movementData.m_flRunSpeed = HL2MP_RUN_SPEED;
+	movementData.m_flWalkSpeed = HL2MP_WALK_SPEED;
+	movementData.m_flSprintSpeed = -1.0f;
+
+	// Create animation state for this player.
+	CHL2MPPlayerAnimState *pRet = new CHL2MPPlayerAnimState( pPlayer, movementData );
+
+	// Specific HL2MP player initialization.
+	pRet->InitHL2MPAnimState( pPlayer );
+
+	return pRet;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  :  - 
+//-----------------------------------------------------------------------------
+CHL2MPPlayerAnimState::CHL2MPPlayerAnimState()
+{
+	m_pHL2MPPlayer = NULL;
+
+	// Don't initialize HL2MP specific variables here. Init them in InitHL2MPAnimState()
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : *pPlayer - 
+//			&movementData - 
+//-----------------------------------------------------------------------------
+CHL2MPPlayerAnimState::CHL2MPPlayerAnimState( CBasePlayer *pPlayer, MultiPlayerMovementData_t &movementData )
+: CMultiPlayerAnimState( pPlayer, movementData )
+{
+	m_pHL2MPPlayer = NULL;
+
+	// Don't initialize HL2MP specific variables here. Init them in InitHL2MPAnimState()
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  :  - 
+//-----------------------------------------------------------------------------
+CHL2MPPlayerAnimState::~CHL2MPPlayerAnimState()
+{
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Initialize HL2MP specific animation state.
+// Input  : *pPlayer - 
+//-----------------------------------------------------------------------------
+void CHL2MPPlayerAnimState::InitHL2MPAnimState( CHL2MP_Player *pPlayer )
+{
+	m_pHL2MPPlayer = pPlayer;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CHL2MPPlayerAnimState::ClearAnimationState( void )
+{
+	BaseClass::ClearAnimationState();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : actDesired - 
+// Output : Activity
+//-----------------------------------------------------------------------------
+Activity CHL2MPPlayerAnimState::TranslateActivity( Activity actDesired )
+{
+	// Hook into baseclass when / if hl2mp player models get swim animations.
+	Activity translateActivity = actDesired; //BaseClass::TranslateActivity( actDesired );
+
+	if ( GetHL2MPPlayer()->GetActiveWeapon() )
+	{
+		bool dummy = false;
+		translateActivity = GetHL2MPPlayer()->GetActiveWeapon()->ActivityOverride( translateActivity, &dummy );
+	}
+
+	return translateActivity;
+}
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CHL2MPPlayerAnimState::Update( float eyeYaw, float eyePitch )
+{
+	// Profile the animation update.
+	VPROF( "CHL2MPPlayerAnimState::Update" );
+
+	// Get the HL2MP player.
+	CHL2MP_Player *pHL2MPPlayer = GetHL2MPPlayer();
+	if ( !pHL2MPPlayer )
+		return;
+
+	// Get the studio header for the player.
+	CStudioHdr *pStudioHdr = pHL2MPPlayer->GetModelPtr();
+	if ( !pStudioHdr )
+		return;
+
+	// Check to see if we should be updating the animation state - dead, ragdolled?
+	if ( !ShouldUpdateAnimState() )
+	{
+		ClearAnimationState();
+		return;
+	}
+
+	// Store the eye angles.
+	m_flEyeYaw = AngleNormalize( eyeYaw );
+	m_flEyePitch = AngleNormalize( eyePitch );
+
+	// Compute the player sequences.
+	ComputeSequences( pStudioHdr );
+
+	if ( SetupPoseParameters( pStudioHdr ) )
+	{
+		// Pose parameter - what direction are the player's legs running in.
+		ComputePoseParam_MoveYaw( pStudioHdr );
+
+		// Pose parameter - Torso aiming (up/down).
+		ComputePoseParam_AimPitch( pStudioHdr );
+
+		// Pose parameter - Torso aiming (rotation).
+		ComputePoseParam_AimYaw( pStudioHdr );
+	}
+
+#ifdef CLIENT_DLL 
+	if ( C_BasePlayer::ShouldDrawLocalPlayer() )
+	{
+		m_pHL2MPPlayer->SetPlaybackRate( 1.0f );
+	}
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : event - 
+//-----------------------------------------------------------------------------
+void CHL2MPPlayerAnimState::DoAnimationEvent( PlayerAnimEvent_t event, int nData )
+{
+	Activity iGestureActivity = ACT_INVALID;
+
+	switch( event )
+	{
+	case PLAYERANIMEVENT_ATTACK_PRIMARY:
+		{
+			// Weapon primary fire.
+			if ( m_pHL2MPPlayer->GetFlags() & FL_DUCKING )
+				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_ATTACK_CROUCH_PRIMARYFIRE );
+			else
+				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_ATTACK_STAND_PRIMARYFIRE );
+
+			iGestureActivity = ACT_VM_PRIMARYATTACK;
+			break;
+		}
+
+	case PLAYERANIMEVENT_VOICE_COMMAND_GESTURE:
+		{
+			if ( !IsGestureSlotActive( GESTURE_SLOT_ATTACK_AND_RELOAD ) )
+				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, (Activity)nData );
+
+			break;
+		}
+	case PLAYERANIMEVENT_ATTACK_SECONDARY:
+		{
+			// Weapon secondary fire.
+			if ( m_pHL2MPPlayer->GetFlags() & FL_DUCKING )
+				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_ATTACK_CROUCH_SECONDARYFIRE );
+			else
+				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_ATTACK_STAND_SECONDARYFIRE );
+
+			iGestureActivity = ACT_VM_PRIMARYATTACK;
+			break;
+		}
+	case PLAYERANIMEVENT_ATTACK_PRE:
+		{
+			if ( m_pHL2MPPlayer->GetFlags() & FL_DUCKING ) 
+			{
+				// Weapon pre-fire. Used for minigun windup, sniper aiming start, etc in crouch.
+				iGestureActivity = ACT_MP_ATTACK_CROUCH_PREFIRE;
+			}
+			else
+			{
+				// Weapon pre-fire. Used for minigun windup, sniper aiming start, etc.
+				iGestureActivity = ACT_MP_ATTACK_STAND_PREFIRE;
+			}
+
+			RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, iGestureActivity, false );
+
+			break;
+		}
+	case PLAYERANIMEVENT_ATTACK_POST:
+		{
+			RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_ATTACK_STAND_POSTFIRE );
+			break;
+		}
+
+	case PLAYERANIMEVENT_RELOAD:
+		{
+			// Weapon reload.
+			if ( GetBasePlayer()->GetFlags() & FL_DUCKING )
+				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_CROUCH );
+			else
+				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_STAND );
+			break;
+		}
+	case PLAYERANIMEVENT_RELOAD_LOOP:
+		{
+			// Weapon reload.
+			if ( GetBasePlayer()->GetFlags() & FL_DUCKING )
+				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_CROUCH_LOOP );
+			else
+				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_STAND_LOOP );
+			break;
+		}
+	case PLAYERANIMEVENT_RELOAD_END:
+		{
+			// Weapon reload.
+			if ( GetBasePlayer()->GetFlags() & FL_DUCKING )
+				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_CROUCH_END );
+			else
+				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_STAND_END );
+			break;
+		}
+	default:
+		{
+			BaseClass::DoAnimationEvent( event, nData );
+			break;
+		}
+	}
+
+#ifdef CLIENT_DLL
+	// Make the weapon play the animation as well
+	if ( iGestureActivity != ACT_INVALID )
+	{
+		CBaseCombatWeapon *pWeapon = GetHL2MPPlayer()->GetActiveWeapon();
+		if ( pWeapon )
+		{
+//			pWeapon->EnsureCorrectRenderingModel();
+			pWeapon->SendWeaponAnim( iGestureActivity );
+//			// Force animation events!
+//			pWeapon->ResetEventsParity();		// reset event parity so the animation events will occur on the weapon. 
+			pWeapon->DoAnimationEvents( pWeapon->GetModelPtr() );
+		}
+	}
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : *idealActivity - 
+//-----------------------------------------------------------------------------
+bool CHL2MPPlayerAnimState::HandleSwimming( Activity &idealActivity )
+{
+	bool bInWater = BaseClass::HandleSwimming( idealActivity );
+
+	return bInWater;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : *idealActivity - 
+// Output : Returns true on success, false on failure.
+//-----------------------------------------------------------------------------
+bool CHL2MPPlayerAnimState::HandleMoving( Activity &idealActivity )
+{
+	return BaseClass::HandleMoving( idealActivity );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : *idealActivity - 
+// Output : Returns true on success, false on failure.
+//-----------------------------------------------------------------------------
+bool CHL2MPPlayerAnimState::HandleDucking( Activity &idealActivity )
+{
+	if ( m_pHL2MPPlayer->GetFlags() & FL_DUCKING )
+	{
+		if ( GetOuterXYSpeed() < MOVING_MINIMUM_SPEED )
+		{
+			idealActivity = ACT_MP_CROUCH_IDLE;		
+		}
+		else
+		{
+			idealActivity = ACT_MP_CROUCHWALK;		
+		}
+
+		return true;
+	}
+	
+	return false;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+bool CHL2MPPlayerAnimState::HandleJumping( Activity &idealActivity )
+{
+	Vector vecVelocity;
+	GetOuterAbsVelocity( vecVelocity );
+
+	if ( m_bJumping )
+	{
+		static bool bNewJump = false; //Tony; hl2mp players only have a 'hop'
+
+		if ( m_bFirstJumpFrame )
+		{
+			m_bFirstJumpFrame = false;
+			RestartMainSequence();	// Reset the animation.
+		}
+
+		// Reset if we hit water and start swimming.
+		if ( m_pHL2MPPlayer->GetWaterLevel() >= WL_Waist )
+		{
+			m_bJumping = false;
+			RestartMainSequence();
+		}
+		// Don't check if he's on the ground for a sec.. sometimes the client still has the
+		// on-ground flag set right when the message comes in.
+		else if ( gpGlobals->curtime - m_flJumpStartTime > 0.2f )
+		{
+			if ( m_pHL2MPPlayer->GetFlags() & FL_ONGROUND )
+			{
+				m_bJumping = false;
+				RestartMainSequence();
+
+				if ( bNewJump )
+				{
+					RestartGesture( GESTURE_SLOT_JUMP, ACT_MP_JUMP_LAND );					
+				}
+			}
+		}
+
+		// if we're still jumping
+		if ( m_bJumping )
+		{
+			if ( bNewJump )
+			{
+				if ( gpGlobals->curtime - m_flJumpStartTime > 0.5 )
+				{
+					idealActivity = ACT_MP_JUMP_FLOAT;
+				}
+				else
+				{
+					idealActivity = ACT_MP_JUMP_START;
+				}
+			}
+			else
+			{
+				idealActivity = ACT_MP_JUMP;
+			}
+		}
+	}	
+
+	if ( m_bJumping )
+		return true;
+
+	return false;
+}
+
+bool CHL2MPPlayerAnimState::SetupPoseParameters( CStudioHdr *pStudioHdr )
+{
+	// Check to see if this has already been done.
+	if ( m_bPoseParameterInit )
+		return true;
+
+	// Save off the pose parameter indices.
+	if ( !pStudioHdr )
+		return false;
+
+	// Tony; just set them both to the same for now.
+	m_PoseParameterData.m_iMoveX = GetBasePlayer()->LookupPoseParameter( pStudioHdr, "move_yaw" );
+	m_PoseParameterData.m_iMoveY = GetBasePlayer()->LookupPoseParameter( pStudioHdr, "move_yaw" );
+	if ( ( m_PoseParameterData.m_iMoveX < 0 ) || ( m_PoseParameterData.m_iMoveY < 0 ) )
+		return false;
+
+	// Look for the aim pitch blender.
+	m_PoseParameterData.m_iAimPitch = GetBasePlayer()->LookupPoseParameter( pStudioHdr, "aim_pitch" );
+	if ( m_PoseParameterData.m_iAimPitch < 0 )
+		return false;
+
+	// Look for aim yaw blender.
+	m_PoseParameterData.m_iAimYaw = GetBasePlayer()->LookupPoseParameter( pStudioHdr, "aim_yaw" );
+	if ( m_PoseParameterData.m_iAimYaw < 0 )
+		return false;
+
+	m_bPoseParameterInit = true;
+
+	return true;
+}
+float SnapYawTo( float flValue );
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CHL2MPPlayerAnimState::EstimateYaw( void )
+{
+	// Get the frame time.
+	float flDeltaTime = gpGlobals->frametime;
+	if ( flDeltaTime == 0.0f )
+		return;
+
+#if 0 // 9way
+	// Get the player's velocity and angles.
+	Vector vecEstVelocity;
+	GetOuterAbsVelocity( vecEstVelocity );
+	QAngle angles = GetBasePlayer()->GetLocalAngles();
+
+	// If we are not moving, sync up the feet and eyes slowly.
+	if ( vecEstVelocity.x == 0.0f && vecEstVelocity.y == 0.0f )
+	{
+		float flYawDelta = angles[YAW] - m_PoseParameterData.m_flEstimateYaw;
+		flYawDelta = AngleNormalize( flYawDelta );
+
+		if ( flDeltaTime < 0.25f )
+		{
+			flYawDelta *= ( flDeltaTime * 4.0f );
+		}
+		else
+		{
+			flYawDelta *= flDeltaTime;
+		}
+
+		m_PoseParameterData.m_flEstimateYaw += flYawDelta;
+		AngleNormalize( m_PoseParameterData.m_flEstimateYaw );
+	}
+	else
+	{
+		m_PoseParameterData.m_flEstimateYaw = ( atan2( vecEstVelocity.y, vecEstVelocity.x ) * 180.0f / M_PI );
+		m_PoseParameterData.m_flEstimateYaw = clamp( m_PoseParameterData.m_flEstimateYaw, -180.0f, 180.0f );
+	}
+#else
+	float dt = gpGlobals->frametime;
+
+	// Get the player's velocity and angles.
+	Vector vecEstVelocity;
+	GetOuterAbsVelocity( vecEstVelocity );
+	QAngle angles = GetBasePlayer()->GetLocalAngles();
+
+	if ( vecEstVelocity.y == 0 && vecEstVelocity.x == 0 )
+	{
+		float flYawDiff = angles[YAW] - m_PoseParameterData.m_flEstimateYaw;
+		flYawDiff = flYawDiff - (int)(flYawDiff / 360) * 360;
+		if (flYawDiff > 180)
+			flYawDiff -= 360;
+		if (flYawDiff < -180)
+			flYawDiff += 360;
+
+		if (dt < 0.25)
+			flYawDiff *= dt * 4;
+		else
+			flYawDiff *= dt;
+
+		m_PoseParameterData.m_flEstimateYaw += flYawDiff;
+		m_PoseParameterData.m_flEstimateYaw = m_PoseParameterData.m_flEstimateYaw - (int)(m_PoseParameterData.m_flEstimateYaw / 360) * 360;
+	}
+	else
+	{
+		m_PoseParameterData.m_flEstimateYaw = (atan2(vecEstVelocity.y, vecEstVelocity.x) * 180 / M_PI);
+
+		if (m_PoseParameterData.m_flEstimateYaw > 180)
+			m_PoseParameterData.m_flEstimateYaw = 180;
+		else if (m_PoseParameterData.m_flEstimateYaw < -180)
+			m_PoseParameterData.m_flEstimateYaw = -180;
+	}
+#endif
+}
+//-----------------------------------------------------------------------------
+// Purpose: Override for backpeddling
+// Input  : dt - 
+//-----------------------------------------------------------------------------
+float SnapYawTo( float flValue );
+void CHL2MPPlayerAnimState::ComputePoseParam_MoveYaw( CStudioHdr *pStudioHdr )
+{
+	// Get the estimated movement yaw.
+	EstimateYaw();
+
+#if 0 // 9way
+	ConVarRef mp_slammoveyaw("mp_slammoveyaw");
+
+	// Get the view yaw.
+	float flAngle = AngleNormalize( m_flEyeYaw );
+
+	// Calc side to side turning - the view vs. movement yaw.
+	float flYaw = flAngle - m_PoseParameterData.m_flEstimateYaw;
+	flYaw = AngleNormalize( -flYaw );
+
+	// Get the current speed the character is running.
+	bool bIsMoving;
+	float flPlaybackRate = 	CalcMovementPlaybackRate( &bIsMoving );
+
+	// Setup the 9-way blend parameters based on our speed and direction.
+	Vector2D vecCurrentMoveYaw( 0.0f, 0.0f );
+	if ( bIsMoving )
+	{
+		if ( mp_slammoveyaw.GetBool() )
+			flYaw = SnapYawTo( flYaw );
+
+		vecCurrentMoveYaw.x = cos( DEG2RAD( flYaw ) ) * flPlaybackRate;
+		vecCurrentMoveYaw.y = -sin( DEG2RAD( flYaw ) ) * flPlaybackRate;
+	}
+
+	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveX, vecCurrentMoveYaw.x );
+	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveY, vecCurrentMoveYaw.y );
+
+	m_DebugAnimData.m_vecMoveYaw = vecCurrentMoveYaw;
+#else
+	// view direction relative to movement
+	float flYaw;	 
+
+	QAngle	angles = GetBasePlayer()->GetLocalAngles();
+	float ang = angles[ YAW ];
+	if ( ang > 180.0f )
+	{
+		ang -= 360.0f;
+	}
+	else if ( ang < -180.0f )
+	{
+		ang += 360.0f;
+	}
+
+	// calc side to side turning
+	flYaw = ang - m_PoseParameterData.m_flEstimateYaw;
+	// Invert for mapping into 8way blend
+	flYaw = -flYaw;
+	flYaw = flYaw - (int)(flYaw / 360) * 360;
+
+	if (flYaw < -180)
+	{
+		flYaw = flYaw + 360;
+	}
+	else if (flYaw > 180)
+	{
+		flYaw = flYaw - 360;
+	}
+
+	//Tony; oops, i inverted this previously above.
+	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveY, flYaw );
+
+#endif
+	
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CHL2MPPlayerAnimState::ComputePoseParam_AimPitch( CStudioHdr *pStudioHdr )
+{
+	// Get the view pitch.
+	float flAimPitch = m_flEyePitch;
+
+	// Set the aim pitch pose parameter and save.
+	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iAimPitch, flAimPitch );
+	m_DebugAnimData.m_flAimPitch = flAimPitch;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CHL2MPPlayerAnimState::ComputePoseParam_AimYaw( CStudioHdr *pStudioHdr )
+{
+	// Get the movement velocity.
+	Vector vecVelocity;
+	GetOuterAbsVelocity( vecVelocity );
+
+	// Check to see if we are moving.
+	bool bMoving = ( vecVelocity.Length() > 1.0f ) ? true : false;
+
+	// If we are moving or are prone and undeployed.
+	if ( bMoving || m_bForceAimYaw )
+	{
+		// The feet match the eye direction when moving - the move yaw takes care of the rest.
+		m_flGoalFeetYaw = m_flEyeYaw;
+	}
+	// Else if we are not moving.
+	else
+	{
+		// Initialize the feet.
+		if ( m_PoseParameterData.m_flLastAimTurnTime <= 0.0f )
+		{
+			m_flGoalFeetYaw	= m_flEyeYaw;
+			m_flCurrentFeetYaw = m_flEyeYaw;
+			m_PoseParameterData.m_flLastAimTurnTime = gpGlobals->curtime;
+		}
+		// Make sure the feet yaw isn't too far out of sync with the eye yaw.
+		// TODO: Do something better here!
+		else
+		{
+			float flYawDelta = AngleNormalize(  m_flGoalFeetYaw - m_flEyeYaw );
+
+			if ( fabs( flYawDelta ) > 45.0f )
+			{
+				float flSide = ( flYawDelta > 0.0f ) ? -1.0f : 1.0f;
+				m_flGoalFeetYaw += ( 45.0f * flSide );
+			}
+		}
+	}
+
+	// Fix up the feet yaw.
+	m_flGoalFeetYaw = AngleNormalize( m_flGoalFeetYaw );
+	if ( m_flGoalFeetYaw != m_flCurrentFeetYaw )
+	{
+		if ( m_bForceAimYaw )
+		{
+			m_flCurrentFeetYaw = m_flGoalFeetYaw;
+		}
+		else
+		{
+			ConvergeYawAngles( m_flGoalFeetYaw, 720.0f, gpGlobals->frametime, m_flCurrentFeetYaw );
+			m_flLastAimTurnTime = gpGlobals->curtime;
+		}
+	}
+
+	// Rotate the body into position.
+	m_angRender[YAW] = m_flCurrentFeetYaw;
+
+	// Find the aim(torso) yaw base on the eye and feet yaws.
+	float flAimYaw = m_flEyeYaw - m_flCurrentFeetYaw;
+	flAimYaw = AngleNormalize( flAimYaw );
+
+	// Set the aim yaw and save.
+	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iAimYaw, flAimYaw );
+	m_DebugAnimData.m_flAimYaw	= flAimYaw;
+
+	// Turn off a force aim yaw - either we have already updated or we don't need to.
+	m_bForceAimYaw = false;
+
+#ifndef CLIENT_DLL
+	QAngle angle = GetBasePlayer()->GetAbsAngles();
+	angle[YAW] = m_flCurrentFeetYaw;
+
+	GetBasePlayer()->SetAbsAngles( angle );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Override the default, because hl2mp models don't use moveX
+// Input  :  - 
+// Output : float
+//-----------------------------------------------------------------------------
+float CHL2MPPlayerAnimState::GetCurrentMaxGroundSpeed()
+{
+	CStudioHdr *pStudioHdr = GetBasePlayer()->GetModelPtr();
+
+	if ( pStudioHdr == NULL )
+		return 1.0f;
+
+//	float prevX = GetBasePlayer()->GetPoseParameter( m_PoseParameterData.m_iMoveX );
+	float prevY = GetBasePlayer()->GetPoseParameter( m_PoseParameterData.m_iMoveY );
+
+	float d = sqrt( /*prevX * prevX + */prevY * prevY );
+	float newY;//, newX;
+	if ( d == 0.0 )
+	{ 
+//		newX = 1.0;
+		newY = 0.0;
+	}
+	else
+	{
+//		newX = prevX / d;
+		newY = prevY / d;
+	}
+
+//	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveX, newX );
+	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveY, newY );
+
+	float speed = GetBasePlayer()->GetSequenceGroundSpeed( GetBasePlayer()->GetSequence() );
+
+//	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveX, prevX );
+	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveY, prevY );
+
+	return speed;
+}
diff --git a/src/game/shared/hl2mp/hl2mp_playeranimstate.h b/src/game/shared/hl2mp/hl2mp_playeranimstate.h
new file mode 100644
index 00000000..20fde735
--- /dev/null
+++ b/src/game/shared/hl2mp/hl2mp_playeranimstate.h
@@ -0,0 +1,65 @@
+//========= Copyright Valve Corporation, All rights reserved. ============//
+#ifndef HL2MP_PLAYERANIMSTATE_H
+#define HL2MP_PLAYERANIMSTATE_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+#include "convar.h"
+#include "multiplayer_animstate.h"
+
+#if defined( CLIENT_DLL )
+class C_HL2MP_Player;
+#define CHL2MP_Player C_HL2MP_Player
+#else
+class CHL2MP_Player;
+#endif
+
+// ------------------------------------------------------------------------------------------------ //
+// CPlayerAnimState declaration.
+// ------------------------------------------------------------------------------------------------ //
+class CHL2MPPlayerAnimState : public CMultiPlayerAnimState
+{
+public:
+
+	DECLARE_CLASS( CHL2MPPlayerAnimState, CMultiPlayerAnimState );
+
+	CHL2MPPlayerAnimState();
+	CHL2MPPlayerAnimState( CBasePlayer *pPlayer, MultiPlayerMovementData_t &movementData );
+	~CHL2MPPlayerAnimState();
+
+	void InitHL2MPAnimState( CHL2MP_Player *pPlayer );
+	CHL2MP_Player *GetHL2MPPlayer( void )							{ return m_pHL2MPPlayer; }
+
+	virtual void ClearAnimationState();
+	virtual Activity TranslateActivity( Activity actDesired );
+	virtual void Update( float eyeYaw, float eyePitch );
+
+	void	DoAnimationEvent( PlayerAnimEvent_t event, int nData = 0 );
+
+	bool	HandleMoving( Activity &idealActivity );
+	bool	HandleJumping( Activity &idealActivity );
+	bool	HandleDucking( Activity &idealActivity );
+	bool	HandleSwimming( Activity &idealActivity );
+
+	virtual float GetCurrentMaxGroundSpeed();
+
+private:
+
+	bool						SetupPoseParameters( CStudioHdr *pStudioHdr );
+	virtual void				EstimateYaw( void );
+	virtual void				ComputePoseParam_MoveYaw( CStudioHdr *pStudioHdr );
+	virtual void				ComputePoseParam_AimPitch( CStudioHdr *pStudioHdr );
+	virtual void				ComputePoseParam_AimYaw( CStudioHdr *pStudioHdr );
+
+	CHL2MP_Player   *m_pHL2MPPlayer;
+	bool		m_bInAirWalk;
+	float		m_flHoldDeployedPoseUntilTime;
+};
+
+CHL2MPPlayerAnimState *CreateHL2MPPlayerAnimState( CHL2MP_Player *pPlayer );
+
+
+
+#endif // HL2MP_PLAYERANIMSTATE_H
diff --git a/src/game/shared/hl2mp/weapon_357.cpp b/src/game/shared/hl2mp/weapon_357.cpp
index 5dd38906..bbdd99a7 100644
--- a/src/game/shared/hl2mp/weapon_357.cpp
+++ b/src/game/shared/hl2mp/weapon_357.cpp
@@ -37,7 +37,7 @@ class CWeapon357 : public CBaseHL2MPCombatWeapon
 	DECLARE_NETWORKCLASS(); 
 	DECLARE_PREDICTABLE();
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
 #endif
 
@@ -58,9 +58,24 @@ LINK_ENTITY_TO_CLASS( weapon_357, CWeapon357 );
 PRECACHE_WEAPON_REGISTER( weapon_357 );
 
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 acttable_t CWeapon357::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PISTOL,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PISTOL,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PISTOL,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PISTOL,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PISTOL,					false },
+#else
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_PISTOL,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_PISTOL,					false },
 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_PISTOL,			false },
@@ -69,6 +84,7 @@ acttable_t CWeapon357::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_PISTOL,					false },
 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_PISTOL,				false },
+#endif // HL2SB
 };
 
 
@@ -92,7 +108,11 @@ CWeapon357::CWeapon357( void )
 void CWeapon357::PrimaryAttack( void )
 {
 	// Only the player fires this way so we can cast
+#ifdef HL2SB
+	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
+#else
 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+#endif // HL2SB
 
 	if ( !pPlayer )
 	{
@@ -118,7 +138,11 @@ void CWeapon357::PrimaryAttack( void )
 	pPlayer->DoMuzzleFlash();
 
 	SendWeaponAnim( ACT_VM_PRIMARYATTACK );
+#ifdef HL2SB
+	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
+#else
 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
+#endif // HL2SB
 
 	m_flNextPrimaryAttack = gpGlobals->curtime + 0.75;
 	m_flNextSecondaryAttack = gpGlobals->curtime + 0.75;
diff --git a/src/game/shared/hl2mp/weapon_ar2.cpp b/src/game/shared/hl2mp/weapon_ar2.cpp
index eb63086d..361012a8 100644
--- a/src/game/shared/hl2mp/weapon_ar2.cpp
+++ b/src/game/shared/hl2mp/weapon_ar2.cpp
@@ -58,10 +58,25 @@ LINK_ENTITY_TO_CLASS( weapon_ar2, CWeaponAR2 );
 PRECACHE_WEAPON_REGISTER(weapon_ar2);
 
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 
 acttable_t	CWeaponAR2::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_AR2,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_AR2,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_AR2,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_AR2,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_AR2,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_AR2,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_AR2,					false },
+#else
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_AR2,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_AR2,					false },
 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_AR2,			false },
@@ -70,6 +85,7 @@ acttable_t	CWeaponAR2::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_AR2,		false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_AR2,					false },
 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_AR2,				false },
+#endif // HL2SB
 };
 
 IMPLEMENT_ACTTABLE(CWeaponAR2);
diff --git a/src/game/shared/hl2mp/weapon_ar2.h b/src/game/shared/hl2mp/weapon_ar2.h
index 101e893d..877ff629 100644
--- a/src/game/shared/hl2mp/weapon_ar2.h
+++ b/src/game/shared/hl2mp/weapon_ar2.h
@@ -75,7 +75,7 @@ class CWeaponAR2 : public CHL2MPMachineGun
 	CNetworkVar( bool,		m_bShotDelayed );
 	int						m_nVentPose;
 	
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
 #endif
 };
diff --git a/src/game/shared/hl2mp/weapon_crossbow.cpp b/src/game/shared/hl2mp/weapon_crossbow.cpp
index 66fa5359..922bc071 100644
--- a/src/game/shared/hl2mp/weapon_crossbow.cpp
+++ b/src/game/shared/hl2mp/weapon_crossbow.cpp
@@ -433,7 +433,7 @@ class CWeaponCrossbow : public CBaseHL2MPCombatWeapon
 	void	SetChargerState( ChargerState_t state );
 	void	DoLoadEffect( void );
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
 #endif
 
@@ -478,10 +478,25 @@ LINK_ENTITY_TO_CLASS( weapon_crossbow, CWeaponCrossbow );
 
 PRECACHE_WEAPON_REGISTER( weapon_crossbow );
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 
 acttable_t	CWeaponCrossbow::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_CROSSBOW,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_CROSSBOW,				false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_CROSSBOW,						false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_CROSSBOW,				false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,			false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,			false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_CROSSBOW,					false },
+#else
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_CROSSBOW,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_CROSSBOW,						false },
 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_CROSSBOW,				false },
@@ -489,6 +504,7 @@ acttable_t	CWeaponCrossbow::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,	false },
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_CROSSBOW,			false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_CROSSBOW,					false },
+#endif // HL2SB
 };
 
 IMPLEMENT_ACTTABLE(CWeaponCrossbow);
@@ -801,6 +817,41 @@ void CWeaponCrossbow::DoLoadEffect( void )
 	if ( pOwner == NULL )
 		return;
 
+#ifdef HL2SB
+	//Tony; change this up a bit; on the server, dispatch an effect but don't send it to the client who fires
+	//on the client, create an effect either in the view model, or on the world model if first person.
+	CEffectData	data;
+
+	data.m_nAttachmentIndex = 1;
+	data.m_vOrigin = pOwner->GetAbsOrigin();
+
+	CPASFilter filter( data.m_vOrigin );
+
+#ifdef GAME_DLL
+	filter.RemoveRecipient( pOwner );
+	data.m_nEntIndex = entindex();
+#else
+	CBaseViewModel *pViewModel = pOwner->GetViewModel();
+	if ( ShouldDrawUsingViewModel() && pViewModel != NULL )
+		data.m_hEntity = pViewModel->GetRefEHandle();
+	else
+		data.m_hEntity = GetRefEHandle();
+#endif
+	DispatchEffect( "CrossbowLoad", data, filter );
+
+#ifndef CLIENT_DLL
+	CSprite *pBlast = CSprite::SpriteCreate( CROSSBOW_GLOW_SPRITE2, GetAbsOrigin(), false );
+
+	if ( pBlast )
+	{
+		pBlast->SetAttachment( this, 1 );
+		pBlast->SetTransparency( kRenderTransAdd, 255, 255, 255, 255, kRenderFxNone );
+		pBlast->SetBrightness( 128 );
+		pBlast->SetScale( 0.2f );
+		pBlast->FadeOutFromSpawn();
+	}
+#endif
+#else
 	CBaseViewModel *pViewModel = pOwner->GetViewModel();
 
 	if ( pViewModel == NULL )
@@ -830,7 +881,7 @@ void CWeaponCrossbow::DoLoadEffect( void )
 		pBlast->FadeOutFromSpawn();
 	}
 #endif
-	
+#endif // HL2SB
 }
 
 //-----------------------------------------------------------------------------
diff --git a/src/game/shared/hl2mp/weapon_crowbar.cpp b/src/game/shared/hl2mp/weapon_crowbar.cpp
index 55a03d1d..0f979aac 100644
--- a/src/game/shared/hl2mp/weapon_crowbar.cpp
+++ b/src/game/shared/hl2mp/weapon_crowbar.cpp
@@ -45,10 +45,25 @@ END_PREDICTION_DATA()
 LINK_ENTITY_TO_CLASS( weapon_crowbar, CWeaponCrowbar );
 PRECACHE_WEAPON_REGISTER( weapon_crowbar );
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 
 acttable_t	CWeaponCrowbar::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_MELEE,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_MELEE,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_MELEE,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_MELEE,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_MELEE,					false },
+#else
 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_SLAM, true },
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_MELEE,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_MELEE,					false },
@@ -57,6 +72,7 @@ acttable_t	CWeaponCrowbar::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_MELEE,					false },
+#endif // HL2SB
 };
 
 IMPLEMENT_ACTTABLE(CWeaponCrowbar);
diff --git a/src/game/shared/hl2mp/weapon_crowbar.h b/src/game/shared/hl2mp/weapon_crowbar.h
index 2cd10fb9..a6d10679 100644
--- a/src/game/shared/hl2mp/weapon_crowbar.h
+++ b/src/game/shared/hl2mp/weapon_crowbar.h
@@ -36,7 +36,7 @@ class CWeaponCrowbar : public CBaseHL2MPBludgeonWeapon
 	DECLARE_NETWORKCLASS(); 
 	DECLARE_PREDICTABLE();
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
 #endif
 
diff --git a/src/game/shared/hl2mp/weapon_frag.cpp b/src/game/shared/hl2mp/weapon_frag.cpp
index 8f4b7b00..d12b54cb 100644
--- a/src/game/shared/hl2mp/weapon_frag.cpp
+++ b/src/game/shared/hl2mp/weapon_frag.cpp
@@ -83,15 +83,30 @@ class CWeaponFrag: public CBaseHL2MPCombatWeapon
 
 	CWeaponFrag( const CWeaponFrag & );
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
 #endif
 };
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 
 acttable_t	CWeaponFrag::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_GRENADE,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_GRENADE,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_GRENADE,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_GRENADE,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_GRENADE,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_GRENADE,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_GRENADE,					false },
+#else
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_GRENADE,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_GRENADE,					false },
 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_GRENADE,			false },
@@ -99,6 +114,7 @@ acttable_t	CWeaponFrag::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,	false },
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_GRENADE,		false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_GRENADE,					false },
+#endif // HL2SB
 };
 
 IMPLEMENT_ACTTABLE(CWeaponFrag);
@@ -341,7 +357,11 @@ void CWeaponFrag::ItemPostFrame( void )
 {
 	if( m_fDrawbackFinished )
 	{
+#ifdef HL2SB
+		CHL2MP_Player *pOwner = ToHL2MPPlayer( GetOwner() );
+#else
 		CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+#endif // HL2SB
 
 		if (pOwner)
 		{
@@ -351,6 +371,9 @@ void CWeaponFrag::ItemPostFrame( void )
 				if( !(pOwner->m_nButtons & IN_ATTACK) )
 				{
 					SendWeaponAnim( ACT_VM_THROW );
+#ifdef HL2SB
+					pOwner->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
+#endif // HL2SB
 					m_fDrawbackFinished = false;
 				}
 				break;
@@ -370,6 +393,11 @@ void CWeaponFrag::ItemPostFrame( void )
 						SendWeaponAnim( ACT_VM_HAULBACK );
 					}
 
+#ifdef HL2SB
+					//Tony; the grenade really should have a secondary anim. but it doesn't on the player.
+					pOwner->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
+#endif // HL2SB
+
 					m_fDrawbackFinished = false;
 				}
 				break;
diff --git a/src/game/shared/hl2mp/weapon_hl2mpbase.cpp b/src/game/shared/hl2mp/weapon_hl2mpbase.cpp
index 15995a5b..6ec5f014 100644
--- a/src/game/shared/hl2mp/weapon_hl2mpbase.cpp
+++ b/src/game/shared/hl2mp/weapon_hl2mpbase.cpp
@@ -106,6 +106,20 @@ bool CWeaponHL2MPBase::IsPredicted() const
 	return true;
 }
 
+#ifdef HL2SB
+//Tony; override for animation purposes.
+bool CWeaponHL2MPBase::Reload( void )
+{
+	bool fRet = DefaultReload( GetMaxClip1(), GetMaxClip2(), ACT_VM_RELOAD );
+	if ( fRet )
+	{
+//		WeaponSound( RELOAD );
+		ToHL2MPPlayer(GetOwner())->DoAnimationEvent( PLAYERANIMEVENT_RELOAD );
+	}
+	return fRet;
+}
+#endif // HL2SB
+
 void CWeaponHL2MPBase::WeaponSound( WeaponSound_t sound_type, float soundtime /* = 0.0f */ )
 {
 #ifdef CLIENT_DLL
diff --git a/src/game/shared/hl2mp/weapon_hl2mpbase.h b/src/game/shared/hl2mp/weapon_hl2mpbase.h
index 0f21044b..8ee04af7 100644
--- a/src/game/shared/hl2mp/weapon_hl2mpbase.h
+++ b/src/game/shared/hl2mp/weapon_hl2mpbase.h
@@ -41,7 +41,9 @@ class CWeaponHL2MPBase : public CBaseCombatWeapon
 	#ifdef GAME_DLL
 		DECLARE_DATADESC();
 	
+#ifdef HL2SB
 		void SendReloadSoundEvent( void );
+#endif // HL2SB
 
 		void Materialize( void );
 		virtual	int	ObjectCaps( void );
@@ -60,6 +62,9 @@ class CWeaponHL2MPBase : public CBaseCombatWeapon
 
 	virtual void FireBullets( const FireBulletsInfo_t &info );
 	virtual void FallInit( void );
+#ifdef HL2SB
+	virtual bool Reload();
+#endif // HL2SB
 	
 public:
 	#if defined( CLIENT_DLL )
diff --git a/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp b/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp
index a20cea56..f0f7faab 100644
--- a/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp
+++ b/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp
@@ -117,7 +117,11 @@ void CHL2MPMachineGun::PrimaryAttack( void )
 	}
 
 	SendWeaponAnim( GetPrimaryAttackActivity() );
+#ifdef HL2SB
+	ToHL2MPPlayer(pPlayer)->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
+#else
 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
+#endif // HL2SB
 }
 
 //-----------------------------------------------------------------------------
diff --git a/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp b/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp
index 336cfcb7..44b3df43 100644
--- a/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp
+++ b/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp
@@ -358,7 +358,11 @@ void CBaseHL2MPBludgeonWeapon::Swing( int bIsSecondary )
 	// Send the anim
 	SendWeaponAnim( nHitActivity );
 
+#ifdef HL2SB
+	ToHL2MPPlayer(pOwner)->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
+#else
 	pOwner->SetAnimation( PLAYER_ATTACK1 );
+#endif // HL2SB
 
 	//Setup our next attack times
 	m_flNextPrimaryAttack = gpGlobals->curtime + GetFireRate();
diff --git a/src/game/shared/hl2mp/weapon_physcannon.cpp b/src/game/shared/hl2mp/weapon_physcannon.cpp
index 26fdfefd..f2370f78 100644
--- a/src/game/shared/hl2mp/weapon_physcannon.cpp
+++ b/src/game/shared/hl2mp/weapon_physcannon.cpp
@@ -900,10 +900,25 @@ END_PREDICTION_DATA()
 LINK_ENTITY_TO_CLASS( weapon_physcannon, CWeaponPhysCannon );
 PRECACHE_WEAPON_REGISTER( weapon_physcannon );
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 
 acttable_t	CWeaponPhysCannon::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PHYSGUN,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PHYSGUN,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PHYSGUN,					false },
+#else
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_PHYSGUN,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_PHYSGUN,					false },
 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_PHYSGUN,			false },
@@ -911,6 +926,7 @@ acttable_t	CWeaponPhysCannon::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_PHYSGUN,					false },
+#endif // HL2SB
 };
 
 IMPLEMENT_ACTTABLE(CWeaponPhysCannon);
@@ -2235,6 +2251,29 @@ void CWeaponPhysCannon::DoEffectIdle( void )
 
 	StartEffects();
 
+#ifdef HL2SB
+	// Turn on the glow sprites
+	for ( int i = PHYSCANNON_GLOW1; i < (PHYSCANNON_GLOW1+NUM_GLOW_SPRITES); i++ )
+	{
+		m_Parameters[i].GetScale().SetAbsolute( random->RandomFloat( 0.075f, 0.05f ) * SPRITE_SCALE );
+		m_Parameters[i].GetAlpha().SetAbsolute( random->RandomInt( 24, 32 ) );
+	}
+
+	// Turn on the glow sprites
+	for ( int i = PHYSCANNON_ENDCAP1; i < (PHYSCANNON_ENDCAP1+NUM_ENDCAP_SPRITES); i++ )
+	{
+		m_Parameters[i].GetScale().SetAbsolute( random->RandomFloat( 3, 5 ) );
+		m_Parameters[i].GetAlpha().SetAbsolute( random->RandomInt( 200, 255 ) );
+	}
+
+	if ( m_EffectState != EFFECT_HOLDING )
+	{
+		// Turn beams off
+		m_Beams[0].SetVisible( false );
+		m_Beams[1].SetVisible( false );
+		m_Beams[2].SetVisible( false );
+	}
+#else
 	//if ( ShouldDrawUsingViewModel() )
 	{
 		// Turn on the glow sprites
@@ -2285,6 +2324,7 @@ void CWeaponPhysCannon::DoEffectIdle( void )
 		}
 	}
 	*/
+#endif // HL2SB
 #endif
 }
 
@@ -2595,6 +2635,18 @@ void CWeaponPhysCannon::StopEffects( bool stopSound )
 	}
 }
 
+#ifdef HL2SB
+#ifdef CLIENT_DLL
+void CWeaponPhysCannon::ThirdPersonSwitch( bool bThirdPerson )
+{
+	//Tony; if we switch to first or third person or whatever, destroy and recreate the effects.
+	//Note: the sound only ever gets shut off on the server, so it's okay - as this is entirely client side.
+	DestroyEffects();
+	StartEffects();
+}
+#endif
+#endif // HL2SB
+
 //-----------------------------------------------------------------------------
 // Purpose: 
 //-----------------------------------------------------------------------------
diff --git a/src/game/shared/hl2mp/weapon_physcannon.h b/src/game/shared/hl2mp/weapon_physcannon.h
index 9b45d9d1..4441199b 100644
--- a/src/game/shared/hl2mp/weapon_physcannon.h
+++ b/src/game/shared/hl2mp/weapon_physcannon.h
@@ -421,6 +421,10 @@ class CWeaponPhysCannon : public CBaseHL2MPCombatWeapon
 
 	void			NotifyShouldTransmit( ShouldTransmitState_t state );
 
+#ifdef HL2SB
+	virtual void ThirdPersonSwitch( bool bThirdPerson );
+#endif // HL2SB
+
 #endif	// CLIENT_DLL
 
 	int		m_nChangeState;				// For delayed state change of elements
@@ -446,7 +450,7 @@ class CWeaponPhysCannon : public CBaseHL2MPCombatWeapon
 private:
 	CWeaponPhysCannon( const CWeaponPhysCannon & );
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
 #endif
 };
diff --git a/src/game/shared/hl2mp/weapon_pistol.cpp b/src/game/shared/hl2mp/weapon_pistol.cpp
index 5a9533c4..ca1ff7bb 100644
--- a/src/game/shared/hl2mp/weapon_pistol.cpp
+++ b/src/game/shared/hl2mp/weapon_pistol.cpp
@@ -15,6 +15,9 @@
 #endif
 
 #include "weapon_hl2mpbasehlmpcombatweapon.h"
+#ifdef HL2SB
+#include "weapon_hl2mpbase_machinegun.h"
+#endif // HL2SB
 
 #define	PISTOL_FASTEST_REFIRE_TIME		0.1f
 #define	PISTOL_FASTEST_DRY_REFIRE_TIME	0.2f
@@ -30,10 +33,17 @@
 // CWeaponPistol
 //-----------------------------------------------------------------------------
 
+#ifdef HL2SB
+class CWeaponPistol : public CHL2MPMachineGun
+{
+public:
+	DECLARE_CLASS( CWeaponPistol, CHL2MPMachineGun );
+#else
 class CWeaponPistol : public CBaseHL2MPCombatWeapon
 {
 public:
 	DECLARE_CLASS( CWeaponPistol, CBaseHL2MPCombatWeapon );
+#endif // HL2SB
 
 	CWeaponPistol(void);
 
@@ -85,7 +95,7 @@ class CWeaponPistol : public CBaseHL2MPCombatWeapon
 		return 0.5f; 
 	}
 	
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
 #endif
 
@@ -127,9 +137,24 @@ END_PREDICTION_DATA()
 LINK_ENTITY_TO_CLASS( weapon_pistol, CWeaponPistol );
 PRECACHE_WEAPON_REGISTER( weapon_pistol );
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 acttable_t CWeaponPistol::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PISTOL,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PISTOL,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PISTOL,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PISTOL,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PISTOL,					false },
+#else
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_PISTOL,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_PISTOL,					false },
 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_PISTOL,			false },
@@ -138,6 +163,7 @@ acttable_t CWeaponPistol::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_PISTOL,					false },
 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_PISTOL,				false },
+#endif // HL2SB
 };
 
 
@@ -313,6 +339,9 @@ bool CWeaponPistol::Reload( void )
 	if ( fRet )
 	{
 		WeaponSound( RELOAD );
+#ifdef HL2SB
+		ToHL2MPPlayer(GetOwner())->DoAnimationEvent( PLAYERANIMEVENT_RELOAD );
+#endif // HL2SB
 		m_flAccuracyPenalty = 0.0f;
 	}
 	return fRet;
diff --git a/src/game/shared/hl2mp/weapon_rpg.cpp b/src/game/shared/hl2mp/weapon_rpg.cpp
index 1859958e..b6596e29 100644
--- a/src/game/shared/hl2mp/weapon_rpg.cpp
+++ b/src/game/shared/hl2mp/weapon_rpg.cpp
@@ -1305,9 +1305,24 @@ END_PREDICTION_DATA()
 
 #endif
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 acttable_t	CWeaponRPG::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_RPG,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_RPG,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_RPG,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_RPG,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_RPG,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_RPG,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_RPG,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_RPG,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_RPG,					false },
+#else
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_RPG,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_RPG,					false },
 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_RPG,			false },
@@ -1316,6 +1331,7 @@ acttable_t	CWeaponRPG::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_RPG,		false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_RPG,					false },
 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_RPG,				false },
+#endif // HL2SB
 };
 
 IMPLEMENT_ACTTABLE(CWeaponRPG);
@@ -1424,7 +1440,11 @@ bool CWeaponRPG::WeaponShouldBeLowered( void )
 void CWeaponRPG::PrimaryAttack( void )
 {
 	// Only the player fires this way so we can cast
+#ifdef HL2SB
+	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
+#else
 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+#endif // HL2SB
 
 	if (!pPlayer)
 		return;
@@ -1479,7 +1499,11 @@ void CWeaponRPG::PrimaryAttack( void )
 	WeaponSound( SINGLE );
 
 	// player "shoot" animation
+#ifdef HL2SB
+	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
+#else
 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
+#endif // HL2SB
 }
 
 //-----------------------------------------------------------------------------
@@ -1882,6 +1906,21 @@ void CWeaponRPG::GetWeaponAttachment( int attachmentId, Vector &outVector, Vecto
 	}
 }
 
+#ifdef HL2SB
+//Tony; added so when the rpg switches to third person, the beam etc is re-created.
+void CWeaponRPG::ThirdPersonSwitch( bool bThirdPerson )
+{
+	if ( m_pBeam != NULL )
+	{
+		//Tell it to die right away and let the beam code free it.
+		m_pBeam->brightness = 0.0f;
+		m_pBeam->flags &= ~FBEAM_FOREVER;
+		m_pBeam->die = gpGlobals->curtime - 0.1;
+		m_pBeam = NULL;
+	}
+}
+#endif // HL2SB
+
 //-----------------------------------------------------------------------------
 // Purpose: Setup our laser beam
 //-----------------------------------------------------------------------------
@@ -2230,7 +2269,11 @@ int CLaserDot::DrawModel( int flags )
 	if ( pOwner != NULL && pOwner->IsDormant() == false )
 	{
 		// Always draw the dot in front of our faces when in first-person
+#ifdef HL2SB
+		if ( pOwner->IsLocalPlayer() && C_BasePlayer::LocalPlayerInFirstPersonView() )	//Tony; !!!
+#else
 		if ( pOwner->IsLocalPlayer() )
+#endif // HL2SB
 		{
 			// Take our view position and orientation
 			vecAttachment = CurrentViewOrigin();
@@ -2241,7 +2284,11 @@ int CLaserDot::DrawModel( int flags )
 			// Take the eye position and direction
 			vecAttachment = pOwner->EyePosition();
 			
+#ifdef HL2SB
+			QAngle angles = pOwner->EyeAngles();
+#else
 			QAngle angles = pOwner->GetAnimEyeAngles();
+#endif // HL2SB
 			AngleVectors( angles, &vecDir );
 		}
 		
diff --git a/src/game/shared/hl2mp/weapon_rpg.h b/src/game/shared/hl2mp/weapon_rpg.h
index bbd6f2dd..dc38eac2 100644
--- a/src/game/shared/hl2mp/weapon_rpg.h
+++ b/src/game/shared/hl2mp/weapon_rpg.h
@@ -238,11 +238,16 @@ class CWeaponRPG : public CBaseHL2MPCombatWeapon
 	CMaterialReference	m_hBeamMaterial;	// Used for the laser beam
 	Beam_t				*m_pBeam;			// Laser beam temp entity
 
+#ifdef HL2SB
+	//Tony; third person check thing, to destroy/reinitialize the beam ( swapping first -> third or back, etc )
+	virtual void			ThirdPersonSwitch( bool bThirdPerson );
+#endif // HL2SB
+
 #endif	//CLIENT_DLL
 
 	CBaseEntity *GetMissile( void ) { return m_hMissile; }
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
 #endif
 	
diff --git a/src/game/shared/hl2mp/weapon_shotgun.cpp b/src/game/shared/hl2mp/weapon_shotgun.cpp
index da370b53..11722687 100644
--- a/src/game/shared/hl2mp/weapon_shotgun.cpp
+++ b/src/game/shared/hl2mp/weapon_shotgun.cpp
@@ -61,7 +61,7 @@ class CWeaponShotgun : public CBaseHL2MPCombatWeapon
 	void DryFire( void );
 	virtual float GetFireRate( void ) { return 0.7; };
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
 #endif
 
@@ -99,9 +99,24 @@ END_PREDICTION_DATA()
 LINK_ENTITY_TO_CLASS( weapon_shotgun, CWeaponShotgun );
 PRECACHE_WEAPON_REGISTER(weapon_shotgun);
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 acttable_t	CWeaponShotgun::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_SHOTGUN,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_SHOTGUN,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_SHOTGUN,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_SHOTGUN,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_SHOTGUN,					false },
+#else
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_SHOTGUN,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_SHOTGUN,					false },
 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_SHOTGUN,			false },
@@ -110,6 +125,7 @@ acttable_t	CWeaponShotgun::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,		false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_SHOTGUN,					false },
 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_SHOTGUN,				false },
+#endif // HL2SB
 };
 
 IMPLEMENT_ACTTABLE(CWeaponShotgun);
@@ -127,7 +143,11 @@ bool CWeaponShotgun::StartReload( void )
 	if ( m_bNeedPump )
 		return false;
 
+#ifdef HL2SB
+	CHL2MP_Player *pOwner = ToHL2MPPlayer( GetOwner() );
+#else
 	CBaseCombatCharacter *pOwner  = GetOwner();
+#endif // HL2SB
 	
 	if ( pOwner == NULL )
 		return false;
@@ -146,6 +166,11 @@ bool CWeaponShotgun::StartReload( void )
 
 	SendWeaponAnim( ACT_SHOTGUN_RELOAD_START );
 
+#ifdef HL2SB
+	//Tony; BUG BUG BUG!!! shotgun does one shell at a time!!! -- player model only has a single reload!!! so I'm just going to dispatch the singular for now.
+	pOwner->DoAnimationEvent( PLAYERANIMEVENT_RELOAD );
+#endif // HL2SB
+
 	// Make shotgun shell visible
 	SetBodygroup(1,0);
 
@@ -293,7 +318,11 @@ void CWeaponShotgun::DryFire( void )
 void CWeaponShotgun::PrimaryAttack( void )
 {
 	// Only the player fires this way so we can cast
+#ifdef HL2SB
+	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
+#else
 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+#endif // HL2SB
 
 	if (!pPlayer)
 	{
@@ -312,7 +341,11 @@ void CWeaponShotgun::PrimaryAttack( void )
 	m_iClip1 -= 1;
 
 	// player "shoot" animation
+#ifdef HL2SB
+	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
+#else
 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
+#endif // HL2SB
 
 	Vector	vecSrc		= pPlayer->Weapon_ShootPosition( );
 	Vector	vecAiming	= pPlayer->GetAutoaimVector( AUTOAIM_10DEGREES );	
@@ -344,7 +377,11 @@ void CWeaponShotgun::PrimaryAttack( void )
 void CWeaponShotgun::SecondaryAttack( void )
 {
 	// Only the player fires this way so we can cast
+#ifdef HL2SB
+	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
+#else
 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+#endif // HL2SB
 
 	if (!pPlayer)
 	{
@@ -364,7 +401,11 @@ void CWeaponShotgun::SecondaryAttack( void )
 	m_iClip1 -= 2;	// Shotgun uses same clip for primary and secondary attacks
 
 	// player "shoot" animation
+#ifdef HL2SB
+	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );	//Tony; shotgun doesn't have a secondary anim, use primary.
+#else
 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
+#endif // HL2SB
 
 	Vector vecSrc	 = pPlayer->Weapon_ShootPosition();
 	Vector vecAiming = pPlayer->GetAutoaimVector( AUTOAIM_10DEGREES );	
diff --git a/src/game/shared/hl2mp/weapon_slam.cpp b/src/game/shared/hl2mp/weapon_slam.cpp
index bc1cb8b4..36ca2479 100644
--- a/src/game/shared/hl2mp/weapon_slam.cpp
+++ b/src/game/shared/hl2mp/weapon_slam.cpp
@@ -14,7 +14,11 @@
 	#include "c_hl2mp_player.h"
 #else
 	#include "hl2mp_player.h"
+#ifdef HL2SB
+	#include "hl2mp/grenade_tripmine.h" // Load the hl2mp version!
+#else
 	#include "grenade_tripmine.h"
+#endif // HL2SB
 	#include "grenade_satchel.h"
 	#include "entitylist.h"
 	#include "eventqueue.h"
@@ -26,6 +30,9 @@
 #include "tier0/memdbgon.h"
 
 #define	SLAM_PRIMARY_VOLUME		450
+#ifdef HL2SB
+#define SLAM_REFIRE_DELAY		0.05f
+#endif // HL2SB
 
 IMPLEMENT_NETWORKCLASS_ALIASED( Weapon_SLAM, DT_Weapon_SLAM )
 
@@ -91,9 +98,26 @@ BEGIN_DATADESC( CWeapon_SLAM )
 	DEFINE_FUNCTION( SlamTouch ),
 
 END_DATADESC()
+#endif
 
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 acttable_t	CWeapon_SLAM::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_SLAM,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_SLAM,				false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_SLAM,						false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_SLAM,				false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_SLAM,			false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_SLAM,			false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_SLAM,					false },
+#else
 	{ ACT_RANGE_ATTACK1, ACT_RANGE_ATTACK_SLAM, true },
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_SLAM,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_SLAM,					false },
@@ -102,6 +126,7 @@ acttable_t	CWeapon_SLAM::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM,	false },
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_SLAM,		false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_SLAM,					false },
+#endif // HL2SB
 };
 
 IMPLEMENT_ACTTABLE(CWeapon_SLAM);
@@ -347,8 +372,13 @@ void CWeapon_SLAM::StartSatchelDetonate()
 	}
 	SatchelDetonate();
 
+#ifdef HL2SB
+	// needs a higher delay on all of these, a minimum time really - to elimiate refires.
+	m_flNextPrimaryAttack	= m_flNextSecondaryAttack = SLAM_REFIRE_DELAY + gpGlobals->curtime + SequenceDuration();
+#else
 	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
 	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
+#endif // HL2SB
 }
 
 
@@ -396,7 +426,10 @@ void CWeapon_SLAM::TripmineAttach( void )
 
 			CTripmineGrenade *pMine = (CTripmineGrenade *)pEnt;
 			pMine->m_hOwner = GetOwner();
-
+#ifdef HL2SB
+			// Attempt to attach to entity, or just sit still in place.
+			pMine->AttachToEntity( pEntity );
+#endif // HL2SB
 #endif
 
 			pOwner->RemoveAmmo( 1, m_iSecondaryAmmoType );
@@ -412,7 +445,11 @@ void CWeapon_SLAM::TripmineAttach( void )
 void CWeapon_SLAM::StartTripmineAttach( void )
 {
 	// Only the player fires this way so we can cast
+#ifdef HL2SB
+	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
+#else
 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+#endif // HL2SB
 	if (!pPlayer)
 	{
 		return;
@@ -439,7 +476,11 @@ void CWeapon_SLAM::StartTripmineAttach( void )
 		if (pEntity && !(pEntity->GetFlags() & FL_CONVEYOR))
 		{
 			// player "shoot" animation
+#ifdef HL2SB
+			pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
+#else
 			pPlayer->SetAnimation( PLAYER_ATTACK1 );
+#endif // HL2SB
 
 			// -----------------------------------------
 			//  Play attach animation
@@ -463,9 +504,14 @@ void CWeapon_SLAM::StartTripmineAttach( void )
 			// ALERT( at_console, "no deploy\n" );
 		}
 	}
-	
+
+#ifdef HL2SB
+	// needs a higher delay on all of these, a minimum time really - to elimiate refires.
+	m_flNextPrimaryAttack	= m_flNextSecondaryAttack = SLAM_REFIRE_DELAY + gpGlobals->curtime + SequenceDuration();
+#else
 	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
 	m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
+#endif // HL2SB
 //	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
 }
 
@@ -476,11 +522,18 @@ void CWeapon_SLAM::StartTripmineAttach( void )
 //-----------------------------------------------------------------------------
 void CWeapon_SLAM::SatchelThrow( void )
 {	
+#ifdef HL2SB
+	// Only the player fires this way so we can cast
+	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
+#endif // HL2SB
+
 #ifndef CLIENT_DLL
 	m_bThrowSatchel = false;
 
+#ifndef HL2SB
 	// Only the player fires this way so we can cast
 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+#endif // !HL2SB
 
 	Vector vecSrc	 = pPlayer->WorldSpaceCenter();
 	Vector vecFacing = pPlayer->BodyDirection3D( );
@@ -512,10 +565,17 @@ void CWeapon_SLAM::SatchelThrow( void )
 	}
 
 	pPlayer->RemoveAmmo( 1, m_iSecondaryAmmoType );
+#ifndef HL2SB
 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
+#endif // !HL2SB
 
 #endif
 
+#ifdef HL2SB
+	//Tony; is there a different anim in the player? must check..
+	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
+#endif // HL2SB
+
 	// Play throw sound
 	EmitSound( "Weapon_SLAM.SatchelThrow" );
 }
@@ -547,8 +607,12 @@ void CWeapon_SLAM::StartSatchelThrow( void )
 	m_bNeedReload		= true;
 	m_bThrowSatchel		= true;
 
+#ifdef HL2SB
+	m_flNextPrimaryAttack	= m_flNextSecondaryAttack = SLAM_REFIRE_DELAY + gpGlobals->curtime + SequenceDuration();
+#else
 	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
 	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
+#endif // HL2SB
 }
 
 //-----------------------------------------------------------------------------
@@ -607,7 +671,11 @@ void CWeapon_SLAM::SatchelAttach( void )
 void CWeapon_SLAM::StartSatchelAttach( void )
 {
 #ifndef CLIENT_DLL
+#ifdef HL2SB
+	CHL2MP_Player *pOwner = ToHL2MPPlayer( GetOwner() );
+#else
 	CBaseCombatCharacter *pOwner  = GetOwner();
+#endif // HL2SB
 	if (!pOwner)
 	{
 		return;
@@ -625,11 +693,16 @@ void CWeapon_SLAM::StartSatchelAttach( void )
 		CBaseEntity *pEntity = tr.m_pEnt;
 		if (pEntity && !(pEntity->GetFlags() & FL_CONVEYOR))
 		{
+#ifndef HL2SB
 			// Only the player fires this way so we can cast
 			CBasePlayer *pPlayer = ToBasePlayer( pOwner );
 
 			// player "shoot" animation
 			pPlayer->SetAnimation( PLAYER_ATTACK1 );
+#else
+			// player "shoot" animation
+			pOwner->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
+#endif // !HL2SB
 
 			// -----------------------------------------
 			//  Play attach animation
@@ -651,7 +724,11 @@ void CWeapon_SLAM::StartSatchelAttach( void )
 			m_bNeedReload		= true;
 			m_bAttachSatchel	= true;
 
+#ifdef HL2SB
+			m_flNextPrimaryAttack	= m_flNextSecondaryAttack = SLAM_REFIRE_DELAY + gpGlobals->curtime + SequenceDuration();
+#else
 			m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
+#endif // HL2SB
 		}
 	}
 #endif
diff --git a/src/game/shared/hl2mp/weapon_slam.h b/src/game/shared/hl2mp/weapon_slam.h
index 11310f6b..a31784bc 100644
--- a/src/game/shared/hl2mp/weapon_slam.h
+++ b/src/game/shared/hl2mp/weapon_slam.h
@@ -79,8 +79,10 @@ class CWeapon_SLAM : public CBaseHL2MPCombatWeapon
 
 	CWeapon_SLAM();
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
+#endif
+#ifndef CLIENT_DLL
 	DECLARE_DATADESC();
 #endif
 
diff --git a/src/game/shared/hl2mp/weapon_smg1.cpp b/src/game/shared/hl2mp/weapon_smg1.cpp
index 7b82a680..4b151010 100644
--- a/src/game/shared/hl2mp/weapon_smg1.cpp
+++ b/src/game/shared/hl2mp/weapon_smg1.cpp
@@ -61,7 +61,7 @@ class CWeaponSMG1 : public CHL2MPMachineGun
 
 	const WeaponProficiencyInfo_t *GetProficiencyValues();
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
 #endif
 
@@ -85,9 +85,24 @@ END_PREDICTION_DATA()
 LINK_ENTITY_TO_CLASS( weapon_smg1, CWeaponSMG1 );
 PRECACHE_WEAPON_REGISTER(weapon_smg1);
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 acttable_t	CWeaponSMG1::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_SMG1,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_SMG1,				false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_SMG1,						false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_SMG1,				false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_SMG1,			false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_SMG1,			false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_SMG1,					false },
+#else
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_SMG1,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_SMG1,						false },
 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_SMG1,				false },
@@ -96,6 +111,7 @@ acttable_t	CWeaponSMG1::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_SMG1,			false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_SMG1,					false },
 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_SMG1,					false },
+#endif // HL2SB
 };
 
 IMPLEMENT_ACTTABLE(CWeaponSMG1);
@@ -164,6 +180,9 @@ bool CWeaponSMG1::Reload( void )
 		m_flNextSecondaryAttack = GetOwner()->m_flNextAttack = fCacheTime;
 
 		WeaponSound( RELOAD );
+#ifdef HL2SB
+		ToHL2MPPlayer(GetOwner())->DoAnimationEvent( PLAYERANIMEVENT_RELOAD );
+#endif // HL2SB
 	}
 
 	return fRet;
@@ -193,7 +212,11 @@ void CWeaponSMG1::AddViewKick( void )
 void CWeaponSMG1::SecondaryAttack( void )
 {
 	// Only the player fires this way so we can cast
+#ifdef HL2SB
+	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
+#else
 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+#endif // HL2SB
 	
 	if ( pPlayer == NULL )
 		return;
@@ -234,7 +257,11 @@ void CWeaponSMG1::SecondaryAttack( void )
 	SendWeaponAnim( ACT_VM_SECONDARYATTACK );
 
 	// player "shoot" animation
+#ifdef HL2SB
+	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
+#else
 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
+#endif // HL2SB
 
 	// Decrease ammo
 	pPlayer->RemoveAmmo( 1, m_iSecondaryAmmoType );
diff --git a/src/game/shared/hl2mp/weapon_stunstick.cpp b/src/game/shared/hl2mp/weapon_stunstick.cpp
index 0d813be2..8259a6e1 100644
--- a/src/game/shared/hl2mp/weapon_stunstick.cpp
+++ b/src/game/shared/hl2mp/weapon_stunstick.cpp
@@ -58,7 +58,7 @@ class CWeaponStunStick : public CBaseHL2MPBludgeonWeapon
 	DECLARE_NETWORKCLASS(); 
 	DECLARE_PREDICTABLE();
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 	DECLARE_ACTTABLE();
 #endif
 
@@ -68,7 +68,9 @@ class CWeaponStunStick : public CBaseHL2MPBludgeonWeapon
 	virtual void			OnDataChanged( DataUpdateType_t updateType );
 	virtual RenderGroup_t	GetRenderGroup( void );
 	virtual void			ViewModelDrawn( C_BaseViewModel *pBaseViewModel );
-	
+#ifdef HL2SB
+	virtual bool			IsTransparent( void );
+#endif // HL2SB
 #endif
 
 	virtual void Precache();
@@ -125,6 +127,11 @@ class CWeaponStunStick : public CBaseHL2MPBludgeonWeapon
 
 	float	m_flFadeTime;
 
+#ifdef HL2SB
+	//Tony; third person check thing, this has to be done for the local player if third person switches, so we can re-calc attachment points.
+	virtual void			ThirdPersonSwitch( bool bThirdPerson );
+#endif // HL2SB
+
 #endif
 
 	CNetworkVar( bool, m_bActive );
@@ -151,10 +158,25 @@ LINK_ENTITY_TO_CLASS( weapon_stunstick, CWeaponStunStick );
 PRECACHE_WEAPON_REGISTER( weapon_stunstick );
 
 
-#ifndef CLIENT_DLL
+#if !defined( CLIENT_DLL ) || defined( HL2SB )
 
 acttable_t	CWeaponStunStick::m_acttable[] = 
 {
+#ifdef HL2SB
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_MELEE,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_MELEE,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_MELEE,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_MELEE,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_MELEE,					false },
+#else
 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_SLAM, true },
 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_MELEE,					false },
 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_MELEE,					false },
@@ -163,6 +185,7 @@ acttable_t	CWeaponStunStick::m_acttable[] =
 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_MELEE,					false },
+#endif // HL2SB
 };
 
 IMPLEMENT_ACTTABLE(CWeaponStunStick);
@@ -449,6 +472,12 @@ void CWeaponStunStick::SetStunState( bool state )
 bool CWeaponStunStick::Deploy( void )
 {
 	SetStunState( true );
+#ifdef HL2SB
+#ifdef CLIENT_DLL
+	//Tony; we need to just do this
+	SetupAttachmentPoints();
+#endif
+#endif // HL2SB
 
 	return BaseClass::Deploy();
 }
@@ -844,6 +873,13 @@ void C_WeaponStunStick::DrawFirstPersonEffects( void )
 	}
 }
 
+#ifdef HL2SB
+void C_WeaponStunStick::ThirdPersonSwitch( bool bThirdPerson )
+{
+	SetupAttachmentPoints();
+}
+#endif // HL2SB
+
 //-----------------------------------------------------------------------------
 // Purpose: Draw our special effects
 //-----------------------------------------------------------------------------
@@ -874,6 +910,16 @@ void C_WeaponStunStick::ViewModelDrawn( C_BaseViewModel *pBaseViewModel )
 	BaseClass::ViewModelDrawn( pBaseViewModel );
 }
 
+#ifdef HL2SB
+//-----------------------------------------------------------------------------
+// Purpose: We are always considered transparent
+//-----------------------------------------------------------------------------
+bool C_WeaponStunStick::IsTransparent( void )
+{
+	return true;
+}
+#endif // HL2SB
+
 //-----------------------------------------------------------------------------
 // Purpose: Draw a cheap glow quad at our impact point (with sparks)
 //-----------------------------------------------------------------------------
@@ -0,0 +1,3711 @@
+diff --git a/src/game/client/c_baseplayer.cpp b/src/game/client/c_baseplayer.cpp
+index a6c682d05..cc91ba7e6 100644
+--- a/src/game/client/c_baseplayer.cpp
++++ b/src/game/client/c_baseplayer.cpp
+@@ -1872,6 +1872,15 @@ void C_BasePlayer::ThirdPersonSwitch( bool bThirdperson )
+ 				}
+ 			}
+ 		}
++		
++#ifdef HL2SB
++		//Notify weapon.
++		CBaseCombatWeapon *pWeapon = GetActiveWeapon();
++		if ( pWeapon )
++		{
++			pWeapon->ThirdPersonSwitch( bThirdperson );
++		}
++#endif// HL2SB
+ 	}
+ }
+ 
+diff --git a/src/game/client/c_te_effect_dispatch.cpp b/src/game/client/c_te_effect_dispatch.cpp
+index 160e11b7c..f6cdfdd95 100644
+--- a/src/game/client/c_te_effect_dispatch.cpp
++++ b/src/game/client/c_te_effect_dispatch.cpp
+@@ -179,6 +179,12 @@ void DispatchEffect( const char *pName, const CEffectData &data )
+ 	te->DispatchEffect( filter, 0.0, data.m_vOrigin, pName, data );
+ }
+ 
++#ifdef HL2SB
++void DispatchEffect( const char *pName, const CEffectData &data, IRecipientFilter &filter )
++{
++	te->DispatchEffect( filter, 0.0, data.m_vOrigin, pName, data );
++}
++#endif // HL2SB
+ 
+ //-----------------------------------------------------------------------------
+ // Playback
+diff --git a/src/game/client/c_te_effect_dispatch.h b/src/game/client/c_te_effect_dispatch.h
+index 63fa61730..a8d128026 100644
+--- a/src/game/client/c_te_effect_dispatch.h
++++ b/src/game/client/c_te_effect_dispatch.h
+@@ -42,5 +42,8 @@ class CClientEffectRegistration
+ 
+ void DispatchEffectToCallback( const char *pEffectName, const CEffectData &m_EffectData );
+ void DispatchEffect( const char *pName, const CEffectData &data );
++#ifdef HL2SB
++void DispatchEffect( const char *pName, const CEffectData &data, IRecipientFilter &filter );
++#endif // HL2SB
+ 
+ #endif // C_TE_EFFECT_DISPATCH_H
+diff --git a/src/game/client/hl2/c_basehlplayer.cpp b/src/game/client/hl2/c_basehlplayer.cpp
+index fbc40eb2f..8d822a506 100644
+--- a/src/game/client/hl2/c_basehlplayer.cpp
++++ b/src/game/client/hl2/c_basehlplayer.cpp
+@@ -53,6 +53,13 @@ void CC_DropPrimary( void )
+ 
+ static ConCommand dropprimary("dropprimary", CC_DropPrimary, "dropprimary: Drops the primary weapon of the player.");
+ 
++#ifdef HL2SB
++// link to the correct class.
++#if !defined ( HL2MP )
++LINK_ENTITY_TO_CLASS( player, C_BaseHLPlayer );
++#endif
++#endif // HL2SB
++
+ //-----------------------------------------------------------------------------
+ // Constructor
+ //-----------------------------------------------------------------------------
+diff --git a/src/game/client/hl2mp/c_hl2mp_player.cpp b/src/game/client/hl2mp/c_hl2mp_player.cpp
+index 49e55e293..318f51214 100644
+--- a/src/game/client/hl2mp/c_hl2mp_player.cpp
++++ b/src/game/client/hl2mp/c_hl2mp_player.cpp
+@@ -14,14 +14,58 @@
+ #include "iviewrender_beams.h"			// flashlight beam
+ #include "r_efx.h"
+ #include "dlight.h"
++#ifdef HL2SB
++#include "c_basetempentity.h"
++#include "prediction.h"
++#include "bone_setup.h"
++#endif // HL2SB
+ 
+ // Don't alias here
+ #if defined( CHL2MP_Player )
+ #undef CHL2MP_Player	
+ #endif
+ 
++#ifdef HL2SB
++#define CYCLELATCH_TOLERANCE		0.15f
++#endif // HL2SB
++
+ LINK_ENTITY_TO_CLASS( player, C_HL2MP_Player );
+ 
++#ifdef HL2SB
++BEGIN_RECV_TABLE_NOBASE( C_HL2MP_Player, DT_HL2MPLocalPlayerExclusive )
++	RecvPropVector( RECVINFO_NAME( m_vecNetworkOrigin, m_vecOrigin ) ),
++	RecvPropFloat( RECVINFO( m_angEyeAngles[0] ) ),
++//	RecvPropFloat( RECVINFO( m_angEyeAngles[1] ) ),
++END_RECV_TABLE()
++
++BEGIN_RECV_TABLE_NOBASE( C_HL2MP_Player, DT_HL2MPNonLocalPlayerExclusive )
++	RecvPropVector( RECVINFO_NAME( m_vecNetworkOrigin, m_vecOrigin ) ),
++	RecvPropFloat( RECVINFO( m_angEyeAngles[0] ) ),
++	RecvPropFloat( RECVINFO( m_angEyeAngles[1] ) ),
++
++	RecvPropInt( RECVINFO( m_cycleLatch ), 0, &C_HL2MP_Player::RecvProxy_CycleLatch ),
++END_RECV_TABLE()
++
++IMPLEMENT_CLIENTCLASS_DT(C_HL2MP_Player, DT_HL2MP_Player, CHL2MP_Player)
++
++	RecvPropDataTable( "hl2mplocaldata", 0, 0, &REFERENCE_RECV_TABLE(DT_HL2MPLocalPlayerExclusive) ),
++	RecvPropDataTable( "hl2mpnonlocaldata", 0, 0, &REFERENCE_RECV_TABLE(DT_HL2MPNonLocalPlayerExclusive) ),
++	RecvPropEHandle( RECVINFO( m_hRagdoll ) ),
++	RecvPropInt( RECVINFO( m_iSpawnInterpCounter ) ),
++	RecvPropInt( RECVINFO( m_iPlayerSoundType) ),
++
++	RecvPropBool( RECVINFO( m_fIsWalking ) ),
++END_RECV_TABLE()
++
++BEGIN_PREDICTION_DATA( C_HL2MP_Player )
++	DEFINE_PRED_FIELD( m_flCycle, FIELD_FLOAT, FTYPEDESC_OVERRIDE | FTYPEDESC_PRIVATE | FTYPEDESC_NOERRORCHECK ),
++	DEFINE_PRED_FIELD( m_fIsWalking, FIELD_BOOLEAN, FTYPEDESC_INSENDTABLE ),
++	DEFINE_PRED_FIELD( m_nSequence, FIELD_INTEGER, FTYPEDESC_OVERRIDE | FTYPEDESC_PRIVATE | FTYPEDESC_NOERRORCHECK ),
++	DEFINE_PRED_FIELD( m_flPlaybackRate, FIELD_FLOAT, FTYPEDESC_OVERRIDE | FTYPEDESC_PRIVATE | FTYPEDESC_NOERRORCHECK ),
++	DEFINE_PRED_ARRAY_TOL( m_flEncodedController, FIELD_FLOAT, MAXSTUDIOBONECTRLS, FTYPEDESC_OVERRIDE | FTYPEDESC_PRIVATE, 0.02f ),
++	DEFINE_PRED_FIELD( m_nNewSequenceParity, FIELD_INTEGER, FTYPEDESC_OVERRIDE | FTYPEDESC_PRIVATE | FTYPEDESC_NOERRORCHECK ),
++END_PREDICTION_DATA()
++#else
+ IMPLEMENT_CLIENTCLASS_DT(C_HL2MP_Player, DT_HL2MP_Player, CHL2MP_Player)
+ 	RecvPropFloat( RECVINFO( m_angEyeAngles[0] ) ),
+ 	RecvPropFloat( RECVINFO( m_angEyeAngles[1] ) ),
+@@ -35,6 +79,7 @@ END_RECV_TABLE()
+ BEGIN_PREDICTION_DATA( C_HL2MP_Player )
+ 	DEFINE_PRED_FIELD( m_fIsWalking, FIELD_BOOLEAN, FTYPEDESC_INSENDTABLE ),
+ END_PREDICTION_DATA()
++#endif // HL2SB
+ 
+ #define	HL2_WALK_SPEED 150
+ #define	HL2_NORM_SPEED 190
+@@ -45,6 +90,22 @@ static ConVar cl_defaultweapon( "cl_defaultweapon", "weapon_physcannon", FCVAR_U
+ 
+ void SpawnBlood (Vector vecSpot, const Vector &vecDir, int bloodColor, float flDamage);
+ 
++#ifdef HL2SB
++C_HL2MP_Player::C_HL2MP_Player() : m_iv_angEyeAngles( "C_HL2MP_Player::m_iv_angEyeAngles" )
++{
++	m_iIDEntIndex = 0;
++	m_iSpawnInterpCounterCache = 0;
++
++	AddVar( &m_angEyeAngles, &m_iv_angEyeAngles, LATCH_SIMULATION_VAR );
++
++	m_PlayerAnimState = CreateHL2MPPlayerAnimState( this );
++	m_blinkTimer.Invalidate();
++
++	m_pFlashlightBeam = NULL;
++
++	m_flServerCycle = -1.0f;
++}
++#else
+ C_HL2MP_Player::C_HL2MP_Player() : m_PlayerAnimState( this ), m_iv_angEyeAngles( "C_HL2MP_Player::m_iv_angEyeAngles" )
+ {
+ 	m_iIDEntIndex = 0;
+@@ -59,10 +120,14 @@ C_HL2MP_Player::C_HL2MP_Player() : m_PlayerAnimState( this ), m_iv_angEyeAngles(
+ 
+ 	m_pFlashlightBeam = NULL;
+ }
++#endif // HL2SB
+ 
+ C_HL2MP_Player::~C_HL2MP_Player( void )
+ {
+ 	ReleaseFlashlight();
++#ifdef HL2SB
++	m_PlayerAnimState->Release();
++#endif // HL2SB
+ }
+ 
+ int C_HL2MP_Player::GetIDTarget() const
+@@ -163,6 +228,14 @@ CStudioHdr *C_HL2MP_Player::OnNewModel( void )
+ 	
+ 	Initialize( );
+ 
++#ifdef HL2SB
++	// Reset the players animation states, gestures
++	if ( m_PlayerAnimState )
++	{
++		m_PlayerAnimState->OnNewModel();
++	}
++#endif // HL2SB
++
+ 	return hdr;
+ }
+ 
+@@ -305,6 +378,7 @@ void C_HL2MP_Player::DoImpactEffect( trace_t &tr, int nDamageType )
+ 
+ void C_HL2MP_Player::PreThink( void )
+ {
++#ifndef HL2SB
+ 	QAngle vTempAngles = GetLocalAngles();
+ 
+ 	if ( GetLocalPlayer() == this )
+@@ -322,6 +396,7 @@ void C_HL2MP_Player::PreThink( void )
+ 	}
+ 
+ 	SetLocalAngles( vTempAngles );
++#endif // !HL2SB
+ 
+ 	BaseClass::PreThink();
+ 
+@@ -355,12 +430,14 @@ void C_HL2MP_Player::AddEntity( void )
+ {
+ 	BaseClass::AddEntity();
+ 
++#ifndef HL2SB
+ 	QAngle vTempAngles = GetLocalAngles();
+ 	vTempAngles[PITCH] = m_angEyeAngles[PITCH];
+ 
+ 	SetLocalAngles( vTempAngles );
+ 		
+ 	m_PlayerAnimState.Update();
++#endif // !HL2SB
+ 
+ 	// Zero out model pitch, blending takes care of all of it.
+ 	SetLocalAnglesDim( X_INDEX, 0 );
+@@ -457,7 +534,11 @@ const QAngle& C_HL2MP_Player::GetRenderAngles()
+ 	}
+ 	else
+ 	{
++#ifdef HL2SB
++		return m_PlayerAnimState->GetRenderAngles();
++#else
+ 		return m_PlayerAnimState.GetRenderAngles();
++#endif // HL2SB
+ 	}
+ }
+ 
+@@ -516,6 +597,21 @@ void C_HL2MP_Player::PostDataUpdate( DataUpdateType_t updateType )
+ 	BaseClass::PostDataUpdate( updateType );
+ }
+ 
++#ifdef HL2SB
++void C_HL2MP_Player::RecvProxy_CycleLatch( const CRecvProxyData *pData, void *pStruct, void *pOut )
++{
++	C_HL2MP_Player* pPlayer = static_cast<C_HL2MP_Player*>( pStruct );
++
++	float flServerCycle = (float)pData->m_Value.m_Int / 16.0f;
++	float flCurCycle = pPlayer->GetCycle();
++	// The cycle is way out of sync.
++	if ( fabs( flCurCycle - flServerCycle ) > CYCLELATCH_TOLERANCE )
++	{
++		pPlayer->SetServerIntendedCycle( flServerCycle );
++	}
++}
++#endif // HL2SB
++
+ void C_HL2MP_Player::ReleaseFlashlight( void )
+ {
+ 	if( m_pFlashlightBeam )
+@@ -976,10 +1072,150 @@ void C_HL2MPRagdoll::SetupWeights( const matrix3x4_t *pBoneToWorld, int nFlexWei
+ 	}
+ }
+ 
++#ifdef HL2SB
++void C_HL2MP_Player::UpdateClientSideAnimation()
++{
++	m_PlayerAnimState->Update( EyeAngles()[YAW], EyeAngles()[PITCH] );
++
++	BaseClass::UpdateClientSideAnimation();
++}
++
++// -------------------------------------------------------------------------------- //
++// Player animation event. Sent to the client when a player fires, jumps, reloads, etc..
++// -------------------------------------------------------------------------------- //
++
++class C_TEPlayerAnimEvent : public C_BaseTempEntity
++{
++public:
++	DECLARE_CLASS( C_TEPlayerAnimEvent, C_BaseTempEntity );
++	DECLARE_CLIENTCLASS();
++
++	virtual void PostDataUpdate( DataUpdateType_t updateType )
++	{
++		// Create the effect.
++		C_HL2MP_Player *pPlayer = dynamic_cast< C_HL2MP_Player* >( m_hPlayer.Get() );
++		if ( pPlayer && !pPlayer->IsDormant() )
++		{
++			pPlayer->DoAnimationEvent( (PlayerAnimEvent_t)m_iEvent.Get(), m_nData );
++		}	
++	}
++
++public:
++	CNetworkHandle( CBasePlayer, m_hPlayer );
++	CNetworkVar( int, m_iEvent );
++	CNetworkVar( int, m_nData );
++};
++
++IMPLEMENT_CLIENTCLASS_EVENT( C_TEPlayerAnimEvent, DT_TEPlayerAnimEvent, CTEPlayerAnimEvent );
++
++BEGIN_RECV_TABLE_NOBASE( C_TEPlayerAnimEvent, DT_TEPlayerAnimEvent )
++	RecvPropEHandle( RECVINFO( m_hPlayer ) ),
++	RecvPropInt( RECVINFO( m_iEvent ) ),
++	RecvPropInt( RECVINFO( m_nData ) )
++END_RECV_TABLE()
++
++void C_HL2MP_Player::DoAnimationEvent( PlayerAnimEvent_t event, int nData )
++{
++	if ( IsLocalPlayer() )
++	{
++		if ( ( prediction->InPrediction() && !prediction->IsFirstTimePredicted() ) )
++			return;
++	}
++
++	MDLCACHE_CRITICAL_SECTION();
++	m_PlayerAnimState->DoAnimationEvent( event, nData );
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++//-----------------------------------------------------------------------------
++void C_HL2MP_Player::CalculateIKLocks( float currentTime )
++{
++	if (!m_pIk) 
++		return;
++
++	int targetCount = m_pIk->m_target.Count();
++	if ( targetCount == 0 )
++		return;
++
++	// In TF, we might be attaching a player's view to a walking model that's using IK. If we are, it can
++	// get in here during the view setup code, and it's not normally supposed to be able to access the spatial
++	// partition that early in the rendering loop. So we allow access right here for that special case.
++	SpatialPartitionListMask_t curSuppressed = partition->GetSuppressedLists();
++	partition->SuppressLists( PARTITION_ALL_CLIENT_EDICTS, false );
++	CBaseEntity::PushEnableAbsRecomputations( false );
++
++	for (int i = 0; i < targetCount; i++)
++	{
++		trace_t trace;
++		CIKTarget *pTarget = &m_pIk->m_target[i];
++
++		if (!pTarget->IsActive())
++			continue;
++
++		switch( pTarget->type)
++		{
++		case IK_GROUND:
++			{
++				pTarget->SetPos( Vector( pTarget->est.pos.x, pTarget->est.pos.y, GetRenderOrigin().z ));
++				pTarget->SetAngles( GetRenderAngles() );
++			}
++			break;
++
++		case IK_ATTACHMENT:
++			{
++				C_BaseEntity *pEntity = NULL;
++				float flDist = pTarget->est.radius;
++
++				// FIXME: make entity finding sticky!
++				// FIXME: what should the radius check be?
++				for ( CEntitySphereQuery sphere( pTarget->est.pos, 64 ); ( pEntity = sphere.GetCurrentEntity() ) != NULL; sphere.NextEntity() )
++				{
++					C_BaseAnimating *pAnim = pEntity->GetBaseAnimating( );
++					if (!pAnim)
++						continue;
++
++					int iAttachment = pAnim->LookupAttachment( pTarget->offset.pAttachmentName );
++					if (iAttachment <= 0)
++						continue;
++
++					Vector origin;
++					QAngle angles;
++					pAnim->GetAttachment( iAttachment, origin, angles );
++
++					// debugoverlay->AddBoxOverlay( origin, Vector( -1, -1, -1 ), Vector( 1, 1, 1 ), QAngle( 0, 0, 0 ), 255, 0, 0, 0, 0 );
++
++					float d = (pTarget->est.pos - origin).Length();
++
++					if ( d >= flDist)
++						continue;
++
++					flDist = d;
++					pTarget->SetPos( origin );
++					pTarget->SetAngles( angles );
++					// debugoverlay->AddBoxOverlay( pTarget->est.pos, Vector( -pTarget->est.radius, -pTarget->est.radius, -pTarget->est.radius ), Vector( pTarget->est.radius, pTarget->est.radius, pTarget->est.radius), QAngle( 0, 0, 0 ), 0, 255, 0, 0, 0 );
++				}
++
++				if (flDist >= pTarget->est.radius)
++				{
++					// debugoverlay->AddBoxOverlay( pTarget->est.pos, Vector( -pTarget->est.radius, -pTarget->est.radius, -pTarget->est.radius ), Vector( pTarget->est.radius, pTarget->est.radius, pTarget->est.radius), QAngle( 0, 0, 0 ), 0, 0, 255, 0, 0 );
++					// no solution, disable ik rule
++					pTarget->IKFailed( );
++				}
++			}
++			break;
++		}
++	}
++
++	CBaseEntity::PopEnableAbsRecomputations();
++	partition->SuppressLists( curSuppressed, true );
++}
++#else
+ void C_HL2MP_Player::PostThink( void )
+ {
+ 	BaseClass::PostThink();
+ 
+ 	// Store the eye angles pitch so the client can compute its animation state correctly.
+ 	m_angEyeAngles = EyeAngles();
+-}
+\ No newline at end of file
++}
++#endif // HL2SB
+diff --git a/src/game/client/hl2mp/c_hl2mp_player.h b/src/game/client/hl2mp/c_hl2mp_player.h
+index bac41977d..82d5b942c 100644
+--- a/src/game/client/hl2mp/c_hl2mp_player.h
++++ b/src/game/client/hl2mp/c_hl2mp_player.h
+@@ -9,7 +9,11 @@
+ #define HL2MP_PLAYER_H
+ #pragma once
+ 
++#ifdef HL2SB
++#include "hl2mp_playeranimstate.h"
++#else
+ class C_HL2MP_Player;
++#endif // HL2SB
+ #include "c_basehlplayer.h"
+ #include "hl2mp_player_shared.h"
+ #include "beamdraw.h"
+@@ -37,7 +41,9 @@ class C_HL2MP_Player : public C_BaseHLPlayer
+ 	virtual int DrawModel( int flags );
+ 	virtual void AddEntity( void );
+ 
++#ifndef HL2SB
+ 	QAngle GetAnimEyeAngles( void ) { return m_angEyeAngles; }
++#endif // !HL2SB
+ 	Vector GetAttackSpread( CBaseCombatWeapon *pWeapon, CBaseEntity *pTarget = NULL );
+ 
+ 
+@@ -84,13 +90,28 @@ class C_HL2MP_Player : public C_BaseHLPlayer
+ 	void StopWalking( void );
+ 	bool IsWalking( void ) { return m_fIsWalking; }
+ 
++#ifdef HL2SB
++	virtual void					UpdateClientSideAnimation();
++	void DoAnimationEvent( PlayerAnimEvent_t event, int nData = 0 );
++	virtual void CalculateIKLocks( float currentTime );
++
++	static void RecvProxy_CycleLatch( const CRecvProxyData *pData, void *pStruct, void *pOut );
++
++	virtual float GetServerIntendedCycle() { return m_flServerCycle; }
++	virtual void SetServerIntendedCycle( float cycle ) { m_flServerCycle = cycle; }
++#else
+ 	virtual void PostThink( void );
++#endif // HL2SB
+ 
+ private:
+ 	
+ 	C_HL2MP_Player( const C_HL2MP_Player & );
+ 
++#ifdef HL2SB
++	CHL2MPPlayerAnimState *m_PlayerAnimState;
++#else
+ 	CPlayerAnimState m_PlayerAnimState;
++#endif // HL2SB
+ 
+ 	QAngle	m_angEyeAngles;
+ 
+@@ -127,6 +148,11 @@ class C_HL2MP_Player : public C_BaseHLPlayer
+ 	CNetworkVar( HL2MPPlayerState, m_iPlayerState );	
+ 
+ 	bool m_fIsWalking;
++
++#ifdef HL2SB
++	int m_cycleLatch; // The animation cycle goes out of sync very easily. Mostly from the player entering/exiting PVS. Server will frequently update us with a new one.
++	float m_flServerCycle;
++#endif // HL2SB
+ };
+ 
+ inline C_HL2MP_Player *ToHL2MPPlayer( CBaseEntity *pEntity )
+diff --git a/src/game/server/baseentity.cpp b/src/game/server/baseentity.cpp
+index 043eb6318..0725bf085 100644
+--- a/src/game/server/baseentity.cpp
++++ b/src/game/server/baseentity.cpp
+@@ -1577,7 +1577,30 @@ int CBaseEntity::VPhysicsTakeDamage( const CTakeDamageInfo &info )
+ 		if ( gameFlags & FVPHYSICS_PLAYER_HELD )
+ 		{
+ 			// if the player is holding the object, use it's real mass (player holding reduced the mass)
++#ifdef HL2SB
++			CBasePlayer *pPlayer = NULL;
++
++			if ( gpGlobals->maxClients == 1 )
++			{
++				pPlayer = UTIL_GetLocalPlayer();
++			}
++			else
++			{
++				// See which MP player is holding the physics object and then use that player to get the real mass of the object.
++				// This is ugly but better than having linkage between an object and its "holding" player.
++				for ( int i = 1; i <= gpGlobals->maxClients; i++ )
++				{
++					CBasePlayer *tempPlayer = UTIL_PlayerByIndex( i );
++					if ( tempPlayer && (tempPlayer->GetHeldObject() == this ) )
++					{
++						pPlayer = tempPlayer;
++						break;
++					}
++				}
++			}
++#else
+ 			CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
++#endif // HL2SB
+ 			if ( pPlayer )
+ 			{
+ 				float mass = pPlayer->GetHeldObjectMass( VPhysicsGetObject() );
+diff --git a/src/game/server/filters.cpp b/src/game/server/filters.cpp
+index 6179254dd..fbec9df12 100644
+--- a/src/game/server/filters.cpp
++++ b/src/game/server/filters.cpp
+@@ -372,7 +372,12 @@ class FilterDamageType : public CBaseFilter
+ 
+ 	bool PassesDamageFilterImpl(const CTakeDamageInfo &info)
+ 	{
++#ifdef HL2SB
++		//Tony; these are bitflags. check them as so.
++		return ((info.GetDamageType() & m_iDamageType) == m_iDamageType);
++#else
+ 	 	return info.GetDamageType() == m_iDamageType;
++#endif // HL2SB
+ 	}
+ 
+ 	int m_iDamageType;
+diff --git a/src/game/server/hl2/hl2_player.cpp b/src/game/server/hl2/hl2_player.cpp
+index 36a55f836..72183a5ba 100644
+--- a/src/game/server/hl2/hl2_player.cpp
++++ b/src/game/server/hl2/hl2_player.cpp
+@@ -3161,6 +3161,13 @@ float CHL2_Player::GetHeldObjectMass( IPhysicsObject *pHeldObject )
+ 	return mass;
+ }
+ 
++#ifdef HL2SB
++CBaseEntity	*CHL2_Player::GetHeldObject( void )
++{
++	return PhysCannonGetHeldEntity( GetActiveWeapon() );
++}
++#endif // HL2SB
++
+ //-----------------------------------------------------------------------------
+ // Purpose: Force the player to drop any physics objects he's carrying
+ //-----------------------------------------------------------------------------
+diff --git a/src/game/server/hl2/hl2_player.h b/src/game/server/hl2/hl2_player.h
+index 6e72bb9e2..93d79af23 100644
+--- a/src/game/server/hl2/hl2_player.h
++++ b/src/game/server/hl2/hl2_player.h
+@@ -15,6 +15,14 @@
+ #include "simtimer.h"
+ #include "soundenvelope.h"
+ 
++// In HL2MP we need to inherit from  BaseMultiplayerPlayer!
++#if defined ( HL2MP ) && defined ( HL2SB )
++#include "basemultiplayerplayer.h"
++#define BASEPLAYERCLASS CBaseMultiplayerPlayer
++#else
++#define BASEPLAYERCLASS CBasePlayer
++#endif
++
+ class CAI_Squad;
+ class CPropCombineBall;
+ 
+@@ -75,10 +83,10 @@ class CSuitPowerDevice
+ //=============================================================================
+ // >> HL2_PLAYER
+ //=============================================================================
+-class CHL2_Player : public CBasePlayer
++class CHL2_Player : public BASEPLAYERCLASS
+ {
+ public:
+-	DECLARE_CLASS( CHL2_Player, CBasePlayer );
++	DECLARE_CLASS( CHL2_Player, BASEPLAYERCLASS );
+ 
+ 	CHL2_Player();
+ 	~CHL2_Player( void );
+@@ -241,6 +249,9 @@ class CHL2_Player : public CBasePlayer
+ 	virtual	bool		IsHoldingEntity( CBaseEntity *pEnt );
+ 	virtual void		ForceDropOfCarriedPhysObjects( CBaseEntity *pOnlyIfHoldindThis );
+ 	virtual float		GetHeldObjectMass( IPhysicsObject *pHeldObject );
++#ifdef HL2SB
++	virtual CBaseEntity	*GetHeldObject( void );
++#endif // HL2SB
+ 
+ 	virtual bool		IsFollowingPhysics( void ) { return (m_afPhysicsFlags & PFLAG_ONBARNACLE) > 0; }
+ 	void				InputForceDropPhysObjects( inputdata_t &data );
+diff --git a/src/game/server/hl2mp/grenade_tripmine.cpp b/src/game/server/hl2mp/grenade_tripmine.cpp
+index e14a929d8..7d7dbe21f 100644
+--- a/src/game/server/hl2mp/grenade_tripmine.cpp
++++ b/src/game/server/hl2mp/grenade_tripmine.cpp
+@@ -8,7 +8,11 @@
+ #include "cbase.h"
+ #include "beam_shared.h"
+ #include "shake.h"
++#ifdef HL2SB
++#include "hl2mp/grenade_tripmine.h" // Load the hl2mp header!!
++#else
+ #include "grenade_tripmine.h"
++#endif // HL2SB
+ #include "vstdlib/random.h"
+ #include "engine/IEngineSound.h"
+ #include "explode.h"
+@@ -49,8 +53,28 @@ CTripmineGrenade::CTripmineGrenade()
+ 	m_vecEnd.Init();
+ 	m_posOwner.Init();
+ 	m_angleOwner.Init();
++
++#ifdef HL2SB
++	m_pConstraint = NULL;
++	m_bAttached = false;
++	m_hAttachEntity = NULL;
++#endif // HL2SB
+ }
+ 
++#ifdef HL2SB
++//-----------------------------------------------------------------------------
++// Purpose: 
++//-----------------------------------------------------------------------------
++CTripmineGrenade::~CTripmineGrenade( void )
++{
++	if (m_pConstraint)
++	{
++		physenv->DestroyConstraint(m_pConstraint);
++		m_pConstraint = NULL;
++	}
++}
++#endif // HL2SB
++
+ void CTripmineGrenade::Spawn( void )
+ {
+ 	Precache( );
+@@ -117,10 +141,20 @@ void CTripmineGrenade::PowerupThink( void  )
+ {
+ 	if (gpGlobals->curtime > m_flPowerUp)
+ 	{
++#ifdef HL2SB
++		m_flPowerUp = 0;
++#endif // HL2SB
+ 		MakeBeam( );
+ 		RemoveSolidFlags( FSOLID_NOT_SOLID );
+ 		m_bIsLive			= true;
+ 
++#ifdef HL2SB
++		// The moment it's live, then do this - incase the attach entity moves between placing it, and activation
++		// use the absorigin of what we're attaching to for the check, if it moves - we blow up.
++		if ( m_bAttached && m_hAttachEntity.Get() != NULL )
++			m_vAttachedPosition = m_hAttachEntity.Get()->GetAbsOrigin();
++#endif // HL2SB
++
+ 		// play enabled sound
+ 		EmitSound( "TripmineGrenade.Activate" );
+ 	}
+@@ -219,12 +253,32 @@ void CTripmineGrenade::BeamBreakThink( void  )
+ 	CBaseEntity *pEntity = tr.m_pEnt;
+ 	CBaseCombatCharacter *pBCC  = ToBaseCombatCharacter( pEntity );
+ 
++#ifdef HL2SB
++	bool bAttachMoved = false;
++	if ( m_bAttached && m_hAttachEntity.Get() != NULL )
++	{
++		if ( m_hAttachEntity.Get()->GetAbsOrigin() != m_vAttachedPosition )
++			bAttachMoved = true;
++	}
++
++	// Also blow up if the attached entity goes away, ie: a crate
++	if (pBCC || fabs( m_flBeamLength - tr.fraction ) > 0.001 || ( m_bAttached && m_hAttachEntity.Get() == NULL) || bAttachMoved )
++	{
++		m_iHealth = 0;
++		if (m_pConstraint)
++			m_pConstraint->Deactivate();
++
++		Event_Killed( CTakeDamageInfo( (CBaseEntity*)m_hOwner, this, 100, GIB_NORMAL ) );
++		return;
++	}
++#else
+ 	if (pBCC || fabs( m_flBeamLength - tr.fraction ) > 0.001)
+ 	{
+ 		m_iHealth = 0;
+ 		Event_Killed( CTakeDamageInfo( (CBaseEntity*)m_hOwner, this, 100, GIB_NORMAL ) );
+ 		return;
+ 	}
++#endif // HL2SB
+ 
+ 	SetNextThink( gpGlobals->curtime + 0.05f );
+ }
+@@ -245,6 +299,25 @@ int CTripmineGrenade::OnTakeDamage_Alive( const CTakeDamageInfo &info )
+ }
+ #endif
+ 
++#ifdef HL2SB
++int CTripmineGrenade::OnTakeDamage( const CTakeDamageInfo &info )
++{
++	if ( m_iHealth < 0 )
++		return 0;	//already dead.
++
++	if ( gpGlobals->curtime > m_flPowerUp )
++	{
++		m_iHealth -= info.GetDamage();
++
++		if ( m_iHealth <= 0 )
++			Event_Killed( info );
++
++		return info.GetDamage();
++	}
++	return 0;
++}
++#endif // HL2SB
++
+ //-----------------------------------------------------------------------------
+ // Purpose:
+ // Input  :
+@@ -254,6 +327,11 @@ void CTripmineGrenade::Event_Killed( const CTakeDamageInfo &info )
+ {
+ 	m_takedamage		= DAMAGE_NO;
+ 
++#ifdef HL2SB
++	if (m_pConstraint)
++		m_pConstraint->Deactivate();
++#endif // HL2SB
++
+ 	SetThink( &CTripmineGrenade::DelayDeathThink );
+ 	SetNextThink( gpGlobals->curtime + 0.25 );
+ 
+@@ -274,3 +352,62 @@ void CTripmineGrenade::DelayDeathThink( void )
+ 	UTIL_Remove( this );
+ }
+ 
++#ifdef HL2SB
++bool CTripmineGrenade::MakeConstraint( CBaseEntity *pObject )
++{
++	IPhysicsObject *cMinePhysics = VPhysicsGetObject();
++
++	Assert( cMinePhysics );
++
++	IPhysicsObject *pAttached = pObject->VPhysicsGetObject();
++	if ( !cMinePhysics || !pAttached )
++		return false;
++
++	// constraining to the world means object 1 is fixed
++	if ( pAttached == g_PhysWorldObject )
++		PhysSetGameFlags( cMinePhysics, FVPHYSICS_CONSTRAINT_STATIC );
++
++	IPhysicsConstraintGroup *pGroup = NULL;
++
++	constraint_fixedparams_t fixed;
++	fixed.Defaults();
++	fixed.InitWithCurrentObjectState( cMinePhysics, pAttached );
++	fixed.constraint.Defaults();
++
++	m_pConstraint = physenv->CreateFixedConstraint( cMinePhysics, pAttached, pGroup, fixed );
++
++	if (!m_pConstraint)
++		return false;
++
++	m_pConstraint->SetGameData( (void *)this );
++
++	return true;
++}
++
++void CTripmineGrenade::AttachToEntity(CBaseEntity *pOther)
++{
++	if (!pOther)
++		return;
++
++	if ( !VPhysicsGetObject() )
++		return;
++
++	m_bAttached			= true;
++	m_hAttachEntity		= pOther;
++
++	SetMoveType			( MOVETYPE_NONE );
++
++	if (pOther->GetSolid() == SOLID_VPHYSICS && pOther->VPhysicsGetObject() != NULL )
++	{
++		SetSolid(SOLID_BBOX); //Tony; switch to bbox solid instead of vphysics, because we've made the physics object non-solid
++		MakeConstraint(pOther);
++		SetMoveType		( MOVETYPE_VPHYSICS ); // use vphysics while constrained!!
++	}
++	//if it isnt vphysics or bsp, use SetParent to follow it.
++	else if (pOther->GetSolid() != SOLID_BSP)
++	{
++		SetSolid(SOLID_BBOX); //Tony; switch to bbox solid instead of vphysics, because we've made the physics object non-solid
++		SetParent( m_hAttachEntity.Get() );
++	}
++}
++#endif // HL2SB
+diff --git a/src/game/server/hl2mp/grenade_tripmine.h b/src/game/server/hl2mp/grenade_tripmine.h
+index e18870960..35e6b50a8 100644
+--- a/src/game/server/hl2mp/grenade_tripmine.h
++++ b/src/game/server/hl2mp/grenade_tripmine.h
+@@ -15,6 +15,10 @@
+ 
+ class CBeam;
+ 
++#ifdef HL2SB
++// for constraints
++#include "vphysics/constraints.h"
++#endif // HL2SB
+ 
+ class CTripmineGrenade : public CBaseGrenade
+ {
+@@ -22,12 +26,19 @@ class CTripmineGrenade : public CBaseGrenade
+ 	DECLARE_CLASS( CTripmineGrenade, CBaseGrenade );
+ 
+ 	CTripmineGrenade();
++#ifdef HL2SB
++	~CTripmineGrenade();
++#endif // HL2SB
++
+ 	void Spawn( void );
+ 	void Precache( void );
+ 
+ #if 0 // FIXME: OnTakeDamage_Alive() is no longer called now that base grenade derives from CBaseAnimating
+ 	int OnTakeDamage_Alive( const CTakeDamageInfo &info );
+ #endif	
++#ifdef HL2SB
++	virtual int OnTakeDamage( const CTakeDamageInfo &info );
++#endif // HL2SB
+ 	void WarningThink( void );
+ 	void PowerupThink( void );
+ 	void BeamBreakThink( void );
+@@ -37,8 +48,18 @@ class CTripmineGrenade : public CBaseGrenade
+ 	void MakeBeam( void );
+ 	void KillBeam( void );
+ 
++#ifdef HL2SB
++	// Added to create a constraint
++	void AttachToEntity( CBaseEntity *pOther );
++	bool MakeConstraint( CBaseEntity *pOther );
++#endif // HL2SB
++
+ public:
+ 	EHANDLE		m_hOwner;
++#ifdef HL2SB
++	// Added for following
++	EHANDLE		m_hAttachEntity;
++#endif // HL2SB
+ 
+ private:
+ 	float		m_flPowerUp;
+@@ -50,6 +71,13 @@ class CTripmineGrenade : public CBaseGrenade
+ 	Vector		m_posOwner;
+ 	Vector		m_angleOwner;
+ 
++#ifdef HL2SB
++	// signifies if we're attached to something, and need to update slightly differently.
++	bool		m_bAttached;
++	IPhysicsConstraint	*m_pConstraint;
++	Vector		m_vAttachedPosition;	// if the attached position changes, we need to detonate
++#endif // HL2SB
++
+ 	DECLARE_DATADESC();
+ };
+ 
+diff --git a/src/game/server/hl2mp/hl2mp_player.cpp b/src/game/server/hl2mp/hl2mp_player.cpp
+index 1469d8420..91942f662 100644
+--- a/src/game/server/hl2mp/hl2mp_player.cpp
++++ b/src/game/server/hl2mp/hl2mp_player.cpp
+@@ -20,12 +20,21 @@
+ #include "grenade_satchel.h"
+ #include "eventqueue.h"
+ #include "gamestats.h"
++#ifdef HL2SB
++#include "tier0/vprof.h"
++#include "bone_setup.h"
++#endif // HL2SB
+ 
+ #include "engine/IEngineSound.h"
+ #include "SoundEmitterSystem/isoundemittersystembase.h"
+ 
+ #include "ilagcompensationmanager.h"
+ 
++#ifdef HL2SB
++// memdbgon must be the last include file in a .cpp file!!!
++#include "tier0/memdbgon.h"
++#endif // HL2SB
++
+ int g_iLastCitizenModel = 0;
+ int g_iLastCombineModel = 0;
+ 
+@@ -35,6 +44,10 @@ extern CBaseEntity				*g_pLastSpawn;
+ 
+ #define HL2MP_COMMAND_MAX_RATE 0.3
+ 
++#ifdef HL2SB
++#define CYCLELATCH_UPDATE_INTERVAL	0.2f
++#endif // HL2SB
++
+ void DropPrimedFragGrenade( CHL2MP_Player *pPlayer, CBaseCombatWeapon *pGrenade );
+ 
+ LINK_ENTITY_TO_CLASS( player, CHL2MP_Player );
+@@ -42,6 +55,64 @@ LINK_ENTITY_TO_CLASS( player, CHL2MP_Player );
+ LINK_ENTITY_TO_CLASS( info_player_combine, CPointEntity );
+ LINK_ENTITY_TO_CLASS( info_player_rebel, CPointEntity );
+ 
++#ifdef HL2SB
++extern void SendProxy_Origin( const SendProp *pProp, const void *pStruct, const void *pData, DVariant *pOut, int iElement, int objectID );
++
++//Tony; this should ideally be added to dt_send.cpp
++void* SendProxy_SendNonLocalDataTable( const SendProp *pProp, const void *pStruct, const void *pVarData, CSendProxyRecipients *pRecipients, int objectID )
++{
++	pRecipients->SetAllRecipients();
++	pRecipients->ClearRecipient( objectID - 1 );
++	return ( void * )pVarData;
++}
++REGISTER_SEND_PROXY_NON_MODIFIED_POINTER( SendProxy_SendNonLocalDataTable );
++
++
++BEGIN_SEND_TABLE_NOBASE( CHL2MP_Player, DT_HL2MPLocalPlayerExclusive )
++	// send a hi-res origin to the local player for use in prediction
++	SendPropVector	(SENDINFO(m_vecOrigin), -1,  SPROP_NOSCALE|SPROP_CHANGES_OFTEN, 0.0f, HIGH_DEFAULT, SendProxy_Origin ),
++	SendPropFloat( SENDINFO_VECTORELEM(m_angEyeAngles, 0), 8, SPROP_CHANGES_OFTEN, -90.0f, 90.0f ),
++//	SendPropAngle( SENDINFO_VECTORELEM(m_angEyeAngles, 1), 10, SPROP_CHANGES_OFTEN ),
++END_SEND_TABLE()
++
++BEGIN_SEND_TABLE_NOBASE( CHL2MP_Player, DT_HL2MPNonLocalPlayerExclusive )
++	// send a lo-res origin to other players
++	SendPropVector	(SENDINFO(m_vecOrigin), -1,  SPROP_COORD_MP_LOWPRECISION|SPROP_CHANGES_OFTEN, 0.0f, HIGH_DEFAULT, SendProxy_Origin ),
++	SendPropFloat( SENDINFO_VECTORELEM(m_angEyeAngles, 0), 8, SPROP_CHANGES_OFTEN, -90.0f, 90.0f ),
++	SendPropAngle( SENDINFO_VECTORELEM(m_angEyeAngles, 1), 10, SPROP_CHANGES_OFTEN ),
++	// Only need to latch cycle for other players
++	// If you increase the number of bits networked, make sure to also modify the code below and in the client class.
++	SendPropInt( SENDINFO( m_cycleLatch ), 4, SPROP_UNSIGNED ),
++END_SEND_TABLE()
++
++IMPLEMENT_SERVERCLASS_ST(CHL2MP_Player, DT_HL2MP_Player)
++	SendPropExclude( "DT_BaseAnimating", "m_flPoseParameter" ),
++	SendPropExclude( "DT_BaseAnimating", "m_flPlaybackRate" ),	
++	SendPropExclude( "DT_BaseAnimating", "m_nSequence" ),
++	SendPropExclude( "DT_BaseEntity", "m_angRotation" ),
++	SendPropExclude( "DT_BaseAnimatingOverlay", "overlay_vars" ),
++
++	SendPropExclude( "DT_BaseEntity", "m_vecOrigin" ),
++
++	// playeranimstate and clientside animation takes care of these on the client
++	SendPropExclude( "DT_ServerAnimationData" , "m_flCycle" ),	
++	SendPropExclude( "DT_AnimTimeMustBeFirst" , "m_flAnimTime" ),
++
++	SendPropExclude( "DT_BaseFlex", "m_flexWeight" ),
++	SendPropExclude( "DT_BaseFlex", "m_blinktoggle" ),
++	SendPropExclude( "DT_BaseFlex", "m_viewtarget" ),
++
++	// Data that only gets sent to the local player.
++	SendPropDataTable( "hl2mplocaldata", 0, &REFERENCE_SEND_TABLE(DT_HL2MPLocalPlayerExclusive), SendProxy_SendLocalDataTable ),
++	// Data that gets sent to all other players
++	SendPropDataTable( "hl2mpnonlocaldata", 0, &REFERENCE_SEND_TABLE(DT_HL2MPNonLocalPlayerExclusive), SendProxy_SendNonLocalDataTable ),
++
++	SendPropEHandle( SENDINFO( m_hRagdoll ) ),
++	SendPropInt( SENDINFO( m_iSpawnInterpCounter), 4 ),
++	SendPropInt( SENDINFO( m_iPlayerSoundType), 3 ),
++
++END_SEND_TABLE()
++#else
+ IMPLEMENT_SERVERCLASS_ST(CHL2MP_Player, DT_HL2MP_Player)
+ 	SendPropAngle( SENDINFO_VECTORELEM(m_angEyeAngles, 0), 11, SPROP_CHANGES_OFTEN ),
+ 	SendPropAngle( SENDINFO_VECTORELEM(m_angEyeAngles, 1), 11, SPROP_CHANGES_OFTEN ),
+@@ -56,6 +127,7 @@ IMPLEMENT_SERVERCLASS_ST(CHL2MP_Player, DT_HL2MP_Player)
+ //	SendPropExclude( "DT_AnimTimeMustBeFirst" , "m_flAnimTime" ),
+ 	
+ END_SEND_TABLE()
++#endif // HL2SB
+ 
+ BEGIN_DATADESC( CHL2MP_Player )
+ END_DATADESC()
+@@ -96,6 +168,38 @@ const char *g_ppszRandomCombineModels[] =
+ 
+ #pragma warning( disable : 4355 )
+ 
++#ifdef HL2SB
++CHL2MP_Player::CHL2MP_Player()
++{
++	//Tony; create our player animation state.
++	m_PlayerAnimState = CreateHL2MPPlayerAnimState( this );
++	UseClientSideAnimation();
++
++	m_angEyeAngles.Init();
++
++	m_iLastWeaponFireUsercmd = 0;
++
++	m_flNextModelChangeTime = 0.0f;
++	m_flNextTeamChangeTime = 0.0f;
++
++	m_iSpawnInterpCounter = 0;
++
++    m_bEnterObserver = false;
++	m_bReady = false;
++
++	m_cycleLatch = 0;
++	m_cycleLatchTimer.Invalidate();
++
++	BaseClass::ChangeTeam( 0 );
++	
++//	UseClientSideAnimation();
++}
++
++CHL2MP_Player::~CHL2MP_Player( void )
++{
++	m_PlayerAnimState->Release();
++}
++#else
+ CHL2MP_Player::CHL2MP_Player() : m_PlayerAnimState( this )
+ {
+ 	m_angEyeAngles.Init();
+@@ -119,6 +223,7 @@ CHL2MP_Player::~CHL2MP_Player( void )
+ {
+ 
+ }
++#endif // HL2SB
+ 
+ void CHL2MP_Player::UpdateOnRemove( void )
+ {
+@@ -304,8 +409,10 @@ void CHL2MP_Player::Spawn(void)
+ 		GiveDefaultItems();
+ 	}
+ 
++#ifndef HL2SB
+ 	SetNumAnimOverlays( 3 );
+ 	ResetAnimation();
++#endif // !HL2SB
+ 
+ 	m_nRenderFX = kRenderNormal;
+ 
+@@ -331,6 +438,13 @@ void CHL2MP_Player::Spawn(void)
+ 	SetPlayerUnderwater(false);
+ 
+ 	m_bReady = false;
++
++#ifdef HL2SB
++	m_cycleLatchTimer.Start( CYCLELATCH_UPDATE_INTERVAL );
++
++	//Tony; do the spawn animevent
++	DoAnimationEvent( PLAYERANIMEVENT_SPAWN );
++#endif // HL2SB
+ }
+ 
+ void CHL2MP_Player::PickupObject( CBaseEntity *pObject, bool bLimitMassAndSize )
+@@ -505,6 +619,7 @@ void CHL2MP_Player::SetupPlayerSoundsByModel( const char *pModelName )
+ 	}
+ }
+ 
++#ifndef HL2SB
+ void CHL2MP_Player::ResetAnimation( void )
+ {
+ 	if ( IsAlive() )
+@@ -520,22 +635,25 @@ void CHL2MP_Player::ResetAnimation( void )
+ 			SetAnimation( PLAYER_WALK );
+ 	}
+ }
+-
++#endif // !HL2SB
+ 
+ bool CHL2MP_Player::Weapon_Switch( CBaseCombatWeapon *pWeapon, int viewmodelindex )
+ {
+ 	bool bRet = BaseClass::Weapon_Switch( pWeapon, viewmodelindex );
+ 
++#ifndef HL2SB
+ 	if ( bRet == true )
+ 	{
+ 		ResetAnimation();
+ 	}
++#endif // !HL2SB
+ 
+ 	return bRet;
+ }
+ 
+ void CHL2MP_Player::PreThink( void )
+ {
++#ifndef HL2SB
+ 	QAngle vOldAngles = GetLocalAngles();
+ 	QAngle vTempAngles = GetLocalAngles();
+ 
+@@ -547,13 +665,16 @@ void CHL2MP_Player::PreThink( void )
+ 	}
+ 
+ 	SetLocalAngles( vTempAngles );
++#endif // !HL2SB
+ 
+ 	BaseClass::PreThink();
+ 	State_PreThink();
+ 
+ 	//Reset bullet force accumulator, only lasts one frame
+ 	m_vecTotalBulletForce = vec3_origin;
++#ifndef HL2SB
+ 	SetLocalAngles( vOldAngles );
++#endif // !HL2SB
+ }
+ 
+ void CHL2MP_Player::PostThink( void )
+@@ -565,14 +686,29 @@ void CHL2MP_Player::PostThink( void )
+ 		SetCollisionBounds( VEC_CROUCH_TRACE_MIN, VEC_CROUCH_TRACE_MAX );
+ 	}
+ 
++#ifndef HL2SB
+ 	m_PlayerAnimState.Update();
+ 
+ 	// Store the eye angles pitch so the client can compute its animation state correctly.
+ 	m_angEyeAngles = EyeAngles();
++#endif // !HL2SB
+ 
+ 	QAngle angles = GetLocalAngles();
+ 	angles[PITCH] = 0;
+ 	SetLocalAngles( angles );
++
++#ifdef HL2SB
++	// Store the eye angles pitch so the client can compute its animation state correctly.
++	m_angEyeAngles = EyeAngles();
++	m_PlayerAnimState->Update( m_angEyeAngles[YAW], m_angEyeAngles[PITCH] );
++
++	if ( IsAlive() && m_cycleLatchTimer.IsElapsed() )
++	{
++		m_cycleLatchTimer.Start( CYCLELATCH_UPDATE_INTERVAL );
++		// Compress the cycle into 4 bits. Can represent 0.0625 in steps which is enough.
++		m_cycleLatch.GetForModify() = 16 * GetCycle();
++	}
++#endif // HL2SB
+ }
+ 
+ void CHL2MP_Player::PlayerDeathThink()
+@@ -671,6 +807,7 @@ Activity CHL2MP_Player::TranslateTeamActivity( Activity ActToTranslate )
+ 
+ extern ConVar hl2_normspeed;
+ 
++#ifndef HL2SB
+ // Set the activity based on an event or current state
+ void CHL2MP_Player::SetAnimation( PLAYER_ANIM playerAnim )
+ {
+@@ -833,7 +970,7 @@ void CHL2MP_Player::SetAnimation( PLAYER_ANIM playerAnim )
+ 	ResetSequence( animDesired );
+ 	SetCycle( 0 );
+ }
+-
++#endif // !HL2SB
+ 
+ extern int	gEvilImpulse101;
+ //-----------------------------------------------------------------------------
+@@ -1225,7 +1362,9 @@ void CHL2MP_Player::Event_Killed( const CTakeDamageInfo &info )
+ 	CTakeDamageInfo subinfo = info;
+ 	subinfo.SetDamageForce( m_vecTotalBulletForce );
+ 
++#ifndef HL2SB
+ 	SetNumAnimOverlays( 0 );
++#endif // !HL2SB
+ 
+ 	// Note: since we're dead, it won't draw us on the client, but we don't set EF_NODRAW
+ 	// because we still want to transmit to the clients in our PVS.
+@@ -1627,3 +1766,141 @@ bool CHL2MP_Player::CanHearAndReadChatFrom( CBasePlayer *pPlayer )
+ 
+ 	return true;
+ }
++
++#ifdef HL2SB
++//-----------------------------------------------------------------------------
++// Purpose: multiplayer does not do autoaiming.
++//-----------------------------------------------------------------------------
++Vector CHL2MP_Player::GetAutoaimVector( float flScale )
++{
++	//No Autoaim
++	Vector	forward;
++	AngleVectors( EyeAngles() + m_Local.m_vecPunchAngle, &forward );
++	return	forward;
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: Do nothing multiplayer_animstate takes care of animation.
++// Input  : playerAnim - 
++//-----------------------------------------------------------------------------
++void CHL2MP_Player::SetAnimation( PLAYER_ANIM playerAnim )
++{
++	return;
++}
++
++// -------------------------------------------------------------------------------- //
++// Player animation event. Sent to the client when a player fires, jumps, reloads, etc..
++// -------------------------------------------------------------------------------- //
++class CTEPlayerAnimEvent : public CBaseTempEntity
++{
++public:
++	DECLARE_CLASS( CTEPlayerAnimEvent, CBaseTempEntity );
++	DECLARE_SERVERCLASS();
++
++	CTEPlayerAnimEvent( const char *name ) : CBaseTempEntity( name )
++	{
++	}
++
++	CNetworkHandle( CBasePlayer, m_hPlayer );
++	CNetworkVar( int, m_iEvent );
++	CNetworkVar( int, m_nData );
++};
++
++IMPLEMENT_SERVERCLASS_ST_NOBASE( CTEPlayerAnimEvent, DT_TEPlayerAnimEvent )
++	SendPropEHandle( SENDINFO( m_hPlayer ) ),
++	SendPropInt( SENDINFO( m_iEvent ), Q_log2( PLAYERANIMEVENT_COUNT ) + 1, SPROP_UNSIGNED ),
++	SendPropInt( SENDINFO( m_nData ), 32 )
++END_SEND_TABLE()
++
++static CTEPlayerAnimEvent g_TEPlayerAnimEvent( "PlayerAnimEvent" );
++
++void TE_PlayerAnimEvent( CBasePlayer *pPlayer, PlayerAnimEvent_t event, int nData )
++{
++	CPVSFilter filter( (const Vector&)pPlayer->EyePosition() );
++
++	//Tony; use prediction rules.
++	filter.UsePredictionRules();
++
++	g_TEPlayerAnimEvent.m_hPlayer = pPlayer;
++	g_TEPlayerAnimEvent.m_iEvent = event;
++	g_TEPlayerAnimEvent.m_nData = nData;
++	g_TEPlayerAnimEvent.Create( filter, 0 );
++}
++
++
++void CHL2MP_Player::DoAnimationEvent( PlayerAnimEvent_t event, int nData )
++{
++	m_PlayerAnimState->DoAnimationEvent( event, nData );
++	TE_PlayerAnimEvent( this, event, nData );	// Send to any clients who can see this guy.
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: Override setup bones so that is uses the render angles from
++//			the HL2MP animation state to setup the hitboxes.
++//-----------------------------------------------------------------------------
++void CHL2MP_Player::SetupBones( matrix3x4_t *pBoneToWorld, int boneMask )
++{
++	VPROF_BUDGET( "CHL2MP_Player::SetupBones", VPROF_BUDGETGROUP_SERVER_ANIM );
++
++	// Get the studio header.
++	Assert( GetModelPtr() );
++	CStudioHdr *pStudioHdr = GetModelPtr( );
++	if ( !pStudioHdr )
++		return;
++
++	Vector pos[MAXSTUDIOBONES];
++	Quaternion q[MAXSTUDIOBONES];
++
++	// Adjust hit boxes based on IK driven offset.
++	Vector adjOrigin = GetAbsOrigin() + Vector( 0, 0, m_flEstIkOffset );
++
++	// FIXME: pass this into Studio_BuildMatrices to skip transforms
++	CBoneBitList boneComputed;
++	if ( m_pIk )
++	{
++		m_iIKCounter++;
++		m_pIk->Init( pStudioHdr, GetAbsAngles(), adjOrigin, gpGlobals->curtime, m_iIKCounter, boneMask );
++		GetSkeleton( pStudioHdr, pos, q, boneMask );
++
++		m_pIk->UpdateTargets( pos, q, pBoneToWorld, boneComputed );
++		CalculateIKLocks( gpGlobals->curtime );
++		m_pIk->SolveDependencies( pos, q, pBoneToWorld, boneComputed );
++	}
++	else
++	{
++		GetSkeleton( pStudioHdr, pos, q, boneMask );
++	}
++
++	CBaseAnimating *pParent = dynamic_cast< CBaseAnimating* >( GetMoveParent() );
++	if ( pParent )
++	{
++		// We're doing bone merging, so do special stuff here.
++		CBoneCache *pParentCache = pParent->GetBoneCache();
++		if ( pParentCache )
++		{
++			BuildMatricesWithBoneMerge( 
++				pStudioHdr, 
++				m_PlayerAnimState->GetRenderAngles(),
++				adjOrigin, 
++				pos, 
++				q, 
++				pBoneToWorld, 
++				pParent, 
++				pParentCache );
++
++			return;
++		}
++	}
++
++	Studio_BuildMatrices( 
++		pStudioHdr, 
++		m_PlayerAnimState->GetRenderAngles(),
++		adjOrigin, 
++		pos, 
++		q, 
++		-1,
++		GetModelScale(), // Scaling
++		pBoneToWorld,
++		boneMask );
++}
++#endif // HL2SB
+diff --git a/src/game/server/hl2mp/hl2mp_player.h b/src/game/server/hl2mp/hl2mp_player.h
+index f91513c73..f520e132e 100644
+--- a/src/game/server/hl2mp/hl2mp_player.h
++++ b/src/game/server/hl2mp/hl2mp_player.h
+@@ -16,6 +16,9 @@ class CHL2MP_Player;
+ #include "hl2_player.h"
+ #include "simtimer.h"
+ #include "soundenvelope.h"
++#ifdef HL2SB
++#include "hl2mp_playeranimstate.h"
++#endif // HL2SB
+ #include "hl2mp_player_shared.h"
+ #include "hl2mp_gamerules.h"
+ #include "utldict.h"
+@@ -51,13 +54,22 @@ class CHL2MP_Player : public CHL2_Player
+ 
+ 	DECLARE_SERVERCLASS();
+ 	DECLARE_DATADESC();
++#ifdef HL2SB
++	DECLARE_PREDICTABLE();
++
++	// This passes the event to the client's and server's CHL2MPPlayerAnimState.
++	void			DoAnimationEvent( PlayerAnimEvent_t event, int nData = 0 );
++	void			SetupBones( matrix3x4_t *pBoneToWorld, int boneMask );
++#endif // HL2SB
+ 
+ 	virtual void Precache( void );
+ 	virtual void Spawn( void );
+ 	virtual void PostThink( void );
+ 	virtual void PreThink( void );
+ 	virtual void PlayerDeathThink( void );
++#ifndef HL2SB
+ 	virtual void SetAnimation( PLAYER_ANIM playerAnim );
++#endif // !HL2SB
+ 	virtual bool HandleCommand_JoinTeam( int team );
+ 	virtual bool ClientCommand( const CCommand &args );
+ 	virtual void CreateViewModel( int viewmodelindex = 0 );
+@@ -82,9 +94,14 @@ class CHL2MP_Player : public CHL2_Player
+ 	void	PrecacheFootStepSounds( void );
+ 	bool	ValidatePlayerModel( const char *pModel );
+ 
++#ifndef HL2SB
+ 	QAngle GetAnimEyeAngles( void ) { return m_angEyeAngles.Get(); }
++#endif // !HL2SB
+ 
+ 	Vector GetAttackSpread( CBaseCombatWeapon *pWeapon, CBaseEntity *pTarget = NULL );
++#ifdef HL2SB
++	virtual Vector GetAutoaimVector( float flDelta );
++#endif // HL2SB
+ 
+ 	void CheatImpulseCommands( int iImpulse );
+ 	void CreateRagdollEntity( void );
+@@ -93,7 +110,12 @@ class CHL2MP_Player : public CHL2_Player
+ 
+ 	void NoteWeaponFired( void );
+ 
++#ifdef HL2SB
++	void SetAnimation( PLAYER_ANIM playerAnim );
++#else
+ 	void ResetAnimation( void );
++#endif // HL2SB
++
+ 	void SetPlayerModel( void );
+ 	void SetPlayerTeamModel( void );
+ 	Activity TranslateTeamActivity( Activity ActToTranslate );
+@@ -140,8 +162,14 @@ class CHL2MP_Player : public CHL2_Player
+ 		
+ private:
+ 
++#ifdef HL2SB
++	CHL2MPPlayerAnimState *m_PlayerAnimState;
++#endif // HL2SB
++
+ 	CNetworkQAngle( m_angEyeAngles );
++#ifndef HL2SB
+ 	CPlayerAnimState   m_PlayerAnimState;
++#endif // !HL2SB
+ 
+ 	int m_iLastWeaponFireUsercmd;
+ 	int m_iModelType;
+@@ -163,6 +191,11 @@ class CHL2MP_Player : public CHL2_Player
+ 
+     bool m_bEnterObserver;
+ 	bool m_bReady;
++
++#ifdef HL2SB
++	CNetworkVar( int, m_cycleLatch ); // Network the cycle to clients periodically
++	CountdownTimer m_cycleLatchTimer;
++#endif // HL2SB
+ };
+ 
+ inline CHL2MP_Player *ToHL2MPPlayer( CBaseEntity *pEntity )
+diff --git a/src/game/server/physics_impact_damage.cpp b/src/game/server/physics_impact_damage.cpp
+index 164568e23..e6892756a 100644
+--- a/src/game/server/physics_impact_damage.cpp
++++ b/src/game/server/physics_impact_damage.cpp
+@@ -335,6 +335,35 @@ float CalculatePhysicsImpactDamage( int index, gamevcollisionevent_t *pEvent, co
+ 
+ 	if ( pEvent->pObjects[otherIndex]->GetGameFlags() & FVPHYSICS_PLAYER_HELD )
+ 	{
++#ifdef HL2SB
++		// if the player is holding the object, use its real mass (player holding reduced the mass)
++
++		CBasePlayer *pPlayer = NULL;
++
++		if ( gpGlobals->maxClients == 1 )
++		{
++			pPlayer = UTIL_GetLocalPlayer();
++		}
++		else
++		{
++			// See which MP player is holding the physics object and then use that player to get the real mass of the object.
++			// This is ugly but better than having linkage between an object and its "holding" player.
++			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
++			{
++				CBasePlayer *tempPlayer = UTIL_PlayerByIndex( i );
++				if ( tempPlayer && pEvent->pEntities[index] == tempPlayer->GetHeldObject() )
++				{
++					pPlayer = tempPlayer;
++					break;
++				}
++			}
++		}
++
++		if ( pPlayer )
++		{
++			otherMass = pPlayer->GetHeldObjectMass( pEvent->pObjects[otherIndex] );
++		}
++#else
+ 		if ( gpGlobals->maxClients == 1 )
+ 		{
+ 			// if the player is holding the object, use it's real mass (player holding reduced the mass)
+@@ -344,6 +373,7 @@ float CalculatePhysicsImpactDamage( int index, gamevcollisionevent_t *pEvent, co
+ 				otherMass = pPlayer->GetHeldObjectMass( pEvent->pObjects[otherIndex] );
+ 			}
+ 		}
++#endif // HL2SB
+ 	}
+ 
+ 	// NOTE: sum the mass of each object in this system for the purpose of damage
+@@ -438,6 +468,38 @@ float CalculatePhysicsImpactDamage( int index, gamevcollisionevent_t *pEvent, co
+ 	}
+ 	else if ( pEvent->pObjects[index]->GetGameFlags() & FVPHYSICS_PLAYER_HELD )
+ 	{
++#ifdef HL2SB
++		// if the player is holding the object, use it's real mass (player holding reduced the mass)
++
++		CBasePlayer *pPlayer = NULL;
++		if ( gpGlobals->maxClients == 1 )
++		{
++			pPlayer = UTIL_GetLocalPlayer();
++		}
++		else
++		{
++			// See which MP player is holding the physics object and then use that player to get the real mass of the object.
++			// This is ugly but better than having linkage between an object and its "holding" player.
++			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
++			{
++				CBasePlayer *tempPlayer = UTIL_PlayerByIndex( i );
++				if ( tempPlayer && pEvent->pEntities[index] == tempPlayer->GetHeldObject() )
++				{
++					pPlayer = tempPlayer;
++					break;
++				}
++			}
++		}
++
++		if ( pPlayer )
++		{
++			float mass = pPlayer->GetHeldObjectMass( pEvent->pObjects[index] );
++			if ( mass > 0 )
++			{
++				invMass = 1.0f / mass;
++			}
++		}
++#else
+ 		if ( gpGlobals->maxClients == 1 )
+ 		{
+ 			// if the player is holding the object, use it's real mass (player holding reduced the mass)
+@@ -451,6 +513,7 @@ float CalculatePhysicsImpactDamage( int index, gamevcollisionevent_t *pEvent, co
+ 				}
+ 			}
+ 		}
++#endif // HL2SB
+ 	}
+ 
+ 	eliminatedEnergy *= invMass * energyScale;
+diff --git a/src/game/server/player.cpp b/src/game/server/player.cpp
+index e0e7ccd28..11f0a7a12 100644
+--- a/src/game/server/player.cpp
++++ b/src/game/server/player.cpp
+@@ -2872,6 +2872,12 @@ float CBasePlayer::GetHeldObjectMass( IPhysicsObject *pHeldObject )
+ 	return 0;
+ }
+ 
++#ifdef HL2SB
++CBaseEntity	*CBasePlayer::GetHeldObject( void )
++{
++	return NULL;
++}
++#endif // HL2SB
+ 
+ //-----------------------------------------------------------------------------
+ // Purpose:	Server side of jumping rules.  Most jumping logic is already
+diff --git a/src/game/server/player.h b/src/game/server/player.h
+index e87af06d8..d7913adc1 100644
+--- a/src/game/server/player.h
++++ b/src/game/server/player.h
+@@ -550,6 +550,9 @@ class CBasePlayer : public CBaseCombatCharacter
+ 	virtual void			PickupObject( CBaseEntity *pObject, bool bLimitMassAndSize = true ) {}
+ 	virtual void			ForceDropOfCarriedPhysObjects( CBaseEntity *pOnlyIfHoldindThis = NULL ) {}
+ 	virtual float			GetHeldObjectMass( IPhysicsObject *pHeldObject );
++#ifdef HL2SB
++	virtual CBaseEntity		*GetHeldObject( void );
++#endif // HL2SB
+ 
+ 	void					CheckSuitUpdate();
+ 	void					SetSuitUpdate(const char *name, int fgroup, int iNoRepeat);
+diff --git a/src/game/shared/basecombatweapon_shared.h b/src/game/shared/basecombatweapon_shared.h
+index 63b5dc5b1..ee26dabc2 100644
+--- a/src/game/shared/basecombatweapon_shared.h
++++ b/src/game/shared/basecombatweapon_shared.h
+@@ -536,6 +536,11 @@ class CBaseCombatWeapon : public BASECOMBATWEAPON_DERIVED_FROM
+ 	bool					WantsToOverrideViewmodelAttachments( void ) { return false; }
+ #endif
+ 
++#ifdef HL2SB
++	//Tony; notifications of any third person switches.
++	virtual void			ThirdPersonSwitch( bool bThirdPerson ) {};
++#endif // HL2SB
++
+ #endif // End client-only methods
+ 
+ 	virtual bool			CanLower( void ) { return false; }
+diff --git a/src/game/shared/hl2mp/hl2mp_player_shared.cpp b/src/game/shared/hl2mp/hl2mp_player_shared.cpp
+index 503d498c2..c1d581bd3 100644
+--- a/src/game/shared/hl2mp/hl2mp_player_shared.cpp
++++ b/src/game/shared/hl2mp/hl2mp_player_shared.cpp
+@@ -18,6 +18,11 @@
+ #include "engine/IEngineSound.h"
+ #include "SoundEmitterSystem/isoundemittersystembase.h"
+ 
++#ifdef HL2SB
++// memdbgon must be the last include file in a .cpp file!!!
++#include "tier0/memdbgon.h"
++#endif // HL2SB
++
+ extern ConVar sv_footsteps;
+ 
+ const char *g_ppszPlayerSoundPrefixNames[PLAYER_SOUNDS_MAX] =
+@@ -121,7 +126,7 @@ void CHL2MP_Player::PlayStepSound( Vector &vecOrigin, surfacedata_t *psurface, f
+ 	EmitSound( filter, entindex(), ep );
+ }
+ 
+-
++#ifndef HL2SB
+ //==========================
+ // ANIMATION CODE
+ //==========================
+@@ -574,4 +579,5 @@ void CPlayerAnimState::GetOuterAbsVelocity( Vector& vel )
+ #else
+ 	vel = GetOuter()->GetAbsVelocity();
+ #endif
+-}
+\ No newline at end of file
++}
++#endif // !HL2SB
+diff --git a/src/game/shared/hl2mp/hl2mp_player_shared.h b/src/game/shared/hl2mp/hl2mp_player_shared.h
+index 3aee9237c..0c06a96ec 100644
+--- a/src/game/shared/hl2mp/hl2mp_player_shared.h
++++ b/src/game/shared/hl2mp/hl2mp_player_shared.h
+@@ -34,6 +34,7 @@ enum HL2MPPlayerState
+ #define CHL2MP_Player C_HL2MP_Player
+ #endif
+ 
++#ifndef HL2SB
+ class CPlayerAnimState
+ {
+ public:
+@@ -93,5 +94,6 @@ class CPlayerAnimState
+ 
+ 	float				m_flTurnCorrectionTime;
+ };
++#endif // !HL2SB
+ 
+ #endif //HL2MP_PLAYER_SHARED_h
+diff --git a/src/game/shared/hl2mp/hl2mp_playeranimstate.cpp b/src/game/shared/hl2mp/hl2mp_playeranimstate.cpp
+new file mode 100644
+index 000000000..a798f27fe
+--- /dev/null
++++ b/src/game/shared/hl2mp/hl2mp_playeranimstate.cpp
+@@ -0,0 +1,703 @@
++//========= Copyright Valve Corporation, All rights reserved. ============//
++#include "cbase.h"
++#include "base_playeranimstate.h"
++#include "tier0/vprof.h"
++#include "animation.h"
++#include "studio.h"
++#include "apparent_velocity_helper.h"
++#include "utldict.h"
++
++#include "hl2mp_playeranimstate.h"
++#include "base_playeranimstate.h"
++#include "datacache/imdlcache.h"
++
++#ifdef CLIENT_DLL
++#include "c_hl2mp_player.h"
++#else
++#include "hl2mp_player.h"
++#endif
++
++#define HL2MP_RUN_SPEED				320.0f
++#define HL2MP_WALK_SPEED			75.0f
++#define HL2MP_CROUCHWALK_SPEED		110.0f
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++// Input  : *pPlayer - 
++// Output : CMultiPlayerAnimState*
++//-----------------------------------------------------------------------------
++CHL2MPPlayerAnimState* CreateHL2MPPlayerAnimState( CHL2MP_Player *pPlayer )
++{
++	MDLCACHE_CRITICAL_SECTION();
++
++	// Setup the movement data.
++	MultiPlayerMovementData_t movementData;
++	movementData.m_flBodyYawRate = 720.0f;
++	movementData.m_flRunSpeed = HL2MP_RUN_SPEED;
++	movementData.m_flWalkSpeed = HL2MP_WALK_SPEED;
++	movementData.m_flSprintSpeed = -1.0f;
++
++	// Create animation state for this player.
++	CHL2MPPlayerAnimState *pRet = new CHL2MPPlayerAnimState( pPlayer, movementData );
++
++	// Specific HL2MP player initialization.
++	pRet->InitHL2MPAnimState( pPlayer );
++
++	return pRet;
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++// Input  :  - 
++//-----------------------------------------------------------------------------
++CHL2MPPlayerAnimState::CHL2MPPlayerAnimState()
++{
++	m_pHL2MPPlayer = NULL;
++
++	// Don't initialize HL2MP specific variables here. Init them in InitHL2MPAnimState()
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++// Input  : *pPlayer - 
++//			&movementData - 
++//-----------------------------------------------------------------------------
++CHL2MPPlayerAnimState::CHL2MPPlayerAnimState( CBasePlayer *pPlayer, MultiPlayerMovementData_t &movementData )
++: CMultiPlayerAnimState( pPlayer, movementData )
++{
++	m_pHL2MPPlayer = NULL;
++
++	// Don't initialize HL2MP specific variables here. Init them in InitHL2MPAnimState()
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++// Input  :  - 
++//-----------------------------------------------------------------------------
++CHL2MPPlayerAnimState::~CHL2MPPlayerAnimState()
++{
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: Initialize HL2MP specific animation state.
++// Input  : *pPlayer - 
++//-----------------------------------------------------------------------------
++void CHL2MPPlayerAnimState::InitHL2MPAnimState( CHL2MP_Player *pPlayer )
++{
++	m_pHL2MPPlayer = pPlayer;
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++//-----------------------------------------------------------------------------
++void CHL2MPPlayerAnimState::ClearAnimationState( void )
++{
++	BaseClass::ClearAnimationState();
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++// Input  : actDesired - 
++// Output : Activity
++//-----------------------------------------------------------------------------
++Activity CHL2MPPlayerAnimState::TranslateActivity( Activity actDesired )
++{
++	// Hook into baseclass when / if hl2mp player models get swim animations.
++	Activity translateActivity = actDesired; //BaseClass::TranslateActivity( actDesired );
++
++	if ( GetHL2MPPlayer()->GetActiveWeapon() )
++	{
++		translateActivity = GetHL2MPPlayer()->GetActiveWeapon()->ActivityOverride( translateActivity, false );
++	}
++
++	return translateActivity;
++}
++//-----------------------------------------------------------------------------
++// Purpose: 
++//-----------------------------------------------------------------------------
++void CHL2MPPlayerAnimState::Update( float eyeYaw, float eyePitch )
++{
++	// Profile the animation update.
++	VPROF( "CHL2MPPlayerAnimState::Update" );
++
++	// Get the HL2MP player.
++	CHL2MP_Player *pHL2MPPlayer = GetHL2MPPlayer();
++	if ( !pHL2MPPlayer )
++		return;
++
++	// Get the studio header for the player.
++	CStudioHdr *pStudioHdr = pHL2MPPlayer->GetModelPtr();
++	if ( !pStudioHdr )
++		return;
++
++	// Check to see if we should be updating the animation state - dead, ragdolled?
++	if ( !ShouldUpdateAnimState() )
++	{
++		ClearAnimationState();
++		return;
++	}
++
++	// Store the eye angles.
++	m_flEyeYaw = AngleNormalize( eyeYaw );
++	m_flEyePitch = AngleNormalize( eyePitch );
++
++	// Compute the player sequences.
++	ComputeSequences( pStudioHdr );
++
++	if ( SetupPoseParameters( pStudioHdr ) )
++	{
++		// Pose parameter - what direction are the player's legs running in.
++		ComputePoseParam_MoveYaw( pStudioHdr );
++
++		// Pose parameter - Torso aiming (up/down).
++		ComputePoseParam_AimPitch( pStudioHdr );
++
++		// Pose parameter - Torso aiming (rotation).
++		ComputePoseParam_AimYaw( pStudioHdr );
++	}
++
++#ifdef CLIENT_DLL 
++	if ( C_BasePlayer::ShouldDrawLocalPlayer() )
++	{
++		m_pHL2MPPlayer->SetPlaybackRate( 1.0f );
++	}
++#endif
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++// Input  : event - 
++//-----------------------------------------------------------------------------
++void CHL2MPPlayerAnimState::DoAnimationEvent( PlayerAnimEvent_t event, int nData )
++{
++	Activity iGestureActivity = ACT_INVALID;
++
++	switch( event )
++	{
++	case PLAYERANIMEVENT_ATTACK_PRIMARY:
++		{
++			// Weapon primary fire.
++			if ( m_pHL2MPPlayer->GetFlags() & FL_DUCKING )
++				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_ATTACK_CROUCH_PRIMARYFIRE );
++			else
++				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_ATTACK_STAND_PRIMARYFIRE );
++
++			iGestureActivity = ACT_VM_PRIMARYATTACK;
++			break;
++		}
++
++	case PLAYERANIMEVENT_VOICE_COMMAND_GESTURE:
++		{
++			if ( !IsGestureSlotActive( GESTURE_SLOT_ATTACK_AND_RELOAD ) )
++				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, (Activity)nData );
++
++			break;
++		}
++	case PLAYERANIMEVENT_ATTACK_SECONDARY:
++		{
++			// Weapon secondary fire.
++			if ( m_pHL2MPPlayer->GetFlags() & FL_DUCKING )
++				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_ATTACK_CROUCH_SECONDARYFIRE );
++			else
++				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_ATTACK_STAND_SECONDARYFIRE );
++
++			iGestureActivity = ACT_VM_PRIMARYATTACK;
++			break;
++		}
++	case PLAYERANIMEVENT_ATTACK_PRE:
++		{
++			if ( m_pHL2MPPlayer->GetFlags() & FL_DUCKING ) 
++			{
++				// Weapon pre-fire. Used for minigun windup, sniper aiming start, etc in crouch.
++				iGestureActivity = ACT_MP_ATTACK_CROUCH_PREFIRE;
++			}
++			else
++			{
++				// Weapon pre-fire. Used for minigun windup, sniper aiming start, etc.
++				iGestureActivity = ACT_MP_ATTACK_STAND_PREFIRE;
++			}
++
++			RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, iGestureActivity, false );
++
++			break;
++		}
++	case PLAYERANIMEVENT_ATTACK_POST:
++		{
++			RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_ATTACK_STAND_POSTFIRE );
++			break;
++		}
++
++	case PLAYERANIMEVENT_RELOAD:
++		{
++			// Weapon reload.
++			if ( GetBasePlayer()->GetFlags() & FL_DUCKING )
++				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_CROUCH );
++			else
++				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_STAND );
++			break;
++		}
++	case PLAYERANIMEVENT_RELOAD_LOOP:
++		{
++			// Weapon reload.
++			if ( GetBasePlayer()->GetFlags() & FL_DUCKING )
++				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_CROUCH_LOOP );
++			else
++				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_STAND_LOOP );
++			break;
++		}
++	case PLAYERANIMEVENT_RELOAD_END:
++		{
++			// Weapon reload.
++			if ( GetBasePlayer()->GetFlags() & FL_DUCKING )
++				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_CROUCH_END );
++			else
++				RestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_MP_RELOAD_STAND_END );
++			break;
++		}
++	default:
++		{
++			BaseClass::DoAnimationEvent( event, nData );
++			break;
++		}
++	}
++
++#ifdef CLIENT_DLL
++	// Make the weapon play the animation as well
++	if ( iGestureActivity != ACT_INVALID )
++	{
++		CBaseCombatWeapon *pWeapon = GetHL2MPPlayer()->GetActiveWeapon();
++		if ( pWeapon )
++		{
++//			pWeapon->EnsureCorrectRenderingModel();
++			pWeapon->SendWeaponAnim( iGestureActivity );
++//			// Force animation events!
++//			pWeapon->ResetEventsParity();		// reset event parity so the animation events will occur on the weapon. 
++			pWeapon->DoAnimationEvents( pWeapon->GetModelPtr() );
++		}
++	}
++#endif
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++// Input  : *idealActivity - 
++//-----------------------------------------------------------------------------
++bool CHL2MPPlayerAnimState::HandleSwimming( Activity &idealActivity )
++{
++	bool bInWater = BaseClass::HandleSwimming( idealActivity );
++
++	return bInWater;
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++// Input  : *idealActivity - 
++// Output : Returns true on success, false on failure.
++//-----------------------------------------------------------------------------
++bool CHL2MPPlayerAnimState::HandleMoving( Activity &idealActivity )
++{
++	return BaseClass::HandleMoving( idealActivity );
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++// Input  : *idealActivity - 
++// Output : Returns true on success, false on failure.
++//-----------------------------------------------------------------------------
++bool CHL2MPPlayerAnimState::HandleDucking( Activity &idealActivity )
++{
++	if ( m_pHL2MPPlayer->GetFlags() & FL_DUCKING )
++	{
++		if ( GetOuterXYSpeed() < MOVING_MINIMUM_SPEED )
++		{
++			idealActivity = ACT_MP_CROUCH_IDLE;		
++		}
++		else
++		{
++			idealActivity = ACT_MP_CROUCHWALK;		
++		}
++
++		return true;
++	}
++	
++	return false;
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++bool CHL2MPPlayerAnimState::HandleJumping( Activity &idealActivity )
++{
++	Vector vecVelocity;
++	GetOuterAbsVelocity( vecVelocity );
++
++	if ( m_bJumping )
++	{
++		static bool bNewJump = false; //Tony; hl2mp players only have a 'hop'
++
++		if ( m_bFirstJumpFrame )
++		{
++			m_bFirstJumpFrame = false;
++			RestartMainSequence();	// Reset the animation.
++		}
++
++		// Reset if we hit water and start swimming.
++		if ( m_pHL2MPPlayer->GetWaterLevel() >= WL_Waist )
++		{
++			m_bJumping = false;
++			RestartMainSequence();
++		}
++		// Don't check if he's on the ground for a sec.. sometimes the client still has the
++		// on-ground flag set right when the message comes in.
++		else if ( gpGlobals->curtime - m_flJumpStartTime > 0.2f )
++		{
++			if ( m_pHL2MPPlayer->GetFlags() & FL_ONGROUND )
++			{
++				m_bJumping = false;
++				RestartMainSequence();
++
++				if ( bNewJump )
++				{
++					RestartGesture( GESTURE_SLOT_JUMP, ACT_MP_JUMP_LAND );					
++				}
++			}
++		}
++
++		// if we're still jumping
++		if ( m_bJumping )
++		{
++			if ( bNewJump )
++			{
++				if ( gpGlobals->curtime - m_flJumpStartTime > 0.5 )
++				{
++					idealActivity = ACT_MP_JUMP_FLOAT;
++				}
++				else
++				{
++					idealActivity = ACT_MP_JUMP_START;
++				}
++			}
++			else
++			{
++				idealActivity = ACT_MP_JUMP;
++			}
++		}
++	}	
++
++	if ( m_bJumping )
++		return true;
++
++	return false;
++}
++
++bool CHL2MPPlayerAnimState::SetupPoseParameters( CStudioHdr *pStudioHdr )
++{
++	// Check to see if this has already been done.
++	if ( m_bPoseParameterInit )
++		return true;
++
++	// Save off the pose parameter indices.
++	if ( !pStudioHdr )
++		return false;
++
++	// Tony; just set them both to the same for now.
++	m_PoseParameterData.m_iMoveX = GetBasePlayer()->LookupPoseParameter( pStudioHdr, "move_yaw" );
++	m_PoseParameterData.m_iMoveY = GetBasePlayer()->LookupPoseParameter( pStudioHdr, "move_yaw" );
++	if ( ( m_PoseParameterData.m_iMoveX < 0 ) || ( m_PoseParameterData.m_iMoveY < 0 ) )
++		return false;
++
++	// Look for the aim pitch blender.
++	m_PoseParameterData.m_iAimPitch = GetBasePlayer()->LookupPoseParameter( pStudioHdr, "aim_pitch" );
++	if ( m_PoseParameterData.m_iAimPitch < 0 )
++		return false;
++
++	// Look for aim yaw blender.
++	m_PoseParameterData.m_iAimYaw = GetBasePlayer()->LookupPoseParameter( pStudioHdr, "aim_yaw" );
++	if ( m_PoseParameterData.m_iAimYaw < 0 )
++		return false;
++
++	m_bPoseParameterInit = true;
++
++	return true;
++}
++float SnapYawTo( float flValue );
++//-----------------------------------------------------------------------------
++// Purpose: 
++//-----------------------------------------------------------------------------
++void CHL2MPPlayerAnimState::EstimateYaw( void )
++{
++	// Get the frame time.
++	float flDeltaTime = gpGlobals->frametime;
++	if ( flDeltaTime == 0.0f )
++		return;
++
++#if 0 // 9way
++	// Get the player's velocity and angles.
++	Vector vecEstVelocity;
++	GetOuterAbsVelocity( vecEstVelocity );
++	QAngle angles = GetBasePlayer()->GetLocalAngles();
++
++	// If we are not moving, sync up the feet and eyes slowly.
++	if ( vecEstVelocity.x == 0.0f && vecEstVelocity.y == 0.0f )
++	{
++		float flYawDelta = angles[YAW] - m_PoseParameterData.m_flEstimateYaw;
++		flYawDelta = AngleNormalize( flYawDelta );
++
++		if ( flDeltaTime < 0.25f )
++		{
++			flYawDelta *= ( flDeltaTime * 4.0f );
++		}
++		else
++		{
++			flYawDelta *= flDeltaTime;
++		}
++
++		m_PoseParameterData.m_flEstimateYaw += flYawDelta;
++		AngleNormalize( m_PoseParameterData.m_flEstimateYaw );
++	}
++	else
++	{
++		m_PoseParameterData.m_flEstimateYaw = ( atan2( vecEstVelocity.y, vecEstVelocity.x ) * 180.0f / M_PI );
++		m_PoseParameterData.m_flEstimateYaw = clamp( m_PoseParameterData.m_flEstimateYaw, -180.0f, 180.0f );
++	}
++#else
++	float dt = gpGlobals->frametime;
++
++	// Get the player's velocity and angles.
++	Vector vecEstVelocity;
++	GetOuterAbsVelocity( vecEstVelocity );
++	QAngle angles = GetBasePlayer()->GetLocalAngles();
++
++	if ( vecEstVelocity.y == 0 && vecEstVelocity.x == 0 )
++	{
++		float flYawDiff = angles[YAW] - m_PoseParameterData.m_flEstimateYaw;
++		flYawDiff = flYawDiff - (int)(flYawDiff / 360) * 360;
++		if (flYawDiff > 180)
++			flYawDiff -= 360;
++		if (flYawDiff < -180)
++			flYawDiff += 360;
++
++		if (dt < 0.25)
++			flYawDiff *= dt * 4;
++		else
++			flYawDiff *= dt;
++
++		m_PoseParameterData.m_flEstimateYaw += flYawDiff;
++		m_PoseParameterData.m_flEstimateYaw = m_PoseParameterData.m_flEstimateYaw - (int)(m_PoseParameterData.m_flEstimateYaw / 360) * 360;
++	}
++	else
++	{
++		m_PoseParameterData.m_flEstimateYaw = (atan2(vecEstVelocity.y, vecEstVelocity.x) * 180 / M_PI);
++
++		if (m_PoseParameterData.m_flEstimateYaw > 180)
++			m_PoseParameterData.m_flEstimateYaw = 180;
++		else if (m_PoseParameterData.m_flEstimateYaw < -180)
++			m_PoseParameterData.m_flEstimateYaw = -180;
++	}
++#endif
++}
++//-----------------------------------------------------------------------------
++// Purpose: Override for backpeddling
++// Input  : dt - 
++//-----------------------------------------------------------------------------
++float SnapYawTo( float flValue );
++void CHL2MPPlayerAnimState::ComputePoseParam_MoveYaw( CStudioHdr *pStudioHdr )
++{
++	// Get the estimated movement yaw.
++	EstimateYaw();
++
++#if 0 // 9way
++	ConVarRef mp_slammoveyaw("mp_slammoveyaw");
++
++	// Get the view yaw.
++	float flAngle = AngleNormalize( m_flEyeYaw );
++
++	// Calc side to side turning - the view vs. movement yaw.
++	float flYaw = flAngle - m_PoseParameterData.m_flEstimateYaw;
++	flYaw = AngleNormalize( -flYaw );
++
++	// Get the current speed the character is running.
++	bool bIsMoving;
++	float flPlaybackRate = 	CalcMovementPlaybackRate( &bIsMoving );
++
++	// Setup the 9-way blend parameters based on our speed and direction.
++	Vector2D vecCurrentMoveYaw( 0.0f, 0.0f );
++	if ( bIsMoving )
++	{
++		if ( mp_slammoveyaw.GetBool() )
++			flYaw = SnapYawTo( flYaw );
++
++		vecCurrentMoveYaw.x = cos( DEG2RAD( flYaw ) ) * flPlaybackRate;
++		vecCurrentMoveYaw.y = -sin( DEG2RAD( flYaw ) ) * flPlaybackRate;
++	}
++
++	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveX, vecCurrentMoveYaw.x );
++	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveY, vecCurrentMoveYaw.y );
++
++	m_DebugAnimData.m_vecMoveYaw = vecCurrentMoveYaw;
++#else
++	// view direction relative to movement
++	float flYaw;	 
++
++	QAngle	angles = GetBasePlayer()->GetLocalAngles();
++	float ang = angles[ YAW ];
++	if ( ang > 180.0f )
++	{
++		ang -= 360.0f;
++	}
++	else if ( ang < -180.0f )
++	{
++		ang += 360.0f;
++	}
++
++	// calc side to side turning
++	flYaw = ang - m_PoseParameterData.m_flEstimateYaw;
++	// Invert for mapping into 8way blend
++	flYaw = -flYaw;
++	flYaw = flYaw - (int)(flYaw / 360) * 360;
++
++	if (flYaw < -180)
++	{
++		flYaw = flYaw + 360;
++	}
++	else if (flYaw > 180)
++	{
++		flYaw = flYaw - 360;
++	}
++
++	//Tony; oops, i inverted this previously above.
++	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveY, flYaw );
++
++#endif
++	
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++//-----------------------------------------------------------------------------
++void CHL2MPPlayerAnimState::ComputePoseParam_AimPitch( CStudioHdr *pStudioHdr )
++{
++	// Get the view pitch.
++	float flAimPitch = m_flEyePitch;
++
++	// Set the aim pitch pose parameter and save.
++	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iAimPitch, flAimPitch );
++	m_DebugAnimData.m_flAimPitch = flAimPitch;
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: 
++//-----------------------------------------------------------------------------
++void CHL2MPPlayerAnimState::ComputePoseParam_AimYaw( CStudioHdr *pStudioHdr )
++{
++	// Get the movement velocity.
++	Vector vecVelocity;
++	GetOuterAbsVelocity( vecVelocity );
++
++	// Check to see if we are moving.
++	bool bMoving = ( vecVelocity.Length() > 1.0f ) ? true : false;
++
++	// If we are moving or are prone and undeployed.
++	if ( bMoving || m_bForceAimYaw )
++	{
++		// The feet match the eye direction when moving - the move yaw takes care of the rest.
++		m_flGoalFeetYaw = m_flEyeYaw;
++	}
++	// Else if we are not moving.
++	else
++	{
++		// Initialize the feet.
++		if ( m_PoseParameterData.m_flLastAimTurnTime <= 0.0f )
++		{
++			m_flGoalFeetYaw	= m_flEyeYaw;
++			m_flCurrentFeetYaw = m_flEyeYaw;
++			m_PoseParameterData.m_flLastAimTurnTime = gpGlobals->curtime;
++		}
++		// Make sure the feet yaw isn't too far out of sync with the eye yaw.
++		// TODO: Do something better here!
++		else
++		{
++			float flYawDelta = AngleNormalize(  m_flGoalFeetYaw - m_flEyeYaw );
++
++			if ( fabs( flYawDelta ) > 45.0f )
++			{
++				float flSide = ( flYawDelta > 0.0f ) ? -1.0f : 1.0f;
++				m_flGoalFeetYaw += ( 45.0f * flSide );
++			}
++		}
++	}
++
++	// Fix up the feet yaw.
++	m_flGoalFeetYaw = AngleNormalize( m_flGoalFeetYaw );
++	if ( m_flGoalFeetYaw != m_flCurrentFeetYaw )
++	{
++		if ( m_bForceAimYaw )
++		{
++			m_flCurrentFeetYaw = m_flGoalFeetYaw;
++		}
++		else
++		{
++			ConvergeYawAngles( m_flGoalFeetYaw, 720.0f, gpGlobals->frametime, m_flCurrentFeetYaw );
++			m_flLastAimTurnTime = gpGlobals->curtime;
++		}
++	}
++
++	// Rotate the body into position.
++	m_angRender[YAW] = m_flCurrentFeetYaw;
++
++	// Find the aim(torso) yaw base on the eye and feet yaws.
++	float flAimYaw = m_flEyeYaw - m_flCurrentFeetYaw;
++	flAimYaw = AngleNormalize( flAimYaw );
++
++	// Set the aim yaw and save.
++	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iAimYaw, flAimYaw );
++	m_DebugAnimData.m_flAimYaw	= flAimYaw;
++
++	// Turn off a force aim yaw - either we have already updated or we don't need to.
++	m_bForceAimYaw = false;
++
++#ifndef CLIENT_DLL
++	QAngle angle = GetBasePlayer()->GetAbsAngles();
++	angle[YAW] = m_flCurrentFeetYaw;
++
++	GetBasePlayer()->SetAbsAngles( angle );
++#endif
++}
++
++//-----------------------------------------------------------------------------
++// Purpose: Override the default, because hl2mp models don't use moveX
++// Input  :  - 
++// Output : float
++//-----------------------------------------------------------------------------
++float CHL2MPPlayerAnimState::GetCurrentMaxGroundSpeed()
++{
++	CStudioHdr *pStudioHdr = GetBasePlayer()->GetModelPtr();
++
++	if ( pStudioHdr == NULL )
++		return 1.0f;
++
++//	float prevX = GetBasePlayer()->GetPoseParameter( m_PoseParameterData.m_iMoveX );
++	float prevY = GetBasePlayer()->GetPoseParameter( m_PoseParameterData.m_iMoveY );
++
++	float d = sqrt( /*prevX * prevX + */prevY * prevY );
++	float newY;//, newX;
++	if ( d == 0.0 )
++	{ 
++//		newX = 1.0;
++		newY = 0.0;
++	}
++	else
++	{
++//		newX = prevX / d;
++		newY = prevY / d;
++	}
++
++//	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveX, newX );
++	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveY, newY );
++
++	float speed = GetBasePlayer()->GetSequenceGroundSpeed( GetBasePlayer()->GetSequence() );
++
++//	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveX, prevX );
++	GetBasePlayer()->SetPoseParameter( pStudioHdr, m_PoseParameterData.m_iMoveY, prevY );
++
++	return speed;
++}
+diff --git a/src/game/shared/hl2mp/hl2mp_playeranimstate.h b/src/game/shared/hl2mp/hl2mp_playeranimstate.h
+new file mode 100644
+index 000000000..20fde7357
+--- /dev/null
++++ b/src/game/shared/hl2mp/hl2mp_playeranimstate.h
+@@ -0,0 +1,65 @@
++//========= Copyright Valve Corporation, All rights reserved. ============//
++#ifndef HL2MP_PLAYERANIMSTATE_H
++#define HL2MP_PLAYERANIMSTATE_H
++#ifdef _WIN32
++#pragma once
++#endif
++
++
++#include "convar.h"
++#include "multiplayer_animstate.h"
++
++#if defined( CLIENT_DLL )
++class C_HL2MP_Player;
++#define CHL2MP_Player C_HL2MP_Player
++#else
++class CHL2MP_Player;
++#endif
++
++// ------------------------------------------------------------------------------------------------ //
++// CPlayerAnimState declaration.
++// ------------------------------------------------------------------------------------------------ //
++class CHL2MPPlayerAnimState : public CMultiPlayerAnimState
++{
++public:
++
++	DECLARE_CLASS( CHL2MPPlayerAnimState, CMultiPlayerAnimState );
++
++	CHL2MPPlayerAnimState();
++	CHL2MPPlayerAnimState( CBasePlayer *pPlayer, MultiPlayerMovementData_t &movementData );
++	~CHL2MPPlayerAnimState();
++
++	void InitHL2MPAnimState( CHL2MP_Player *pPlayer );
++	CHL2MP_Player *GetHL2MPPlayer( void )							{ return m_pHL2MPPlayer; }
++
++	virtual void ClearAnimationState();
++	virtual Activity TranslateActivity( Activity actDesired );
++	virtual void Update( float eyeYaw, float eyePitch );
++
++	void	DoAnimationEvent( PlayerAnimEvent_t event, int nData = 0 );
++
++	bool	HandleMoving( Activity &idealActivity );
++	bool	HandleJumping( Activity &idealActivity );
++	bool	HandleDucking( Activity &idealActivity );
++	bool	HandleSwimming( Activity &idealActivity );
++
++	virtual float GetCurrentMaxGroundSpeed();
++
++private:
++
++	bool						SetupPoseParameters( CStudioHdr *pStudioHdr );
++	virtual void				EstimateYaw( void );
++	virtual void				ComputePoseParam_MoveYaw( CStudioHdr *pStudioHdr );
++	virtual void				ComputePoseParam_AimPitch( CStudioHdr *pStudioHdr );
++	virtual void				ComputePoseParam_AimYaw( CStudioHdr *pStudioHdr );
++
++	CHL2MP_Player   *m_pHL2MPPlayer;
++	bool		m_bInAirWalk;
++	float		m_flHoldDeployedPoseUntilTime;
++};
++
++CHL2MPPlayerAnimState *CreateHL2MPPlayerAnimState( CHL2MP_Player *pPlayer );
++
++
++
++#endif // HL2MP_PLAYERANIMSTATE_H
+diff --git a/src/game/shared/hl2mp/weapon_357.cpp b/src/game/shared/hl2mp/weapon_357.cpp
+index d943f2787..5e1fdc6a2 100644
+--- a/src/game/shared/hl2mp/weapon_357.cpp
++++ b/src/game/shared/hl2mp/weapon_357.cpp
+@@ -36,7 +36,7 @@ class CWeapon357 : public CBaseHL2MPCombatWeapon
+ 	DECLARE_NETWORKCLASS(); 
+ 	DECLARE_PREDICTABLE();
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
+ #endif
+ 
+@@ -57,9 +57,24 @@ LINK_ENTITY_TO_CLASS( weapon_357, CWeapon357 );
+ PRECACHE_WEAPON_REGISTER( weapon_357 );
+ 
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ acttable_t CWeapon357::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PISTOL,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PISTOL,			false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PISTOL,					false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PISTOL,			false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PISTOL,					false },
++#else
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_PISTOL,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_PISTOL,					false },
+ 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_PISTOL,			false },
+@@ -68,6 +83,7 @@ acttable_t CWeapon357::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_PISTOL,					false },
+ 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_PISTOL,				false },
++#endif // HL2SB
+ };
+ 
+ 
+@@ -91,7 +107,11 @@ CWeapon357::CWeapon357( void )
+ void CWeapon357::PrimaryAttack( void )
+ {
+ 	// Only the player fires this way so we can cast
++#ifdef HL2SB
++	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
++#else
+ 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
++#endif // HL2SB
+ 
+ 	if ( !pPlayer )
+ 	{
+@@ -117,7 +137,11 @@ void CWeapon357::PrimaryAttack( void )
+ 	pPlayer->DoMuzzleFlash();
+ 
+ 	SendWeaponAnim( ACT_VM_PRIMARYATTACK );
++#ifdef HL2SB
++	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
++#else
+ 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
++#endif // HL2SB
+ 
+ 	m_flNextPrimaryAttack = gpGlobals->curtime + 0.75;
+ 	m_flNextSecondaryAttack = gpGlobals->curtime + 0.75;
+diff --git a/src/game/shared/hl2mp/weapon_ar2.cpp b/src/game/shared/hl2mp/weapon_ar2.cpp
+index 5086db1bc..de698b9af 100644
+--- a/src/game/shared/hl2mp/weapon_ar2.cpp
++++ b/src/game/shared/hl2mp/weapon_ar2.cpp
+@@ -46,10 +46,25 @@ LINK_ENTITY_TO_CLASS( weapon_ar2, CWeaponAR2 );
+ PRECACHE_WEAPON_REGISTER(weapon_ar2);
+ 
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 
+ acttable_t	CWeaponAR2::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_AR2,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_AR2,			false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_AR2,					false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_AR2,			false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_AR2,		false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_AR2,		false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_AR2,					false },
++#else
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_AR2,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_AR2,					false },
+ 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_AR2,			false },
+@@ -58,6 +73,7 @@ acttable_t	CWeaponAR2::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_AR2,		false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_AR2,					false },
+ 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_AR2,				false },
++#endif // HL2SB
+ };
+ 
+ IMPLEMENT_ACTTABLE(CWeaponAR2);
+diff --git a/src/game/shared/hl2mp/weapon_ar2.h b/src/game/shared/hl2mp/weapon_ar2.h
+index 8aa8dde85..9e0362b56 100644
+--- a/src/game/shared/hl2mp/weapon_ar2.h
++++ b/src/game/shared/hl2mp/weapon_ar2.h
+@@ -75,7 +75,7 @@ class CWeaponAR2 : public CHL2MPMachineGun
+ 	bool					m_bShotDelayed;
+ 	int						m_nVentPose;
+ 	
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
+ #endif
+ };
+diff --git a/src/game/shared/hl2mp/weapon_crossbow.cpp b/src/game/shared/hl2mp/weapon_crossbow.cpp
+index 5bada600f..665ed1870 100644
+--- a/src/game/shared/hl2mp/weapon_crossbow.cpp
++++ b/src/game/shared/hl2mp/weapon_crossbow.cpp
+@@ -433,7 +433,7 @@ class CWeaponCrossbow : public CBaseHL2MPCombatWeapon
+ 	void	SetChargerState( ChargerState_t state );
+ 	void	DoLoadEffect( void );
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
+ #endif
+ 
+@@ -475,10 +475,25 @@ LINK_ENTITY_TO_CLASS( weapon_crossbow, CWeaponCrossbow );
+ 
+ PRECACHE_WEAPON_REGISTER( weapon_crossbow );
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 
+ acttable_t	CWeaponCrossbow::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_CROSSBOW,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_CROSSBOW,				false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_CROSSBOW,						false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_CROSSBOW,				false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,			false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,			false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_CROSSBOW,					false },
++#else
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_CROSSBOW,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_CROSSBOW,						false },
+ 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_CROSSBOW,				false },
+@@ -486,6 +501,7 @@ acttable_t	CWeaponCrossbow::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,	false },
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_CROSSBOW,			false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_CROSSBOW,					false },
++#endif // HL2SB
+ };
+ 
+ IMPLEMENT_ACTTABLE(CWeaponCrossbow);
+@@ -792,6 +808,41 @@ void CWeaponCrossbow::DoLoadEffect( void )
+ 	if ( pOwner == NULL )
+ 		return;
+ 
++#ifdef HL2SB
++	//Tony; change this up a bit; on the server, dispatch an effect but don't send it to the client who fires
++	//on the client, create an effect either in the view model, or on the world model if first person.
++	CEffectData	data;
++
++	data.m_nAttachmentIndex = 1;
++	data.m_vOrigin = pOwner->GetAbsOrigin();
++
++	CPASFilter filter( data.m_vOrigin );
++
++#ifdef GAME_DLL
++	filter.RemoveRecipient( pOwner );
++	data.m_nEntIndex = entindex();
++#else
++	CBaseViewModel *pViewModel = pOwner->GetViewModel();
++	if ( ShouldDrawUsingViewModel() && pViewModel != NULL )
++		data.m_hEntity = pViewModel->GetRefEHandle();
++	else
++		data.m_hEntity = GetRefEHandle();
++#endif
++	DispatchEffect( "CrossbowLoad", data, filter );
++
++#ifndef CLIENT_DLL
++	CSprite *pBlast = CSprite::SpriteCreate( CROSSBOW_GLOW_SPRITE2, GetAbsOrigin(), false );
++
++	if ( pBlast )
++	{
++		pBlast->SetAttachment( this, 1 );
++		pBlast->SetTransparency( kRenderTransAdd, 255, 255, 255, 255, kRenderFxNone );
++		pBlast->SetBrightness( 128 );
++		pBlast->SetScale( 0.2f );
++		pBlast->FadeOutFromSpawn();
++	}
++#endif
++#else
+ 	CBaseViewModel *pViewModel = pOwner->GetViewModel();
+ 
+ 	if ( pViewModel == NULL )
+@@ -821,7 +872,7 @@ void CWeaponCrossbow::DoLoadEffect( void )
+ 		pBlast->FadeOutFromSpawn();
+ 	}
+ #endif
+-	
++#endif // HL2SB
+ }
+ 
+ //-----------------------------------------------------------------------------
+diff --git a/src/game/shared/hl2mp/weapon_crowbar.cpp b/src/game/shared/hl2mp/weapon_crowbar.cpp
+index 55a03d1d6..ca12892bb 100644
+--- a/src/game/shared/hl2mp/weapon_crowbar.cpp
++++ b/src/game/shared/hl2mp/weapon_crowbar.cpp
+@@ -45,10 +45,25 @@ END_PREDICTION_DATA()
+ LINK_ENTITY_TO_CLASS( weapon_crowbar, CWeaponCrowbar );
+ PRECACHE_WEAPON_REGISTER( weapon_crowbar );
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 
+ acttable_t	CWeaponCrowbar::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_MELEE,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_MELEE,			false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_MELEE,					false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_MELEE,			false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_MELEE,					false },
++#else
+ 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_SLAM, true },
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_MELEE,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_MELEE,					false },
+@@ -57,6 +72,7 @@ acttable_t	CWeaponCrowbar::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_MELEE,					false },
++#endif // HL2SB
+ };
+ 
+ IMPLEMENT_ACTTABLE(CWeaponCrowbar);
+diff --git a/src/game/shared/hl2mp/weapon_crowbar.h b/src/game/shared/hl2mp/weapon_crowbar.h
+index 2cd10fb9c..b36254e4b 100644
+--- a/src/game/shared/hl2mp/weapon_crowbar.h
++++ b/src/game/shared/hl2mp/weapon_crowbar.h
+@@ -36,7 +36,7 @@ class CWeaponCrowbar : public CBaseHL2MPBludgeonWeapon
+ 	DECLARE_NETWORKCLASS(); 
+ 	DECLARE_PREDICTABLE();
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
+ #endif
+ 
+diff --git a/src/game/shared/hl2mp/weapon_frag.cpp b/src/game/shared/hl2mp/weapon_frag.cpp
+index 9ddcb8133..86c8ebe7f 100644
+--- a/src/game/shared/hl2mp/weapon_frag.cpp
++++ b/src/game/shared/hl2mp/weapon_frag.cpp
+@@ -83,15 +83,30 @@ class CWeaponFrag: public CBaseHL2MPCombatWeapon
+ 
+ 	CWeaponFrag( const CWeaponFrag & );
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
+ #endif
+ };
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 
+ acttable_t	CWeaponFrag::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_GRENADE,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_GRENADE,			false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_GRENADE,					false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_GRENADE,			false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_GRENADE,		false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_GRENADE,		false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_GRENADE,					false },
++#else
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_GRENADE,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_GRENADE,					false },
+ 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_GRENADE,			false },
+@@ -99,6 +114,7 @@ acttable_t	CWeaponFrag::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,	false },
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_GRENADE,		false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_GRENADE,					false },
++#endif // HL2SB
+ };
+ 
+ IMPLEMENT_ACTTABLE(CWeaponFrag);
+@@ -341,7 +357,11 @@ void CWeaponFrag::ItemPostFrame( void )
+ {
+ 	if( m_fDrawbackFinished )
+ 	{
++#ifdef HL2SB
++		CHL2MP_Player *pOwner = ToHL2MPPlayer( GetOwner() );
++#else
+ 		CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
++#endif // HL2SB
+ 
+ 		if (pOwner)
+ 		{
+@@ -351,6 +371,9 @@ void CWeaponFrag::ItemPostFrame( void )
+ 				if( !(pOwner->m_nButtons & IN_ATTACK) )
+ 				{
+ 					SendWeaponAnim( ACT_VM_THROW );
++#ifdef HL2SB
++					pOwner->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
++#endif // HL2SB
+ 					m_fDrawbackFinished = false;
+ 				}
+ 				break;
+@@ -370,6 +393,11 @@ void CWeaponFrag::ItemPostFrame( void )
+ 						SendWeaponAnim( ACT_VM_HAULBACK );
+ 					}
+ 
++#ifdef HL2SB
++					//Tony; the grenade really should have a secondary anim. but it doesn't on the player.
++					pOwner->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
++#endif // HL2SB
++
+ 					m_fDrawbackFinished = false;
+ 				}
+ 				break;
+diff --git a/src/game/shared/hl2mp/weapon_hl2mpbase.cpp b/src/game/shared/hl2mp/weapon_hl2mpbase.cpp
+index 15995a5be..88004b862 100644
+--- a/src/game/shared/hl2mp/weapon_hl2mpbase.cpp
++++ b/src/game/shared/hl2mp/weapon_hl2mpbase.cpp
+@@ -106,6 +106,20 @@ bool CWeaponHL2MPBase::IsPredicted() const
+ 	return true;
+ }
+ 
++#ifdef HL2SB
++//Tony; override for animation purposes.
++bool CWeaponHL2MPBase::Reload( void )
++{
++	bool fRet = DefaultReload( GetMaxClip1(), GetMaxClip2(), ACT_VM_RELOAD );
++	if ( fRet )
++	{
++//		WeaponSound( RELOAD );
++		ToHL2MPPlayer(GetOwner())->DoAnimationEvent( PLAYERANIMEVENT_RELOAD );
++	}
++	return fRet;
++}
++#endif // HL2SB
++
+ void CWeaponHL2MPBase::WeaponSound( WeaponSound_t sound_type, float soundtime /* = 0.0f */ )
+ {
+ #ifdef CLIENT_DLL
+diff --git a/src/game/shared/hl2mp/weapon_hl2mpbase.h b/src/game/shared/hl2mp/weapon_hl2mpbase.h
+index 0f21044b1..2e22867af 100644
+--- a/src/game/shared/hl2mp/weapon_hl2mpbase.h
++++ b/src/game/shared/hl2mp/weapon_hl2mpbase.h
+@@ -41,7 +41,9 @@ class CWeaponHL2MPBase : public CBaseCombatWeapon
+ 	#ifdef GAME_DLL
+ 		DECLARE_DATADESC();
+ 	
++#ifdef HL2SB
+ 		void SendReloadSoundEvent( void );
++#endif // HL2SB
+ 
+ 		void Materialize( void );
+ 		virtual	int	ObjectCaps( void );
+@@ -60,6 +62,9 @@ class CWeaponHL2MPBase : public CBaseCombatWeapon
+ 
+ 	virtual void FireBullets( const FireBulletsInfo_t &info );
+ 	virtual void FallInit( void );
++#ifdef HL2SB
++	virtual bool Reload();
++#endif // HL2SB
+ 	
+ public:
+ 	#if defined( CLIENT_DLL )
+diff --git a/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp b/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp
+index b5a0040ef..ebc4d9bc2 100644
+--- a/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp
++++ b/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp
+@@ -114,7 +114,11 @@ void CHL2MPMachineGun::PrimaryAttack( void )
+ 	}
+ 
+ 	SendWeaponAnim( GetPrimaryAttackActivity() );
++#ifdef HL2SB
++	ToHL2MPPlayer(pPlayer)->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
++#else
+ 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
++#endif // HL2SB
+ }
+ 
+ //-----------------------------------------------------------------------------
+diff --git a/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp b/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp
+index 21373ca8d..b20747cfe 100644
+--- a/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp
++++ b/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp
+@@ -355,7 +355,11 @@ void CBaseHL2MPBludgeonWeapon::Swing( int bIsSecondary )
+ 	// Send the anim
+ 	SendWeaponAnim( nHitActivity );
+ 
++#ifdef HL2SB
++	ToHL2MPPlayer(pOwner)->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
++#else
+ 	pOwner->SetAnimation( PLAYER_ATTACK1 );
++#endif // HL2SB
+ 
+ 	//Setup our next attack times
+ 	m_flNextPrimaryAttack = gpGlobals->curtime + GetFireRate();
+diff --git a/src/game/shared/hl2mp/weapon_physcannon.cpp b/src/game/shared/hl2mp/weapon_physcannon.cpp
+index 4972a1ed6..70843d145 100644
+--- a/src/game/shared/hl2mp/weapon_physcannon.cpp
++++ b/src/game/shared/hl2mp/weapon_physcannon.cpp
+@@ -1225,6 +1225,12 @@ class CWeaponPhysCannon : public CBaseHL2MPCombatWeapon
+ 
+ 	void			NotifyShouldTransmit( ShouldTransmitState_t state );
+ 
++#ifdef HL2SB
++private:
++	virtual void ThirdPersonSwitch( bool bThirdPerson );
++protected:
++#endif // HL2SB
++
+ #endif	// CLIENT_DLL
+ 
+ 	int		m_nChangeState;				// For delayed state change of elements
+@@ -1250,7 +1256,7 @@ class CWeaponPhysCannon : public CBaseHL2MPCombatWeapon
+ private:
+ 	CWeaponPhysCannon( const CWeaponPhysCannon & );
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
+ #endif
+ };
+@@ -1289,10 +1295,25 @@ END_PREDICTION_DATA()
+ LINK_ENTITY_TO_CLASS( weapon_physcannon, CWeaponPhysCannon );
+ PRECACHE_WEAPON_REGISTER( weapon_physcannon );
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 
+ acttable_t	CWeaponPhysCannon::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PHYSGUN,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PHYSGUN,			false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PHYSGUN,					false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PHYSGUN,			false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PHYSGUN,					false },
++#else
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_PHYSGUN,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_PHYSGUN,					false },
+ 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_PHYSGUN,			false },
+@@ -1300,6 +1321,7 @@ acttable_t	CWeaponPhysCannon::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_PHYSGUN,					false },
++#endif // HL2SB
+ };
+ 
+ IMPLEMENT_ACTTABLE(CWeaponPhysCannon);
+@@ -2601,6 +2623,29 @@ void CWeaponPhysCannon::DoEffectIdle( void )
+ 
+ 	StartEffects();
+ 
++#ifdef HL2SB
++	// Turn on the glow sprites
++	for ( int i = PHYSCANNON_GLOW1; i < (PHYSCANNON_GLOW1+NUM_GLOW_SPRITES); i++ )
++	{
++		m_Parameters[i].GetScale().SetAbsolute( random->RandomFloat( 0.075f, 0.05f ) * SPRITE_SCALE );
++		m_Parameters[i].GetAlpha().SetAbsolute( random->RandomInt( 24, 32 ) );
++	}
++
++	// Turn on the glow sprites
++	for ( int i = PHYSCANNON_ENDCAP1; i < (PHYSCANNON_ENDCAP1+NUM_ENDCAP_SPRITES); i++ )
++	{
++		m_Parameters[i].GetScale().SetAbsolute( random->RandomFloat( 3, 5 ) );
++		m_Parameters[i].GetAlpha().SetAbsolute( random->RandomInt( 200, 255 ) );
++	}
++
++	if ( m_EffectState != EFFECT_HOLDING )
++	{
++		// Turn beams off
++		m_Beams[0].SetVisible( false );
++		m_Beams[1].SetVisible( false );
++		m_Beams[2].SetVisible( false );
++	}
++#else
+ 	//if ( ShouldDrawUsingViewModel() )
+ 	{
+ 		// Turn on the glow sprites
+@@ -2651,6 +2696,7 @@ void CWeaponPhysCannon::DoEffectIdle( void )
+ 		}
+ 	}
+ 	*/
++#endif // HL2SB
+ #endif
+ }
+ 
+@@ -2957,6 +3003,18 @@ void CWeaponPhysCannon::StopEffects( bool stopSound )
+ #endif	// !CLIENT_DLL
+ }
+ 
++#ifdef HL2SB
++#ifdef CLIENT_DLL
++void CWeaponPhysCannon::ThirdPersonSwitch( bool bThirdPerson )
++{
++	//Tony; if we switch to first or third person or whatever, destroy and recreate the effects.
++	//Note: the sound only ever gets shut off on the server, so it's okay - as this is entirely client side.
++	DestroyEffects();
++	StartEffects();
++}
++#endif
++#endif // HL2SB
++
+ //-----------------------------------------------------------------------------
+ // Purpose: 
+ //-----------------------------------------------------------------------------
+diff --git a/src/game/shared/hl2mp/weapon_pistol.cpp b/src/game/shared/hl2mp/weapon_pistol.cpp
+index 5a9533c43..5a53e4837 100644
+--- a/src/game/shared/hl2mp/weapon_pistol.cpp
++++ b/src/game/shared/hl2mp/weapon_pistol.cpp
+@@ -15,6 +15,9 @@
+ #endif
+ 
+ #include "weapon_hl2mpbasehlmpcombatweapon.h"
++#ifdef HL2SB
++#include "weapon_hl2mpbase_machinegun.h"
++#endif // HL2SB
+ 
+ #define	PISTOL_FASTEST_REFIRE_TIME		0.1f
+ #define	PISTOL_FASTEST_DRY_REFIRE_TIME	0.2f
+@@ -30,10 +33,17 @@
+ // CWeaponPistol
+ //-----------------------------------------------------------------------------
+ 
++#ifdef HL2SB
++class CWeaponPistol : public CHL2MPMachineGun
++{
++public:
++	DECLARE_CLASS( CWeaponPistol, CHL2MPMachineGun );
++#else
+ class CWeaponPistol : public CBaseHL2MPCombatWeapon
+ {
+ public:
+ 	DECLARE_CLASS( CWeaponPistol, CBaseHL2MPCombatWeapon );
++#endif // HL2SB
+ 
+ 	CWeaponPistol(void);
+ 
+@@ -85,7 +95,7 @@ class CWeaponPistol : public CBaseHL2MPCombatWeapon
+ 		return 0.5f; 
+ 	}
+ 	
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
+ #endif
+ 
+@@ -127,9 +137,24 @@ END_PREDICTION_DATA()
+ LINK_ENTITY_TO_CLASS( weapon_pistol, CWeaponPistol );
+ PRECACHE_WEAPON_REGISTER( weapon_pistol );
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ acttable_t CWeaponPistol::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PISTOL,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PISTOL,			false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PISTOL,					false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PISTOL,			false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PISTOL,					false },
++#else
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_PISTOL,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_PISTOL,					false },
+ 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_PISTOL,			false },
+@@ -138,6 +163,7 @@ acttable_t CWeaponPistol::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_PISTOL,					false },
+ 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_PISTOL,				false },
++#endif // HL2SB
+ };
+ 
+ 
+@@ -313,6 +339,9 @@ bool CWeaponPistol::Reload( void )
+ 	if ( fRet )
+ 	{
+ 		WeaponSound( RELOAD );
++#ifdef HL2SB
++		ToHL2MPPlayer(GetOwner())->DoAnimationEvent( PLAYERANIMEVENT_RELOAD );
++#endif // HL2SB
+ 		m_flAccuracyPenalty = 0.0f;
+ 	}
+ 	return fRet;
+diff --git a/src/game/shared/hl2mp/weapon_rpg.cpp b/src/game/shared/hl2mp/weapon_rpg.cpp
+index aa3cc8fd0..70e53f314 100644
+--- a/src/game/shared/hl2mp/weapon_rpg.cpp
++++ b/src/game/shared/hl2mp/weapon_rpg.cpp
+@@ -1248,7 +1248,11 @@ void CAPCMissile::ComputeActualDotPosition( CLaserDot *pLaserDot, Vector *pActua
+ 
+ #define	RPG_BEAM_SPRITE		"effects/laser1.vmt"
+ #define	RPG_BEAM_SPRITE_NOZ	"effects/laser1_noz.vmt"
++#ifdef HL2SB
++#define	RPG_LASER_SPRITE	"sprites/redglow1.vmt"
++#else
+ #define	RPG_LASER_SPRITE	"sprites/redglow1"
++#endif // HL2SB
+ 
+ //=============================================================================
+ // RPG
+@@ -1305,9 +1309,24 @@ END_PREDICTION_DATA()
+ 
+ #endif
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ acttable_t	CWeaponRPG::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_RPG,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_RPG,			false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_RPG,					false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_RPG,			false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_RPG,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_RPG,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_RPG,		false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_RPG,		false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_RPG,					false },
++#else
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_RPG,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_RPG,					false },
+ 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_RPG,			false },
+@@ -1316,6 +1335,7 @@ acttable_t	CWeaponRPG::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_RPG,		false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_RPG,					false },
+ 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_RPG,				false },
++#endif // HL2SB
+ };
+ 
+ IMPLEMENT_ACTTABLE(CWeaponRPG);
+@@ -1361,7 +1381,9 @@ void CWeaponRPG::Precache( void )
+ 	PrecacheScriptSound( "Missile.Accelerate" );
+ 
+ 	// Laser dot...
++#ifndef HL2SB
+ 	PrecacheModel( "sprites/redglow1.vmt" );
++#endif // !HL2SB
+ 	PrecacheModel( RPG_LASER_SPRITE );
+ 	PrecacheModel( RPG_BEAM_SPRITE );
+ 	PrecacheModel( RPG_BEAM_SPRITE_NOZ );
+@@ -1425,7 +1447,11 @@ bool CWeaponRPG::WeaponShouldBeLowered( void )
+ void CWeaponRPG::PrimaryAttack( void )
+ {
+ 	// Only the player fires this way so we can cast
++#ifdef HL2SB
++	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
++#else
+ 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
++#endif // HL2SB
+ 
+ 	if (!pPlayer)
+ 		return;
+@@ -1480,7 +1506,11 @@ void CWeaponRPG::PrimaryAttack( void )
+ 	WeaponSound( SINGLE );
+ 
+ 	// player "shoot" animation
++#ifdef HL2SB
++	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
++#else
+ 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
++#endif // HL2SB
+ }
+ 
+ //-----------------------------------------------------------------------------
+@@ -1883,6 +1913,21 @@ void CWeaponRPG::GetWeaponAttachment( int attachmentId, Vector &outVector, Vecto
+ 	}
+ }
+ 
++#ifdef HL2SB
++//Tony; added so when the rpg switches to third person, the beam etc is re-created.
++void CWeaponRPG::ThirdPersonSwitch( bool bThirdPerson )
++{
++	if ( m_pBeam != NULL )
++	{
++		//Tell it to die right away and let the beam code free it.
++		m_pBeam->brightness = 0.0f;
++		m_pBeam->flags &= ~FBEAM_FOREVER;
++		m_pBeam->die = gpGlobals->curtime - 0.1;
++		m_pBeam = NULL;
++	}
++}
++#endif // HL2SB
++
+ //-----------------------------------------------------------------------------
+ // Purpose: Setup our laser beam
+ //-----------------------------------------------------------------------------
+@@ -2231,7 +2276,11 @@ int CLaserDot::DrawModel( int flags )
+ 	if ( pOwner != NULL && pOwner->IsDormant() == false )
+ 	{
+ 		// Always draw the dot in front of our faces when in first-person
++#ifdef HL2SB
++		if ( pOwner->IsLocalPlayer() && C_BasePlayer::LocalPlayerInFirstPersonView() )	//Tony; !!!
++#else
+ 		if ( pOwner->IsLocalPlayer() )
++#endif // HL2SB
+ 		{
+ 			// Take our view position and orientation
+ 			vecAttachment = CurrentViewOrigin();
+@@ -2242,7 +2291,11 @@ int CLaserDot::DrawModel( int flags )
+ 			// Take the eye position and direction
+ 			vecAttachment = pOwner->EyePosition();
+ 			
++#ifdef HL2SB
++			QAngle angles = pOwner->EyeAngles();
++#else
+ 			QAngle angles = pOwner->GetAnimEyeAngles();
++#endif // HL2SB
+ 			AngleVectors( angles, &vecDir );
+ 		}
+ 		
+diff --git a/src/game/shared/hl2mp/weapon_rpg.h b/src/game/shared/hl2mp/weapon_rpg.h
+index bbd6f2dd2..ab4a99c56 100644
+--- a/src/game/shared/hl2mp/weapon_rpg.h
++++ b/src/game/shared/hl2mp/weapon_rpg.h
+@@ -238,11 +238,16 @@ class CWeaponRPG : public CBaseHL2MPCombatWeapon
+ 	CMaterialReference	m_hBeamMaterial;	// Used for the laser beam
+ 	Beam_t				*m_pBeam;			// Laser beam temp entity
+ 
++#ifdef HL2SB
++	//Tony; third person check thing, to destroy/reinitialize the beam ( swapping first -> third or back, etc )
++	virtual void			ThirdPersonSwitch( bool bThirdPerson );
++#endif // HL2SB
++
+ #endif	//CLIENT_DLL
+ 
+ 	CBaseEntity *GetMissile( void ) { return m_hMissile; }
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
+ #endif
+ 	
+diff --git a/src/game/shared/hl2mp/weapon_shotgun.cpp b/src/game/shared/hl2mp/weapon_shotgun.cpp
+index da370b539..ea5b622dd 100644
+--- a/src/game/shared/hl2mp/weapon_shotgun.cpp
++++ b/src/game/shared/hl2mp/weapon_shotgun.cpp
+@@ -61,7 +61,7 @@ class CWeaponShotgun : public CBaseHL2MPCombatWeapon
+ 	void DryFire( void );
+ 	virtual float GetFireRate( void ) { return 0.7; };
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
+ #endif
+ 
+@@ -99,9 +99,24 @@ END_PREDICTION_DATA()
+ LINK_ENTITY_TO_CLASS( weapon_shotgun, CWeaponShotgun );
+ PRECACHE_WEAPON_REGISTER(weapon_shotgun);
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ acttable_t	CWeaponShotgun::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_SHOTGUN,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_SHOTGUN,			false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_SHOTGUN,					false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_SHOTGUN,			false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,		false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,		false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_SHOTGUN,					false },
++#else
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_SHOTGUN,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_SHOTGUN,					false },
+ 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_SHOTGUN,			false },
+@@ -110,6 +125,7 @@ acttable_t	CWeaponShotgun::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,		false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_SHOTGUN,					false },
+ 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_SHOTGUN,				false },
++#endif // HL2SB
+ };
+ 
+ IMPLEMENT_ACTTABLE(CWeaponShotgun);
+@@ -127,7 +143,11 @@ bool CWeaponShotgun::StartReload( void )
+ 	if ( m_bNeedPump )
+ 		return false;
+ 
++#ifdef HL2SB
++	CHL2MP_Player *pOwner = ToHL2MPPlayer( GetOwner() );
++#else
+ 	CBaseCombatCharacter *pOwner  = GetOwner();
++#endif // HL2SB
+ 	
+ 	if ( pOwner == NULL )
+ 		return false;
+@@ -146,6 +166,11 @@ bool CWeaponShotgun::StartReload( void )
+ 
+ 	SendWeaponAnim( ACT_SHOTGUN_RELOAD_START );
+ 
++#ifdef HL2SB
++	//Tony; BUG BUG BUG!!! shotgun does one shell at a time!!! -- player model only has a single reload!!! so I'm just going to dispatch the singular for now.
++	pOwner->DoAnimationEvent( PLAYERANIMEVENT_RELOAD );
++#endif // HL2SB
++
+ 	// Make shotgun shell visible
+ 	SetBodygroup(1,0);
+ 
+@@ -293,7 +318,11 @@ void CWeaponShotgun::DryFire( void )
+ void CWeaponShotgun::PrimaryAttack( void )
+ {
+ 	// Only the player fires this way so we can cast
++#ifdef HL2SB
++	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
++#else
+ 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
++#endif // HL2SB
+ 
+ 	if (!pPlayer)
+ 	{
+@@ -312,7 +341,11 @@ void CWeaponShotgun::PrimaryAttack( void )
+ 	m_iClip1 -= 1;
+ 
+ 	// player "shoot" animation
++#ifdef HL2SB
++	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
++#else
+ 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
++#endif // HL2SB
+ 
+ 	Vector	vecSrc		= pPlayer->Weapon_ShootPosition( );
+ 	Vector	vecAiming	= pPlayer->GetAutoaimVector( AUTOAIM_10DEGREES );	
+@@ -344,7 +377,11 @@ void CWeaponShotgun::PrimaryAttack( void )
+ void CWeaponShotgun::SecondaryAttack( void )
+ {
+ 	// Only the player fires this way so we can cast
++#ifdef HL2SB
++	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
++#else
+ 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
++#endif // HL2SB
+ 
+ 	if (!pPlayer)
+ 	{
+@@ -364,7 +401,11 @@ void CWeaponShotgun::SecondaryAttack( void )
+ 	m_iClip1 -= 2;	// Shotgun uses same clip for primary and secondary attacks
+ 
+ 	// player "shoot" animation
++#ifdef HL2SB
++	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );	//Tony; shotgun doesn't have a secondary anim, use primary.
++#else
+ 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
++#endif // HL2SB
+ 
+ 	Vector vecSrc	 = pPlayer->Weapon_ShootPosition();
+ 	Vector vecAiming = pPlayer->GetAutoaimVector( AUTOAIM_10DEGREES );	
+diff --git a/src/game/shared/hl2mp/weapon_slam.cpp b/src/game/shared/hl2mp/weapon_slam.cpp
+index bcdec40cd..84485dd2d 100644
+--- a/src/game/shared/hl2mp/weapon_slam.cpp
++++ b/src/game/shared/hl2mp/weapon_slam.cpp
+@@ -14,7 +14,11 @@
+ 	#include "c_hl2mp_player.h"
+ #else
+ 	#include "hl2mp_player.h"
++#ifdef HL2SB
++	#include "hl2mp/grenade_tripmine.h" // Load the hl2mp version!
++#else
+ 	#include "grenade_tripmine.h"
++#endif // HL2SB
+ 	#include "grenade_satchel.h"
+ 	#include "entitylist.h"
+ 	#include "eventqueue.h"
+@@ -26,6 +30,9 @@
+ #include "tier0/memdbgon.h"
+ 
+ #define	SLAM_PRIMARY_VOLUME		450
++#ifdef HL2SB
++#define SLAM_REFIRE_DELAY		0.05f
++#endif // HL2SB
+ 
+ IMPLEMENT_NETWORKCLASS_ALIASED( Weapon_SLAM, DT_Weapon_SLAM )
+ 
+@@ -91,9 +98,26 @@ BEGIN_DATADESC( CWeapon_SLAM )
+ 	DEFINE_FUNCTION( SlamTouch ),
+ 
+ END_DATADESC()
++#endif
+ 
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ acttable_t	CWeapon_SLAM::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_SLAM,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_SLAM,				false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_SLAM,						false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_SLAM,				false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_SLAM,			false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_SLAM,			false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_SLAM,					false },
++#else
+ 	{ ACT_RANGE_ATTACK1, ACT_RANGE_ATTACK_SLAM, true },
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_SLAM,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_SLAM,					false },
+@@ -102,6 +126,7 @@ acttable_t	CWeapon_SLAM::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM,	false },
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_SLAM,		false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_SLAM,					false },
++#endif // HL2SB
+ };
+ 
+ IMPLEMENT_ACTTABLE(CWeapon_SLAM);
+@@ -327,8 +352,13 @@ void CWeapon_SLAM::StartSatchelDetonate()
+ 	}
+ 	SatchelDetonate();
+ 
++#ifdef HL2SB
++	// needs a higher delay on all of these, a minimum time really - to elimiate refires.
++	m_flNextPrimaryAttack	= m_flNextSecondaryAttack = SLAM_REFIRE_DELAY + gpGlobals->curtime + SequenceDuration();
++#else
+ 	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
+ 	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
++#endif // HL2SB
+ }
+ 
+ 
+@@ -376,7 +406,10 @@ void CWeapon_SLAM::TripmineAttach( void )
+ 
+ 			CTripmineGrenade *pMine = (CTripmineGrenade *)pEnt;
+ 			pMine->m_hOwner = GetOwner();
+-
++#ifdef HL2SB
++			// Attempt to attach to entity, or just sit still in place.
++			pMine->AttachToEntity( pEntity );
++#endif // HL2SB
+ #endif
+ 
+ 			pOwner->RemoveAmmo( 1, m_iSecondaryAmmoType );
+@@ -392,7 +425,11 @@ void CWeapon_SLAM::TripmineAttach( void )
+ void CWeapon_SLAM::StartTripmineAttach( void )
+ {
+ 	// Only the player fires this way so we can cast
++#ifdef HL2SB
++	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
++#else
+ 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
++#endif // HL2SB
+ 	if (!pPlayer)
+ 	{
+ 		return;
+@@ -419,7 +456,11 @@ void CWeapon_SLAM::StartTripmineAttach( void )
+ 		if (pEntity && !(pEntity->GetFlags() & FL_CONVEYOR))
+ 		{
+ 			// player "shoot" animation
++#ifdef HL2SB
++			pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
++#else
+ 			pPlayer->SetAnimation( PLAYER_ATTACK1 );
++#endif // HL2SB
+ 
+ 			// -----------------------------------------
+ 			//  Play attach animation
+@@ -443,9 +484,14 @@ void CWeapon_SLAM::StartTripmineAttach( void )
+ 			// ALERT( at_console, "no deploy\n" );
+ 		}
+ 	}
+-	
++
++#ifdef HL2SB
++	// needs a higher delay on all of these, a minimum time really - to elimiate refires.
++	m_flNextPrimaryAttack	= m_flNextSecondaryAttack = SLAM_REFIRE_DELAY + gpGlobals->curtime + SequenceDuration();
++#else
+ 	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
+ 	m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
++#endif // HL2SB
+ //	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
+ }
+ 
+@@ -456,11 +502,18 @@ void CWeapon_SLAM::StartTripmineAttach( void )
+ //-----------------------------------------------------------------------------
+ void CWeapon_SLAM::SatchelThrow( void )
+ {	
++#ifdef HL2SB
++	// Only the player fires this way so we can cast
++	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
++#endif // HL2SB
++
+ #ifndef CLIENT_DLL
+ 	m_bThrowSatchel = false;
+ 
++#ifndef HL2SB
+ 	// Only the player fires this way so we can cast
+ 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
++#endif // !HL2SB
+ 
+ 	Vector vecSrc	 = pPlayer->WorldSpaceCenter();
+ 	Vector vecFacing = pPlayer->BodyDirection3D( );
+@@ -492,10 +545,17 @@ void CWeapon_SLAM::SatchelThrow( void )
+ 	}
+ 
+ 	pPlayer->RemoveAmmo( 1, m_iSecondaryAmmoType );
++#ifndef HL2SB
+ 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
++#endif // !HL2SB
+ 
+ #endif
+ 
++#ifdef HL2SB
++	//Tony; is there a different anim in the player? must check..
++	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
++#endif // HL2SB
++
+ 	// Play throw sound
+ 	EmitSound( "Weapon_SLAM.SatchelThrow" );
+ }
+@@ -527,8 +587,12 @@ void CWeapon_SLAM::StartSatchelThrow( void )
+ 	m_bNeedReload		= true;
+ 	m_bThrowSatchel		= true;
+ 
++#ifdef HL2SB
++	m_flNextPrimaryAttack	= m_flNextSecondaryAttack = SLAM_REFIRE_DELAY + gpGlobals->curtime + SequenceDuration();
++#else
+ 	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
+ 	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
++#endif // HL2SB
+ }
+ 
+ //-----------------------------------------------------------------------------
+@@ -587,7 +651,11 @@ void CWeapon_SLAM::SatchelAttach( void )
+ void CWeapon_SLAM::StartSatchelAttach( void )
+ {
+ #ifndef CLIENT_DLL
++#ifdef HL2SB
++	CHL2MP_Player *pOwner = ToHL2MPPlayer( GetOwner() );
++#else
+ 	CBaseCombatCharacter *pOwner  = GetOwner();
++#endif // HL2SB
+ 	if (!pOwner)
+ 	{
+ 		return;
+@@ -605,11 +673,16 @@ void CWeapon_SLAM::StartSatchelAttach( void )
+ 		CBaseEntity *pEntity = tr.m_pEnt;
+ 		if (pEntity && !(pEntity->GetFlags() & FL_CONVEYOR))
+ 		{
++#ifndef HL2SB
+ 			// Only the player fires this way so we can cast
+ 			CBasePlayer *pPlayer = ToBasePlayer( pOwner );
+ 
+ 			// player "shoot" animation
+ 			pPlayer->SetAnimation( PLAYER_ATTACK1 );
++#else
++			// player "shoot" animation
++			pOwner->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
++#endif // !HL2SB
+ 
+ 			// -----------------------------------------
+ 			//  Play attach animation
+@@ -631,7 +704,11 @@ void CWeapon_SLAM::StartSatchelAttach( void )
+ 			m_bNeedReload		= true;
+ 			m_bAttachSatchel	= true;
+ 
++#ifdef HL2SB
++			m_flNextPrimaryAttack	= m_flNextSecondaryAttack = SLAM_REFIRE_DELAY + gpGlobals->curtime + SequenceDuration();
++#else
+ 			m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
++#endif // HL2SB
+ 		}
+ 	}
+ #endif
+diff --git a/src/game/shared/hl2mp/weapon_slam.h b/src/game/shared/hl2mp/weapon_slam.h
+index 0b59bed77..c6ca1024e 100644
+--- a/src/game/shared/hl2mp/weapon_slam.h
++++ b/src/game/shared/hl2mp/weapon_slam.h
+@@ -78,8 +78,10 @@ class CWeapon_SLAM : public CBaseHL2MPCombatWeapon
+ 
+ 	CWeapon_SLAM();
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
++#endif
++#ifndef CLIENT_DLL
+ 	DECLARE_DATADESC();
+ #endif
+ 
+diff --git a/src/game/shared/hl2mp/weapon_smg1.cpp b/src/game/shared/hl2mp/weapon_smg1.cpp
+index bd6e1d429..34802467d 100644
+--- a/src/game/shared/hl2mp/weapon_smg1.cpp
++++ b/src/game/shared/hl2mp/weapon_smg1.cpp
+@@ -61,7 +61,7 @@ class CWeaponSMG1 : public CHL2MPMachineGun
+ 
+ 	const WeaponProficiencyInfo_t *GetProficiencyValues();
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
+ #endif
+ 
+@@ -85,9 +85,24 @@ END_PREDICTION_DATA()
+ LINK_ENTITY_TO_CLASS( weapon_smg1, CWeaponSMG1 );
+ PRECACHE_WEAPON_REGISTER(weapon_smg1);
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ acttable_t	CWeaponSMG1::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_SMG1,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_SMG1,				false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_SMG1,						false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_SMG1,				false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_SMG1,			false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_SMG1,			false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_SMG1,					false },
++#else
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_SMG1,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_SMG1,						false },
+ 	{ ACT_HL2MP_IDLE_CROUCH,			ACT_HL2MP_IDLE_CROUCH_SMG1,				false },
+@@ -96,6 +111,7 @@ acttable_t	CWeaponSMG1::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_SMG1,			false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_SMG1,					false },
+ 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_SMG1,					false },
++#endif // HL2SB
+ };
+ 
+ IMPLEMENT_ACTTABLE(CWeaponSMG1);
+@@ -164,6 +180,9 @@ bool CWeaponSMG1::Reload( void )
+ 		m_flNextSecondaryAttack = GetOwner()->m_flNextAttack = fCacheTime;
+ 
+ 		WeaponSound( RELOAD );
++#ifdef HL2SB
++		ToHL2MPPlayer(GetOwner())->DoAnimationEvent( PLAYERANIMEVENT_RELOAD );
++#endif // HL2SB
+ 	}
+ 
+ 	return fRet;
+@@ -193,7 +212,11 @@ void CWeaponSMG1::AddViewKick( void )
+ void CWeaponSMG1::SecondaryAttack( void )
+ {
+ 	// Only the player fires this way so we can cast
++#ifdef HL2SB
++	CHL2MP_Player *pPlayer = ToHL2MPPlayer( GetOwner() );
++#else
+ 	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
++#endif // HL2SB
+ 	
+ 	if ( pPlayer == NULL )
+ 		return;
+@@ -234,7 +257,11 @@ void CWeaponSMG1::SecondaryAttack( void )
+ 	SendWeaponAnim( ACT_VM_SECONDARYATTACK );
+ 
+ 	// player "shoot" animation
++#ifdef HL2SB
++	pPlayer->DoAnimationEvent( PLAYERANIMEVENT_ATTACK_PRIMARY );
++#else
+ 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
++#endif // HL2SB
+ 
+ 	// Decrease ammo
+ 	pPlayer->RemoveAmmo( 1, m_iSecondaryAmmoType );
+diff --git a/src/game/shared/hl2mp/weapon_stunstick.cpp b/src/game/shared/hl2mp/weapon_stunstick.cpp
+index 9f7069833..73c86b71b 100644
+--- a/src/game/shared/hl2mp/weapon_stunstick.cpp
++++ b/src/game/shared/hl2mp/weapon_stunstick.cpp
+@@ -58,7 +58,7 @@ class CWeaponStunStick : public CBaseHL2MPBludgeonWeapon
+ 	DECLARE_NETWORKCLASS(); 
+ 	DECLARE_PREDICTABLE();
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 	DECLARE_ACTTABLE();
+ #endif
+ 
+@@ -68,7 +68,9 @@ class CWeaponStunStick : public CBaseHL2MPBludgeonWeapon
+ 	virtual void			OnDataChanged( DataUpdateType_t updateType );
+ 	virtual RenderGroup_t	GetRenderGroup( void );
+ 	virtual void			ViewModelDrawn( C_BaseViewModel *pBaseViewModel );
+-	
++#ifdef HL2SB
++	virtual bool			IsTransparent( void );
++#endif // HL2SB
+ #endif
+ 
+ 	virtual void Precache();
+@@ -123,6 +125,11 @@ class CWeaponStunStick : public CBaseHL2MPBludgeonWeapon
+ 
+ 	float	m_flFadeTime;
+ 
++#ifdef HL2SB
++	//Tony; third person check thing, this has to be done for the local player if third person switches, so we can re-calc attachment points.
++	virtual void			ThirdPersonSwitch( bool bThirdPerson );
++#endif // HL2SB
++
+ #endif
+ 
+ 	CNetworkVar( bool, m_bActive );
+@@ -149,10 +156,25 @@ LINK_ENTITY_TO_CLASS( weapon_stunstick, CWeaponStunStick );
+ PRECACHE_WEAPON_REGISTER( weapon_stunstick );
+ 
+ 
+-#ifndef CLIENT_DLL
++#if !defined( CLIENT_DLL ) || defined( HL2SB )
+ 
+ acttable_t	CWeaponStunStick::m_acttable[] = 
+ {
++#ifdef HL2SB
++	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_MELEE,					false },
++	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_MELEE,			false },
++
++	{ ACT_MP_RUN,						ACT_HL2MP_RUN_MELEE,					false },
++	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_MELEE,			false },
++
++	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
++	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
++
++	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
++	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
++
++	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_MELEE,					false },
++#else
+ 	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_SLAM, true },
+ 	{ ACT_HL2MP_IDLE,					ACT_HL2MP_IDLE_MELEE,					false },
+ 	{ ACT_HL2MP_RUN,					ACT_HL2MP_RUN_MELEE,					false },
+@@ -161,6 +183,7 @@ acttable_t	CWeaponStunStick::m_acttable[] =
+ 	{ ACT_HL2MP_GESTURE_RANGE_ATTACK,	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,	false },
+ 	{ ACT_HL2MP_GESTURE_RELOAD,			ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
+ 	{ ACT_HL2MP_JUMP,					ACT_HL2MP_JUMP_MELEE,					false },
++#endif // HL2SB
+ };
+ 
+ IMPLEMENT_ACTTABLE(CWeaponStunStick);
+@@ -447,6 +470,12 @@ void CWeaponStunStick::SetStunState( bool state )
+ bool CWeaponStunStick::Deploy( void )
+ {
+ 	SetStunState( true );
++#ifdef HL2SB
++#ifdef CLIENT_DLL
++	//Tony; we need to just do this
++	SetupAttachmentPoints();
++#endif
++#endif // HL2SB
+ 
+ 	return BaseClass::Deploy();
+ }
+@@ -842,6 +871,13 @@ void C_WeaponStunStick::DrawFirstPersonEffects( void )
+ 	}
+ }
+ 
++#ifdef HL2SB
++void C_WeaponStunStick::ThirdPersonSwitch( bool bThirdPerson )
++{
++	SetupAttachmentPoints();
++}
++#endif // HL2SB
++
+ //-----------------------------------------------------------------------------
+ // Purpose: Draw our special effects
+ //-----------------------------------------------------------------------------
+@@ -872,6 +908,16 @@ void C_WeaponStunStick::ViewModelDrawn( C_BaseViewModel *pBaseViewModel )
+ 	BaseClass::ViewModelDrawn( pBaseViewModel );
+ }
+ 
++#ifdef HL2SB
++//-----------------------------------------------------------------------------
++// Purpose: We are always considered transparent
++//-----------------------------------------------------------------------------
++bool C_WeaponStunStick::IsTransparent( void )
++{
++	return true;
++}
++#endif // HL2SB
++
+ //-----------------------------------------------------------------------------
+ // Purpose: Draw a cheap glow quad at our impact point (with sparks)
+ //-----------------------------------------------------------------------------
+diff --git a/sp/src/game/server/filters.cpp b/sp/src/game/server/filters.cpp
+index 6179254dd..fbec9df12 100644
+--- a/sp/src/game/server/filters.cpp
++++ b/sp/src/game/server/filters.cpp
+@@ -372,7 +372,12 @@ class FilterDamageType : public CBaseFilter
+ 
+ 	bool PassesDamageFilterImpl(const CTakeDamageInfo &info)
+ 	{
++#ifdef HL2SB
++		//Tony; these are bitflags. check them as so.
++		return ((info.GetDamageType() & m_iDamageType) == m_iDamageType);
++#else
+ 	 	return info.GetDamageType() == m_iDamageType;
++#endif // HL2SB
+ 	}
+ 
+ 	int m_iDamageType;
