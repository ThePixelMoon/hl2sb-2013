 src/game/client/c_baseanimating.cpp                |   31 +
 src/game/client/c_baseanimating.h                  |    6 +
 src/game/client/c_baseentity.cpp                   |   67 +-
 src/game/client/c_baseentity.h                     |    8 +
 src/game/client/c_baseplayer.cpp                   |   34 +
 src/game/client/c_baseplayer.h                     |   12 +
 src/game/client/c_basetempentity.h                 |    3 +
 src/game/client/c_baseviewmodel.cpp                |    4 +-
 src/game/client/c_playerresource.cpp               |    6 +
 src/game/client/c_sceneentity.cpp                  |   56 +
 src/game/client/c_smoke_trail.cpp                  |    4 +
 src/game/client/c_te_legacytempents.cpp            |   29 +
 src/game/client/c_world.cpp                        |    9 +
 src/game/client/cdll_client_int.cpp                |  139 +
 src/game/client/classmap.cpp                       |  115 +
 src/game/client/client_hl2mp-2005.vcproj           |  567 ++-
 src/game/client/clientmode_shared.cpp              |  191 +
 src/game/client/clientmode_shared.h                |   17 +
 src/game/client/enginesprite.h                     |    3 +
 src/game/client/entity_client_tools.cpp            |   11 +
 src/game/client/game_controls/baseviewport.cpp     |   23 +
 src/game/client/hl2/c_weapon_gravitygun.cpp        |   43 +-
 src/game/client/hl2/hud_credits.cpp                |    4 +
 src/game/client/hl2/hud_weaponselection.cpp        |  380 ++
 src/game/client/hl2/vgui_rootpanel_hl2.cpp         |  114 +
 src/game/client/hl2/vgui_rootpanel_hl2.h           |   56 +
 src/game/client/hl2mp/c_hl2mp_player.cpp           |   82 +
 src/game/client/hl2mp/clientmode_hl2mpnormal.cpp   |   11 +
 src/game/client/hl2mp/clientmode_hl2mpnormal.h     |    6 +
 src/game/client/hl2mp/hud_deathnotice.cpp          |   31 +
 src/game/client/hl2mp/ui/hl2mpclientscoreboard.cpp |   33 +
 src/game/client/hud.cpp                            |   26 +
 src/game/client/hud.h                              |    3 +
 src/game/client/iclassmap.h                        |    8 +
 src/game/client/iclientmode.h                      |    6 +
 src/game/client/in_main.cpp                        |    3 +-
 src/game/client/in_mouse.cpp                       |   10 +
 src/game/client/iviewrender.h                      |    4 +
 src/game/client/lc_baseanimating.cpp               | 1051 +++++
 src/game/client/lc_baseanimating.h                 |   37 +
 src/game/client/lc_baseentity.cpp                  |  184 +
 src/game/client/lc_baseplayer.cpp                  |   42 +
 src/game/client/lc_recipientfilter.cpp             |  268 ++
 src/game/client/lc_recipientfilter.h               |   43 +
 src/game/client/lcdll_util.cpp                     |  213 +
 src/game/client/liclientshadowmgr.cpp              |   87 +
 src/game/client/lprediction.cpp                    |  127 +
 src/game/client/prediction.cpp                     |   33 +
 src/game/client/scripted_controls/lButton.cpp      |  513 +++
 src/game/client/scripted_controls/lButton.h        |   63 +
 src/game/client/scripted_controls/lCheckButton.cpp |  320 ++
 src/game/client/scripted_controls/lCheckButton.h   |   75 +
 src/game/client/scripted_controls/lFrame.cpp       |  519 +++
 src/game/client/scripted_controls/lFrame.h         |   62 +
 src/game/client/scripted_controls/lPanel.cpp       |  490 +++
 src/game/client/scripted_controls/lPanel.h         |  109 +
 .../client/scripted_controls/lPropertyDialog.cpp   |  456 ++
 .../client/scripted_controls/lPropertyDialog.h     |   88 +
 .../client/scripted_controls/lPropertyPage.cpp     |  402 ++
 src/game/client/scripted_controls/lPropertyPage.h  |   94 +
 .../scripted_controls/scriptedclientluapanel.cpp   |   71 +
 .../scripted_controls/scriptedclientluapanel.h     |   35 +
 .../scripted_controls/scriptedhudviewport.cpp      |   54 +
 .../client/scripted_controls/scriptedhudviewport.h |   32 +
 src/game/client/spritemodel.cpp                    |   28 +
 src/game/client/vgui_int.cpp                       |    9 +
 src/game/client/vgui_int.h                         |    6 +
 src/game/client/view.cpp                           |   56 +
 src/game/client/viewrender.h                       |    4 +
 src/game/server/ai_basenpc.cpp                     |   67 +-
 src/game/server/ai_basenpc_schedule.cpp            |    8 +
 src/game/server/ai_behavior_fear.cpp               |   10 +
 src/game/server/ai_behavior_follow.cpp             |   27 +
 src/game/server/ai_behavior_lead.cpp               |   40 +
 src/game/server/ai_behavior_passenger.cpp          |   14 +-
 src/game/server/ai_behavior_standoff.cpp           |   16 +
 src/game/server/ai_eventresponse.cpp               |    5 +
 src/game/server/ai_hint.cpp                        |    6 +
 src/game/server/ai_network.h                       |    4 +
 src/game/server/ai_planesolver.cpp                 |    5 +
 src/game/server/ai_playerally.cpp                  |   37 +-
 src/game/server/ai_relationship.cpp                |    4 +
 src/game/server/ai_scriptconditions.cpp            |   19 +
 src/game/server/ai_scriptconditions.h              |    4 +
 src/game/server/ai_speech.cpp                      |   18 +-
 src/game/server/ai_utils.h                         |   35 +
 src/game/server/baseanimating.cpp                  |    2 +
 src/game/server/baseanimating.h                    |    6 +
 src/game/server/basecombatcharacter.cpp            |   20 +
 src/game/server/baseentity.cpp                     |   31 +
 src/game/server/baseentity.h                       |    8 +
 src/game/server/baseflex.cpp                       |    8 +
 src/game/server/basescriptedtrigger.cpp            |  261 ++
 src/game/server/basescriptedtrigger.h              |   49 +
 src/game/server/client.cpp                         |   33 +
 src/game/server/colorcorrectionvolume.cpp          |    4 +
 src/game/server/effects.cpp                        |    4 +
 src/game/server/entitylist.cpp                     |   20 +
 src/game/server/env_zoom.cpp                       |   18 +
 src/game/server/envhudhint.cpp                     |    8 +
 src/game/server/envmessage.cpp                     |   28 +
 src/game/server/envmicrophone.cpp                  |    2 +
 .../episodic/ai_behavior_passenger_companion.cpp   |   14 +-
 src/game/server/episodic/npc_hunter.cpp            |   30 +
 src/game/server/episodic/vehicle_hl2buggy.cpp      |    5 +
 src/game/server/episodic/vehicle_jeep_episodic.cpp |   35 +
 src/game/server/episodic/weapon_striderbuster.cpp  |    5 +
 src/game/server/fogcontroller.cpp                  |   14 +
 src/game/server/gameinterface.cpp                  |  113 +
 src/game/server/gib.cpp                            |    4 +
 src/game/server/hl2/ai_behavior_actbusy.cpp        |   12 +
 src/game/server/hl2/antlion_maker.cpp              |    8 +
 src/game/server/hl2/combine_mine.cpp               |    4 +
 src/game/server/hl2/func_tank.cpp                  |   57 +-
 src/game/server/hl2/func_tank.h                    |    6 +-
 src/game/server/hl2/grenade_spit.cpp               |    4 +
 src/game/server/hl2/hl2_player.cpp                 |   13 +
 src/game/server/hl2/item_dynamic_resupply.cpp      |    4 +
 src/game/server/hl2/item_healthkit.cpp             |    8 +
 src/game/server/hl2/lhl2_player.cpp                |   51 +
 src/game/server/hl2/npc_alyx_episodic.cpp          |   67 +
 src/game/server/hl2/npc_antlion.cpp                |    4 +
 src/game/server/hl2/npc_antlionguard.cpp           |    4 +
 src/game/server/hl2/npc_attackchopper.cpp          |    4 +
 src/game/server/hl2/npc_basescanner.cpp            |    4 +
 src/game/server/hl2/npc_basezombie.cpp             |   16 +
 src/game/server/hl2/npc_citizen17.cpp              |  109 +-
 src/game/server/hl2/npc_combine.cpp                |    4 +
 src/game/server/hl2/npc_combines.cpp               |   24 +
 src/game/server/hl2/npc_dog.cpp                    |   20 +
 src/game/server/hl2/npc_enemyfinder.cpp            |    8 +
 src/game/server/hl2/npc_headcrab.cpp               |   22 +-
 src/game/server/hl2/npc_metropolice.cpp            |   30 +-
 src/game/server/hl2/npc_playercompanion.cpp        |   62 +-
 src/game/server/hl2/npc_scanner.cpp                |    4 +
 src/game/server/hl2/npc_strider.cpp                |    8 +
 src/game/server/hl2/npc_turret_floor.cpp           |    4 +
 src/game/server/hl2/npc_vortigaunt_episodic.cpp    |   24 +-
 src/game/server/hl2/npc_zombine.cpp                |   16 +
 src/game/server/hl2/proto_sniper.cpp               |   36 +-
 src/game/server/hl2/script_intro.cpp               |    4 +
 src/game/server/hl2/vehicle_airboat.cpp            |    4 +
 src/game/server/hl2/vehicle_jeep.cpp               |   16 +-
 src/game/server/hl2mp/hl2mp_bot_temp.cpp           |    3 +-
 src/game/server/hl2mp/hl2mp_client.cpp             |   18 +-
 src/game/server/hl2mp/hl2mp_player.cpp             |  280 ++
 src/game/server/item_world.cpp                     |    6 +
 src/game/server/lbaseanimating.cpp                 |  564 +++
 src/game/server/lbaseanimating.h                   |   35 +
 src/game/server/lbaseentity.cpp                    |  783 ++++
 src/game/server/lbaseentity.h                      |   17 +
 src/game/server/lentitylist.cpp                    |  200 +
 src/game/server/lplayer.cpp                        |  609 +++
 src/game/server/lrecipientfilter.cpp               |  292 ++
 src/game/server/lrecipientfilter.h                 |   43 +
 src/game/server/lutil.cpp                          |  521 +++
 src/game/server/lutil.h                            |   16 +
 src/game/server/message_entity.cpp                 |    4 +
 src/game/server/monstermaker.cpp                   |    4 +
 src/game/server/npc_talker.cpp                     |   15 +
 src/game/server/physconstraint.cpp                 |    4 +
 src/game/server/physgun.cpp                        |  136 +-
 src/game/server/physics_npc_solver.cpp             |    4 +
 src/game/server/physics_prop_ragdoll.cpp           |    4 +
 src/game/server/player.cpp                         |   88 +-
 src/game/server/player.h                           |   24 +
 src/game/server/player_pickup.cpp                  |    4 +
 src/game/server/sceneentity.cpp                    |  172 +
 src/game/server/server_hl2mp-2005.vcproj           |  529 ++-
 src/game/server/test_stressentities.cpp            |    4 +
 src/game/server/ticketfix.cpp                      |   79 +
 src/game/server/ticketfix.h                        |   15 +
 src/game/server/triggers.cpp                       |   55 +
 src/game/server/util.cpp                           |   90 +
 src/game/server/util.h                             |   23 +
 src/game/server/vehicle_choreo_generic.cpp         |    8 +
 src/game/server/world.cpp                          |   17 +
 src/game/shared/activitylist.cpp                   |    4 +
 src/game/shared/activitylist.h                     |    5 +
 src/game/shared/basecombatweapon_shared.cpp        |   17 +-
 src/game/shared/basecombatweapon_shared.h          |   14 +
 src/game/shared/baseentity_shared.cpp              |    2 +-
 src/game/shared/basegrenade_shared.h               |    3 +-
 src/game/shared/baseplayer_shared.cpp              |   32 +
 src/game/shared/basescripted.cpp                   |  304 ++
 src/game/shared/basescripted.h                     |   74 +
 src/game/shared/baseviewmodel_shared.cpp           |    7 +
 src/game/shared/gamerules.cpp                      |    7 +
 src/game/shared/gamerules.h                        |    8 +
 src/game/shared/hl2/hl2_gamerules.cpp              |   23 +
 src/game/shared/hl2/hl2_gamerules.h                |    8 +
 src/game/shared/hl2/hl_gamemovement.cpp            |   29 +
 src/game/shared/hl2/survival_gamerules.cpp         |   21 +
 src/game/shared/hl2mp/hl2mp_gamerules.cpp          | 1575 ++++++-
 src/game/shared/hl2mp/hl2mp_gamerules.h            |   57 +
 src/game/shared/hl2mp/hl2mp_player_shared.cpp      |   17 +
 src/game/shared/hl2mp/hl2mp_playeranimstate.cpp    |   39 +
 src/game/shared/hl2mp/hl2mp_playeranimstate.h      |   15 +
 src/game/shared/hl2mp/lhl2mp_player_shared.cpp     |  255 ++
 src/game/shared/hl2mp/lhl2mp_player_shared.h       |   42 +
 src/game/shared/hl2mp/weapon_ar2.cpp               |  259 ++
 src/game/shared/hl2mp/weapon_ar2.h                 |   15 +
 src/game/shared/hl2mp/weapon_crowbar.cpp           |    5 +
 src/game/shared/hl2mp/weapon_hl2mpbase.h           |    6 +
 .../shared/hl2mp/weapon_hl2mpbase_machinegun.h     |    8 +
 .../hl2mp/weapon_hl2mpbase_scriptedweapon.cpp      | 1022 +++++
 .../shared/hl2mp/weapon_hl2mpbase_scriptedweapon.h |  113 +
 .../shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp  |   28 +
 .../shared/hl2mp/weapon_hl2mpbasebasebludgeon.h    |    6 +
 src/game/shared/hl2mp/weapon_physcannon.cpp        |  102 +
 src/game/shared/hl2mp/weapon_physgun.cpp           | 1456 +++++++
 src/game/shared/hl2mp/weapon_physgun_argg.cpp      | 1331 ++++++
 src/game/shared/hl2mp/weapon_physgun_valve.cpp     | 1188 ++++++
 src/game/shared/hl2mp/weapon_pistol.cpp            |  114 +
 src/game/shared/hl2mp/weapon_rpg.cpp               |  244 ++
 src/game/shared/hl2mp/weapon_rpg.h                 |   39 +
 src/game/shared/hl2mp/weapon_shotgun.cpp           |  277 ++
 src/game/shared/hl2mp/weapon_smg1.cpp              |  330 ++
 src/game/shared/hl2mp/weapon_stunstick.cpp         |   49 +-
 src/game/shared/lbasecombatweapon_shared.cpp       | 1117 +++++
 src/game/shared/lbasecombatweapon_shared.h         |   35 +
 src/game/shared/lbaseentity_shared.cpp             | 1747 ++++++++
 src/game/shared/lbaseentity_shared.h               |   38 +
 src/game/shared/lbaseplayer_shared.cpp             | 1065 +++++
 src/game/shared/lbaseplayer_shared.h               |   38 +
 src/game/shared/leffect_dispatch_data.cpp          |  211 +
 src/game/shared/leffect_dispatch_data.h            |   37 +
 src/game/shared/limovehelper.cpp                   |  136 +
 src/game/shared/limovehelper.h                     |   38 +
 src/game/shared/lin_buttons.cpp                    |   48 +
 src/game/shared/lipredictionsystem.cpp             |   43 +
 src/game/shared/lshareddefs.cpp                    |  129 +
 src/game/shared/lshareddefs.h                      |   32 +
 src/game/shared/lsrcinit.cpp                       |  119 +
 src/game/shared/ltakedamageinfo.cpp                |  371 ++
 src/game/shared/ltakedamageinfo.h                  |   37 +
 src/game/shared/luacachefile.cpp                   |  358 ++
 src/game/shared/luacachefile.h                     |   31 +
 src/game/shared/luamanager.cpp                     |  821 ++++
 src/game/shared/luamanager.h                       |  341 ++
 src/game/shared/luasrclib.h                        |  194 +
 src/game/shared/lutil_shared.cpp                   |  190 +
 src/game/shared/mountaddons.cpp                    |   73 +
 src/game/shared/mountaddons.h                      |   16 +
 src/game/shared/mountsteamcontent.cpp              |  194 +
 src/game/shared/mountsteamcontent.h                |   21 +
 src/game/shared/multiplay_gamerules.cpp            |   48 +
 src/game/shared/multiplay_gamerules.h              |    9 +
 src/game/shared/takedamageinfo.h                   |   18 +
 src/game/shared/teamplay_gamerules.cpp             |   46 +
 src/game/shared/teamplay_gamerules.h               |    8 +
 src/game/shared/util_shared.cpp                    |    5 +
 src/game/shared/voice_status.cpp                   |   12 +
 src/public/XUnzip_src.cpp                          | 4369 ++++++++++++++++++++
 src/public/cdll_int.h                              |    5 -
 src/public/client_class.h                          |   19 +
 src/public/engine/livdebugoverlay.cpp              |  108 +
 src/public/gametrace.h                             |    4 +
 src/public/lColor.cpp                              |  150 +
 src/public/lColor.h                                |   37 +
 src/public/lbspflags.cpp                           |  127 +
 src/public/lcdll_int.cpp                           |  541 +++
 src/public/lcmodel.h                               |   36 +
 src/public/leiface.cpp                             |  347 ++
 src/public/lfilesystem.cpp                         |  425 ++
 src/public/lfilesystem.h                           |   37 +
 src/public/lgametrace.cpp                          |  212 +
 src/public/lgametrace.h                            |   37 +
 src/public/lglobalvars_base.cpp                    |   97 +
 src/public/licvar.cpp                              |  107 +
 src/public/licvar.h                                |   15 +
 src/public/lienginevgui.cpp                        |   52 +
 src/public/linetchannelinfo.cpp                    |  249 ++
 src/public/linetchannelinfo.h                      |   44 +
 src/public/lnetworkstringtabledefs.cpp             |  206 +
 src/public/lnetworkstringtabledefs.h               |   38 +
 src/public/lvphysics_interface.cpp                 | 1204 ++++++
 src/public/lvphysics_interface.h                   |   61 +
 src/public/materialsystem/limaterial.cpp           |  360 ++
 src/public/materialsystem/limaterial.h             |   38 +
 src/public/mathlib/lmathlib.cpp                    |  200 +
 src/public/mathlib/lmathlib.h                      |   37 +
 src/public/mathlib/lvector.cpp                     |  463 +++
 src/public/mathlib/lvector.h                       |   50 +
 src/public/mathlib/lvmatrix.cpp                    |  645 +++
 src/public/mathlib/lvmatrix.h                      |   56 +
 .../lisoundemittersystembase.cpp                   |  100 +
 .../soundemittersystem/lisoundemittersystembase.h  |   32 +
 src/public/steam/listeamfriends.cpp                |  115 +
 src/public/steam/listeamfriends.h                  |   38 +
 src/public/steam/lsteam_api.cpp                    |   37 +
 src/public/tier0/ldbg.cpp                          |  168 +
 src/public/tier1/LKeyValues.cpp                    |  399 ++
 src/public/tier1/LKeyValues.h                      |   39 +
 src/public/tier1/lconvar.cpp                       |  489 +++
 src/public/tier1/lconvar.h                         |   54 +
 src/public/tier1/liconvar.cpp                      |   55 +
 src/public/trace.h                                 |    4 +
 src/public/vgui/LIInput.cpp                        |  342 ++
 src/public/vgui/LIScheme.cpp                       |  191 +
 src/public/vgui/LIScheme.h                         |   38 +
 src/public/vgui/LISurface.cpp                      |  607 +++
 src/public/vgui/LVGUI.cpp                          |  129 +
 src/public/vgui/LVGUI.h                            |   44 +
 src/public/vgui_controls/lControls.h               |   66 +
 src/public/vgui_controls/lEditablePanel.cpp        |  321 ++
 src/public/vgui_controls/lEditablePanel.h          |   41 +
 src/public/vgui_controls/lPanel.cpp                | 1325 ++++++
 src/public/vgui_controls/lPanel.h                  |   45 +
 src/public/vgui_controls/lvgui_controls.cpp        |   29 +
 src/public/vgui_controls/phandle.h                 |    2 +
 src/public/vgui_controls/propertydialog.h          |    4 +
 src/public/vphysics/lperformance.cpp               |   88 +
 src/public/vphysics/lperformance.h                 |   34 +
 src/public/vstdlib/lrandom.cpp                     |   97 +
 src/public/zip_utils_src.cpp                       | 1663 ++++++++
 316 files changed, 47621 insertions(+), 221 deletions(-)

diff --git a/src/game/client/c_baseanimating.cpp b/src/game/client/c_baseanimating.cpp
index 2697c3c..172ed9b 100644
--- a/src/game/client/c_baseanimating.cpp
+++ b/src/game/client/c_baseanimating.cpp
@@ -3490,6 +3490,36 @@ void C_BaseAnimating::FireEvent( const Vector& origin, const QAngle& angles, int
 
 	// Eject brass
 	case CL_EVENT_EJECTBRASS1:
+#if defined ( HL2SB )
+		{
+			// Check if we're a weapon, if we belong to the local player, and if the local player is in third person - if all are true, don't do a muzzleflash in this instance, because
+			// we're using the view models dispatch for smoothness.
+			if ( dynamic_cast< C_BaseCombatWeapon *>(this) != NULL )
+			{
+				C_BaseCombatWeapon *pWeapon = dynamic_cast< C_BaseCombatWeapon *>(this);
+				if ( pWeapon && pWeapon->GetOwner() == C_BasePlayer::GetLocalPlayer() && ::input->CAM_IsThirdPerson() )
+					break;
+			}
+			
+			if ( ( prediction->InPrediction() && !prediction->IsFirstTimePredicted() ) )
+				break;
+
+			if ( m_Attachments.Count() > 0 )
+			{
+				if ( MainViewOrigin().DistToSqr( GetAbsOrigin() ) < (256 * 256) )
+				{
+					Vector attachOrigin;
+					QAngle attachAngles; 
+					
+					if( GetAttachment( 2, attachOrigin, attachAngles ) )
+					{
+						tempents->EjectBrass( attachOrigin, attachAngles, GetAbsAngles(), atoi( options ) );
+					}
+				}
+			}
+			break;
+		}
+#else
 		if ( m_Attachments.Count() > 0 )
 		{
 			if ( MainViewOrigin().DistToSqr( GetAbsOrigin() ) < (256 * 256) )
@@ -3504,6 +3534,7 @@ void C_BaseAnimating::FireEvent( const Vector& origin, const QAngle& angles, int
 			}
 		}
 		break;
+#endif
 
 	case AE_MUZZLEFLASH:
 		{
diff --git a/src/game/client/c_baseanimating.h b/src/game/client/c_baseanimating.h
index 8476583..93c2a3c 100644
--- a/src/game/client/c_baseanimating.h
+++ b/src/game/client/c_baseanimating.h
@@ -529,10 +529,16 @@ private:
 	CInterpolatedVarArray< float, MAXSTUDIOBONECTRLS >		m_iv_flEncodedController;
 	float							m_flOldEncodedController[MAXSTUDIOBONECTRLS];
 
+#ifdef HL2SB
+public:
+#endif
 	// Clientside animation
 	bool							m_bClientSideAnimation;
 	bool							m_bLastClientSideFrameReset;
 
+#ifdef HL2SB
+private:
+#endif
 	int								m_nNewSequenceParity;
 	int								m_nResetEventsParity;
 
diff --git a/src/game/client/c_baseentity.cpp b/src/game/client/c_baseentity.cpp
index 8d94e4b..45a5497 100644
--- a/src/game/client/c_baseentity.cpp
+++ b/src/game/client/c_baseentity.cpp
@@ -40,6 +40,10 @@
 #include "decals.h"
 #include "cdll_bounded_cvars.h"
 #include "inetchannelinfo.h"
+#ifdef LUA_SDK
+#include "luamanager.h"
+#include "mathlib/lvector.h"
+#endif
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
@@ -939,6 +943,10 @@ C_BaseEntity::C_BaseEntity() :
 #endif
 
 	ParticleProp()->Init( this );
+
+#if defined( LUA_SDK )
+	m_nTableReference = LUA_NOREF;
+#endif
 }
 
 
@@ -956,6 +964,9 @@ C_BaseEntity::~C_BaseEntity()
 #endif
 	RemoveFromInterpolationList();
 	RemoveFromTeleportList();
+#if defined( LUA_SDK )
+	lua_unref( L, m_nTableReference );
+#endif
 }
 
 void C_BaseEntity::Clear( void )
@@ -1550,11 +1561,43 @@ int C_BaseEntity::GetSoundSourceIndex() const
 //-----------------------------------------------------------------------------
 const Vector& C_BaseEntity::GetRenderOrigin( void )
 {
+#ifdef LUA_SDK
+	if ( m_nTableReference != LUA_NOREF )
+	{
+		lua_getref( L, m_nTableReference );
+		lua_getfield( L, -1, "m_vecRenderOrigin" );
+		lua_remove( L, -2 );
+		if ( lua_isuserdata( L, -1 ) && luaL_checkudata( L, -1, "Vector" ) )
+		{
+			const Vector& res = luaL_checkvector( L, -1 );
+			lua_pop( L, 1 );
+			return res;
+		}
+		lua_pop( L, 1 );
+	}
+#endif
+
 	return GetAbsOrigin();
 }
 
 const QAngle& C_BaseEntity::GetRenderAngles( void )
 {
+#ifdef LUA_SDK
+	if ( m_nTableReference != LUA_NOREF )
+	{
+		lua_getref( L, m_nTableReference );
+		lua_getfield( L, -1, "m_angRenderAngles" );
+		lua_remove( L, -2 );
+		if ( lua_isuserdata( L, -1 ) && luaL_checkudata( L, -1, "QAngle" ) )
+		{
+			const QAngle& res = luaL_checkangle( L, -1 );
+			lua_pop( L, 1 );
+			return res;
+		}
+		lua_pop( L, 1 );
+	}
+#endif
+
 	return GetAbsAngles();
 }
 
@@ -1629,7 +1672,9 @@ void C_BaseEntity::GetShadowRenderBounds( Vector &mins, Vector &maxs, ShadowType
 //-----------------------------------------------------------------------------
 const Vector& C_BaseEntity::GetAbsOrigin( void ) const
 {
+#ifndef HL2SB
 	Assert( s_bAbsQueriesValid );
+#endif
 	const_cast<C_BaseEntity*>(this)->CalcAbsolutePosition();
 	return m_vecAbsOrigin;
 }
@@ -1641,7 +1686,9 @@ const Vector& C_BaseEntity::GetAbsOrigin( void ) const
 //-----------------------------------------------------------------------------
 const QAngle& C_BaseEntity::GetAbsAngles( void ) const
 {
+#ifndef HL2SB
 	Assert( s_bAbsQueriesValid );
+#endif
 	const_cast<C_BaseEntity*>(this)->CalcAbsolutePosition();
 	return m_angAbsRotation;
 }
@@ -4557,6 +4604,13 @@ const char *C_BaseEntity::GetClassname( void )
 	static char outstr[ 256 ];
 	outstr[ 0 ] = 0;
 	bool gotname = false;
+#if defined ( LUA_SDK )
+	if ( m_iClassname && m_iClassname[ 0 ] )
+	{
+		Q_snprintf( outstr, sizeof( outstr ), "%s", m_iClassname );
+		gotname = true;
+	}
+#endif
 #ifndef NO_ENTITY_PREDICTION
 	if ( GetPredDescMap() )
 	{
@@ -5652,14 +5706,11 @@ float C_BaseEntity::GetInterpolationAmount( int flags )
 		return TICK_INTERVAL * serverTickMultiple;
 	}
 
-	// Always fully interpolate during multi-player or during demo playback, if the recorded
-	// demo was recorded locally.
-	const bool bPlayingDemo = engine->IsPlayingDemo();
-	const bool bPlayingMultiplayer = !bPlayingDemo && ( gpGlobals->maxClients > 1 );
-	const bool bPlayingNonLocallyRecordedDemo = bPlayingDemo && !engine->IsPlayingDemoALocallyRecordedDemo();
-	if ( bPlayingMultiplayer || bPlayingNonLocallyRecordedDemo )
+	// Always fully interpolate during multi-player or during demo playback...
+	if ( ( gpGlobals->maxClients > 1 ) || 
+		engine->IsPlayingDemo() )
 	{
-		return AdjustInterpolationAmount( this, TICKS_TO_TIME( TIME_TO_TICKS( GetClientInterpAmount() ) + serverTickMultiple ) );
+		return AdjustInterpolationAmount( this, TICKS_TO_TIME ( TIME_TO_TICKS( GetClientInterpAmount() ) + serverTickMultiple ) );
 	}
 
 	int expandedServerTickMultiple = serverTickMultiple;
@@ -5682,7 +5733,7 @@ float C_BaseEntity::GetInterpolationAmount( int flags )
 		return TICK_INTERVAL * expandedServerTickMultiple;
 	}
 
-	return AdjustInterpolationAmount( this, TICKS_TO_TIME( TIME_TO_TICKS( GetClientInterpAmount() ) + serverTickMultiple ) );
+	return AdjustInterpolationAmount( this, TICK_INTERVAL * ( TIME_TO_TICKS( GetClientInterpAmount() ) +  serverTickMultiple ) );
 }
 
 
diff --git a/src/game/client/c_baseentity.h b/src/game/client/c_baseentity.h
index e7e9f1c..4276242 100644
--- a/src/game/client/c_baseentity.h
+++ b/src/game/client/c_baseentity.h
@@ -1616,6 +1616,14 @@ public:
 	bool							m_bEnableRenderingClipPlane; //true to use the custom clip plane when drawing
 	float *							GetRenderClipPlane( void ); // Rendering clip plane, should be 4 floats, return value of NULL indicates a disabled render clip plane
 
+#if defined( LUA_SDK )
+	// Andrew; This is used to determine an entity's reference in Lua's LUA_REGISTRYINDEX.
+	// I'd rather do this than create a struct and pass that to each bounded function, plus it'll save some perf for massive executions, like Think funcs.
+	int								m_nTableReference;
+	// Henry; There's an IsPlayer and IsWorld and such, why not an IsWeapon?
+	virtual bool					IsWeapon( void ) const { return false; }
+#endif
+
 protected:
 
 	void AddToInterpolationList();
diff --git a/src/game/client/c_baseplayer.cpp b/src/game/client/c_baseplayer.cpp
index 29ac38d..48761c3 100644
--- a/src/game/client/c_baseplayer.cpp
+++ b/src/game/client/c_baseplayer.cpp
@@ -39,6 +39,9 @@
 #include "vgui/isurface.h"
 #include "voice_status.h"
 #include "fx.h"
+#ifdef LUA_SDK
+#include "luamanager.h"
+#endif
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
@@ -206,6 +209,13 @@ END_RECV_TABLE()
 
 		RecvPropVector		( RECVINFO( m_vecBaseVelocity ) ),
 
+#ifdef ARGG
+		// adnan
+		// get the use angles
+		RecvPropVector		( RECVINFO( m_vecUseAngles ) ),
+		// end adnan
+#endif
+
 		RecvPropEHandle		( RECVINFO( m_hConstraintEntity)),
 		RecvPropVector		( RECVINFO( m_vecConstraintCenter) ),
 		RecvPropFloat		( RECVINFO( m_flConstraintRadius )),
@@ -248,6 +258,13 @@ END_RECV_TABLE()
 		RecvPropFloat	(RECVINFO(m_flMaxspeed)),
 		RecvPropInt		(RECVINFO(m_fFlags)),
 
+#ifdef ARGG
+		// adnan
+		// get the use angles
+		RecvPropVector		( RECVINFO( m_vecUseAngles ) ),
+		// end adnan
+#endif
+
 
 		RecvPropInt		(RECVINFO(m_iObserverMode) ),
 		RecvPropEHandle	(RECVINFO(m_hObserverTarget), RecvProxy_ObserverTarget ),
@@ -1193,6 +1210,23 @@ void C_BasePlayer::CreateWaterEffects( void )
 //-----------------------------------------------------------------------------
 void C_BasePlayer::OverrideView( CViewSetup *pSetup )
 {
+#ifdef ARGG
+	// adnan
+	// OVERRIDING THE VIEW
+	// need to override the angles too
+	C_BaseCombatWeapon *pWeapon = GetActiveWeapon();
+	if ( pWeapon )
+	{
+		// adnan
+		if(pWeapon->OverrideViewAngles()) {
+			// use the useAngles!
+				// override with the angles the server sends to us as useAngles
+				// use the useAngles only if we're holding and rotating with the grav gun
+			pSetup->angles = m_vecUseAngles;
+		}
+	}
+	// end adnan
+#endif
 }
 
 bool C_BasePlayer::ShouldInterpolate()
diff --git a/src/game/client/c_baseplayer.h b/src/game/client/c_baseplayer.h
index 5e5e4d8..0bbef03 100644
--- a/src/game/client/c_baseplayer.h
+++ b/src/game/client/c_baseplayer.h
@@ -392,6 +392,14 @@ public:
 
 	CUserCmd		*m_pCurrentCommand;
 
+#ifdef ARGG
+	// adnan
+	// store the use angles
+	// set when the player presses use
+	QAngle		m_vecUseAngles;
+	// end adnan
+#endif
+
 	// Movement constraints
 	EHANDLE			m_hConstraintEntity;
 	Vector			m_vecConstraintCenter;
@@ -562,7 +570,11 @@ protected:
 	byte			m_ubEFNoInterpParity;
 	byte			m_ubOldEFNoInterpParity;
 
+#if !defined( LUA_SDK )
 private:
+#else
+public:
+#endif
 
 	struct StepSoundCache_t
 	{
diff --git a/src/game/client/c_basetempentity.h b/src/game/client/c_basetempentity.h
index e0a7548..21b4f37 100644
--- a/src/game/client/c_basetempentity.h
+++ b/src/game/client/c_basetempentity.h
@@ -70,6 +70,9 @@ public:
 	void NetworkStateChanged() {}
 	void NetworkStateChanged( void *pVar ) {}
 
+	// Dummy for scripted weapons.
+	void SetClassname( const char *classname ) {}
+
 	virtual bool					Init(int entnum, int iSerialNum);
 
 	virtual void					Precache( void );
diff --git a/src/game/client/c_baseviewmodel.cpp b/src/game/client/c_baseviewmodel.cpp
index 27b0ff3..666a6fa 100644
--- a/src/game/client/c_baseviewmodel.cpp
+++ b/src/game/client/c_baseviewmodel.cpp
@@ -23,7 +23,7 @@
 #include "tier0/memdbgon.h"
 
 //Tony; modified so that the sdk view models are right handed out of the box.
-#if defined( CSTRIKE_DLL ) || defined( SDK_DLL )
+#if defined( CSTRIKE_DLL ) || defined( SDK_DLL ) || defined( LUA_SDK )
 	ConVar cl_righthand( "cl_righthand", "1", FCVAR_ARCHIVE, "Use right-handed view models." );
 #endif
 
@@ -175,7 +175,7 @@ bool C_BaseViewModel::Interpolate( float currentTime )
 inline bool C_BaseViewModel::ShouldFlipViewModel()
 {
 //Tony; changed for SDK so that the CSS models can be flipped out of the box.
-#if defined( CSTRIKE_DLL ) || defined ( SDK_DLL )
+#if defined( CSTRIKE_DLL ) || defined ( SDK_DLL ) || defined ( LUA_SDK )
 	//Tony; move this up here.
 	if (!cl_righthand.GetBool())
 		return false;
diff --git a/src/game/client/c_playerresource.cpp b/src/game/client/c_playerresource.cpp
index 06b6be5..7a18dbb 100644
--- a/src/game/client/c_playerresource.cpp
+++ b/src/game/client/c_playerresource.cpp
@@ -128,7 +128,10 @@ const char *C_PlayerResource::GetPlayerName( int iIndex )
 {
 	if ( iIndex < 1 || iIndex > MAX_PLAYERS )
 	{
+		// Andrew; In HL2SB, we could be an NPC calling into this code
+#ifndef HL2SB
 		Assert( false );
+#endif
 		return "ERRORNAME";
 	}
 	
@@ -155,7 +158,10 @@ int C_PlayerResource::GetTeam(int iIndex )
 {
 	if ( iIndex < 1 || iIndex > MAX_PLAYERS )
 	{
+		// Andrew; In HL2SB, we could be an NPC calling into this code
+#ifndef HL2SB
 		Assert( false );
+#endif
 		return 0;
 	}
 	else
diff --git a/src/game/client/c_sceneentity.cpp b/src/game/client/c_sceneentity.cpp
index 8a349e2..0ff9283 100644
--- a/src/game/client/c_sceneentity.cpp
+++ b/src/game/client/c_sceneentity.cpp
@@ -744,6 +744,61 @@ public:
 };
 CChoreoStringPool g_ChoreoStringPool;
 
+#ifdef HL2SB
+//Andrew; See https://developer.valvesoftware.com/wiki/Scenes.image
+CChoreoScene *C_SceneEntity::LoadScene( const char *filename )
+{
+	char loadfile[MAX_PATH];
+	Q_strncpy( loadfile, filename, sizeof( loadfile ) );
+	Q_SetExtension( loadfile, ".vcd", sizeof( loadfile ) );
+	Q_FixSlashes( loadfile );
+ 
+	void *pBuffer = 0;
+	CChoreoScene *pScene = NULL;
+ 
+	int fileSize = filesystem->ReadFileEx( loadfile, "GAME", &pBuffer, true );
+	if (fileSize)
+	{
+		g_TokenProcessor.SetBuffer((char*)pBuffer);
+		pScene = ChoreoLoadScene( loadfile, this, &g_TokenProcessor, Scene_Printf );
+	}
+	else
+	{
+		fileSize = scenefilecache->GetSceneBufferSize( loadfile );
+		if ( fileSize <= 0 )
+			return NULL;
+ 
+		pBuffer = new char[ fileSize ];
+		if ( !scenefilecache->GetSceneData( filename, (byte *)pBuffer, fileSize ) )
+		{
+			delete[] pBuffer;
+			return NULL;
+		}
+ 
+ 
+		if ( IsBufferBinaryVCD( (char*)pBuffer, fileSize ) )
+		{
+			pScene = new CChoreoScene( this );
+			CUtlBuffer buf( pBuffer, fileSize, CUtlBuffer::READ_ONLY );
+			if ( !pScene->RestoreFromBinaryBuffer( buf, loadfile, &g_ChoreoStringPool ) )
+			{
+				Warning( "Unable to restore scene '%s'\n", loadfile );
+				delete pScene;
+				pScene = NULL;
+			}
+		}
+	}
+ 
+	if(pScene)
+	{
+		pScene->SetPrintFunc( Scene_Printf );
+		pScene->SetEventCallbackInterface( this );
+	}
+ 
+	delete[] pBuffer;
+	return pScene;
+}
+#else
 CChoreoScene *C_SceneEntity::LoadScene( const char *filename )
 {
 	char loadfile[ 512 ];
@@ -789,6 +844,7 @@ CChoreoScene *C_SceneEntity::LoadScene( const char *filename )
 	delete[] pBuffer;
 	return pScene;
 }
+#endif
 
 
 //-----------------------------------------------------------------------------
diff --git a/src/game/client/c_smoke_trail.cpp b/src/game/client/c_smoke_trail.cpp
index 16ef392..e6edb88 100644
--- a/src/game/client/c_smoke_trail.cpp
+++ b/src/game/client/c_smoke_trail.cpp
@@ -317,7 +317,11 @@ void C_SmokeTrail::Update( float fTimeDelta )
 		pParticle->m_vecVelocity.Random( -1.0f, 1.0f );
 		pParticle->m_vecVelocity *= random->RandomFloat( m_MinSpeed, m_MaxSpeed );
 
+		// Andrew; taking this out again fixes the smoke bug with the SMG
+		// grenade. Why was this needed in the first place?
+#ifndef HL2SB
 		pParticle->m_vecVelocity = pParticle->m_vecVelocity + GetAbsVelocity();
+#endif
 		
 		float flDirectedVel = random->RandomFloat( m_MinDirectedSpeed, m_MaxDirectedSpeed );
 		VectorMA( pParticle->m_vecVelocity, flDirectedVel, vecForward, pParticle->m_vecVelocity );
diff --git a/src/game/client/c_te_legacytempents.cpp b/src/game/client/c_te_legacytempents.cpp
index fbd6a6f..569589d 100644
--- a/src/game/client/c_te_legacytempents.cpp
+++ b/src/game/client/c_te_legacytempents.cpp
@@ -33,6 +33,12 @@
 #include "engine/IVDebugOverlay.h"
 #include "effect_dispatch_data.h"
 #include "c_te_effect_dispatch.h"
+#ifdef LUA_SDK
+#include "weapon_hl2mpbase_scriptedweapon.h"
+#include "luamanager.h"
+#include "lbasecombatweapon_shared.h"
+#include "mathlib/lvector.h"
+#endif
 
 // NOTE: Always include this last!
 #include "tier0/memdbgon.h"
@@ -1793,6 +1799,29 @@ void CTempEnts::MuzzleFlash( const Vector& pos1, const QAngle& angles, int type,
 
 #else
 
+#if defined ( LUA_SDK )
+	CBasePlayer *pPlayer = dynamic_cast<CBasePlayer *>((CBaseEntity*)hEntity.Get());
+	if ( pPlayer != NULL )
+	{
+		CBaseCombatWeapon *pWeapon = dynamic_cast<CHL2MPScriptedWeapon *>(pPlayer->GetActiveWeapon());
+
+		if ( pWeapon != NULL )
+		{
+			Vector pos = pos1;
+			QAngle ang = angles;
+
+			BEGIN_LUA_CALL_WEAPON_HOOK( "MuzzleFlash", pWeapon );
+				lua_pushvector( L, pos );
+				lua_pushangle( L, ang );
+				lua_pushinteger( L, type );
+				lua_pushboolean( L, firstPerson );
+			END_LUA_CALL_WEAPON_HOOK( 4, 1 );
+
+			RETURN_LUA_NONE();
+		}
+	}
+#endif
+
 	//NOTENOTE: This function is becoming obsolete as the muzzles are moved over to being local to attachments
 
 	switch ( type )
diff --git a/src/game/client/c_world.cpp b/src/game/client/c_world.cpp
index e8fbf79..1e896c4 100644
--- a/src/game/client/c_world.cpp
+++ b/src/game/client/c_world.cpp
@@ -13,6 +13,9 @@
 #include "ivieweffects.h"
 #include "shake.h"
 #include "eventlist.h"
+#ifdef LUA_SDK
+#include "luamanager.h"
+#endif
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -122,7 +125,13 @@ void C_World::OnDataChanged( DataUpdateType_t updateType )
 
 void C_World::RegisterSharedActivities( void )
 {
+#ifdef LUA_SDK
+	// BEGIN_LUA_SET_ENUM_LIBRARY( "Activity" );
+#endif
 	ActivityList_RegisterSharedActivities();
+#ifdef LUA_SDK
+	// END_LUA_SET_ENUM_LIBRARY();
+#endif
 	EventList_RegisterSharedEvents();
 }
 
diff --git a/src/game/client/cdll_client_int.cpp b/src/game/client/cdll_client_int.cpp
index 03f8ef7..220cab9 100644
--- a/src/game/client/cdll_client_int.cpp
+++ b/src/game/client/cdll_client_int.cpp
@@ -94,6 +94,23 @@
 #include "matsys_controls/matsyscontrols.h"
 #include "GameStats.h"
 
+#ifdef LUA_SDK
+#include "luamanager.h"
+#include "luacachefile.h"
+#include "mountaddons.h"
+#endif
+
+#ifdef HL2SB
+#include "mountsteamcontent.h"
+#ifdef _WIN32
+// HACKHACK: this is dumb, and unsafe. Things that should be uninitialized at the
+// engine-level can kiss their deconstructors goodbye. See Shutdown for an
+// explanation.
+DLL_IMPORT BOOL STDCALL TerminateProcess(HANDLE hProcess, unsigned int uExitCode);
+DLL_IMPORT HANDLE STDCALL GetCurrentProcess(void);
+#endif
+#endif
+
 #ifdef PORTAL
 #include "PortalRender.h"
 #endif
@@ -132,6 +149,7 @@ ISceneFileCache *scenefilecache = NULL;
 IXboxSystem *xboxsystem = NULL;	// Xbox 360 only
 IMatchmaking *matchmaking = NULL;
 IAvi *avi = NULL;
+IBik *bik = NULL;
 IUploadGameStats *gamestatsuploader = NULL;
 
 
@@ -326,6 +344,24 @@ public:
 	virtual void GetPlayerTextColor(int entindex, int color[3])
 	{
 		color[0] = color[1] = color[2] = 128;
+
+#if defined ( LUA_SDK )
+		BEGIN_LUA_CALL_HOOK( "GetPlayerTextColor" );
+			lua_pushinteger( L, entindex );
+			lua_pushinteger( L, color[0] );
+			lua_pushinteger( L, color[1] );
+			lua_pushinteger( L, color[2] );
+		END_LUA_CALL_HOOK( 4, 3 );
+
+		if ( lua_isnumber( L, -3 ) )
+			color[2] = (int)lua_tointeger( L, -3 );
+		if ( lua_isnumber( L, -2 ) )
+			color[1] = (int)lua_tointeger( L, -2 );
+		if ( lua_isnumber( L, -1 ) )
+			color[0] = (int)lua_tointeger( L, -1 );
+
+		lua_pop( L, 3 );
+#endif
 	}
 
 	virtual void UpdateCursorState()
@@ -334,6 +370,13 @@ public:
 
 	virtual bool			CanShowSpeakerLabels()
 	{
+#if defined ( LUA_SDK )
+		BEGIN_LUA_CALL_HOOK( "CanShowSpeakerLabels" );
+		END_LUA_CALL_HOOK( 0, 1 );
+
+		RETURN_LUA_BOOLEAN();
+#endif
+
 		return true;
 	}
 };
@@ -446,6 +489,7 @@ public:
 
 	virtual int						Init( CreateInterfaceFn appSystemFactory, CreateInterfaceFn physicsFactory, CGlobalVarsBase *pGlobals );
 
+	virtual bool					GameInit( void );
 	virtual void					PostInit();
 	virtual void					Shutdown( void );
 
@@ -737,6 +781,8 @@ int CHLClient::Init( CreateInterfaceFn appSystemFactory, CreateInterfaceFn physi
 		return false;
 	if ( IsPC() && (avi = (IAvi *)appSystemFactory(AVI_INTERFACE_VERSION, NULL)) == NULL )
 		return false;
+	if ( (bik = (IBik *)appSystemFactory(BIK_INTERFACE_VERSION, NULL)) == NULL )
+		return false;
 	if ( (scenefilecache = (ISceneFileCache *)appSystemFactory( SCENE_FILE_CACHE_INTERFACE_VERSION, NULL )) == NULL )
 		return false;
 	if ( IsX360() && (xboxsystem = (IXboxSystem *)appSystemFactory( XBOXSYSTEM_INTERFACE_VERSION, NULL )) == NULL )
@@ -764,6 +810,14 @@ int CHLClient::Init( CreateInterfaceFn appSystemFactory, CreateInterfaceFn physi
 	//Tony; mount an extra appId if it exists.
 	MountAdditionalContent();
 
+#if defined ( HL2SB )
+	//Andrew; then mount everything the user wants to use.
+	MountUserContent();
+
+	// Finally, load all of the player's addons.
+	MountAddons();
+#endif
+
 	if ( CommandLine()->FindParm( "-textmode" ) )
 		g_bTextMode = true;
 
@@ -796,6 +850,13 @@ int CHLClient::Init( CreateInterfaceFn appSystemFactory, CreateInterfaceFn physi
 
 	vgui::VGui_InitMatSysInterfacesList( "ClientDLL", &appSystemFactory, 1 );
 
+#if defined ( LUA_SDK )
+	// Initialize the GameUI state
+	luasrc_init_gameui();
+
+	luasrc_dofolder( LGameUI, LUA_PATH_GAMEUI );
+#endif
+
 	// Add the client systems.	
 	
 	// Client Leaf System has to be initialized first, since DetailObjectSystem uses it
@@ -878,11 +939,21 @@ void CHLClient::PostInit()
 	IGameSystem::PostInitAllSystems();
 }
 
+// This is called when a new game is started. (restart, map)
+bool CHLClient::GameInit( void )
+{
+	return true;
+}
+
 //-----------------------------------------------------------------------------
 // Purpose: Called when the client .dll is being dismissed
 //-----------------------------------------------------------------------------
 void CHLClient::Shutdown( void )
 {
+#if defined ( LUA_SDK )
+	luasrc_shutdown_gameui();
+#endif
+
 	C_BaseAnimating::ShutdownBoneSetupThreadPool();
 	ClientWorldFactoryShutdown();
 
@@ -911,6 +982,11 @@ void CHLClient::Shutdown( void )
 	
 	ClearKeyValuesCache();
 
+#if defined( HL2SB )
+	//Andrew; fixes the "CNet Encrypt:0" issue in 2007-based mods.
+	SteamAPI_Shutdown();
+#endif
+
 	DisconnectTier3Libraries( );
 	DisconnectTier2Libraries( );
 	ConVar_Unregister();
@@ -1216,6 +1292,46 @@ void CHLClient::LevelInitPreEntity( char const* pMapName )
 		return;
 	g_bLevelInitialized = true;
 
+#if defined ( LUA_SDK )
+	lcf_recursivedeletefile( LUA_PATH_CACHE );
+
+	// Add the Lua environment.
+	// Andrew; unarchive the Lua Cache File
+	if ( gpGlobals->maxClients > 1 )
+	{
+		luasrc_ExtractLcf();
+	}
+
+	luasrc_init();
+
+	if ( gpGlobals->maxClients > 1 )
+	{
+		luasrc_dofolder( L, LUA_PATH_CACHE LUA_PATH_EXTENSIONS );
+		luasrc_dofolder( L, LUA_PATH_CACHE LUA_PATH_MODULES );
+		luasrc_dofolder( L, LUA_PATH_CACHE LUA_PATH_GAME_SHARED );
+		luasrc_dofolder( L, LUA_PATH_CACHE LUA_PATH_GAME_CLIENT );
+	}
+
+	luasrc_dofolder( L, LUA_PATH_EXTENSIONS );
+	luasrc_dofolder( L, LUA_PATH_MODULES );
+	luasrc_dofolder( L, LUA_PATH_GAME_SHARED );
+	luasrc_dofolder( L, LUA_PATH_GAME_CLIENT );
+
+	luasrc_LoadWeapons();
+	luasrc_LoadEntities();
+	// luasrc_LoadEffects();
+
+	//Andrew; loadup base gamemode.
+	luasrc_LoadGamemode( LUA_BASE_GAMEMODE );
+
+	luasrc_LoadGamemode( gamemode.GetString() );
+	luasrc_SetGamemode( gamemode.GetString() );
+
+	BEGIN_LUA_CALL_HOOK( "LevelInitPreEntity" );
+		lua_pushstring( L, pMapName );
+	END_LUA_CALL_HOOK( 1, 0 );
+#endif
+
 	input->LevelInit();
 
 	vieweffects->LevelInit();
@@ -1270,6 +1386,11 @@ void CHLClient::LevelInitPreEntity( char const* pMapName )
 //-----------------------------------------------------------------------------
 void CHLClient::LevelInitPostEntity( )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "LevelInitPostEntity" );
+	END_LUA_CALL_HOOK( 0, 0 );
+#endif
+
 	IGameSystem::LevelInitPostEntityAllSystems();
 	C_PhysPropClientside::RecreateAll();
 	internalCenterPrint->Clear();
@@ -1299,6 +1420,14 @@ void CHLClient::LevelShutdown( void )
 
 	g_bLevelInitialized = false;
 
+#if defined ( LUA_SDK )
+	if (g_bLuaInitialized)
+	{
+		BEGIN_LUA_CALL_HOOK( "LevelShutdown" );
+		END_LUA_CALL_HOOK( 0, 0 );
+	}
+#endif
+
 	// Disable abs recomputations when everything is shutting down
 	CBaseEntity::EnableAbsRecomputations( false );
 
@@ -1348,6 +1477,10 @@ void CHLClient::LevelShutdown( void )
 
 	// string tables are cleared on disconnect from a server, so reset our global pointers to NULL
 	ResetStringTablePointers();
+
+#ifdef LUA_SDK
+	luasrc_shutdown();
+#endif
 }
 
 
@@ -1759,6 +1892,12 @@ void OnRenderStart()
 
 	C_BaseAnimating::ThreadedBoneSetup();
 
+#ifdef HL2SB
+	//Tony; in multiplayer do some extra stuff. like re-calc the view if in a vehicle!
+	if ( engine->GetMaxClients() > 1 )
+		view->MP_PostSimulate();
+#endif
+
 	{
 		VPROF_("Client TempEnts", 0, VPROF_BUDGETGROUP_CLIENT_SIM, false, BUDGETFLAG_CLIENT);
 		// This creates things like temp entities.
diff --git a/src/game/client/classmap.cpp b/src/game/client/classmap.cpp
index 7ed2c4d..b860a8b 100644
--- a/src/game/client/classmap.cpp
+++ b/src/game/client/classmap.cpp
@@ -17,8 +17,14 @@ public:
 	classentry_t()
 	{
 		mapname[ 0 ] = 0;
+#ifdef LUA_SDK
+		classname[ 0 ] = 0;
+#endif
 		factory = 0;
 		size = -1;
+#ifdef LUA_SDK
+		scripted = false;
+#endif
 	}
 
 	char const *GetMapName() const
@@ -31,17 +37,43 @@ public:
 		Q_strncpy( mapname, newname, sizeof( mapname ) );
 	}
 
+#if defined ( LUA_SDK )
+	char const *GetClassName() const
+	{
+		return classname;
+	}
+
+	void SetClassName( char const *newname )
+	{
+		Q_strncpy( classname, newname, sizeof( classname ) );
+	}
+#endif
+
 	DISPATCHFUNCTION	factory;
 	int					size;
+#if defined ( LUA_SDK )
+	bool				scripted;
+#endif
 private:
 	char				mapname[ 40 ];
+#if defined ( LUA_SDK )
+	char				classname[ 40 ];
+#endif
 };
 
 class CClassMap : public IClassMap
 {
 public:
+#ifdef LUA_SDK
+	virtual void			Add( const char *mapname, const char *classname, int size, DISPATCHFUNCTION factory /*= 0*/, bool scripted );
+	virtual void			RemoveAllScripted( void );
+#else
 	virtual void			Add( const char *mapname, const char *classname, int size, DISPATCHFUNCTION factory /*= 0*/ );
+#endif
 	virtual const char		*Lookup( const char *classname );
+#ifdef LUA_SDK
+	virtual DISPATCHFUNCTION FindFactory( const char *classname );
+#endif
 	virtual C_BaseEntity	*CreateEntity( const char *mapname );
 	virtual int				GetClassSize( const char *classname );
 
@@ -55,8 +87,25 @@ IClassMap& GetClassMap( void )
 	return g_Classmap;
 }
 
+#ifdef LUA_SDK
+void CClassMap::Add( const char *mapname, const char *classname, int size, DISPATCHFUNCTION factory = 0, bool scripted = false )
+#else
 void CClassMap::Add( const char *mapname, const char *classname, int size, DISPATCHFUNCTION factory = 0 )
+#endif
 {
+#if defined ( LUA_SDK )
+	for ( int i=m_ClassDict.First(); i != m_ClassDict.InvalidIndex(); i=m_ClassDict.Next( i ) )
+	{
+		classentry_t *lookup = &m_ClassDict[ i ];
+		if ( !lookup )
+			continue;
+
+		if ( !Q_stricmp( lookup->GetMapName(), mapname ) )
+		{
+			m_ClassDict.RemoveAt( i );
+		}
+	}
+#else
 	const char *map = Lookup( classname );
 	if ( map && !Q_strcasecmp( mapname, map ) )
 		return;
@@ -67,14 +116,79 @@ void CClassMap::Add( const char *mapname, const char *classname, int size, DISPA
 		Assert( index != m_ClassDict.InvalidIndex() );
 		m_ClassDict.RemoveAt( index );
 	}
+#endif
 
 	classentry_t element;
 	element.SetMapName( mapname );
 	element.factory = factory;
 	element.size = size;
+#if defined ( LUA_SDK )
+	element.SetClassName( classname );
+	element.scripted = scripted;
+	m_ClassDict.Insert( mapname, element );
+#else
 	m_ClassDict.Insert( classname, element );
+#endif
 }
 
+#ifdef LUA_SDK
+void CClassMap::RemoveAllScripted( void )
+{
+	int c = m_ClassDict.Count();
+	int i;
+
+	for ( i = 0; i < c; i++ )
+	{
+		classentry_t *lookup = &m_ClassDict[ i ];
+		if ( !lookup )
+			continue;
+
+		if ( lookup->scripted )
+		{
+			m_ClassDict.RemoveAt( i );
+		}
+	}
+}
+#endif
+
+#if defined ( LUA_SDK )
+const char *CClassMap::Lookup( const char *classname )
+{
+	int c = m_ClassDict.Count();
+	int i;
+
+	for ( i = 0; i < c; i++ )
+	{
+		classentry_t *lookup = &m_ClassDict[ i ];
+		if ( !lookup )
+			continue;
+
+		if ( Q_stricmp( lookup->GetClassName(), classname ) )
+			continue;
+
+		return lookup->GetMapName();
+	}
+
+	return NULL;
+}
+
+DISPATCHFUNCTION CClassMap::FindFactory( const char *classname )
+{
+	for ( int i=m_ClassDict.First(); i != m_ClassDict.InvalidIndex(); i=m_ClassDict.Next( i ) )
+	{
+		classentry_t *lookup = &m_ClassDict[ i ];
+		if ( !lookup )
+			continue;
+
+		if ( Q_stricmp( lookup->GetMapName(), classname ) )
+			continue;
+
+		return lookup->factory;
+	}
+
+	return NULL;
+}
+#else
 const char *CClassMap::Lookup( const char *classname )
 {
 	unsigned short index;
@@ -87,6 +201,7 @@ const char *CClassMap::Lookup( const char *classname )
 	lookup = m_ClassDict.Element( index );
 	return lookup.GetMapName();
 }
+#endif
 
 C_BaseEntity *CClassMap::CreateEntity( const char *mapname )
 {
diff --git a/src/game/client/client_hl2mp-2005.vcproj b/src/game/client/client_hl2mp-2005.vcproj
index afaa4b2..0a1fdf2 100644
--- a/src/game/client/client_hl2mp-2005.vcproj
+++ b/src/game/client/client_hl2mp-2005.vcproj
@@ -2,8 +2,9 @@
 <VisualStudioProject
 	ProjectType="Visual C++"
 	Version="8.00"
-	Name="Client HL2MP"
+	Name="Client HL2SB"
 	ProjectGUID="{5FE91DC8-B6DF-4061-984E-36FD36623E72}"
+	RootNamespace="Client HL2MP"
 	>
 	<Platforms>
 		<Platform
@@ -15,8 +16,8 @@
 	<Configurations>
 		<Configuration
 			Name="Debug|Win32"
-			OutputDirectory=".\Debug_hl2mp"
-			IntermediateDirectory=".\Debug_hl2mp"
+			OutputDirectory=".\Debug_hl2sb"
+			IntermediateDirectory=".\Debug_hl2sb"
 			ConfigurationType="2"
 			CharacterSet="2"
 			>
@@ -27,9 +28,9 @@
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
-				Description="Copying to D:\SteamLibrary\steamapps\SourceMods\mymod\bin\"
-				CommandLine="if exist &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\client.dll&quot; attrib -r &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\client.dll&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)&quot;client.dll &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin&quot;&#x0D;&#x0A;"
-				Outputs="D:\SteamLibrary\steamapps\SourceMods\mymod\bin\client.dll"
+				Description=""
+				CommandLine=""
+				Outputs=""
 			/>
 			<Tool
 				Name="VCXMLDataGeneratorTool"
@@ -44,8 +45,8 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="/MP"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\;..\..\common;..\..\public;..\..\public\tier0;..\..\public\tier1;..\..\vgui2\include;..\..\vgui2\controls;..\..\game\shared;.\game_controls;hl2mp\UI;.\hl2mp;..\..\game\shared\hl2mp;.\hl2;.\hl2\elements;..\..\game\shared\hl2;..\..\game\shared\Multiplayer"
-				PreprocessorDefinitions="WIN32;_WIN32;_DEBUG;DEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;NO_STRING_T;CLIENT_DLL;VECTOR;PROTECTED_THINGS_ENABLE;fopen=dont_use_fopen;strncpy=use_Q_strncpy_instead;_snprintf=use_Q_snprintf_instead;ENABLE_HTMLWINDOW;HL2MP;HL2_CLIENT_DLL;VERSION_SAFE_STEAM_API_INTERFACES;MP_SDK"
+				AdditionalIncludeDirectories="..\..\lua-5.1.5\src;..\..\lua-5.1.5\etc;..\..\open-steamworks\Open Steamworks;.\;..\..\common;..\..\public;..\..\public\tier0;..\..\public\tier1;..\..\vgui2\include;..\..\vgui2\controls;..\..\game\shared;.\scripted_controls;.\game_controls;hl2mp\UI;.\hl2mp;..\..\game\shared\hl2mp;.\hl2;.\hl2\elements;..\..\game\shared\hl2;..\..\game\shared\Multiplayer;..\..\game\shared\episodic"
+				PreprocessorDefinitions="WIN32;_WIN32;_DEBUG;DEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;NO_STRING_T;CLIENT_DLL;VECTOR;PROTECTED_THINGS_ENABLE;fopen=dont_use_fopen;strncpy=use_Q_strncpy_instead;_snprintf=use_Q_snprintf_instead;ENABLE_HTMLWINDOW;HL2MP;HL2SB;ARGG;HL2_CLIENT_DLL;HL2_EPISODIC;VERSION_SAFE_STEAM_API_INTERFACES;MP_SDK;LUA_SDK"
 				StringPooling="true"
 				MinimalRebuild="true"
 				ExceptionHandling="0"
@@ -86,12 +87,12 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="true"
 				UseUnicodeResponseFiles="false"
-				AdditionalDependencies="winmm.lib"
+				AdditionalDependencies="winmm.lib user32.lib lua51.lib kernel32.lib"
 				ShowProgress="0"
 				OutputFile="$(OutDir)/Client.dll"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="..\..\lib\common;..\..\lib\public"
+				AdditionalLibraryDirectories="..\..\lua-5.1.5\src;..\..\lib\common;..\..\lib\public"
 				GenerateManifest="false"
 				IgnoreDefaultLibraryNames="libc;libcd;libcmt"
 				GenerateDebugInformation="true"
@@ -130,14 +131,15 @@
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
-				CommandLine=""
+				Description="Copying to c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\"
+				CommandLine="if exist &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\client.dll&quot; attrib -r &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\client.dll&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)&quot;client.dll &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin&quot;&#x0D;&#x0A;"
 				ExcludedFromBuild="false"
 			/>
 		</Configuration>
 		<Configuration
 			Name="Release|Win32"
-			OutputDirectory=".\Release_hl2mp"
-			IntermediateDirectory=".\Release_hl2mp"
+			OutputDirectory=".\Release_hl2sb"
+			IntermediateDirectory=".\Release_hl2sb"
 			ConfigurationType="2"
 			CharacterSet="2"
 			>
@@ -148,9 +150,9 @@
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
-				Description="Copying to D:\SteamLibrary\steamapps\SourceMods\mymod\bin\"
-				CommandLine="if exist &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\client.dll&quot; attrib -r &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\client.dll&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)&quot;client.dll &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin&quot;&#x0D;&#x0A;if exist &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\client.pdb&quot; attrib -r &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\client.pdb&quot;&#x0D;&#x0A;if exist &quot;$(TargetDir)&quot;client.pdb copy &quot;$(TargetDir)&quot;client.pdb &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\client.pdb&quot;&#x0D;&#x0A;"
-				Outputs="D:\SteamLibrary\steamapps\SourceMods\mymod\bin\client.dll;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\client.pdb"
+				Description=""
+				CommandLine=""
+				Outputs=""
 			/>
 			<Tool
 				Name="VCXMLDataGeneratorTool"
@@ -168,8 +170,8 @@
 				InlineFunctionExpansion="2"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\;..\..\common;..\..\public;..\..\public\tier0;..\..\public\tier1;..\..\vgui2\include;..\..\vgui2\controls;..\..\game\shared;.\game_controls;hl2mp\UI;.\hl2mp;..\..\game\shared\hl2mp;.\hl2;.\hl2\elements;..\..\game\shared\hl2;..\..\game\shared\Multiplayer"
-				PreprocessorDefinitions="WIN32;_WIN32;NDEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;NO_STRING_T;CLIENT_DLL;VECTOR;PROTECTED_THINGS_ENABLE;fopen=dont_use_fopen;strncpy=use_Q_strncpy_instead;_snprintf=use_Q_snprintf_instead;ENABLE_HTMLWINDOW;HL2MP;HL2_CLIENT_DLL;VERSION_SAFE_STEAM_API_INTERFACES;MP_SDK"
+				AdditionalIncludeDirectories="..\..\lua-5.1.5\src;..\..\lua-5.1.5\etc;..\..\open-steamworks\Open Steamworks;.\;..\..\common;..\..\public;..\..\public\tier0;..\..\public\tier1;..\..\vgui2\include;..\..\vgui2\controls;..\..\game\shared;.\scripted_controls;.\game_controls;hl2mp\UI;.\hl2mp;..\..\game\shared\hl2mp;.\hl2;.\hl2\elements;..\..\game\shared\hl2;..\..\game\shared\Multiplayer;..\..\game\shared\episodic"
+				PreprocessorDefinitions="WIN32;_WIN32;NDEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;NO_STRING_T;CLIENT_DLL;VECTOR;PROTECTED_THINGS_ENABLE;fopen=dont_use_fopen;strncpy=use_Q_strncpy_instead;_snprintf=use_Q_snprintf_instead;ENABLE_HTMLWINDOW;HL2MP;HL2SB;ARGG;HL2_CLIENT_DLL;HL2_EPISODIC;VERSION_SAFE_STEAM_API_INTERFACES;MP_SDK;LUA_SDK"
 				StringPooling="true"
 				ExceptionHandling="0"
 				RuntimeLibrary="0"
@@ -209,12 +211,12 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="true"
 				UseUnicodeResponseFiles="false"
-				AdditionalDependencies="winmm.lib"
+				AdditionalDependencies="winmm.lib user32.lib lua51.lib kernel32.lib"
 				ShowProgress="0"
 				OutputFile="$(OutDir)/Client.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="..\..\lib\common;..\..\lib\public"
+				AdditionalLibraryDirectories="..\..\lua-5.1.5\src;..\..\lib\common;..\..\lib\public"
 				GenerateManifest="false"
 				IgnoreDefaultLibraryNames="libc;libcd;libcmtd"
 				GenerateDebugInformation="true"
@@ -255,7 +257,8 @@
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
-				CommandLine=""
+				Description="Copying to c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\"
+				CommandLine="if exist &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\client.dll&quot; attrib -r &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\client.dll&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)&quot;client.dll &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin&quot;&#x0D;&#x0A;if exist &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\client.pdb&quot; attrib -r &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\client.pdb&quot;&#x0D;&#x0A;if exist &quot;$(TargetDir)&quot;client.pdb copy &quot;$(TargetDir)&quot;client.pdb &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\client.pdb&quot;&#x0D;&#x0A;"
 				ExcludedFromBuild="false"
 			/>
 		</Configuration>
@@ -374,6 +377,14 @@
 				RelativePath=".\basepresence.cpp"
 				>
 			</File>
+			<File
+				RelativePath="..\shared\basescripted.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\basescripted.h"
+				>
+			</File>
 			<File
 				RelativePath="..\shared\baseviewmodel_shared.cpp"
 				>
@@ -1330,6 +1341,226 @@
 				RelativePath=".\lamphaloproxy.cpp"
 				>
 			</File>
+			<File
+				RelativePath="..\shared\lbasecombatweapon_shared.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lbaseentity_shared.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lbaseplayer_shared.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lbspflags.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\lc_baseanimating.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\lc_baseanimating.h"
+				>
+			</File>
+			<File
+				RelativePath=".\lc_baseentity.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\lc_baseplayer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lcdll_int.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\lcdll_util.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lColor.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier1\lconvar.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier0\ldbg.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui_controls\lEditablePanel.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\leffect_dispatch_data.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lfilesystem.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lgametrace.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lglobalvars_base.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\liclientshadowmgr.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier1\liconvar.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\licvar.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lienginevgui.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui\LIInput.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\materialsystem\limaterial.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\limovehelper.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lin_buttons.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lipredictionsystem.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui\LIScheme.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\SoundEmitterSystem\lisoundemittersystembase.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\steam\listeamfriends.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\steam\listeamfriends.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui\LISurface.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\engine\livdebugoverlay.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier1\LKeyValues.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\mathlib\lmathlib.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lnetworkstringtabledefs.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui_controls\lPanel.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vphysics\lperformance.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\lprediction.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vstdlib\lrandom.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lshareddefs.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lsrcinit.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\steam\lsteam_api.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\steam\lsteam_api.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\ltakedamageinfo.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\luacachefile.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\luacachefile.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\luamanager.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\luamanager.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lutil_shared.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\mathlib\lvector.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui\LVGUI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui_controls\lvgui_controls.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\mathlib\lvmatrix.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lvphysics_interface.cpp"
+				>
+			</File>
 			<File
 				RelativePath="..\shared\mapentities_shared.cpp"
 				>
@@ -1370,6 +1601,22 @@
 				RelativePath=".\message.cpp"
 				>
 			</File>
+			<File
+				RelativePath="..\shared\mountaddons.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\mountaddons.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\mountsteamcontent.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\mountsteamcontent.h"
+				>
+			</File>
 			<File
 				RelativePath=".\movehelper_client.cpp"
 				>
@@ -2014,6 +2261,10 @@
 				RelativePath=".\vgui_slideshow_display_screen.cpp"
 				>
 			</File>
+			<File
+				RelativePath=".\vgui_video.cpp"
+				>
+			</File>
 			<File
 				RelativePath=".\view.cpp"
 				>
@@ -2090,6 +2341,14 @@
 				RelativePath=".\WorldDimsProxy.cpp"
 				>
 			</File>
+			<File
+				RelativePath="..\..\public\XUnzip_src.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\zip_utils_src.cpp"
+				>
+			</File>
 			<Filter
 				Name="Precompiled Header"
 				>
@@ -2361,6 +2620,10 @@
 					RelativePath=".\fx_sparks.cpp"
 					>
 				</File>
+				<File
+					RelativePath=".\lc_recipientfilter.cpp"
+					>
+				</File>
 				<File
 					RelativePath=".\particlesphererenderer.cpp"
 					>
@@ -2593,6 +2856,10 @@
 					RelativePath=".\hl2\c_vehicle_crane.h"
 					>
 				</File>
+				<File
+					RelativePath=".\episodic\c_vehicle_jeep_episodic.cpp"
+					>
+				</File>
 				<File
 					RelativePath=".\hl2\c_vehicle_prisoner_pod.cpp"
 					>
@@ -2621,6 +2888,10 @@
 					RelativePath="..\shared\hl2\env_headcrabcanister_shared.h"
 					>
 				</File>
+				<File
+					RelativePath=".\episodic\flesh_internal_material_proxy.cpp"
+					>
+				</File>
 				<File
 					RelativePath=".\hl2\fx_antlion.cpp"
 					>
@@ -2709,6 +2980,14 @@
 					RelativePath=".\hl2\hud_quickinfo.cpp"
 					>
 				</File>
+				<File
+					RelativePath=".\hl2\hud_radar.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\hl2\hud_radar.h"
+					>
+				</File>
 				<File
 					RelativePath=".\hud_squadstatus.cpp"
 					>
@@ -2737,6 +3016,10 @@
 					RelativePath=".\hl2\shieldproxy.cpp"
 					>
 				</File>
+				<File
+					RelativePath="..\shared\hl2\survival_gamerules.cpp"
+					>
+				</File>
 				<File
 					RelativePath=".\hl2\vgui_rootpanel_hl2.cpp"
 					>
@@ -2797,6 +3080,14 @@
 					RelativePath="..\shared\hl2mp\hl2mp_weapon_parse.h"
 					>
 				</File>
+				<File
+					RelativePath="..\shared\hl2mp\lhl2mp_player_shared.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\shared\hl2mp\lhl2mp_player_shared.h"
+					>
+				</File>
 				<Filter
 					Name="Weapons"
 					>
@@ -2840,6 +3131,14 @@
 						RelativePath="..\shared\hl2mp\weapon_hl2mpbase_machinegun.h"
 						>
 					</File>
+					<File
+						RelativePath="..\shared\hl2mp\weapon_hl2mpbase_scriptedweapon.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\shared\hl2mp\weapon_hl2mpbase_scriptedweapon.h"
+						>
+					</File>
 					<File
 						RelativePath="..\shared\hl2mp\weapon_hl2mpbasebasebludgeon.cpp"
 						>
@@ -2860,6 +3159,10 @@
 						RelativePath="..\shared\hl2mp\weapon_physcannon.h"
 						>
 					</File>
+					<File
+						RelativePath="..\shared\hl2mp\weapon_physgun.cpp"
+						>
+					</File>
 					<File
 						RelativePath="..\shared\hl2mp\weapon_pistol.cpp"
 						>
@@ -2954,6 +3257,60 @@
 					>
 				</File>
 			</Filter>
+			<Filter
+				Name="scripted_controls"
+				>
+				<File
+					RelativePath=".\scripted_controls\lButton.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\scripted_controls\lCheckButton.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\scripted_controls\lFrame.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\scripted_controls\lPanel.cpp"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath=".\scripted_controls\lPropertyDialog.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\scripted_controls\lPropertyPage.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\scripted_controls\scriptedclientluapanel.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\scripted_controls\scriptedhudviewport.cpp"
+					>
+				</File>
+			</Filter>
 		</Filter>
 		<Filter
 			Name="Link Libraries"
@@ -2970,6 +3327,10 @@
 				RelativePath="..\..\lib\public\dmxloader.lib"
 				>
 			</File>
+			<File
+				RelativePath="..\..\lua-5.1.5\src\lua51.lib"
+				>
+			</File>
 			<File
 				RelativePath="..\..\lib\public\mathlib.lib"
 				>
@@ -3594,10 +3955,30 @@
 				RelativePath=".\kbutton.h"
 				>
 			</File>
+			<File
+				RelativePath=".\lc_recipientfilter.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lcdll_int.h"
+				>
+			</File>
+			<File
+				RelativePath=".\lcdll_util.h"
+				>
+			</File>
 			<File
 				RelativePath=".\lerp_functions.h"
 				>
 			</File>
+			<File
+				RelativePath="..\..\public\lglobalvars_base.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lvphysics_interface.h"
+				>
+			</File>
 			<File
 				RelativePath=".\menu.h"
 				>
@@ -3798,6 +4179,10 @@
 				RelativePath=".\vgui_int.h"
 				>
 			</File>
+			<File
+				RelativePath=".\vgui_video.h"
+				>
+			</File>
 			<File
 				RelativePath=".\vguicenterprint.h"
 				>
@@ -4362,10 +4747,86 @@
 				RelativePath="..\..\public\vgui_controls\Label.h"
 				>
 			</File>
+			<File
+				RelativePath="..\..\public\lcmodel.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lColor.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui_controls\lControls.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier1\lconvar.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier0\ldbg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui_controls\lEditablePanel.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lfilesystem.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lgametrace.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\licvar.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\materialsystem\limaterial.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui\LIScheme.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\SoundEmitterSystem\lisoundemittersystembase.h"
+				>
+			</File>
 			<File
 				RelativePath="..\..\public\vgui_controls\ListPanel.h"
 				>
 			</File>
+			<File
+				RelativePath="..\..\public\tier1\LKeyValues.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lnetworkstringtabledefs.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui_controls\lPanel.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vstdlib\lrandom.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\mathlib\lvector.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vgui\LVGUI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\mathlib\lvmatrix.h"
+				>
+			</File>
 			<File
 				RelativePath="..\..\public\mathlib\mathlib.h"
 				>
@@ -4954,6 +5415,34 @@
 				RelativePath="..\shared\IVehicle.h"
 				>
 			</File>
+			<File
+				RelativePath="..\shared\lbaseplayer_shared.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\leffect_dispatch_data.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\limovehelper.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lshareddefs.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\ltakedamageinfo.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\luasrclib.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lutil_shared.h"
+				>
+			</File>
 			<File
 				RelativePath="..\shared\mapdata_shared.h"
 				>
@@ -5251,6 +5740,42 @@
 				>
 			</File>
 		</Filter>
+		<Filter
+			Name="scripted_controls Header Files"
+			>
+			<File
+				RelativePath=".\scripted_controls\lButton.h"
+				>
+			</File>
+			<File
+				RelativePath=".\scripted_controls\lCheckButton.h"
+				>
+			</File>
+			<File
+				RelativePath=".\scripted_controls\lFrame.h"
+				>
+			</File>
+			<File
+				RelativePath=".\scripted_controls\lPanel.h"
+				>
+			</File>
+			<File
+				RelativePath=".\scripted_controls\lPropertyDialog.h"
+				>
+			</File>
+			<File
+				RelativePath=".\scripted_controls\lPropertyPage.h"
+				>
+			</File>
+			<File
+				RelativePath=".\scripted_controls\scriptedclientluapanel.h"
+				>
+			</File>
+			<File
+				RelativePath=".\scripted_controls\scriptedhudviewport.h"
+				>
+			</File>
+		</Filter>
 	</Files>
 	<Globals>
 	</Globals>
diff --git a/src/game/client/clientmode_shared.cpp b/src/game/client/clientmode_shared.cpp
index b5f19ff..6c9440b 100644
--- a/src/game/client/clientmode_shared.cpp
+++ b/src/game/client/clientmode_shared.cpp
@@ -35,6 +35,11 @@
 #if defined( _X360 )
 #include "xbox/xbox_console.h"
 #endif
+#if defined( LUA_SDK )
+#include "luamanager.h"
+#include "lbaseentity_shared.h"
+#include "lbaseplayer_shared.h"
+#endif
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
@@ -158,7 +163,13 @@ static void __MsgFunc_VGUIMenu( bf_read &msg )
 //-----------------------------------------------------------------------------
 ClientModeShared::ClientModeShared()
 {
+#ifdef LUA_SDK
+	m_pScriptedViewport = NULL;
+#endif
 	m_pViewport = NULL;
+#ifdef LUA_SDK
+	m_pClientLuaPanel = NULL;
+#endif
 	m_pChatElement = NULL;
 	m_pWeaponSelection = NULL;
 	m_nRootSize[ 0 ] = m_nRootSize[ 1 ] = -1;
@@ -169,7 +180,15 @@ ClientModeShared::ClientModeShared()
 //-----------------------------------------------------------------------------
 ClientModeShared::~ClientModeShared()
 {
+#ifdef LUA_SDK
+	// NOTE: Due to the behavior of many crashes, if you end up here from a
+	// .mdmp or debug attach, you might as well ignore this call stack.
+	delete m_pScriptedViewport; 
+#endif
 	delete m_pViewport; 
+#ifdef LUA_SDK
+	delete m_pClientLuaPanel; 
+#endif
 }
 
 void ClientModeShared::ReloadScheme( void )
@@ -218,8 +237,16 @@ void ClientModeShared::InitViewport()
 
 void ClientModeShared::VGui_Shutdown()
 {
+#ifdef LUA_SDK
+	delete m_pScriptedViewport;
+	m_pScriptedViewport = NULL;
+#endif
 	delete m_pViewport;
 	m_pViewport = NULL;
+#ifdef LUA_SDK
+	delete m_pClientLuaPanel;
+	m_pClientLuaPanel = NULL;
+#endif
 }
 
 
@@ -298,11 +325,26 @@ void ClientModeShared::OverrideView( CViewSetup *pSetup )
 //-----------------------------------------------------------------------------
 bool ClientModeShared::ShouldDrawEntity(C_BaseEntity *pEnt)
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "ShouldDrawEntity" );
+		lua_pushentity( L, pEnt );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 	return true;
 }
 
 bool ClientModeShared::ShouldDrawParticles( )
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "ShouldDrawParticles" );
+	END_LUA_CALL_HOOK( 0, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 	return true;
 }
 
@@ -318,16 +360,50 @@ void ClientModeShared::OverrideMouseInput( float *x, float *y )
 	}
 }
 
+#ifdef ARGG
+//-----------------------------------------------------------------------------
+// Purpose: Allow weapons to override mouse input to view angles (for orbiting)
+//-----------------------------------------------------------------------------
+// adnan
+// control the mouse input in the grav gun through this
+bool ClientModeShared::OverrideViewAngles( void )
+{
+	C_BaseCombatWeapon *pWeapon = GetActiveWeapon();
+	if ( pWeapon )
+	{
+		// adnan
+		return pWeapon->OverrideViewAngles();
+	}
+
+	return false;
+}
+// end adnan
+#endif
+
 //-----------------------------------------------------------------------------
 // Purpose: 
 //-----------------------------------------------------------------------------
 bool ClientModeShared::ShouldDrawViewModel()
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "ShouldDrawViewModel" );
+	END_LUA_CALL_HOOK( 0, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 	return true;
 }
 
 bool ClientModeShared::ShouldDrawDetailObjects( )
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "ShouldDrawDetailObjects" );
+	END_LUA_CALL_HOOK( 0, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 	return true;
 }
 
@@ -337,6 +413,13 @@ bool ClientModeShared::ShouldDrawDetailObjects( )
 //-----------------------------------------------------------------------------
 bool ClientModeShared::ShouldDrawCrosshair( void )
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "ShouldDrawCrosshair" );
+	END_LUA_CALL_HOOK( 0, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 	return true;
 }
 
@@ -345,6 +428,14 @@ bool ClientModeShared::ShouldDrawCrosshair( void )
 //-----------------------------------------------------------------------------
 bool ClientModeShared::ShouldDrawLocalPlayer( C_BasePlayer *pPlayer )
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "ShouldDrawLocalPlayer" );
+		lua_pushplayer( L, pPlayer );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 	if ( ( pPlayer->index == render->GetViewEntity() ) && !C_BasePlayer::ShouldDrawLocalPlayer() )
 		return false;
 
@@ -357,6 +448,13 @@ bool ClientModeShared::ShouldDrawLocalPlayer( C_BasePlayer *pPlayer )
 //-----------------------------------------------------------------------------
 bool ClientModeShared::ShouldDrawFog( void )
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "ShouldDrawFog" );
+	END_LUA_CALL_HOOK( 0, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 	return true;
 }
 
@@ -365,6 +463,25 @@ bool ClientModeShared::ShouldDrawFog( void )
 //-----------------------------------------------------------------------------
 void ClientModeShared::AdjustEngineViewport( int& x, int& y, int& width, int& height )
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "AdjustEngineViewport" );
+		lua_pushinteger( L, x );
+		lua_pushinteger( L, y );
+		lua_pushinteger( L, width );
+		lua_pushinteger( L, height );
+	END_LUA_CALL_HOOK( 4, 4 );
+
+	if ( lua_isnumber( L, -4 ) )
+		x = luaL_checkint( L, -4 );
+	if ( lua_isnumber( L, -3 ) )
+		y = luaL_checkint( L, -3 );
+	if ( lua_isnumber( L, -2 ) )
+		width = luaL_checkint( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+		height = luaL_checkint( L, -1 );
+
+	lua_pop( L, 4 );
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -392,6 +509,13 @@ void ClientModeShared::PostRenderVGui()
 //-----------------------------------------------------------------------------
 void ClientModeShared::Update()
 {
+#ifdef LUA_SDK
+	if ( m_pScriptedViewport->IsVisible() != cl_drawhud.GetBool() )
+	{
+		m_pScriptedViewport->SetVisible( cl_drawhud.GetBool() );
+	}
+#endif
+
 	if ( m_pViewport->IsVisible() != cl_drawhud.GetBool() )
 	{
 		m_pViewport->SetVisible( cl_drawhud.GetBool() );
@@ -414,6 +538,19 @@ void ClientModeShared::ProcessInput(bool bActive)
 //-----------------------------------------------------------------------------
 int	ClientModeShared::KeyInput( int down, ButtonCode_t keynum, const char *pszCurrentBinding )
 {
+#ifdef LUA_SDK
+	if ( g_bLuaInitialized )
+	{
+		BEGIN_LUA_CALL_HOOK( "KeyInput" );
+			lua_pushinteger( L, down );
+			lua_pushinteger( L, keynum );
+			lua_pushstring( L, pszCurrentBinding );
+		END_LUA_CALL_HOOK( 3, 1 );
+
+		RETURN_LUA_INTEGER();
+	}
+#endif
+
 	if ( engine->Con_IsVisible() )
 		return 1;
 	
@@ -604,21 +741,57 @@ void ClientModeShared::Enable()
 	// Add our viewport to the root panel.
 	if( (pRoot = VGui_GetClientDLLRootPanel() ) != NULL )
 	{
+#ifdef LUA_SDK
+		m_pScriptedViewport->SetParent( pRoot );
+#endif
 		m_pViewport->SetParent( pRoot );
+#ifdef LUA_SDK
+		m_pClientLuaPanel->SetParent( pRoot );
+#endif
 	}
 
 	// All hud elements should be proportional
 	// This sets that flag on the viewport and all child panels
+#ifdef LUA_SDK
+	m_pScriptedViewport->SetProportional( true );
+#endif
 	m_pViewport->SetProportional( true );
+#ifdef LUA_SDK
+	m_pClientLuaPanel->SetProportional( false );
+#endif
 
+#ifdef LUA_SDK
+	m_pScriptedViewport->SetCursor( m_CursorNone );
+#endif
 	m_pViewport->SetCursor( m_CursorNone );
+#ifdef LUA_SDK
+	m_pClientLuaPanel->SetCursor( m_CursorNone );
+#endif
 	vgui::surface()->SetCursor( m_CursorNone );
 
+#ifdef LUA_SDK
+	m_pScriptedViewport->SetVisible( true );
+#endif
 	m_pViewport->SetVisible( true );
+#ifdef LUA_SDK
+	m_pClientLuaPanel->SetVisible( true );
+#endif
+#ifdef LUA_SDK
+	if ( m_pScriptedViewport->IsKeyBoardInputEnabled() )
+	{
+		m_pScriptedViewport->RequestFocus();
+	}
+#endif
 	if ( m_pViewport->IsKeyBoardInputEnabled() )
 	{
 		m_pViewport->RequestFocus();
 	}
+#ifdef LUA_SDK
+	if ( m_pClientLuaPanel->IsKeyBoardInputEnabled() )
+	{
+		m_pClientLuaPanel->RequestFocus();
+	}
+#endif
 
 	Layout();
 }
@@ -631,10 +804,22 @@ void ClientModeShared::Disable()
 	// Remove our viewport from the root panel.
 	if( ( pRoot = VGui_GetClientDLLRootPanel() ) != NULL )
 	{
+#ifdef LUA_SDK
+		m_pScriptedViewport->SetParent( (vgui::VPANEL)NULL );
+#endif
 		m_pViewport->SetParent( (vgui::VPANEL)NULL );
+#ifdef LUA_SDK
+		m_pClientLuaPanel->SetParent( (vgui::VPANEL)NULL );
+#endif
 	}
 
+#ifdef LUA_SDK
+	m_pScriptedViewport->SetVisible( false );
+#endif
 	m_pViewport->SetVisible( false );
+#ifdef LUA_SDK
+	m_pClientLuaPanel->SetVisible( false );
+#endif
 }
 
 
@@ -652,7 +837,13 @@ void ClientModeShared::Layout()
 		m_nRootSize[ 0 ] = wide;
 		m_nRootSize[ 1 ] = tall;
 
+#ifdef LUA_SDK
+		m_pScriptedViewport->SetBounds(0, 0, wide, tall);
+#endif
 		m_pViewport->SetBounds(0, 0, wide, tall);
+#ifdef LUA_SDK
+		m_pClientLuaPanel->SetBounds(0, 0, wide, tall);
+#endif
 		if ( changed )
 		{
 			ReloadScheme();
diff --git a/src/game/client/clientmode_shared.h b/src/game/client/clientmode_shared.h
index fd741d7..2e3e983 100644
--- a/src/game/client/clientmode_shared.h
+++ b/src/game/client/clientmode_shared.h
@@ -15,6 +15,10 @@
 #include "iclientmode.h"
 #include "gameeventlistener.h"
 #include <baseviewport.h>
+#ifdef LUA_SDK
+#include <scriptedhudviewport.h>
+#include <scriptedclientluapanel.h>
+#endif
 
 class CBaseHudChat;
 class CBaseHudWeaponSelection;
@@ -71,6 +75,12 @@ public:
 
 	// Input
 	virtual int		KeyInput( int down, ButtonCode_t keynum, const char *pszCurrentBinding );
+#ifdef ARGG
+	// adnan
+	// does this weapon need to override the view angles?
+	virtual bool	OverrideViewAngles( void );
+	// end adnan
+#endif
 	virtual int		HudElementKeyInput( int down, ButtonCode_t keynum, const char *pszCurrentBinding );
 	virtual void	OverrideMouseInput( float *x, float *y );
 	virtual void	StartMessageMode( int iMessageModeType );
@@ -95,7 +105,14 @@ public:
 	virtual int HandleSpectatorKeyInput( int down, ButtonCode_t keynum, const char *pszCurrentBinding );
 
 protected:
+#ifdef LUA_SDK
+	CScriptedHudViewport	*m_pScriptedViewport;
+#endif
 	CBaseViewport			*m_pViewport;
+#ifdef LUA_SDK
+public:
+	CScriptedClientLuaPanel	*m_pClientLuaPanel;
+#endif
 
 private:
 	// Message mode handling
diff --git a/src/game/client/enginesprite.h b/src/game/client/enginesprite.h
index f9737be..17aaa14 100644
--- a/src/game/client/enginesprite.h
+++ b/src/game/client/enginesprite.h
@@ -13,6 +13,7 @@
 
 #include "mathlib/vector.h"
 #include "avi/iavi.h"
+#include "avi/ibik.h"
 
 
 //-----------------------------------------------------------------------------
@@ -51,10 +52,12 @@ public:
 	void DrawFrame( int frame, int x, int y, const wrect_t *prcSubRect );
 	void DrawFrameOfSize( int frame, int x, int y, int iWidth, int iHeight, const wrect_t *prcSubRect);
 	bool IsAVI();
+	bool IsBIK();
 	void GetTexCoordRange( float *pMinU, float *pMinV, float *pMaxU, float *pMaxV );
 
 private:
 	AVIMaterial_t m_hAVIMaterial;
+	BIKMaterial_t m_hBIKMaterial;
 	int m_width;
 	int m_height;
 	int m_numFrames;
diff --git a/src/game/client/entity_client_tools.cpp b/src/game/client/entity_client_tools.cpp
index fef86ba..bd13bca 100644
--- a/src/game/client/entity_client_tools.cpp
+++ b/src/game/client/entity_client_tools.cpp
@@ -13,6 +13,11 @@
 #include "particle_parse.h"
 #include "rendertexture.h"
 
+#ifdef LUA_SDK
+	#include "luamanager.h"
+	#include "lbaseentity_shared.h"
+#endif
+
 #ifdef PORTAL
 	#include "portalrender.h"
 #endif
@@ -567,6 +572,12 @@ void CClientTools::OnEntityDeleted( CBaseEntity *pEntity )
 
 void CClientTools::OnEntityCreated( CBaseEntity *pEntity )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "OnEntityCreated" );
+		lua_pushentity( L, pEntity );
+	END_LUA_CALL_HOOK( 1, 0 );
+#endif
+
 	if ( !m_bInRecordingMode )
 		return;
 
diff --git a/src/game/client/game_controls/baseviewport.cpp b/src/game/client/game_controls/baseviewport.cpp
index 330d579..7c18aeb 100644
--- a/src/game/client/game_controls/baseviewport.cpp
+++ b/src/game/client/game_controls/baseviewport.cpp
@@ -49,6 +49,11 @@
 #include "ienginevgui.h"
 #include "iclientmode.h"
 
+// lua hooks
+#ifdef LUA_SDK
+#include "luamanager.h"
+#endif
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -208,6 +213,16 @@ void CBaseViewport::OnScreenSizeChanged(int iOldWide, int iOldTall)
 	{
 		ShowPanel( PANEL_SPECGUI, true );
 	}
+
+#ifdef LUA_SDK
+	if ( g_bLuaInitialized )
+	{
+		BEGIN_LUA_CALL_HOOK( "OnScreenSizeChanged" );
+			lua_pushinteger( L, iOldWide );
+			lua_pushinteger( L, iOldTall );
+		END_LUA_CALL_HOOK( 2, 0 );
+	}
+#endif
 }
 
 void CBaseViewport::CreateDefaultPanels( void )
@@ -611,6 +626,10 @@ void CBaseViewport::SetParent(vgui::VPANEL parent)
 //-----------------------------------------------------------------------------
 void CBaseViewport::ActivateClientUI() 
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "ActivateClientUI" );
+	END_LUA_CALL_HOOK( 0, 0 );
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -618,6 +637,10 @@ void CBaseViewport::ActivateClientUI()
 //-----------------------------------------------------------------------------
 void CBaseViewport::HideClientUI()
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "HideClientUI" );
+	END_LUA_CALL_HOOK( 0, 0 );
+#endif
 }
 
 //-----------------------------------------------------------------------------
diff --git a/src/game/client/hl2/c_weapon_gravitygun.cpp b/src/game/client/hl2/c_weapon_gravitygun.cpp
index 2c7ddf9..2434d7f 100644
--- a/src/game/client/hl2/c_weapon_gravitygun.cpp
+++ b/src/game/client/hl2/c_weapon_gravitygun.cpp
@@ -11,6 +11,7 @@
 #include "beamdraw.h"
 #include "c_weapon__stubs.h"
 #include "ClientEffectPrecacheSystem.h"
+#include "weapon_hl2mpbasehlmpcombatweapon.h"
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
@@ -25,6 +26,11 @@ public:
 	C_BeamQuadratic();
 	void			Update( C_BaseEntity *pOwner );
 
+	const matrix3x4_t &C_BeamQuadratic::RenderableToWorldTransform( void )
+	{
+		return RenderableToWorldTransform();
+	}
+
 	// IClientRenderable
 	virtual const Vector&			GetRenderOrigin( void ) { return m_worldPosition; }
 	virtual const QAngle&			GetRenderAngles( void ) { return vec3_angle; }
@@ -36,9 +42,12 @@ public:
 	// Returns the bounds relative to the origin (render bounds)
 	virtual void	GetRenderBounds( Vector& mins, Vector& maxs )
 	{
-		// bogus.  But it should draw if you can see the end point
-		mins.Init(-32,-32,-32);
-		maxs.Init(32,32,32);
+		ClearBounds( mins, maxs );
+		AddPointToBounds( vec3_origin, mins, maxs );
+		AddPointToBounds( m_targetPosition, mins, maxs );
+		AddPointToBounds( m_worldPosition, mins, maxs );
+		mins -= GetRenderOrigin();
+		maxs -= GetRenderOrigin();
 	}
 
 	C_BaseEntity			*m_pOwner;
@@ -50,9 +59,9 @@ public:
 };
 
 
-class C_WeaponGravityGun : public C_BaseCombatWeapon
+class C_WeaponGravityGun : public C_BaseHL2MPCombatWeapon
 {
-	DECLARE_CLASS( C_WeaponGravityGun, C_BaseCombatWeapon );
+	DECLARE_CLASS( C_WeaponGravityGun, C_BaseHL2MPCombatWeapon );
 public:
 	C_WeaponGravityGun() {}
 
@@ -89,6 +98,8 @@ private:
 	C_WeaponGravityGun( const C_WeaponGravityGun & );
 
 	C_BeamQuadratic	m_beam;
+
+	DECLARE_ACTTABLE();
 };
 
 STUB_WEAPON_CLASS_IMPLEMENT( weapon_physgun, C_WeaponGravityGun );
@@ -101,6 +112,25 @@ IMPLEMENT_CLIENTCLASS_DT( C_WeaponGravityGun, DT_WeaponGravityGun, CWeaponGravit
 	RecvPropInt( RECVINFO_NAME(m_beam.m_viewModelIndex, m_viewModelIndex) ),
 END_RECV_TABLE()
 
+acttable_t	C_WeaponGravityGun::m_acttable[] = 
+{
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PHYSGUN,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PHYSGUN,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PHYSGUN,					false },
+};
+
+IMPLEMENT_ACTTABLE(C_WeaponGravityGun);
+
 
 C_BeamQuadratic::C_BeamQuadratic()
 {
@@ -159,7 +189,8 @@ int	C_BeamQuadratic::DrawModel( int )
 	}
 
 	float scrollOffset = gpGlobals->curtime - (int)gpGlobals->curtime;
-	materials->Bind( pMat );
+	CMatRenderContextPtr pRenderContext( materials );
+	pRenderContext->Bind( pMat );
 	DrawBeamQuadratic( points[0], points[1], points[2], 13, color, scrollOffset );
 	return 1;
 }
diff --git a/src/game/client/hl2/hud_credits.cpp b/src/game/client/hl2/hud_credits.cpp
index 08b4472..1d25426 100644
--- a/src/game/client/hl2/hud_credits.cpp
+++ b/src/game/client/hl2/hud_credits.cpp
@@ -141,7 +141,11 @@ void CHudCredits::PrepareCredits( const char *pKeyName )
 	Clear();
 
 	KeyValues *pKV= new KeyValues( "CreditsFile" );
+#ifndef HL2SB
 	if ( !pKV->LoadFromFile( filesystem, CREDITS_FILE, "MOD" ) )
+#else
+	if ( !pKV->LoadFromFile( filesystem, CREDITS_FILE, "GAME" ) )
+#endif
 	{
 		pKV->deleteThis();
 
diff --git a/src/game/client/hl2/hud_weaponselection.cpp b/src/game/client/hl2/hud_weaponselection.cpp
index 8825123..90064cf 100644
--- a/src/game/client/hl2/hud_weaponselection.cpp
+++ b/src/game/client/hl2/hud_weaponselection.cpp
@@ -19,6 +19,12 @@
 
 #include "vgui/ILocalize.h"
 
+#ifdef LUA_SDK
+#include "luamanager.h"
+#include "lbasecombatweapon_shared.h"
+#include "lColor.h"
+#endif
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -56,6 +62,9 @@ public:
 
 	virtual C_BaseCombatWeapon *GetWeaponInSlot( int iSlot, int iSlotPos );
 	virtual void SelectWeaponSlot( int iSlot );
+#ifdef LUA_SDK
+	virtual C_BaseCombatWeapon	*GetNextActivePos( int iSlot, int iSlotPos );
+#endif
 
 	virtual C_BaseCombatWeapon	*GetSelectedWeapon( void )
 	{ 
@@ -108,6 +117,12 @@ private:
 	void ActivateWeaponHighlight( C_BaseCombatWeapon *pWeapon );
 	float GetWeaponBoxAlpha( bool bSelected );
 	int GetLastPosInSlot( int iSlot ) const;
+#ifdef LUA_SDK
+	int GetNumberOfWeaponsInSlotPos( int iSlot, int iPos ) const;
+	int GetNumberOfSelectableWeaponsInSlotPos( int iSlot, int iPos );
+	C_BaseCombatWeapon *GetLastWeaponInSlotPos( int iSlot, int iPos );
+	C_BaseCombatWeapon *GetLastSelectableWeaponInSlotPos( int iSlot, int iPos );
+#endif
     
 	void FastWeaponSwitch( int iWeaponSlot );
 	void PlusTypeFastWeaponSwitch( int iWeaponSlot );
@@ -659,6 +674,7 @@ void CHudWeaponSelection::Paint()
 
 					for (int slotpos = 0; slotpos <= iLastPos; slotpos++)
 					{
+#if !defined ( LUA_SDK )
 						C_BaseCombatWeapon *pWeapon = GetWeaponInSlot( i, slotpos );
 						if ( !pWeapon )
 						{
@@ -683,6 +699,53 @@ void CHudWeaponSelection::Paint()
 						// move down to the next bucket
 						ypos += (largeBoxTall + m_flBoxGap);
 						bDrawBucketNumber = false;
+#else
+						int iWeaponsInSlotPos = GetNumberOfWeaponsInSlotPos( i, slotpos );
+
+						if ( iWeaponsInSlotPos == 0 )
+						{
+							if ( !hud_showemptyweaponslots.GetBool() )
+								continue;
+							DrawBox( xpos, ypos, largeBoxWide, largeBoxTall, m_EmptyBoxColor, m_flAlphaOverride, bDrawBucketNumber ? i + 1 : -1 );
+
+							// move down to the next bucket
+							ypos += (largeBoxTall + m_flBoxGap);
+							bDrawBucketNumber = false;
+						}
+						else
+						{
+							for ( int j = 0; j < MAX_WEAPONS; j++ )
+							{
+								C_BasePlayer *player = C_BasePlayer::GetLocalPlayer();
+
+								if ( !player )
+									continue;
+
+								C_BaseCombatWeapon *pWeapon = player->GetWeapon(j);
+								
+								if ( pWeapon == NULL )
+									continue;
+
+								if ( pWeapon->GetSlot() == i && pWeapon->GetPosition() == slotpos )
+								{
+									bool bSelected = (pWeapon == pSelectedWeapon);
+									DrawLargeWeaponBox( pWeapon, 
+														bSelected, 
+														xpos, 
+														ypos, 
+														largeBoxWide, 
+														largeBoxTall, 
+														bSelected ? selectedColor : m_BoxColor, 
+														GetWeaponBoxAlpha( bSelected ), 
+														bDrawBucketNumber ? i + 1 : -1 );
+
+									// move down to the next bucket
+									ypos += (largeBoxTall + m_flBoxGap);
+									bDrawBucketNumber = false;
+								}
+							}
+						}
+#endif
 					}
 
 					xpos += largeBoxWide;
@@ -877,14 +940,33 @@ void CHudWeaponSelection::DrawLargeWeaponBox( C_BaseCombatWeapon *pWeapon, bool
 		return;
 	}
 
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_WEAPON_HOOK( "DrawLargeWeaponBox", pWeapon );
+		lua_pushboolean( L, bSelected );
+		lua_pushinteger( L, xpos );
+		lua_pushinteger( L, ypos );
+		lua_pushinteger( L, boxWide );
+		lua_pushinteger( L, boxTall );
+		lua_pushcolor( L, selectedColor );
+		lua_pushnumber( L, alpha );
+		lua_pushinteger( L, number );
+	END_LUA_CALL_WEAPON_HOOK( 8, 0 );
+#endif
+
 	// draw text
 	col = m_TextColor;
+#if !defined ( LUA_SDK )
 	const FileWeaponInfo_t &weaponInfo = pWeapon->GetWpnData();
+#endif
 
 	if ( bSelected )
 	{
 		wchar_t text[128];
+#if defined ( LUA_SDK )
+		wchar_t *tempString = g_pVGuiLocalize->Find(pWeapon->GetPrintName());
+#else
 		wchar_t *tempString = g_pVGuiLocalize->Find(weaponInfo.szPrintName);
+#endif
 
 		// setup our localized string
 		if ( tempString )
@@ -895,7 +977,11 @@ void CHudWeaponSelection::DrawLargeWeaponBox( C_BaseCombatWeapon *pWeapon, bool
 		else
 		{
 			// string wasn't found by g_pVGuiLocalize->Find()
+#if defined ( LUA_SDK )
+			g_pVGuiLocalize->ConvertANSIToUnicode(pWeapon->GetPrintName(), text, sizeof(text));
+#else
 			g_pVGuiLocalize->ConvertANSIToUnicode(weaponInfo.szPrintName, text, sizeof(text));
+#endif
 		}
 
 		surface()->DrawSetTextColor( col );
@@ -1045,8 +1131,43 @@ C_BaseCombatWeapon *CHudWeaponSelection::FindNextWeaponInWeaponSelection(int iCu
 	if ( !pPlayer )
 		return NULL;
 
+#if defined ( LUA_SDK )
+	C_BaseCombatWeapon *pCurWeapon = IsInSelectionMode() ? GetSelectedWeapon() : GetActiveWeapon();
+#endif
 	C_BaseCombatWeapon *pNextWeapon = NULL;
 
+#if defined ( LUA_SDK )
+	int iWeaponsInSlotPos = GetNumberOfWeaponsInSlotPos( iCurrentSlot, iCurrentPosition );
+	if ( iWeaponsInSlotPos > 1 )
+	{
+		bool bCurrentWeaponFound = false;
+
+		for ( int i = 0; i < MAX_WEAPONS; i++ )
+		{
+			C_BaseCombatWeapon *pWeapon = pPlayer->GetWeapon(i);
+			if ( !pWeapon )
+				continue;
+
+			int weaponSlot = pWeapon->GetSlot(), weaponPosition = pWeapon->GetPosition();
+
+			if ( weaponSlot == iCurrentSlot && weaponPosition == iCurrentPosition )
+			{
+				if ( pWeapon == pCurWeapon )
+				{
+					bCurrentWeaponFound = true;
+				}
+				else if ( bCurrentWeaponFound )
+				{
+					if ( CanBeSelectedInHUD( pWeapon ) )
+					{
+						return pWeapon;
+					}
+				}
+			}
+		}
+	}
+#endif
+
 	// search all the weapons looking for the closest next
 	int iLowestNextSlot = MAX_WEAPON_SLOTS;
 	int iLowestNextPosition = MAX_WEAPON_POSITIONS;
@@ -1086,8 +1207,43 @@ C_BaseCombatWeapon *CHudWeaponSelection::FindPrevWeaponInWeaponSelection(int iCu
 	if ( !pPlayer )
 		return NULL;
 
+#if defined ( LUA_SDK )
+	C_BaseCombatWeapon *pCurWeapon = IsInSelectionMode() ? GetSelectedWeapon() : GetActiveWeapon();
+#endif
 	C_BaseCombatWeapon *pPrevWeapon = NULL;
 
+#if defined ( LUA_SDK )
+	int iWeaponsInSlotPos = GetNumberOfWeaponsInSlotPos( iCurrentSlot, iCurrentPosition );
+	if ( iWeaponsInSlotPos > 1 )
+	{
+		bool bCurrentWeaponFound = false;
+
+		for ( int i = MAX_WEAPONS - 1; i >= 0; i-- )
+		{
+			C_BaseCombatWeapon *pWeapon = pPlayer->GetWeapon(i);
+			if ( !pWeapon )
+				continue;
+
+			int weaponSlot = pWeapon->GetSlot(), weaponPosition = pWeapon->GetPosition();
+
+			if ( weaponSlot == iCurrentSlot && weaponPosition == iCurrentPosition )
+			{
+				if ( pWeapon == pCurWeapon )
+				{
+					bCurrentWeaponFound = true;
+				}
+				else if ( bCurrentWeaponFound )
+				{
+					if ( CanBeSelectedInHUD( pWeapon ) )
+					{
+						return pWeapon;
+					}
+				}
+			}
+		}
+	}
+#endif
+
 	// search all the weapons looking for the closest next
 	int iLowestPrevSlot = -1;
 	int iLowestPrevPosition = -1;
@@ -1115,6 +1271,29 @@ C_BaseCombatWeapon *CHudWeaponSelection::FindPrevWeaponInWeaponSelection(int iCu
 		}
 	}
 
+#if defined ( LUA_SDK )
+	iWeaponsInSlotPos = GetNumberOfWeaponsInSlotPos( iLowestPrevSlot, iLowestPrevPosition );
+	if ( iWeaponsInSlotPos > 1 )
+	{
+		for ( int i = MAX_WEAPONS - 1; i >= 0; i-- )
+		{
+			C_BaseCombatWeapon *pWeapon = pPlayer->GetWeapon(i);
+			if ( !pWeapon )
+				continue;
+
+			if ( CanBeSelectedInHUD( pWeapon ) )
+			{
+				int weaponSlot = pWeapon->GetSlot(), weaponPosition = pWeapon->GetPosition();
+
+				if ( weaponSlot == iLowestPrevSlot && weaponPosition == iLowestPrevPosition )
+				{
+					return pWeapon;
+				}
+			}
+		}
+	}
+#endif
+
 	return pPrevWeapon;
 }
 
@@ -1250,6 +1429,63 @@ int CHudWeaponSelection::GetLastPosInSlot( int iSlot ) const
 	return iMaxSlotPos;
 }
 
+#ifdef LUA_SDK
+//-----------------------------------------------------------------------------
+// Purpose: returns the # of the weapons in the specified position
+//-----------------------------------------------------------------------------
+int CHudWeaponSelection::GetNumberOfWeaponsInSlotPos( int iSlot, int iPos ) const
+{
+	C_BasePlayer *player = C_BasePlayer::GetLocalPlayer();
+	int iWeaponsInSlotPos;
+
+	if ( !player )
+		return -1;
+
+	iWeaponsInSlotPos = 0;
+	for ( int i = 0; i < MAX_WEAPONS; i++ )
+	{
+		C_BaseCombatWeapon *pWeapon = player->GetWeapon(i);
+		
+		if ( pWeapon == NULL )
+			continue;
+
+		if ( pWeapon->GetSlot() == iSlot && pWeapon->GetPosition() == iPos )
+			iWeaponsInSlotPos++;
+	}
+
+	return iWeaponsInSlotPos;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: returns the # of the selectable weapons in the specified position
+//-----------------------------------------------------------------------------
+int CHudWeaponSelection::GetNumberOfSelectableWeaponsInSlotPos( int iSlot, int iPos )
+{
+	C_BasePlayer *player = C_BasePlayer::GetLocalPlayer();
+	int iSelectableWeaponsInSlotPos;
+
+	if ( !player )
+		return -1;
+
+	iSelectableWeaponsInSlotPos = 0;
+	for ( int i = 0; i < MAX_WEAPONS; i++ )
+	{
+		C_BaseCombatWeapon *pWeapon = player->GetWeapon(i);
+		
+		if ( pWeapon == NULL )
+			continue;
+
+		if ( CanBeSelectedInHUD( pWeapon ) )
+		{
+			if ( pWeapon->GetSlot() == iSlot && pWeapon->GetPosition() == iPos )
+				iSelectableWeaponsInSlotPos++;
+		}
+	}
+
+	return iSelectableWeaponsInSlotPos;
+}
+#endif
+
 //-----------------------------------------------------------------------------
 // Purpose: returns the weapon in the specified slot
 //-----------------------------------------------------------------------------
@@ -1273,6 +1509,139 @@ C_BaseCombatWeapon *CHudWeaponSelection::GetWeaponInSlot( int iSlot, int iSlotPo
 	return NULL;
 }
 
+#ifdef LUA_SDK
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+C_BaseCombatWeapon *CHudWeaponSelection::GetNextActivePos( int iSlot, int iSlotPos )
+{
+	if ( iSlotPos >= MAX_WEAPON_POSITIONS || iSlot >= MAX_WEAPON_SLOTS )
+		return NULL;
+
+	int iLowestPosition = MAX_WEAPON_POSITIONS;
+	C_BaseCombatWeapon *pNextWeapon = NULL;
+
+	C_BasePlayer *player = C_BasePlayer::GetLocalPlayer();
+	if ( !player )
+		return NULL;
+	C_BaseCombatWeapon *pCurWeapon = IsInSelectionMode() ? GetSelectedWeapon() : NULL;
+	if ( pCurWeapon && ( pCurWeapon->GetSlot() != iSlot || pCurWeapon->GetPosition() != iSlotPos ) )
+		pCurWeapon = NULL;
+
+	int iWeaponsInSlotPos = GetNumberOfWeaponsInSlotPos( iSlot, iSlotPos );
+	if ( iWeaponsInSlotPos > 1 )
+	{
+		bool bCurrentWeaponFound = false;
+
+		for ( int i = 0; i < MAX_WEAPONS; i++ )
+		{
+			C_BaseCombatWeapon *pWeapon = player->GetWeapon(i);
+			if ( !pWeapon )
+				continue;
+
+			if ( CanBeSelectedInHUD( pWeapon ) )
+			{
+				int weaponSlot = pWeapon->GetSlot(), weaponPosition = pWeapon->GetPosition();
+
+				if ( weaponSlot == iSlot && weaponPosition == iSlotPos )
+				{
+					if ( !pCurWeapon )
+						return pWeapon;
+
+					if ( pWeapon == pCurWeapon )
+					{
+						bCurrentWeaponFound = true;
+					}
+					else if ( bCurrentWeaponFound )
+					{
+						return pWeapon;
+					}
+				}
+			}
+		}
+	}
+	for ( int i = 0; i < MAX_WEAPONS; i++ )
+	{
+		C_BaseCombatWeapon *pWeapon = player->GetWeapon( i );
+		if ( !pWeapon )
+			continue;
+
+		if ( CanBeSelectedInHUD( pWeapon ) && pWeapon->GetSlot() == iSlot )
+		{
+			// If this weapon is lower in the slot than the current lowest, and above our desired position, it's our new winner
+			if ( pWeapon->GetPosition() <= iLowestPosition && pWeapon->GetPosition() >= iSlotPos )
+			{
+				iLowestPosition = pWeapon->GetPosition();
+				pNextWeapon = pWeapon;
+			}
+		}
+	}
+
+	return pNextWeapon;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: returns the last weapon in the specified position
+//-----------------------------------------------------------------------------
+C_BaseCombatWeapon *CHudWeaponSelection::GetLastWeaponInSlotPos( int iSlot, int iPos )
+{
+	C_BasePlayer *player = C_BasePlayer::GetLocalPlayer();
+	int iWeaponsInSlotPos = GetNumberOfWeaponsInSlotPos( iSlot, iPos );
+
+	if ( !player )
+		return NULL;
+
+	int iWeaponsInSlotPosFound = 0;
+	for ( int i = 0; i < MAX_WEAPONS; i++ )
+	{
+		C_BaseCombatWeapon *pWeapon = player->GetWeapon(i);
+		
+		if ( pWeapon == NULL )
+			continue;
+
+		if ( pWeapon->GetSlot() == iSlot && pWeapon->GetPosition() == iPos )
+			iWeaponsInSlotPosFound++;
+
+		if ( iWeaponsInSlotPosFound == iWeaponsInSlotPos )
+			return pWeapon;
+	}
+
+	return NULL;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: returns the last selectable weapon in the specified position
+//-----------------------------------------------------------------------------
+C_BaseCombatWeapon *CHudWeaponSelection::GetLastSelectableWeaponInSlotPos( int iSlot, int iPos )
+{
+	C_BasePlayer *player = C_BasePlayer::GetLocalPlayer();
+	int iSelectableWeaponsInSlotPos = GetNumberOfSelectableWeaponsInSlotPos( iSlot, iPos );
+
+	if ( !player )
+		return NULL;
+
+	int iSelectableWeaponsInSlotPosFound = 0;
+	for ( int i = 0; i < MAX_WEAPONS; i++ )
+	{
+		C_BaseCombatWeapon *pWeapon = player->GetWeapon(i);
+		
+		if ( pWeapon == NULL )
+			continue;
+
+		if ( CanBeSelectedInHUD( pWeapon ) )
+		{
+			if ( pWeapon->GetSlot() == iSlot && pWeapon->GetPosition() == iPos )
+				iSelectableWeaponsInSlotPosFound++;
+
+			if ( iSelectableWeaponsInSlotPosFound == iSelectableWeaponsInSlotPos )
+				return pWeapon;
+		}
+	}
+
+	return NULL;
+}
+#endif
+
 //-----------------------------------------------------------------------------
 // Purpose: Opens the next weapon in the slot
 //-----------------------------------------------------------------------------
@@ -1460,7 +1829,18 @@ void CHudWeaponSelection::SelectWeaponSlot( int iSlot )
 			// start later in the list
 			if ( IsInSelectionMode() && pActiveWeapon && pActiveWeapon->GetSlot() == iSlot )
 			{
+#if !defined ( LUA_SDK )
 				slotPos = pActiveWeapon->GetPosition() + 1;
+#else
+				int weaponSlot = pActiveWeapon->GetSlot(), weaponPosition = pActiveWeapon->GetPosition();
+				int iWeaponsInSlotPos = GetNumberOfWeaponsInSlotPos( weaponSlot, weaponPosition );
+				// bool bLastWeaponInSlotPos = pActiveWeapon == GetLastWeaponInSlotPos( weaponSlot, weaponPosition );
+				bool bLastSelectableWeaponInSlotPos = pActiveWeapon == GetLastSelectableWeaponInSlotPos( weaponSlot, weaponPosition );
+
+				slotPos = pActiveWeapon->GetPosition() + ( ( iWeaponsInSlotPos > 1 &&
+															 // !bLastWeaponInSlotPos &&
+															 !bLastSelectableWeaponInSlotPos ) ? 0 : 1 );
+#endif
 			}
 
 			// find the weapon in this slot
diff --git a/src/game/client/hl2/vgui_rootpanel_hl2.cpp b/src/game/client/hl2/vgui_rootpanel_hl2.cpp
index 016b48a..37d8d9a 100644
--- a/src/game/client/hl2/vgui_rootpanel_hl2.cpp
+++ b/src/game/client/hl2/vgui_rootpanel_hl2.cpp
@@ -7,10 +7,37 @@
 #include "cbase.h"
 #include "vgui_int.h"
 #include "ienginevgui.h"
+#ifdef LUA_SDK
+#include "vgui/IVgui.h"
+#include "vgui_rootpanel_hl2.h"
+#include "clientmode_shared.h"
+#endif
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
+#ifdef LUA_SDK
+C_ScriptedBaseGameUIPanel *g_pScriptedBaseGameUIPanel = NULL;
+
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void VGUI_CreateGameUIRootPanel( void )
+{
+	g_pScriptedBaseGameUIPanel = new C_ScriptedBaseGameUIPanel( enginevgui->GetPanel( PANEL_GAMEUIDLL ) );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void VGUI_DestroyGameUIRootPanel( void )
+{
+	delete g_pScriptedBaseGameUIPanel;
+	g_pScriptedBaseGameUIPanel = NULL;
+}
+#endif
+
 //-----------------------------------------------------------------------------
 // Purpose: 
 //-----------------------------------------------------------------------------
@@ -35,3 +62,90 @@ vgui::VPANEL VGui_GetClientDLLRootPanel( void )
 	vgui::VPANEL root = enginevgui->GetPanel( PANEL_CLIENTDLL );
 	return root;
 }
+
+#ifdef LUA_SDK
+vgui::Panel *VGui_GetGameUIPanel( void )
+{
+	return g_pScriptedBaseGameUIPanel;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Game specific root panel
+// Output : vgui::Panel
+//-----------------------------------------------------------------------------
+vgui::Panel *VGui_GetClientLuaRootPanel( void )
+{
+	ClientModeShared *mode = ( ClientModeShared * )GetClientModeNormal();
+	vgui::Panel *pRoot = mode->m_pClientLuaPanel;
+	return pRoot;
+}
+#endif
+
+//-----------------------------------------------------------------------------
+// C_ScriptedBaseGameUIPanel implementation.
+//-----------------------------------------------------------------------------
+C_ScriptedBaseGameUIPanel::C_ScriptedBaseGameUIPanel( vgui::VPANEL parent )
+	: BaseClass( NULL, "ScriptedBaseGameUIPanel" )
+{
+	SetParent( parent );
+	SetPaintEnabled( false );
+	SetPaintBorderEnabled( false );
+	SetPaintBackgroundEnabled( false );
+
+	// This panel does post child painting
+	SetPostChildPaintEnabled( true );
+
+	// Make it screen sized
+	SetBounds( 0, 0, ScreenWidth(), ScreenHeight() );
+
+	// Ask for OnTick messages
+	vgui::ivgui()->AddTickSignal( GetVPanel() );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+C_ScriptedBaseGameUIPanel::~C_ScriptedBaseGameUIPanel( void )
+{
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void C_ScriptedBaseGameUIPanel::PostChildPaint()
+{
+	BaseClass::PostChildPaint();
+
+	// Draw all panel effects
+	RenderPanelEffects();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: For each panel effect, check if it wants to draw and draw it on
+//  this panel/surface if so
+//-----------------------------------------------------------------------------
+void C_ScriptedBaseGameUIPanel::RenderPanelEffects( void )
+{
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void C_ScriptedBaseGameUIPanel::OnTick( void )
+{
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Reset effects on level load/shutdown
+//-----------------------------------------------------------------------------
+void C_ScriptedBaseGameUIPanel::LevelInit( void )
+{
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void C_ScriptedBaseGameUIPanel::LevelShutdown( void )
+{
+}
+
diff --git a/src/game/client/hl2/vgui_rootpanel_hl2.h b/src/game/client/hl2/vgui_rootpanel_hl2.h
new file mode 100644
index 0000000..8aca184
--- /dev/null
+++ b/src/game/client/hl2/vgui_rootpanel_hl2.h
@@ -0,0 +1,56 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+//=============================================================================//
+
+#ifndef VGUI_ROOTPANEL_HL2_H
+#define VGUI_ROOTPANEL_HL2_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+#include <vgui_controls/Panel.h>
+#include <vgui_controls/EditablePanel.h>
+#include "UtlVector.h"
+
+
+class CPanelEffect;
+
+
+// Serial under of effect, for safe lookup
+typedef unsigned int EFFECT_HANDLE;
+
+//-----------------------------------------------------------------------------
+// Purpose: Sits between engine and client .dll panels
+//  Responsible for drawing screen overlays
+//-----------------------------------------------------------------------------
+class C_ScriptedBaseGameUIPanel : public vgui::Panel
+{
+	typedef vgui::Panel BaseClass;
+public:
+						C_ScriptedBaseGameUIPanel( vgui::VPANEL parent );
+	virtual				~C_ScriptedBaseGameUIPanel( void );
+
+	// Draw Panel effects here
+	virtual void		PostChildPaint();
+
+	// Clear list of Panel Effects
+	virtual void		LevelInit( void );
+	virtual void		LevelShutdown( void );
+
+	// Run effects and let them decide whether to remove themselves
+	void				OnTick( void );
+
+private:
+
+	// Render all panel effects
+	void		RenderPanelEffects( void );
+
+	// List of current panel effects
+	CUtlVector< CPanelEffect *> m_Effects;
+};
+
+
+#endif // VGUI_ROOTPANEL_HL2_H
diff --git a/src/game/client/hl2mp/c_hl2mp_player.cpp b/src/game/client/hl2mp/c_hl2mp_player.cpp
index 8762241..fd9b3e7 100644
--- a/src/game/client/hl2mp/c_hl2mp_player.cpp
+++ b/src/game/client/hl2mp/c_hl2mp_player.cpp
@@ -22,6 +22,18 @@
 #include "c_team.h"
 #include "obstacle_pushaway.h"
 
+#if defined( LUA_SDK )
+#include "luamanager.h"
+#include "lgametrace.h"
+#include "lhl2mp_player_shared.h"
+#include "ltakedamageinfo.h"
+#include "mathlib/lvector.h"
+#endif
+
+#if defined( ARGG )
+#include "iclientmode.h"
+#endif
+
 // Don't alias here
 #if defined( CHL2MP_Player )
 #undef CHL2MP_Player	
@@ -134,22 +146,57 @@ void C_HL2MP_Player::UpdateIDTarget()
 
 void C_HL2MP_Player::TraceAttack( const CTakeDamageInfo &info, const Vector &vecDir, trace_t *ptr )
 {
+#if defined ( LUA_SDK )
+	// Andrew; push a copy of the damageinfo/vector, bring the changes back out
+	// of Lua and set info/vecDir to the new value if it's been modified.
+	CTakeDamageInfo lInfo = info;
+	Vector lvecDir = vecDir;
+
+	BEGIN_LUA_CALL_HOOK( "PlayerTraceAttack" );
+		lua_pushhl2mpplayer( L, this );
+		lua_pushdamageinfo( L, lInfo );
+		lua_pushvector( L, lvecDir );
+		lua_pushtrace( L, *ptr );
+	END_LUA_CALL_HOOK( 4, 1 );
+
+	RETURN_LUA_NONE();
+#endif
+
+#if defined ( LUA_SDK )
+	Vector vecOrigin = ptr->endpos - lvecDir * 4;
+#else
 	Vector vecOrigin = ptr->endpos - vecDir * 4;
+#endif
 
 	float flDistance = 0.0f;
 	
+#if defined ( LUA_SDK )
+	if ( lInfo.GetAttacker() )
+	{
+		flDistance = (ptr->endpos - lInfo.GetAttacker()->GetAbsOrigin()).Length();
+	}
+#else
 	if ( info.GetAttacker() )
 	{
 		flDistance = (ptr->endpos - info.GetAttacker()->GetAbsOrigin()).Length();
 	}
+#endif
 
 	if ( m_takedamage )
 	{
+#if defined ( LUA_SDK )
+		AddMultiDamage( lInfo, this );
+#else
 		AddMultiDamage( info, this );
+#endif
 
 		int blood = BloodColor();
 		
+#if defined ( LUA_SDK )
+		CBaseEntity *pAttacker = lInfo.GetAttacker();
+#else
 		CBaseEntity *pAttacker = info.GetAttacker();
+#endif
 
 		if ( pAttacker )
 		{
@@ -159,8 +206,13 @@ void C_HL2MP_Player::TraceAttack( const CTakeDamageInfo &info, const Vector &vec
 
 		if ( blood != DONT_BLEED )
 		{
+#if defined ( LUA_SDK )
+			SpawnBlood( vecOrigin, lvecDir, blood, flDistance );// a little surface blood.
+			TraceBleed( flDistance, lvecDir, ptr, lInfo.GetDamageType() );
+#else
 			SpawnBlood( vecOrigin, vecDir, blood, flDistance );// a little surface blood.
 			TraceBleed( flDistance, vecDir, ptr, info.GetDamageType() );
+#endif
 		}
 	}
 }
@@ -480,8 +532,38 @@ void C_HL2MP_Player::UpdateFlashlight()
 			EyeVectors( &vecForward, &vecRight, &vecUp );
 
 
+#ifdef LUA_SDK
+		int nDistance = FLASHLIGHT_DISTANCE;
+
+		BEGIN_LUA_CALL_HOOK( "PlayerUpdateFlashlight" );
+			lua_pushhl2mpplayer( L, this );
+			lua_pushvector( L, position );
+			lua_pushvector( L, vecForward );
+			lua_pushvector( L, vecRight );
+			lua_pushvector( L, vecUp );
+			lua_pushinteger( L, nDistance );
+		END_LUA_CALL_HOOK( 6, 5 );
+
+		if ( lua_isuserdata( L, -5 ) && luaL_checkudata( L, -5, "Vector" ) )
+			VectorCopy( luaL_checkvector( L, -5 ), position );
+		if ( lua_isuserdata( L, -4 ) && luaL_checkudata( L, -4, "Vector" ) )
+			VectorCopy( luaL_checkvector( L, -4 ), vecForward );
+		if ( lua_isuserdata( L, -3 ) && luaL_checkudata( L, -3, "Vector" ) )
+			VectorCopy( luaL_checkvector( L, -3 ), vecRight );
+		if ( lua_isuserdata( L, -2 ) && luaL_checkudata( L, -2, "Vector" ) )
+			VectorCopy( luaL_checkvector( L, -2 ), vecUp );
+		if ( lua_isnumber( L, -1 ) )
+			nDistance = (int)lua_tointeger( L, -1 );
+
+		lua_pop( L, 5 );
+
+
+		// Update the light with the new position and direction.		
+		m_pHL2MPFlashLightEffect->UpdateLight( position, vecForward, vecRight, vecUp, nDistance );
+#else
 		// Update the light with the new position and direction.		
 		m_pHL2MPFlashLightEffect->UpdateLight( position, vecForward, vecRight, vecUp, FLASHLIGHT_DISTANCE );
+#endif
 	}
 	else if (m_pHL2MPFlashLightEffect)
 	{
diff --git a/src/game/client/hl2mp/clientmode_hl2mpnormal.cpp b/src/game/client/hl2mp/clientmode_hl2mpnormal.cpp
index 90da7dc..6a84d4f 100644
--- a/src/game/client/hl2mp/clientmode_hl2mpnormal.cpp
+++ b/src/game/client/hl2mp/clientmode_hl2mpnormal.cpp
@@ -18,6 +18,10 @@
 #include "hl2mpclientscoreboard.h"
 #include "hl2mptextwindow.h"
 #include "ienginevgui.h"
+#ifdef LUA_SDK
+#include "scriptedhudviewport.h"
+#include "scriptedclientluapanel.h"
+#endif
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
@@ -96,8 +100,15 @@ IViewPortPanel* CHudViewport::CreatePanelByName( const char *szPanelName )
 //-----------------------------------------------------------------------------
 ClientModeHL2MPNormal::ClientModeHL2MPNormal()
 {
+#ifdef LUA_SDK
+	m_pScriptedViewport = new CScriptedHudViewport();
+#endif
 	m_pViewport = new CHudViewport();
 	m_pViewport->Start( gameuifuncs, gameeventmanager );
+#ifdef LUA_SDK
+	m_pClientLuaPanel = new CScriptedClientLuaPanel();
+	m_pClientLuaPanel->Start( gameuifuncs, gameeventmanager );
+#endif
 }
 
 
diff --git a/src/game/client/hl2mp/clientmode_hl2mpnormal.h b/src/game/client/hl2mp/clientmode_hl2mpnormal.h
index 399576b..19133b5 100644
--- a/src/game/client/hl2mp/clientmode_hl2mpnormal.h
+++ b/src/game/client/hl2mp/clientmode_hl2mpnormal.h
@@ -16,7 +16,13 @@
 #include <vgui_controls/EditablePanel.h>
 #include <vgui/Cursor.h>
 
+#ifdef LUA_SDK
+class CScriptedHudViewport;
+#endif
 class CHudViewport;
+#ifdef LUA_SDK
+class CScriptedClientLuaPanel;
+#endif
 
 namespace vgui
 {
diff --git a/src/game/client/hl2mp/hud_deathnotice.cpp b/src/game/client/hl2mp/hud_deathnotice.cpp
index 355a824..810770d 100644
--- a/src/game/client/hl2mp/hud_deathnotice.cpp
+++ b/src/game/client/hl2mp/hud_deathnotice.cpp
@@ -271,7 +271,13 @@ void CHudDeathNotice::FireGameEvent( IGameEvent * event )
 	// the event should be "player_death"
 	int killer = engine->GetPlayerForUserID( event->GetInt("attacker") );
 	int victim = engine->GetPlayerForUserID( event->GetInt("userid") );
+#ifdef LUA_SDK
+	const char *killername = event->GetString( "attackername" );
+#endif
 	const char *killedwith = event->GetString( "weapon" );
+#ifdef LUA_SDK
+	const char *killedwithname = event->GetString( "weaponname" );
+#endif
 
 	char fullkilledwith[128];
 	if ( killedwith && *killedwith )
@@ -304,10 +310,25 @@ void CHudDeathNotice::FireGameEvent( IGameEvent * event )
 	DeathNoticeItem deathMsg;
 	deathMsg.Killer.iEntIndex = killer;
 	deathMsg.Victim.iEntIndex = victim;
+#ifndef LUA_SDK
 	Q_strncpy( deathMsg.Killer.szName, killer_name, MAX_PLAYER_NAME_LENGTH );
+#else
+	if ( killer )
+	{
+		Q_strncpy( deathMsg.Killer.szName, killer_name, MAX_PLAYER_NAME_LENGTH );
+	}
+	else
+	{
+		Q_strncpy( deathMsg.Killer.szName, killername, MAX_PLAYER_NAME_LENGTH );
+	}
+#endif
 	Q_strncpy( deathMsg.Victim.szName, victim_name, MAX_PLAYER_NAME_LENGTH );
 	deathMsg.flDisplayTime = gpGlobals->curtime + hud_deathnotice_time.GetFloat();
+#ifndef LUA_SDK
 	deathMsg.iSuicide = ( !killer || killer == victim );
+#else
+	deathMsg.iSuicide = ( killer == victim );
+#endif
 
 	// Try and find the death identifier in the icon list
 	deathMsg.iconDeath = gHUD.GetIcon( fullkilledwith );
@@ -339,10 +360,20 @@ void CHudDeathNotice::FireGameEvent( IGameEvent * event )
 	{
 		Q_snprintf( sDeathMsg, sizeof( sDeathMsg ), "%s killed %s", deathMsg.Killer.szName, deathMsg.Victim.szName );
 
+#ifndef LUA_SDK
 		if ( fullkilledwith && *fullkilledwith && (*fullkilledwith > 13 ) )
+#else
+		if ( fullkilledwith && *fullkilledwith && (*fullkilledwith > 13 ) && Q_strcmp( deathMsg.Killer.szName, killedwithname ) )
+#endif
 		{
 			Q_strncat( sDeathMsg, VarArgs( " with %s.\n", fullkilledwith+6 ), sizeof( sDeathMsg ), COPY_ALL_CHARACTERS );
 		}
+#ifdef LUA_SDK
+		else
+		{
+			Q_strncat( sDeathMsg, "\n", sizeof( sDeathMsg ), COPY_ALL_CHARACTERS );
+		}
+#endif
 	}
 
 	Msg( "%s", sDeathMsg );
diff --git a/src/game/client/hl2mp/ui/hl2mpclientscoreboard.cpp b/src/game/client/hl2mp/ui/hl2mpclientscoreboard.cpp
index 5aa4eb5..e7a9b68 100644
--- a/src/game/client/hl2mp/ui/hl2mpclientscoreboard.cpp
+++ b/src/game/client/hl2mp/ui/hl2mpclientscoreboard.cpp
@@ -25,6 +25,10 @@
 #include "voice_status.h"
 #include "vgui_avatarimage.h"
 
+#ifdef LUA_SDK
+#include "luamanager.h"
+#endif
+
 using namespace vgui;
 
 //-----------------------------------------------------------------------------
@@ -287,6 +291,31 @@ void CHL2MPClientScoreBoardDialog::UpdateTeamInfo()
 			const char *pDialogVarTeamScore = NULL;
 			const char *pDialogVarTeamPlayerCount = NULL;
 			const char *pDialogVarTeamPing = NULL;
+#if defined ( LUA_SDK )
+			wchar_t wgamemode[64];
+			const char *gamemode = NULL;
+			lua_getglobal( L, "_GAMEMODE" );
+			if ( lua_istable( L, -1 ) )
+			{
+				lua_getfield( L, -1, "Name" );
+				if ( lua_isstring( L, -1 ) )
+				{
+					lua_remove( L, -2 );
+					gamemode = lua_tostring( L, -1 );
+				}
+				else
+				{
+					lua_pop( L, 1 );
+					gamemode = "Half-Life 2: Sandbox";
+				}
+			}
+			else
+			{
+				gamemode = "Half-Life 2: Sandbox";
+			}
+			lua_pop( L, 1 );
+			g_pVGuiLocalize->ConvertANSIToUnicode( gamemode, wgamemode, sizeof( wgamemode ) );
+#endif
 			switch ( teamIndex ) 
 			{
 				case TEAM_REBELS:
@@ -302,7 +331,11 @@ void CHL2MPClientScoreBoardDialog::UpdateTeamInfo()
 					pDialogVarTeamPing = "c_teamping";
 					break;
 				case TEAM_UNASSIGNED:
+#if defined ( LUA_SDK )
+					teamName = wgamemode;
+#else
 					teamName = g_pVGuiLocalize->Find( "#HL2MP_ScoreBoard_DM" );
+#endif
 					pDialogVarTeamPlayerCount = "dm_playercount";
 					pDialogVarTeamPing = "dm_ping";
 					break;
diff --git a/src/game/client/hud.cpp b/src/game/client/hud.cpp
index 6314a69..e811a61 100644
--- a/src/game/client/hud.cpp
+++ b/src/game/client/hud.cpp
@@ -26,6 +26,9 @@
 #include <vgui_controls/AnimationController.h>
 #include <vgui/ISurface.h>
 #include "hud_lcd.h"
+#ifdef LUA_SDK
+#include "luamanager.h"
+#endif
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
@@ -174,6 +177,18 @@ void CHudElement::SetHiddenBits( int iBits )
 //-----------------------------------------------------------------------------
 bool CHudElement::ShouldDraw( void )
 {
+#if defined ( LUA_SDK )
+	C_BasePlayer *pPlayer = C_BasePlayer::GetLocalPlayer();
+	if ( pPlayer )
+	{
+		BEGIN_LUA_CALL_HOOK( "HudElementShouldDraw" );
+			lua_pushstring( L, GetName() );
+		END_LUA_CALL_HOOK( 1, 1 );
+
+		RETURN_LUA_BOOLEAN();
+	}
+#endif
+
 	bool bShouldDraw = ( !gHUD.IsHidden( m_iHiddenBits ) );
 
 	if ( bShouldDraw )
@@ -274,6 +289,9 @@ CHud::CHud()
 	SetDefLessFunc( m_RenderGroups );
 
 	m_flScreenShotTime = -1;
+#ifdef HL2SB
+	m_bSkipClear = false;
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -1056,8 +1074,16 @@ bool CHud::DoesRenderGroupExist( int iGroupIndex )
 //-----------------------------------------------------------------------------
 void CHud::UpdateHud( bool bActive )
 {
+#ifndef HL2SB
 	// clear the weapon bits.
 	gHUD.m_iKeyBits &= (~(IN_WEAPON1|IN_WEAPON2));
+#else
+	if ( !gHUD.m_bSkipClear )
+	{
+		// clear the weapon bits.
+		gHUD.m_iKeyBits &= (~(IN_WEAPON1|IN_WEAPON2));
+	}
+#endif
 
 	g_pClientMode->Update();
 
diff --git a/src/game/client/hud.h b/src/game/client/hud.h
index 7ea5a4c..5fe7f1f 100644
--- a/src/game/client/hud.h
+++ b/src/game/client/hud.h
@@ -190,6 +190,9 @@ public:
 public:
 
 	int							m_iKeyBits;
+#ifdef HL2SB
+	bool						m_bSkipClear;
+#endif
 #ifndef _XBOX
 	float						m_flMouseSensitivity;
 	float						m_flMouseSensitivityFactor;
diff --git a/src/game/client/iclassmap.h b/src/game/client/iclassmap.h
index adbc2b4..b7c3bd5 100644
--- a/src/game/client/iclassmap.h
+++ b/src/game/client/iclassmap.h
@@ -19,8 +19,16 @@ abstract_class IClassMap
 public:
 	virtual					~IClassMap() {}
 
+#ifdef LUA_SDK
+	virtual void			Add( const char *mapname, const char *classname, int size, DISPATCHFUNCTION factory = 0, bool scripted = false ) = 0;
+	virtual void			RemoveAllScripted( void ) = 0;
+#else
 	virtual void			Add( const char *mapname, const char *classname, int size, DISPATCHFUNCTION factory = 0 ) = 0;
+#endif
 	virtual char const		*Lookup( const char *classname ) = 0;
+#ifdef LUA_SDK
+	virtual DISPATCHFUNCTION FindFactory( const char *classname ) = 0;
+#endif
 	virtual C_BaseEntity	*CreateEntity( const char *mapname ) = 0;
 	virtual int				GetClassSize( const char *classname ) = 0;
 };
diff --git a/src/game/client/iclientmode.h b/src/game/client/iclientmode.h
index f972be1..48e1d5c 100644
--- a/src/game/client/iclientmode.h
+++ b/src/game/client/iclientmode.h
@@ -84,6 +84,12 @@ public:
 	virtual int		KeyInput( int down, ButtonCode_t keynum, const char *pszCurrentBinding ) = 0;
 	virtual void	StartMessageMode( int iMessageModeType ) = 0;
 	virtual vgui::Panel *GetMessagePanel() = 0;
+#ifdef ARGG
+	// adnan
+	// does this weapon need to override the view angles?
+	virtual bool	OverrideViewAngles( void ) = 0;
+	// end adnan
+#endif
 	virtual void	OverrideMouseInput( float *x, float *y ) = 0;
 	virtual bool	CreateMove( float flInputSampleTime, CUserCmd *cmd ) = 0;
 
diff --git a/src/game/client/in_main.cpp b/src/game/client/in_main.cpp
index 7a35b77..937a0c1 100644
--- a/src/game/client/in_main.cpp
+++ b/src/game/client/in_main.cpp
@@ -1456,7 +1456,8 @@ static ConCommand startgrenade1( "+grenade1", IN_Grenade1Down );
 static ConCommand endgrenade2( "-grenade2", IN_Grenade2Up );
 static ConCommand startgrenade2( "+grenade2", IN_Grenade2Down );
 
-#ifdef TF_CLIENT_DLL
+// #ifdef TF_CLIENT_DLL
+#if defined( TF_CLIENT_DLL ) || defined( HL2SB )
 static ConCommand toggle_duck( "toggle_duck", IN_DuckToggle );
 #endif
 
diff --git a/src/game/client/in_mouse.cpp b/src/game/client/in_mouse.cpp
index dd90ba1..62cd6b9 100644
--- a/src/game/client/in_mouse.cpp
+++ b/src/game/client/in_mouse.cpp
@@ -597,8 +597,18 @@ void CInput::MouseMove( CUserCmd *cmd )
 		ResetMouse();
 	}
 
+#ifdef ARGG
+	// adnan
+	// only set the new viewangles if we're not supposed to override them
+	if( !(g_pClientMode->OverrideViewAngles()) )
+	{
+#endif
 	// Store out the new viewangles.
 	engine->SetViewAngles( viewangles );
+#ifdef ARGG
+	} 
+	// end adnan
+#endif
 }
 
 //-----------------------------------------------------------------------------
diff --git a/src/game/client/iviewrender.h b/src/game/client/iviewrender.h
index cdd4395..3be28a1 100644
--- a/src/game/client/iviewrender.h
+++ b/src/game/client/iviewrender.h
@@ -83,6 +83,10 @@ public:
 	// Called to render just a particular setup ( for timerefresh and envmap creation )
 	virtual void		RenderView( const CViewSetup &view, int nClearFlags, int whatToDraw ) = 0;
 
+#ifdef HL2SB
+	virtual void        MP_PostSimulate() = 0;
+#endif
+
 	// What are we currently rendering? Returns a combination of DF_ flags.
 	virtual int GetDrawFlags() = 0;
 
diff --git a/src/game/client/lc_baseanimating.cpp b/src/game/client/lc_baseanimating.cpp
new file mode 100644
index 0000000..2762751
--- /dev/null
+++ b/src/game/client/lc_baseanimating.cpp
@@ -0,0 +1,1051 @@
+//===== Copy	right  1996-2005, Valve Corporation, All rights reserved. ==//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+#define lc_baseanimating_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lc_baseanimating.h"
+#include "lbaseentity_shared.h"
+#include "lbaseplayer_shared.h"
+#include "mathlib/lvector.h"
+#include "lvphysics_interface.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CBaseAnimating *lua_toanimating (lua_State *L, int idx) {
+  CBaseHandle *hEntity = dynamic_cast<CBaseHandle *>((CBaseHandle *)lua_touserdata(L, idx));
+  if (hEntity == NULL)
+    return NULL;
+  return dynamic_cast<lua_CBaseAnimating *>(hEntity->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushanimating (lua_State *L, CBaseAnimating *pEntity) {
+  CBaseHandle *hEntity = (CBaseHandle *)lua_newuserdata(L, sizeof(CBaseHandle));
+  hEntity->Set(pEntity);
+  luaL_getmetatable(L, "CBaseAnimating");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CBaseAnimating *luaL_checkanimating (lua_State *L, int narg) {
+  lua_CBaseAnimating *d = lua_toanimating(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "CBaseAnimating expected, got NULL entity");
+  return d;
+}
+
+
+static int CBaseAnimating_AddEntity (lua_State *L) {
+  luaL_checkanimating(L, 1)->AddEntity();
+  return 0;
+}
+
+static int CBaseAnimating_AddToClientSideAnimationList (lua_State *L) {
+  luaL_checkanimating(L, 1)->AddToClientSideAnimationList();
+  return 0;
+}
+
+static int CBaseAnimating_BecomeRagdollOnClient (lua_State *L) {
+  lua_pushanimating(L, luaL_checkanimating(L, 1)->BecomeRagdollOnClient());
+  return 1;
+}
+
+static int CBaseAnimating_CalculateIKLocks (lua_State *L) {
+  luaL_checkanimating(L, 1)->CalculateIKLocks(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_ClampCycle (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->ClampCycle(luaL_checknumber(L, 2), luaL_checkboolean(L, 3)));
+  return 1;
+}
+
+static int CBaseAnimating_Clear (lua_State *L) {
+  luaL_checkanimating(L, 1)->Clear();
+  return 0;
+}
+
+static int CBaseAnimating_ClearRagdoll (lua_State *L) {
+  luaL_checkanimating(L, 1)->ClearRagdoll();
+  return 0;
+}
+
+static int CBaseAnimating_ClientSideAnimationChanged (lua_State *L) {
+  luaL_checkanimating(L, 1)->ClientSideAnimationChanged();
+  return 0;
+}
+
+static int CBaseAnimating_ComputeClientSideAnimationFlags (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->ComputeClientSideAnimationFlags());
+  return 1;
+}
+
+static int CBaseAnimating_ComputeEntitySpaceHitboxSurroundingBox (lua_State *L) {
+  Vector pVecWorldMins, pVecWorldMaxs;
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->ComputeEntitySpaceHitboxSurroundingBox(&pVecWorldMins, &pVecWorldMaxs));
+  lua_pushvector(L, pVecWorldMins);
+  lua_pushvector(L, pVecWorldMaxs);
+  return 3;
+}
+
+static int CBaseAnimating_ComputeHitboxSurroundingBox (lua_State *L) {
+  Vector pVecWorldMins, pVecWorldMaxs;
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->ComputeHitboxSurroundingBox(&pVecWorldMins, &pVecWorldMaxs));
+  lua_pushvector(L, pVecWorldMins);
+  lua_pushvector(L, pVecWorldMaxs);
+  return 3;
+}
+
+static int CBaseAnimating_CreateRagdollCopy (lua_State *L) {
+  lua_pushanimating(L, luaL_checkanimating(L, 1)->CreateRagdollCopy());
+  return 1;
+}
+
+static int CBaseAnimating_CreateUnragdollInfo (lua_State *L) {
+  luaL_checkanimating(L, 1)->CreateUnragdollInfo(luaL_checkanimating(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_DisableMuzzleFlash (lua_State *L) {
+  luaL_checkanimating(L, 1)->DisableMuzzleFlash();
+  return 0;
+}
+
+static int CBaseAnimating_DispatchMuzzleEffect (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->DispatchMuzzleEffect(luaL_checkstring(L, 2), luaL_checkboolean(L, 3)));
+  return 1;
+}
+
+static int CBaseAnimating_DoMuzzleFlash (lua_State *L) {
+  luaL_checkanimating(L, 1)->DoMuzzleFlash();
+  return 0;
+}
+
+static int CBaseAnimating_DrawClientHitboxes (lua_State *L) {
+  luaL_checkanimating(L, 1)->DrawClientHitboxes(luaL_optnumber(L, 2, 0.0f), luaL_optboolean(L, 3, false));
+  return 0;
+}
+
+static int CBaseAnimating_DrawModel (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->DrawModel(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_FindBodygroupByName (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->FindBodygroupByName(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_FindFollowedEntity (lua_State *L) {
+  lua_pushanimating(L, luaL_checkanimating(L, 1)->FindFollowedEntity());
+  return 1;
+}
+
+static int CBaseAnimating_FindTransitionSequence (lua_State *L) {
+  int piDir;
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->FindTransitionSequence(luaL_checkint(L, 2), luaL_checkint(L, 3), &piDir));
+  lua_pushinteger(L, piDir);
+  return 2;
+}
+
+static int CBaseAnimating_FireEvent (lua_State *L) {
+  luaL_checkanimating(L, 1)->FireEvent(luaL_checkvector(L, 2), luaL_checkangle(L, 3), luaL_checkint(L, 4), luaL_checkstring(L, 5));
+  return 0;
+}
+
+static int CBaseAnimating_FireObsoleteEvent (lua_State *L) {
+  luaL_checkanimating(L, 1)->FireObsoleteEvent(luaL_checkvector(L, 2), luaL_checkangle(L, 3), luaL_checkint(L, 4), luaL_checkstring(L, 5));
+  return 0;
+}
+
+static int CBaseAnimating_ForceClientSideAnimationOn (lua_State *L) {
+  luaL_checkanimating(L, 1)->ForceClientSideAnimationOn();
+  return 0;
+}
+
+static int CBaseAnimating_FrameAdvance (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->FrameAdvance(luaL_optnumber(L, 2, 0.0f)));
+  return 1;
+}
+
+static int CBaseAnimating_GetAimEntOrigin (lua_State *L) {
+  luaL_checkanimating(L, 1)->GetAimEntOrigin(luaL_checkentity(L, 2), &luaL_checkvector(L, 3), &luaL_checkangle(L, 4));
+  return 0;
+}
+
+static int CBaseAnimating_GetAnimTimeInterval (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetAnimTimeInterval());
+  return 1;
+}
+
+static int CBaseAnimating_GetAttachment (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+      {
+        if (lua_gettop(L) <= 3)
+          lua_pushboolean(L, luaL_checkanimating(L, 1)->GetAttachment(luaL_checkint(L, 2), luaL_checkvector(L, 3)));
+        else
+          lua_pushboolean(L, luaL_checkanimating(L, 1)->GetAttachment(luaL_checkint(L, 2), luaL_checkvector(L, 3), luaL_checkangle(L, 4)));
+        break;
+      }
+	case LUA_TSTRING:
+	default:
+      {
+        if (lua_gettop(L) <= 3)
+          lua_pushboolean(L, luaL_checkanimating(L, 1)->GetAttachment(luaL_checkstring(L, 2), luaL_checkvector(L, 3)));
+        else
+          lua_pushboolean(L, luaL_checkanimating(L, 1)->GetAttachment(luaL_checkstring(L, 2), luaL_checkvector(L, 3), luaL_checkangle(L, 4)));
+        break;
+	  }
+  }
+  return 1;
+}
+
+static int CBaseAnimating_GetAttachmentLocal (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->GetAttachmentLocal(luaL_checkint(L, 2), luaL_checkvector(L, 3), luaL_checkangle(L, 4)));
+  return 1;
+}
+
+static int CBaseAnimating_GetAttachmentVelocity (lua_State *L) {
+  Vector originVel;
+  Quaternion angleVel;
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->GetAttachmentVelocity(luaL_checkint(L, 2), originVel, angleVel));
+  lua_pushvector(L, originVel);
+  // Todo: implement Quaternion class!!
+  // lua_pushquaternion(L, &angleVel);
+  return 2;
+}
+
+static int CBaseAnimating_GetBaseAnimating (lua_State *L) {
+  lua_pushanimating(L, luaL_checkanimating(L, 1)->GetBaseAnimating());
+  return 1;
+}
+
+static int CBaseAnimating_GetBlendedLinearVelocity (lua_State *L) {
+  Vector pVec;
+  luaL_checkanimating(L, 1)->GetBlendedLinearVelocity(&pVec);
+  lua_pushvector(L, pVec);
+  return 1;
+}
+
+static int CBaseAnimating_GetBody (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetBody());
+  return 1;
+}
+
+static int CBaseAnimating_GetBodygroup (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetBodygroup(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetBodygroupCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetBodygroupCount(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetBodygroupName (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetBodygroupName(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetBoneControllers (lua_State *L) {
+  float controllers[MAXSTUDIOBONECTRLS];
+  luaL_checkanimating(L, 1)->GetBoneControllers(controllers);
+  int i;
+  for( i=0; i < MAXSTUDIOBONECTRLS; i++)
+  {
+	  lua_pushnumber(L, controllers[ i ]);
+  }
+  return MAXSTUDIOBONECTRLS;
+}
+
+static int CBaseAnimating_GetBonePosition (lua_State *L) {
+  luaL_checkanimating(L, 1)->GetBonePosition(luaL_checkint(L, 2), luaL_checkvector(L, 3), luaL_checkangle(L, 4));
+  return 0;
+}
+
+static int CBaseAnimating_GetClientSideFade (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetClientSideFade());
+  return 1;
+}
+
+static int CBaseAnimating_GetCollideType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetCollideType());
+  return 1;
+}
+
+static int CBaseAnimating_GetCycle (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetCycle());
+  return 1;
+}
+
+static int CBaseAnimating_GetFlexControllerName (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetFlexControllerName((LocalFlexController_t)luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetFlexControllerType (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetFlexControllerType((LocalFlexController_t)luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetFlexDescFacs (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetFlexDescFacs(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetHitboxSet (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetHitboxSet());
+  return 1;
+}
+
+static int CBaseAnimating_GetHitboxSetCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetHitboxSetCount());
+  return 1;
+}
+
+static int CBaseAnimating_GetHitboxSetName (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetHitboxSetName());
+  return 1;
+}
+
+static int CBaseAnimating_GetModelWidthScale (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetModelWidthScale());
+  return 1;
+}
+
+static int CBaseAnimating_GetNumBodyGroups (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetNumBodyGroups());
+  return 1;
+}
+
+static int CBaseAnimating_GetNumFlexControllers (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetNumFlexControllers());
+  return 1;
+}
+
+static int CBaseAnimating_GetPlaybackRate (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetPlaybackRate());
+  return 1;
+}
+
+static int CBaseAnimating_GetPoseParameter (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetPoseParameter(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetPoseParameterRange (lua_State *L) {
+  float minValue, maxValue;
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->GetPoseParameterRange(luaL_checkint(L, 2), minValue, maxValue));
+  lua_pushnumber(L, minValue);
+  lua_pushnumber(L, maxValue);
+  return 3;
+}
+
+static int CBaseAnimating_GetRenderAngles (lua_State *L) {
+  QAngle v = luaL_checkanimating(L, 1)->GetRenderAngles();
+  lua_pushangle(L, v);
+  return 1;
+}
+
+static int CBaseAnimating_GetRenderBounds (lua_State *L) {
+  Vector theMins, theMaxs;
+  luaL_checkanimating(L, 1)->GetRenderBounds(theMins, theMaxs);
+  lua_pushvector(L, theMins);
+  lua_pushvector(L, theMaxs);
+  return 2;
+}
+
+static int CBaseAnimating_GetRenderOrigin (lua_State *L) {
+  Vector v = luaL_checkanimating(L, 1)->GetRenderOrigin();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseAnimating_GetSequence (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetSequence());
+  return 1;
+}
+
+static int CBaseAnimating_GetSequenceActivity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetSequenceActivity(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetSequenceActivityName (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetSequenceActivityName(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetSequenceGroundSpeed (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetSequenceGroundSpeed(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetSequenceLinearMotion (lua_State *L) {
+  Vector pVec;
+  luaL_checkanimating(L, 1)->GetSequenceLinearMotion(luaL_checkint(L, 2), &pVec);
+  lua_pushvector(L, pVec);
+  return 1;
+}
+
+static int CBaseAnimating_GetSequenceName (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetSequenceName(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetServerIntendedCycle (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetServerIntendedCycle());
+  return 1;
+}
+
+static int CBaseAnimating_GetSkin (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetSkin());
+  return 1;
+}
+
+static int CBaseAnimating_IgniteRagdoll (lua_State *L) {
+  luaL_checkanimating(L, 1)->IgniteRagdoll(luaL_checkanimating(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_InitBoneSetupThreadPool (lua_State *L) {
+  CBaseAnimating::InitBoneSetupThreadPool();
+  return 0;
+}
+
+static int CBaseAnimating_InitModelEffects (lua_State *L) {
+  luaL_checkanimating(L, 1)->InitModelEffects();
+  return 0;
+}
+
+static int CBaseAnimating_InternalDrawModel (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->InternalDrawModel(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_Interpolate (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->Interpolate(luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_InvalidateBoneCache (lua_State *L) {
+  luaL_checkanimating(L, 1)->InvalidateBoneCache();
+  return 0;
+}
+
+static int CBaseAnimating_InvalidateBoneCaches (lua_State *L) {
+  CBaseAnimating::InvalidateBoneCaches();
+  return 0;
+}
+
+static int CBaseAnimating_InvalidateMdlCache (lua_State *L) {
+  luaL_checkanimating(L, 1)->InvalidateMdlCache();
+  return 0;
+}
+
+static int CBaseAnimating_IsActivityFinished (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsActivityFinished());
+  return 1;
+}
+
+static int CBaseAnimating_IsBoneCacheValid (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsBoneCacheValid());
+  return 1;
+}
+
+static int CBaseAnimating_IsOnFire (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsOnFire());
+  return 1;
+}
+
+static int CBaseAnimating_IsRagdoll (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsRagdoll());
+  return 1;
+}
+
+static int CBaseAnimating_IsSelfAnimating (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsSelfAnimating());
+  return 1;
+}
+
+static int CBaseAnimating_IsSequenceFinished (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsSequenceFinished());
+  return 1;
+}
+
+static int CBaseAnimating_IsSequenceLooping (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsSequenceLooping(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_IsViewModel (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsViewModel());
+  return 1;
+}
+
+static int CBaseAnimating_LookupActivity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->LookupActivity(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_LookupAttachment (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->LookupAttachment(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_LookupBone (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->LookupBone(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_LookupPoseParameter (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->LookupPoseParameter(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_LookupRandomAttachment (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->LookupRandomAttachment(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_LookupSequence (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->LookupSequence(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_NotifyShouldTransmit (lua_State *L) {
+  luaL_checkanimating(L, 1)->NotifyShouldTransmit((ShouldTransmitState_t)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_OnDataChanged (lua_State *L) {
+  luaL_checkanimating(L, 1)->OnDataChanged((DataUpdateType_t)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_OnPreDataChanged (lua_State *L) {
+  luaL_checkanimating(L, 1)->OnPreDataChanged((DataUpdateType_t)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_PopBoneAccess (lua_State *L) {
+  C_BaseAnimating::PopBoneAccess(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int CBaseAnimating_PostDataUpdate (lua_State *L) {
+  luaL_checkanimating(L, 1)->PostDataUpdate((DataUpdateType_t)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_PreDataUpdate (lua_State *L) {
+  luaL_checkanimating(L, 1)->PreDataUpdate((DataUpdateType_t)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_ProcessMuzzleFlashEvent (lua_State *L) {
+  luaL_checkanimating(L, 1)->ProcessMuzzleFlashEvent();
+  return 0;
+}
+
+static int CBaseAnimating_PushAllowBoneAccess (lua_State *L) {
+  C_BaseAnimating::PushAllowBoneAccess(luaL_checkboolean(L, 1), luaL_checkboolean(L, 2), luaL_checkstring(L, 3));
+  return 0;
+}
+
+static int CBaseAnimating_RagdollMoved (lua_State *L) {
+  luaL_checkanimating(L, 1)->RagdollMoved();
+  return 0;
+}
+
+static int CBaseAnimating_Release (lua_State *L) {
+  luaL_checkanimating(L, 1)->Release();
+  return 0;
+}
+
+static int CBaseAnimating_RemoveFromClientSideAnimationList (lua_State *L) {
+  luaL_checkanimating(L, 1)->RemoveFromClientSideAnimationList();
+  return 0;
+}
+
+static int CBaseAnimating_ResetEventsParity (lua_State *L) {
+  luaL_checkanimating(L, 1)->ResetEventsParity();
+  return 0;
+}
+
+static int CBaseAnimating_ResetLatched (lua_State *L) {
+  luaL_checkanimating(L, 1)->ResetLatched();
+  return 0;
+}
+
+static int CBaseAnimating_ResetSequence (lua_State *L) {
+  luaL_checkanimating(L, 1)->ResetSequence(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_ResetSequenceInfo (lua_State *L) {
+  luaL_checkanimating(L, 1)->ResetSequenceInfo();
+  return 0;
+}
+
+static int CBaseAnimating_RetrieveRagdollInfo (lua_State *L) {
+  Vector pos;
+  Quaternion q;
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->RetrieveRagdollInfo(&pos, &q));
+  lua_pushvector(L, pos);
+  // Todo: implement Quaternion class!!
+  // lua_pushquaternion(L, &q);
+  return 2;
+}
+
+static int CBaseAnimating_SelectWeightedSequence (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->SelectWeightedSequence(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_SequenceDuration (lua_State *L) {
+  if (lua_isnoneornil(L, 2))
+    lua_pushnumber(L, luaL_checkanimating(L, 1)->SequenceDuration());
+  else
+	lua_pushnumber(L, luaL_checkanimating(L, 1)->SequenceDuration(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_SequenceLoops (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->SequenceLoops());
+  return 1;
+}
+
+static int CBaseAnimating_SetBodygroup (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetBodygroup(luaL_checkint(L, 2), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int CBaseAnimating_SetBoneController (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->SetBoneController(luaL_checkint(L, 2), luaL_checknumber(L, 3)));
+  return 1;
+}
+
+static int CBaseAnimating_SetCycle (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetCycle(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetHitboxSet (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetHitboxSet(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetHitboxSetByName (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetHitboxSetByName(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetModelWidthScale (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetModelWidthScale(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetPlaybackRate (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetPlaybackRate(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetPoseParameter (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+	  lua_pushnumber(L, luaL_checkanimating(L, 1)->SetPoseParameter(luaL_checkint(L, 2), luaL_checknumber(L, 3)));
+	  break;
+	case LUA_TSTRING:
+	default:
+	  lua_pushnumber(L, luaL_checkanimating(L, 1)->SetPoseParameter(luaL_checkstring(L, 2), luaL_checknumber(L, 3)));
+	  break;
+  }
+  return 1;
+}
+
+static int CBaseAnimating_SetPredictable (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetPredictable(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetPredictionEligible (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetPredictionEligible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetPredictionPlayer (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetPredictionPlayer(luaL_checkplayer(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetReceivedSequence (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetReceivedSequence();
+  return 0;
+}
+
+static int CBaseAnimating_SetSequence (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetSequence(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetServerIntendedCycle (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetServerIntendedCycle(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_ShadowCastType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->ShadowCastType());
+  return 1;
+}
+
+static int CBaseAnimating_ShouldMuzzleFlash (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->ShouldMuzzleFlash());
+  return 1;
+}
+
+static int CBaseAnimating_ShouldResetSequenceOnNewModel (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->ShouldResetSequenceOnNewModel());
+  return 1;
+}
+
+static int CBaseAnimating_ShutdownBoneSetupThreadPool (lua_State *L) {
+  CBaseAnimating::ShutdownBoneSetupThreadPool();
+  return 0;
+}
+
+static int CBaseAnimating_Simulate (lua_State *L) {
+  luaL_checkanimating(L, 1)->Simulate();
+  return 0;
+}
+
+static int CBaseAnimating_StudioFrameAdvance (lua_State *L) {
+  luaL_checkanimating(L, 1)->StudioFrameAdvance();
+  return 0;
+}
+
+static int CBaseAnimating_ThreadedBoneSetup (lua_State *L) {
+  CBaseAnimating::ThreadedBoneSetup();
+  return 0;
+}
+
+static int CBaseAnimating_TransferDissolveFrom (lua_State *L) {
+  luaL_checkanimating(L, 1)->TransferDissolveFrom(luaL_checkanimating(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_UncorrectViewModelAttachment (lua_State *L) {
+  luaL_checkanimating(L, 1)->UncorrectViewModelAttachment(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_UpdateClientSideAnimation (lua_State *L) {
+  luaL_checkanimating(L, 1)->UpdateClientSideAnimation();
+  return 0;
+}
+
+static int CBaseAnimating_UpdateClientSideAnimations (lua_State *L) {
+  CBaseAnimating::UpdateClientSideAnimations();
+  return 0;
+}
+
+static int CBaseAnimating_UpdateIKLocks (lua_State *L) {
+  luaL_checkanimating(L, 1)->UpdateIKLocks(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_UseClientSideAnimation (lua_State *L) {
+  luaL_checkanimating(L, 1)->UseClientSideAnimation();
+  return 0;
+}
+
+static int CBaseAnimating_UsesPowerOfTwoFrameBufferTexture (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->UsesPowerOfTwoFrameBufferTexture());
+  return 1;
+}
+
+static int CBaseAnimating_VPhysicsGetObjectList (lua_State *L) {
+  IPhysicsObject *pList[VPHYSICS_MAX_OBJECT_LIST_COUNT];
+  int count = luaL_checkanimating(L, 1)->VPhysicsGetObjectList( pList, ARRAYSIZE(pList) );
+  lua_pushinteger(L, count);
+  lua_newtable(L);
+  for( int i = 0 ; i < count ; i++ )
+  {
+	  lua_pushinteger(L, i);
+	  lua_pushphysicsobject(L, pList[i]);
+	  lua_settable(L, -3);
+  }
+  return 2;
+}
+
+static int CBaseAnimating_VPhysicsUpdate (lua_State *L) {
+  luaL_checkanimating(L, 1)->VPhysicsUpdate(luaL_checkphysicsobject(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating___index (lua_State *L) {
+  CBaseAnimating *pEntity = lua_toanimating(L, 1);
+  if (pEntity == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  if (pEntity->m_nTableReference != LUA_NOREF) {
+    lua_getref(L, pEntity->m_nTableReference);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      lua_getmetatable(L, 1);
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "CBaseEntity");
+        lua_pushvalue(L, 2);
+        lua_gettable(L, -2);
+      }
+    }
+  }
+  else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      luaL_getmetatable(L, "CBaseEntity");
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+    }
+  }
+  return 1;
+}
+
+static int CBaseAnimating___newindex (lua_State *L) {
+  CBaseAnimating *pEntity = lua_toanimating(L, 1);
+  if (pEntity == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "m_bClientSideAnimation") == 0)
+    pEntity->m_bClientSideAnimation = luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_bLastClientSideFrameReset") == 0)
+    pEntity->m_bLastClientSideFrameReset = luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_nBody") == 0)
+    pEntity->m_nBody = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_nHitboxSet") == 0)
+    pEntity->m_nHitboxSet = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_nSkin") == 0)
+    pEntity->m_nSkin = luaL_checkint(L, 3);
+  else {
+    if (pEntity->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      pEntity->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, pEntity->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, field);
+	lua_pop(L, 1);
+  }
+  return 0;
+}
+
+static int CBaseAnimating___eq (lua_State *L) {
+  lua_pushboolean(L, lua_toanimating(L, 1) == lua_toanimating(L, 2));
+  return 1;
+}
+
+static int CBaseAnimating___tostring (lua_State *L) {
+  CBaseAnimating *pEntity = lua_toanimating(L, 1);
+  if (pEntity == NULL)
+    lua_pushstring(L, "NULL");
+  else
+    lua_pushfstring(L, "CBaseAnimating: %d \"%s\"", pEntity->entindex(), pEntity->GetClassname());
+  return 1;
+}
+
+
+static const luaL_Reg CBaseAnimatingmeta[] = {
+  {"AddEntity", CBaseAnimating_AddEntity},
+  {"AddToClientSideAnimationList", CBaseAnimating_AddToClientSideAnimationList},
+  {"BecomeRagdollOnClient", CBaseAnimating_BecomeRagdollOnClient},
+  {"CalculateIKLocks", CBaseAnimating_CalculateIKLocks},
+  {"ClampCycle", CBaseAnimating_ClampCycle},
+  {"Clear", CBaseAnimating_Clear},
+  {"ClearRagdoll", CBaseAnimating_ClearRagdoll},
+  {"ClientSideAnimationChanged", CBaseAnimating_ClientSideAnimationChanged},
+  {"ComputeClientSideAnimationFlags", CBaseAnimating_ComputeClientSideAnimationFlags},
+  {"ComputeEntitySpaceHitboxSurroundingBox", CBaseAnimating_ComputeEntitySpaceHitboxSurroundingBox},
+  {"ComputeHitboxSurroundingBox", CBaseAnimating_ComputeHitboxSurroundingBox},
+  {"CreateRagdollCopy", CBaseAnimating_CreateRagdollCopy},
+  {"CreateUnragdollInfo", CBaseAnimating_CreateUnragdollInfo},
+  {"DisableMuzzleFlash", CBaseAnimating_DisableMuzzleFlash},
+  {"DispatchMuzzleEffect", CBaseAnimating_DispatchMuzzleEffect},
+  {"DoMuzzleFlash", CBaseAnimating_DoMuzzleFlash},
+  {"DrawClientHitboxes", CBaseAnimating_DrawClientHitboxes},
+  {"DrawModel", CBaseAnimating_DrawModel},
+  {"FindBodygroupByName", CBaseAnimating_FindBodygroupByName},
+  {"FindFollowedEntity", CBaseAnimating_FindFollowedEntity},
+  {"FindTransitionSequence", CBaseAnimating_FindTransitionSequence},
+  {"FireEvent", CBaseAnimating_FireEvent},
+  {"FireObsoleteEvent", CBaseAnimating_FireObsoleteEvent},
+  {"ForceClientSideAnimationOn", CBaseAnimating_ForceClientSideAnimationOn},
+  {"FrameAdvance", CBaseAnimating_FrameAdvance},
+  {"GetAimEntOrigin", CBaseAnimating_GetAimEntOrigin},
+  {"GetAnimTimeInterval", CBaseAnimating_GetAnimTimeInterval},
+  {"GetAttachment", CBaseAnimating_GetAttachment},
+  {"GetAttachmentLocal", CBaseAnimating_GetAttachmentLocal},
+  {"GetAttachmentVelocity", CBaseAnimating_GetAttachmentVelocity},
+  {"GetBaseAnimating", CBaseAnimating_GetBaseAnimating},
+  {"GetBlendedLinearVelocity", CBaseAnimating_GetBlendedLinearVelocity},
+  {"GetBody", CBaseAnimating_GetBody},
+  {"GetBodygroup", CBaseAnimating_GetBodygroup},
+  {"GetBodygroupCount", CBaseAnimating_GetBodygroupCount},
+  {"GetBodygroupName", CBaseAnimating_GetBodygroupName},
+  {"GetBoneControllers", CBaseAnimating_GetBoneControllers},
+  {"GetBonePosition", CBaseAnimating_GetBonePosition},
+  {"GetClientSideFade", CBaseAnimating_GetClientSideFade},
+  {"GetCollideType", CBaseAnimating_GetCollideType},
+  {"GetCycle", CBaseAnimating_GetCycle},
+  {"GetFlexControllerName", CBaseAnimating_GetFlexControllerName},
+  {"GetFlexControllerType", CBaseAnimating_GetFlexControllerType},
+  {"GetFlexDescFacs", CBaseAnimating_GetFlexDescFacs},
+  {"GetHitboxSet", CBaseAnimating_GetHitboxSet},
+  {"GetHitboxSetCount", CBaseAnimating_GetHitboxSetCount},
+  {"GetHitboxSetName", CBaseAnimating_GetHitboxSetName},
+  {"GetModelWidthScale", CBaseAnimating_GetModelWidthScale},
+  {"GetNumBodyGroups", CBaseAnimating_GetNumBodyGroups},
+  {"GetNumFlexControllers", CBaseAnimating_GetNumFlexControllers},
+  {"GetPlaybackRate", CBaseAnimating_GetPlaybackRate},
+  {"GetPoseParameter", CBaseAnimating_GetPoseParameter},
+  {"GetPoseParameterRange", CBaseAnimating_GetPoseParameterRange},
+  {"GetRenderAngles", CBaseAnimating_GetRenderAngles},
+  {"GetRenderBounds", CBaseAnimating_GetRenderBounds},
+  {"GetRenderOrigin", CBaseAnimating_GetRenderOrigin},
+  {"GetSequence", CBaseAnimating_GetSequence},
+  {"GetSequenceActivity", CBaseAnimating_GetSequenceActivity},
+  {"GetSequenceActivityName", CBaseAnimating_GetSequenceActivityName},
+  {"GetSequenceGroundSpeed", CBaseAnimating_GetSequenceGroundSpeed},
+  {"GetSequenceLinearMotion", CBaseAnimating_GetSequenceLinearMotion},
+  {"GetSequenceName", CBaseAnimating_GetSequenceName},
+  {"GetServerIntendedCycle", CBaseAnimating_GetServerIntendedCycle},
+  {"GetSkin", CBaseAnimating_GetSkin},
+  {"IgniteRagdoll", CBaseAnimating_IgniteRagdoll},
+  {"InitBoneSetupThreadPool", CBaseAnimating_InitBoneSetupThreadPool},
+  {"InitModelEffects", CBaseAnimating_InitModelEffects},
+  {"InternalDrawModel", CBaseAnimating_InternalDrawModel},
+  {"Interpolate", CBaseAnimating_Interpolate},
+  {"InvalidateBoneCache", CBaseAnimating_InvalidateBoneCache},
+  {"InvalidateBoneCaches", CBaseAnimating_InvalidateBoneCaches},
+  {"InvalidateMdlCache", CBaseAnimating_InvalidateMdlCache},
+  {"IsActivityFinished", CBaseAnimating_IsActivityFinished},
+  {"IsBoneCacheValid", CBaseAnimating_IsBoneCacheValid},
+  {"IsOnFire", CBaseAnimating_IsOnFire},
+  {"IsRagdoll", CBaseAnimating_IsRagdoll},
+  {"IsSelfAnimating", CBaseAnimating_IsSelfAnimating},
+  {"IsSequenceFinished", CBaseAnimating_IsSequenceFinished},
+  {"IsSequenceLooping", CBaseAnimating_IsSequenceLooping},
+  {"IsViewModel", CBaseAnimating_IsViewModel},
+  {"LookupActivity", CBaseAnimating_LookupActivity},
+  {"LookupAttachment", CBaseAnimating_LookupAttachment},
+  {"LookupBone", CBaseAnimating_LookupBone},
+  {"LookupPoseParameter", CBaseAnimating_LookupPoseParameter},
+  {"LookupRandomAttachment", CBaseAnimating_LookupRandomAttachment},
+  {"LookupSequence", CBaseAnimating_LookupSequence},
+  {"NotifyShouldTransmit", CBaseAnimating_NotifyShouldTransmit},
+  {"OnDataChanged", CBaseAnimating_OnDataChanged},
+  {"OnPreDataChanged", CBaseAnimating_OnPreDataChanged},
+  {"PopBoneAccess", CBaseAnimating_PopBoneAccess},
+  {"PostDataUpdate", CBaseAnimating_PostDataUpdate},
+  {"PreDataUpdate", CBaseAnimating_PreDataUpdate},
+  {"ProcessMuzzleFlashEvent", CBaseAnimating_ProcessMuzzleFlashEvent},
+  {"PushAllowBoneAccess", CBaseAnimating_PushAllowBoneAccess},
+  {"RagdollMoved", CBaseAnimating_RagdollMoved},
+  {"Release", CBaseAnimating_Release},
+  {"RemoveFromClientSideAnimationList", CBaseAnimating_RemoveFromClientSideAnimationList},
+  {"ResetEventsParity", CBaseAnimating_ResetEventsParity},
+  {"ResetLatched", CBaseAnimating_ResetLatched},
+  {"ResetSequence", CBaseAnimating_ResetSequence},
+  {"ResetSequenceInfo", CBaseAnimating_ResetSequenceInfo},
+  {"RetrieveRagdollInfo", CBaseAnimating_RetrieveRagdollInfo},
+  {"SelectWeightedSequence", CBaseAnimating_SelectWeightedSequence},
+  {"SequenceDuration", CBaseAnimating_SequenceDuration},
+  {"SequenceLoops", CBaseAnimating_SequenceLoops},
+  {"SetBodygroup", CBaseAnimating_SetBodygroup},
+  {"SetBoneController", CBaseAnimating_SetBoneController},
+  {"SetCycle", CBaseAnimating_SetCycle},
+  {"SetHitboxSet", CBaseAnimating_SetHitboxSet},
+  {"SetHitboxSetByName", CBaseAnimating_SetHitboxSetByName},
+  {"SetModelWidthScale", CBaseAnimating_SetModelWidthScale},
+  {"SetPlaybackRate", CBaseAnimating_SetPlaybackRate},
+  {"SetPoseParameter", CBaseAnimating_SetPoseParameter},
+  {"SetPredictable", CBaseAnimating_SetPredictable},
+  {"SetPredictionEligible", CBaseAnimating_SetPredictionEligible},
+  {"SetPredictionPlayer", CBaseAnimating_SetPredictionPlayer},
+  {"SetReceivedSequence", CBaseAnimating_SetReceivedSequence},
+  {"SetSequence", CBaseAnimating_SetSequence},
+  {"SetServerIntendedCycle", CBaseAnimating_SetServerIntendedCycle},
+  {"ShadowCastType", CBaseAnimating_ShadowCastType},
+  {"ShouldMuzzleFlash", CBaseAnimating_ShouldMuzzleFlash},
+  {"ShouldResetSequenceOnNewModel", CBaseAnimating_ShouldResetSequenceOnNewModel},
+  {"ShutdownBoneSetupThreadPool", CBaseAnimating_ShutdownBoneSetupThreadPool},
+  {"Simulate", CBaseAnimating_Simulate},
+  {"StudioFrameAdvance", CBaseAnimating_StudioFrameAdvance},
+  {"ThreadedBoneSetup", CBaseAnimating_ThreadedBoneSetup},
+  {"TransferDissolveFrom", CBaseAnimating_TransferDissolveFrom},
+  {"UncorrectViewModelAttachment", CBaseAnimating_UncorrectViewModelAttachment},
+  {"UpdateClientSideAnimation", CBaseAnimating_UpdateClientSideAnimation},
+  {"UpdateClientSideAnimations", CBaseAnimating_UpdateClientSideAnimations},
+  {"UpdateIKLocks", CBaseAnimating_UpdateIKLocks},
+  {"UseClientSideAnimation", CBaseAnimating_UseClientSideAnimation},
+  {"UsesPowerOfTwoFrameBufferTexture", CBaseAnimating_UsesPowerOfTwoFrameBufferTexture},
+  {"VPhysicsGetObjectList", CBaseAnimating_VPhysicsGetObjectList},
+  {"VPhysicsUpdate", CBaseAnimating_VPhysicsUpdate},
+  {"__index", CBaseAnimating___index},
+  {"__newindex", CBaseAnimating___newindex},
+  {"__eq", CBaseAnimating___eq},
+  {"__tostring", CBaseAnimating___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CBaseAnimating object
+*/
+LUALIB_API int luaopen_CBaseAnimating (lua_State *L) {
+  luaL_newmetatable(L, LUA_BASEANIMATINGLIBNAME);
+  luaL_register(L, NULL, CBaseAnimatingmeta);
+  lua_pushstring(L, "entity");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "entity" */
+  return 1;
+}
+
diff --git a/src/game/client/lc_baseanimating.h b/src/game/client/lc_baseanimating.h
new file mode 100644
index 0000000..da103ac
--- /dev/null
+++ b/src/game/client/lc_baseanimating.h
@@ -0,0 +1,37 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $Workfile:     $
+// $NoKeywords: $
+//=============================================================================//
+#ifndef LC_BASEANIMATING_H
+#define LC_BASEANIMATING_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for C_BaseAnimating functions */
+typedef C_BaseAnimating lua_CBaseAnimating;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CBaseAnimating     *(lua_toanimating) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushanimating) (lua_State *L, lua_CBaseAnimating *pEntity);
+
+
+
+LUALIB_API lua_CBaseAnimating *(luaL_checkanimating) (lua_State *L, int narg);
+
+
+#endif // LC_BASEANIMATING_H
diff --git a/src/game/client/lc_baseentity.cpp b/src/game/client/lc_baseentity.cpp
new file mode 100644
index 0000000..c924c7e
--- /dev/null
+++ b/src/game/client/lc_baseentity.cpp
@@ -0,0 +1,184 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+#define lc_baseentity_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lbaseentity_shared.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+static int CBaseEntity_SpawnClientEntity (lua_State *L) {
+  luaL_checkentity(L, 1)->SpawnClientEntity();
+  return 0;
+}
+
+static int CBaseEntity_Interp_HierarchyUpdateInterpolationAmounts (lua_State *L) {
+  luaL_checkentity(L, 1)->Interp_HierarchyUpdateInterpolationAmounts();
+  return 0;
+}
+
+static int CBaseEntity_Init (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->Init(luaL_checkint(L, 2), luaL_checkint(L, 3)));
+  return 1;
+}
+
+static int CBaseEntity_Term (lua_State *L) {
+  luaL_checkentity(L, 1)->Term();
+  return 0;
+}
+
+static int CBaseEntity_EnableInToolView (lua_State *L) {
+  luaL_checkentity(L, 1)->EnableInToolView(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_IsEnabledInToolView (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsEnabledInToolView());
+  return 1;
+}
+
+static int CBaseEntity_SetToolRecording (lua_State *L) {
+  luaL_checkentity(L, 1)->SetToolRecording(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_IsToolRecording (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsToolRecording());
+  return 1;
+}
+
+static int CBaseEntity_HasRecordedThisFrame (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->HasRecordedThisFrame());
+  return 1;
+}
+
+static int CBaseEntity_RecordToolMessage (lua_State *L) {
+  luaL_checkentity(L, 1)->RecordToolMessage();
+  return 0;
+}
+
+static int CBaseEntity_DontRecordInTools (lua_State *L) {
+  luaL_checkentity(L, 1)->DontRecordInTools();
+  return 0;
+}
+
+static int CBaseEntity_ShouldRecordInTools (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->ShouldRecordInTools());
+  return 1;
+}
+
+static int CBaseEntity_Release (lua_State *L) {
+  luaL_checkentity(L, 1)->Release();
+  return 0;
+}
+
+static int CBaseEntity_GetRenderOrigin (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->GetRenderOrigin();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_GetRenderAngles (lua_State *L) {
+  QAngle v = luaL_checkentity(L, 1)->GetRenderAngles();
+  lua_pushangle(L, v);
+  return 1;
+}
+
+static int CBaseEntity_GetObserverCamOrigin (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->GetObserverCamOrigin();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_IsTwoPass (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsTwoPass());
+  return 1;
+}
+
+static int CBaseEntity_UsesPowerOfTwoFrameBufferTexture (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->UsesPowerOfTwoFrameBufferTexture());
+  return 1;
+}
+
+static int CBaseEntity_UsesFullFrameBufferTexture (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->UsesFullFrameBufferTexture());
+  return 1;
+}
+
+static int CBaseEntity_DrawModel (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->DrawModel(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_ComputeFxBlend (lua_State *L) {
+  luaL_checkentity(L, 1)->ComputeFxBlend();
+  return 0;
+}
+
+static int CBaseEntity_GetFxBlend (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetFxBlend());
+  return 1;
+}
+
+static int CBaseEntity_LODTest (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->LODTest());
+  return 1;
+}
+
+static int CBaseEntity_SetNextClientThink (lua_State *L) {
+  luaL_checkentity(L, 1)->SetNextClientThink(luaL_checknumber(L, 2));
+  return 0;
+}
+
+
+static const luaL_Reg CBaseEntitymeta[] = {
+  {"SpawnClientEntity", CBaseEntity_SpawnClientEntity},
+  {"Interp_HierarchyUpdateInterpolationAmounts", CBaseEntity_Interp_HierarchyUpdateInterpolationAmounts},
+  {"Init", CBaseEntity_Init},
+  {"Term", CBaseEntity_Term},
+  {"EnableInToolView", CBaseEntity_EnableInToolView},
+  {"IsEnabledInToolView", CBaseEntity_IsEnabledInToolView},
+  {"SetToolRecording", CBaseEntity_SetToolRecording},
+  {"IsToolRecording", CBaseEntity_IsToolRecording},
+  {"HasRecordedThisFrame", CBaseEntity_HasRecordedThisFrame},
+  {"RecordToolMessage", CBaseEntity_RecordToolMessage},
+  {"DontRecordInTools", CBaseEntity_DontRecordInTools},
+  {"ShouldRecordInTools", CBaseEntity_ShouldRecordInTools},
+  {"Release", CBaseEntity_Release},
+  {"GetRenderOrigin", CBaseEntity_GetRenderOrigin},
+  {"GetRenderAngles", CBaseEntity_GetRenderAngles},
+  {"GetObserverCamOrigin", CBaseEntity_GetObserverCamOrigin},
+  {"IsTwoPass", CBaseEntity_IsTwoPass},
+  {"UsesPowerOfTwoFrameBufferTexture", CBaseEntity_UsesPowerOfTwoFrameBufferTexture},
+  {"UsesFullFrameBufferTexture", CBaseEntity_UsesFullFrameBufferTexture},
+  {"DrawModel", CBaseEntity_DrawModel},
+  {"ComputeFxBlend", CBaseEntity_ComputeFxBlend},
+  {"GetFxBlend", CBaseEntity_GetFxBlend},
+  {"LODTest", CBaseEntity_LODTest},
+  {"SetNextClientThink", CBaseEntity_SetNextClientThink},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CBaseEntity object
+*/
+LUALIB_API int luaopen_CBaseEntity (lua_State *L) {
+  luaL_getmetatable(L, LUA_BASEENTITYLIBNAME);
+  if (lua_isnoneornil(L, -1)) {
+    lua_pop(L, 1);
+    luaL_newmetatable(L, LUA_BASEENTITYLIBNAME);
+  }
+  luaL_register(L, NULL, CBaseEntitymeta);
+  return 1;
+}
+
diff --git a/src/game/client/lc_baseplayer.cpp b/src/game/client/lc_baseplayer.cpp
new file mode 100644
index 0000000..3e11460
--- /dev/null
+++ b/src/game/client/lc_baseplayer.cpp
@@ -0,0 +1,42 @@
+//====== Copyright  1996-2005, Valve Corporation, All rights reserved. =====//
+//
+// Purpose: Client-side CBasePlayer.
+//
+//			- Manages the player's flashlight effect.
+//
+//===========================================================================//
+#define lc_baseplayer_cpp
+
+#include "cbase.h"
+#include "c_baseplayer.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lbaseplayer_shared.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int CBasePlayer_GetLocalPlayer (lua_State *L) {
+  lua_pushplayer(L, CBasePlayer::GetLocalPlayer());
+  return 1;
+}
+
+
+static const luaL_Reg CBasePlayermeta[] = {
+  {"GetLocalPlayer", CBasePlayer_GetLocalPlayer},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CBasePlayer object
+*/
+LUALIB_API int luaopen_CBasePlayer (lua_State *L) {
+  luaL_getmetatable(L, LUA_BASEPLAYERLIBNAME);
+  if (lua_isnoneornil(L, -1)) {
+    lua_pop(L, 1);
+    luaL_newmetatable(L, LUA_BASEPLAYERLIBNAME);
+  }
+  luaL_register(L, NULL, CBasePlayermeta);
+  return 1;
+}
diff --git a/src/game/client/lc_recipientfilter.cpp b/src/game/client/lc_recipientfilter.cpp
new file mode 100644
index 0000000..6f08cd7
--- /dev/null
+++ b/src/game/client/lc_recipientfilter.cpp
@@ -0,0 +1,268 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+#define lc_recipientfilter_cpp
+
+#include "cbase.h"
+#include "c_recipientfilter.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lc_recipientfilter.h"
+#include "lbaseplayer_shared.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static lua_CRecipientFilter *s_pFilter = new C_RecipientFilter();
+static lua_CPASFilter *s_pPASFilter = new CPASFilter( vec3_origin );
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CRecipientFilter &lua_torecipientfilter (lua_State *L, int idx) {
+  lua_CRecipientFilter **ppFilter = (lua_CRecipientFilter **)lua_touserdata(L, idx);
+  return **ppFilter;
+}
+
+
+LUA_API lua_CPASFilter &lua_topasfilter (lua_State *L, int idx) {
+  lua_CPASFilter **ppFilter = (lua_CPASFilter **)lua_touserdata(L, idx);
+  return **ppFilter;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushrecipientfilter (lua_State *L, lua_CRecipientFilter &filter) {
+  lua_CRecipientFilter **ppFilter = (lua_CRecipientFilter **)lua_newuserdata(L, sizeof(lua_CRecipientFilter));
+  s_pFilter->Reset();
+  s_pFilter->CopyFrom(filter);
+  *ppFilter = s_pFilter;
+  luaL_getmetatable(L, "CRecipientFilter");
+  lua_setmetatable(L, -2);
+}
+
+
+LUA_API void lua_pushpasfilter (lua_State *L, lua_CPASFilter &filter) {
+  lua_CPASFilter **ppFilter = (lua_CPASFilter **)lua_newuserdata(L, sizeof(lua_CPASFilter));
+  s_pPASFilter->Reset();
+  s_pPASFilter->CopyFrom(filter);
+  *ppFilter = s_pPASFilter;
+  luaL_getmetatable(L, "CPASFilter");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CRecipientFilter &luaL_checkrecipientfilter (lua_State *L, int narg) {
+  lua_CRecipientFilter *d = (lua_CRecipientFilter *)lua_touserdata(L, narg);
+  if (!d)
+    luaL_typerror(L, narg, "CRecipientFilter");
+  return **(lua_CRecipientFilter **)d;
+}
+
+
+LUALIB_API lua_CPASFilter &luaL_checkpasfilter (lua_State *L, int narg) {
+  lua_CPASFilter **d = (lua_CPASFilter **)luaL_checkudata(L, narg, "CPASFilter");
+  return **d;
+}
+
+
+static int C_RecipientFilter_AddAllPlayers (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).AddAllPlayers();
+  return 0;
+}
+
+static int C_RecipientFilter_AddRecipient (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).AddRecipient(luaL_checkplayer(L, 2));
+  return 0;
+}
+
+static int C_RecipientFilter_AddRecipientsByPAS (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).AddRecipientsByPAS(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int C_RecipientFilter_AddRecipientsByPVS (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).AddRecipientsByPVS(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int C_RecipientFilter_CopyFrom (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).CopyFrom(luaL_checkrecipientfilter(L, 2));
+  return 0;
+}
+
+static int C_RecipientFilter_GetRecipientCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkrecipientfilter(L, 1).GetRecipientCount());
+  return 1;
+}
+
+static int C_RecipientFilter_GetRecipientIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkrecipientfilter(L, 1).GetRecipientIndex(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int C_RecipientFilter_IgnorePredictionCull (lua_State *L) {
+  lua_pushboolean(L, luaL_checkrecipientfilter(L, 1).IgnorePredictionCull());
+  return 1;
+}
+
+static int C_RecipientFilter_IsInitMessage (lua_State *L) {
+  lua_pushboolean(L, luaL_checkrecipientfilter(L, 1).IsInitMessage());
+  return 1;
+}
+
+static int C_RecipientFilter_IsReliable (lua_State *L) {
+  lua_pushboolean(L, luaL_checkrecipientfilter(L, 1).IsReliable());
+  return 1;
+}
+
+static int C_RecipientFilter_IsUsingPredictionRules (lua_State *L) {
+  lua_pushboolean(L, luaL_checkrecipientfilter(L, 1).IsUsingPredictionRules());
+  return 1;
+}
+
+static int C_RecipientFilter_MakeReliable (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).MakeReliable();
+  return 0;
+}
+
+static int C_RecipientFilter_RemoveRecipient (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).RemoveRecipient(luaL_checkplayer(L, 2));
+  return 0;
+}
+
+static int C_RecipientFilter_Reset (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).Reset();
+  return 0;
+}
+
+static int C_RecipientFilter_SetIgnorePredictionCull (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).SetIgnorePredictionCull(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int C_RecipientFilter_UsePredictionRules (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).UsePredictionRules();
+  return 0;
+}
+
+static int C_RecipientFilter___tostring (lua_State *L) {
+  lua_pushfstring(L, "CRecipientFilter: %p", luaL_checkudata(L, 1, "CRecipientFilter"));
+  return 1;
+}
+
+
+static const luaL_Reg C_RecipientFiltermeta[] = {
+  {"AddAllPlayers", C_RecipientFilter_AddAllPlayers},
+  {"AddRecipient", C_RecipientFilter_AddRecipient},
+  {"AddRecipientsByPAS", C_RecipientFilter_AddRecipientsByPAS},
+  {"AddRecipientsByPVS", C_RecipientFilter_AddRecipientsByPVS},
+  {"CopyFrom", C_RecipientFilter_CopyFrom},
+  {"GetRecipientCount", C_RecipientFilter_GetRecipientCount},
+  {"GetRecipientIndex", C_RecipientFilter_GetRecipientIndex},
+  {"IgnorePredictionCull", C_RecipientFilter_IgnorePredictionCull},
+  {"IsInitMessage", C_RecipientFilter_IsInitMessage},
+  {"IsReliable", C_RecipientFilter_IsReliable},
+  {"IsUsingPredictionRules", C_RecipientFilter_IsUsingPredictionRules},
+  {"MakeReliable", C_RecipientFilter_MakeReliable},
+  {"RemoveRecipient", C_RecipientFilter_RemoveRecipient},
+  {"Reset", C_RecipientFilter_Reset},
+  {"SetIgnorePredictionCull", C_RecipientFilter_SetIgnorePredictionCull},
+  {"UsePredictionRules", C_RecipientFilter_UsePredictionRules},
+  {"__tostring", C_RecipientFilter___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_C_RecipientFilter (lua_State *L) {
+  C_RecipientFilter filter;
+  lua_pushrecipientfilter(L, filter);
+  return 1;
+}
+
+
+static const luaL_Reg C_RecipientFilter_funcs[] = {
+  {"CRecipientFilter", luasrc_C_RecipientFilter},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CRecipientFilter object
+*/
+LUALIB_API int luaopen_CRecipientFilter (lua_State *L) {
+  luaL_newmetatable(L, LUA_RECIPIENTFILTERLIBNAME);
+  luaL_register(L, NULL, C_RecipientFiltermeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "recipientfilter");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "recipientfilter" */
+  luaL_register(L, "_G", C_RecipientFilter_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
+
+static int CPASFilter___index (lua_State *L) {
+  lua_getmetatable(L, 1);
+  lua_pushvalue(L, 2);
+  lua_gettable(L, -2);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 2);
+    luaL_getmetatable(L, "CRecipientFilter");
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+  }
+  return 1;
+}
+
+static int CPASFilter___tostring (lua_State *L) {
+  lua_pushfstring(L, "CPASFilter: %p", luaL_checkudata(L, 1, "CPASFilter"));
+  return 1;
+}
+
+
+static const luaL_Reg CPASFiltermeta[] = {
+  {"__index", CPASFilter___index},
+  {"__tostring", CPASFilter___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_CPASFilter (lua_State *L) {
+  CPASFilter filter(luaL_checkvector(L, 1));
+  lua_pushpasfilter(L, filter);
+  return 1;
+}
+
+
+static const luaL_Reg CPASFilter_funcs[] = {
+  {"CPASFilter", luasrc_CPASFilter},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CPASFilter object
+*/
+LUALIB_API int luaopen_CPASFilter (lua_State *L) {
+  luaL_newmetatable(L, LUA_PASFILTERLIBNAME);
+  luaL_register(L, NULL, CPASFiltermeta);
+  lua_pushstring(L, "recipientfilter");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "recipientfilter" */
+  luaL_register(L, "_G", CPASFilter_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
\ No newline at end of file
diff --git a/src/game/client/lc_recipientfilter.h b/src/game/client/lc_recipientfilter.h
new file mode 100644
index 0000000..eeab74e
--- /dev/null
+++ b/src/game/client/lc_recipientfilter.h
@@ -0,0 +1,43 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LC_RECIPIENTFILTER_H
+#define LC_RECIPIENTFILTER_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for CRecipientFilter functions */
+typedef C_RecipientFilter lua_CRecipientFilter;
+
+
+/* type for CPASFilter functions */
+typedef CPASFilter lua_CPASFilter;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CRecipientFilter     &(lua_torecipientfilter) (lua_State *L, int idx);
+LUA_API lua_CPASFilter     &(lua_topasfilter) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushrecipientfilter) (lua_State *L, lua_CRecipientFilter &filter);
+LUA_API void  (lua_pushpasfilter) (lua_State *L, lua_CPASFilter &filter);
+
+
+
+LUALIB_API lua_CRecipientFilter &(luaL_checkrecipientfilter) (lua_State *L, int narg);
+LUALIB_API lua_CPASFilter &(luaL_checkpasfilter) (lua_State *L, int narg);
+
+
+#endif // LC_RECIPIENTFILTER_H
diff --git a/src/game/client/lcdll_util.cpp b/src/game/client/lcdll_util.cpp
new file mode 100644
index 0000000..c8ee70d
--- /dev/null
+++ b/src/game/client/lcdll_util.cpp
@@ -0,0 +1,213 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $Workfile:     $
+// $NoKeywords: $
+//=============================================================================//
+
+#define lcdll_util_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "lbaseplayer_shared.h"
+#include "lbaseentity_shared.h"
+#include "lgametrace.h"
+#include "mathlib/lvector.h"
+#include "vgui/lvgui.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+
+static int luasrc_IsPlayerIndex (lua_State *L) {
+  lua_pushboolean(L, IsPlayerIndex(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int luasrc_GetLocalPlayerIndex (lua_State *L) {
+  lua_pushinteger(L, GetLocalPlayerIndex());
+  return 1;
+}
+
+static int luasrc_IsLocalPlayerSpectator (lua_State *L) {
+  lua_pushboolean(L, IsLocalPlayerSpectator());
+  return 1;
+}
+
+static int luasrc_GetSpectatorMode (lua_State *L) {
+  lua_pushinteger(L, GetSpectatorMode());
+  return 1;
+}
+
+static int luasrc_GetSpectatorTarget (lua_State *L) {
+  lua_pushinteger(L, GetSpectatorTarget());
+  return 1;
+}
+
+static int luasrc_GetLocalPlayerTeam (lua_State *L) {
+  lua_pushinteger(L, GetLocalPlayerTeam());
+  return 1;
+}
+
+static int luasrc_NormalizeAngles (lua_State *L) {
+  NormalizeAngles(luaL_checkangle(L, 1));
+  return 0;
+}
+
+static int luasrc_InterpolateAngles (lua_State *L) {
+  InterpolateAngles(luaL_checkangle(L, 1), luaL_checkangle(L, 2), luaL_checkangle(L, 3), luaL_checknumber(L, 4));
+  return 0;
+}
+
+static int luasrc_ScreenHeight (lua_State *L) {
+  lua_pushinteger(L, ScreenHeight());
+  return 1;
+}
+
+static int luasrc_ScreenWidth (lua_State *L) {
+  lua_pushinteger(L, ScreenWidth());
+  return 1;
+}
+
+static int luasrc_UTIL_ComputeStringWidth (lua_State *L) {
+  lua_pushinteger(L, UTIL_ComputeStringWidth(*(vgui::HFont *)luaL_checkfont(L, 1), luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int luasrc_UTIL_AngleDiff (lua_State *L) {
+  lua_pushnumber(L, UTIL_AngleDiff(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int luasrc_UTIL_Bubbles (lua_State *L) {
+  UTIL_Bubbles(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int luasrc_UTIL_ScreenShake (lua_State *L) {
+  UTIL_ScreenShake(luaL_checkvector(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checknumber(L, 4), luaL_checknumber(L, 5), (ShakeCommand_t)luaL_checkint(L, 6), luaL_optboolean(L, 7, 0));
+  return 0;
+}
+
+static int luasrc_UTIL_Tracer (lua_State *L) {
+  UTIL_Tracer(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checknumber(L, 5), luaL_checkboolean(L, 6), luaL_checkstring(L, 7));
+  return 0;
+}
+
+static int luasrc_UTIL_Smoke (lua_State *L) {
+  UTIL_Smoke(luaL_checkvector(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3));
+  return 0;
+}
+
+static int luasrc_UTIL_ImpactTrace (lua_State *L) {
+  UTIL_ImpactTrace(&luaL_checktrace(L, 1), luaL_checkint(L, 2), (char *)luaL_optstring(L, 3, 0));
+  return 0;
+}
+
+static int luasrc_UTIL_SetOrigin (lua_State *L) {
+  UTIL_SetOrigin(luaL_checkentity(L, 1), luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int luasrc_UTIL_PrecacheOther (lua_State *L) {
+  UTIL_PrecacheOther(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_ClientPrint (lua_State *L) {
+  ClientPrint(luaL_checkplayer(L, 1), luaL_checkint(L, 2), luaL_checkstring(L, 3), luaL_optstring(L, 4, 0), luaL_optstring(L, 5, 0), luaL_optstring(L, 6, 0), luaL_optstring(L, 7, 0));
+  return 0;
+}
+
+#define MAX_ENTITYARRAY 1024
+
+static int luasrc_UTIL_EntitiesInBox (lua_State *L) {
+  C_BaseEntity *pList[MAX_ENTITYARRAY];
+
+  int count = UTIL_EntitiesInBox(pList, luaL_checkint(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkint(L, 4), luaL_optint(L, 5, PARTITION_CLIENT_NON_STATIC_EDICTS));
+  lua_pushinteger(L, count);
+  lua_newtable(L);
+  for( int i = 0 ; i < count ; i++ )
+  {
+	  lua_pushinteger(L, i);
+	  lua_pushentity(L, pList[ i ]);
+	  lua_settable(L, -3);
+  }
+  return 2;
+}
+
+static int luasrc_UTIL_EntitiesInSphere (lua_State *L) {
+  C_BaseEntity *pList[MAX_ENTITYARRAY];
+
+  int count = UTIL_EntitiesInSphere(pList, luaL_checkint(L, 1), luaL_checkvector(L, 2), luaL_checknumber(L, 3), luaL_checkint(L, 4), luaL_optint(L, 5, PARTITION_CLIENT_NON_STATIC_EDICTS));
+  lua_pushinteger(L, count);
+  lua_newtable(L);
+  for( int i = 0 ; i < count ; i++ )
+  {
+	  lua_pushinteger(L, i);
+	  lua_pushentity(L, pList[ i ]);
+	  lua_settable(L, -3);
+  }
+  return 2;
+}
+
+static int luasrc_UTIL_SafeName (lua_State *L) {
+  lua_pushstring(L, UTIL_SafeName(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int luasrc_UTIL_BoundToWorldSize (lua_State *L) {
+  UTIL_BoundToWorldSize(&luaL_checkvector(L, 1));
+  return 0;
+}
+
+
+static const luaL_Reg util_funcs[] = {
+  {"IsPlayerIndex",  luasrc_IsPlayerIndex},
+  {"GetLocalPlayerIndex",  luasrc_GetLocalPlayerIndex},
+  {"IsLocalPlayerSpectator",  luasrc_IsLocalPlayerSpectator},
+  {"GetSpectatorMode",  luasrc_GetSpectatorMode},
+  {"GetSpectatorTarget",  luasrc_GetSpectatorTarget},
+  {"NormalizeAngles",  luasrc_NormalizeAngles},
+  {"InterpolateAngles",  luasrc_InterpolateAngles},
+  {"ScreenHeight",  luasrc_ScreenHeight},
+  {"ScreenWidth",  luasrc_ScreenWidth},
+  // {"UTIL_ComputeStringWidth", luasrc_UTIL_ComputeStringWidth},
+  {"ComputeStringWidth", luasrc_UTIL_ComputeStringWidth},
+  // {"UTIL_AngleDiff",  luasrc_UTIL_AngleDiff},
+  {"AngleDiff",  luasrc_UTIL_AngleDiff},
+  // {"UTIL_Bubbles",  luasrc_UTIL_Bubbles},
+  {"Bubbles",  luasrc_UTIL_Bubbles},
+  // {"UTIL_ScreenShake",  luasrc_UTIL_ScreenShake},
+  {"ScreenShake",  luasrc_UTIL_ScreenShake},
+  // {"UTIL_Tracer",  luasrc_UTIL_Tracer},
+  {"Tracer",  luasrc_UTIL_Tracer},
+  // {"UTIL_Smoke",  luasrc_UTIL_Smoke},
+  {"Smoke",  luasrc_UTIL_Smoke},
+  // {"UTIL_ImpactTrace",  luasrc_UTIL_ImpactTrace},
+  {"ImpactTrace",  luasrc_UTIL_ImpactTrace},
+  // {"UTIL_SetOrigin",  luasrc_UTIL_SetOrigin},
+  {"SetOrigin",  luasrc_UTIL_SetOrigin},
+  // {"UTIL_PrecacheOther",  luasrc_UTIL_PrecacheOther},
+  {"PrecacheOther",  luasrc_UTIL_PrecacheOther},
+  {"ClientPrint",  luasrc_ClientPrint},
+  // {"UTIL_EntitiesInBox",  luasrc_UTIL_EntitiesInBox},
+  {"EntitiesInBox",  luasrc_UTIL_EntitiesInBox},
+  // {"UTIL_EntitiesInSphere",  luasrc_UTIL_EntitiesInSphere},
+  {"EntitiesInSphere",  luasrc_UTIL_EntitiesInSphere},
+  // {"UTIL_SafeName",  luasrc_UTIL_SafeName},
+  {"SafeName",  luasrc_UTIL_SafeName},
+  // {"UTIL_BoundToWorldSize",  luasrc_UTIL_BoundToWorldSize},
+  {"BoundToWorldSize",  luasrc_UTIL_BoundToWorldSize},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_UTIL (lua_State *L) {
+  // luaL_register(L, "_G", util_funcs);
+  luaL_register(L, "UTIL", util_funcs);
+  return 1;
+}
+
diff --git a/src/game/client/liclientshadowmgr.cpp b/src/game/client/liclientshadowmgr.cpp
new file mode 100644
index 0000000..4735948
--- /dev/null
+++ b/src/game/client/liclientshadowmgr.cpp
@@ -0,0 +1,87 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+
+#define liclientshadowmgr_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+
+static int g_pClientShadowMgr_AdvanceFrame (lua_State *L) {
+  g_pClientShadowMgr->AdvanceFrame();
+  return 0;
+}
+
+static int g_pClientShadowMgr_GetShadowDirection (lua_State *L) {
+  Vector v = g_pClientShadowMgr->GetShadowDirection();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int g_pClientShadowMgr_RenderShadowTexture (lua_State *L) {
+  g_pClientShadowMgr->RenderShadowTexture(luaL_checkint(L, 1), luaL_checkint(L, 2));
+  return 0;
+}
+
+static int g_pClientShadowMgr_SetShadowBlobbyCutoffArea (lua_State *L) {
+  g_pClientShadowMgr->SetShadowBlobbyCutoffArea(luaL_checknumber(L, 1));
+  return 0;
+}
+
+static int g_pClientShadowMgr_SetShadowColor (lua_State *L) {
+  g_pClientShadowMgr->SetShadowColor(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int g_pClientShadowMgr_SetShadowDirection (lua_State *L) {
+  g_pClientShadowMgr->SetShadowDirection(luaL_checkvector(L, 1));
+  return 0;
+}
+
+static int g_pClientShadowMgr_SetShadowDistance (lua_State *L) {
+  g_pClientShadowMgr->SetShadowDistance(luaL_checknumber(L, 1));
+  return 0;
+}
+
+static int g_pClientShadowMgr_SetShadowsDisabled (lua_State *L) {
+  g_pClientShadowMgr->SetShadowsDisabled(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int g_pClientShadowMgr_UnlockAllShadowDepthTextures (lua_State *L) {
+  g_pClientShadowMgr->UnlockAllShadowDepthTextures();
+  return 0;
+}
+
+
+static const luaL_Reg g_pClientShadowMgrlib[] = {
+  {"AdvanceFrame",   g_pClientShadowMgr_AdvanceFrame},
+  {"GetShadowDirection",   g_pClientShadowMgr_GetShadowDirection},
+  {"RenderShadowTexture",   g_pClientShadowMgr_RenderShadowTexture},
+  {"SetShadowBlobbyCutoffArea",   g_pClientShadowMgr_SetShadowBlobbyCutoffArea},
+  {"SetShadowColor",   g_pClientShadowMgr_SetShadowColor},
+  {"SetShadowDirection",   g_pClientShadowMgr_SetShadowDirection},
+  {"SetShadowDistance",   g_pClientShadowMgr_SetShadowDistance},
+  {"UnlockAllShadowDepthTextures",   g_pClientShadowMgr_UnlockAllShadowDepthTextures},
+  {NULL, NULL}
+};
+
+
+/*
+** Open g_pClientShadowMgr library
+*/
+LUALIB_API int luaopen_g_pClientShadowMgr (lua_State *L) {
+  luaL_register(L, "g_pClientShadowMgr", g_pClientShadowMgrlib);
+  return 1;
+}
+
diff --git a/src/game/client/lprediction.cpp b/src/game/client/lprediction.cpp
new file mode 100644
index 0000000..2f79cec
--- /dev/null
+++ b/src/game/client/lprediction.cpp
@@ -0,0 +1,127 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#define lprediction_cpp
+
+#include "cbase.h"
+#include "prediction.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int prediction_GetIdealPitch (lua_State *L) {
+  lua_pushnumber(L, prediction->GetIdealPitch());
+  return 1;
+}
+
+static int prediction_GetIncomingPacketNumber (lua_State *L) {
+  lua_pushinteger(L, prediction->GetIncomingPacketNumber());
+  return 1;
+}
+
+static int prediction_GetLocalViewAngles (lua_State *L) {
+  QAngle ang;
+  prediction->GetLocalViewAngles(ang);
+  lua_pushangle(L, ang);
+  return 1;
+}
+
+static int prediction_GetViewAngles (lua_State *L) {
+  QAngle ang;
+  prediction->GetViewAngles(ang);
+  lua_pushangle(L, ang);
+  return 1;
+}
+
+static int prediction_GetViewOrigin (lua_State *L) {
+  Vector org;
+  prediction->GetViewOrigin(org);
+  lua_pushvector(L, org);
+  return 1;
+}
+
+static int prediction_InPrediction (lua_State *L) {
+  lua_pushboolean(L, prediction->InPrediction());
+  return 1;
+}
+
+static int prediction_IsFirstTimePredicted (lua_State *L) {
+  lua_pushboolean(L, prediction->IsFirstTimePredicted());
+  return 1;
+}
+
+static int prediction_OnReceivedUncompressedPacket (lua_State *L) {
+  prediction->OnReceivedUncompressedPacket();
+  return 0;
+}
+
+static int prediction_PostEntityPacketReceived (lua_State *L) {
+  prediction->PostEntityPacketReceived();
+  return 0;
+}
+
+static int prediction_PostNetworkDataReceived (lua_State *L) {
+  prediction->PostNetworkDataReceived(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int prediction_PreEntityPacketReceived (lua_State *L) {
+  prediction->PreEntityPacketReceived(luaL_checkint(L, 1), luaL_checkint(L, 2));
+  return 0;
+}
+
+static int prediction_SetLocalViewAngles (lua_State *L) {
+  prediction->SetLocalViewAngles(luaL_checkangle(L, 1));
+  return 0;
+}
+
+static int prediction_SetViewAngles (lua_State *L) {
+  prediction->SetViewAngles(luaL_checkangle(L, 1));
+  return 0;
+}
+
+static int prediction_SetViewOrigin (lua_State *L) {
+  prediction->SetViewOrigin(luaL_checkvector(L, 1));
+  return 0;
+}
+
+static int prediction_Update (lua_State *L) {
+  prediction->Update(luaL_checkint(L, 1), luaL_checkboolean(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+
+static const luaL_Reg predictionlib[] = {
+  {"GetIdealPitch",   prediction_GetIdealPitch},
+  {"GetIncomingPacketNumber",   prediction_GetIncomingPacketNumber},
+  {"GetLocalViewAngles",   prediction_GetLocalViewAngles},
+  {"GetViewAngles",   prediction_GetViewAngles},
+  {"GetViewOrigin",   prediction_GetViewOrigin},
+  {"InPrediction",   prediction_InPrediction},
+  {"IsFirstTimePredicted",   prediction_IsFirstTimePredicted},
+  {"OnReceivedUncompressedPacket",   prediction_OnReceivedUncompressedPacket},
+  {"PostEntityPacketReceived",   prediction_PostEntityPacketReceived},
+  {"PostNetworkDataReceived",   prediction_PostNetworkDataReceived},
+  {"PreEntityPacketReceived",   prediction_PreEntityPacketReceived},
+  {"SetLocalViewAngles",   prediction_SetLocalViewAngles},
+  {"SetViewAngles",   prediction_SetViewAngles},
+  {"SetViewOrigin",   prediction_SetViewOrigin},
+  {"Update",   prediction_Update},
+  {NULL, NULL}
+};
+
+
+/*
+** Open prediction library
+*/
+LUALIB_API int luaopen_prediction (lua_State *L) {
+  luaL_register(L, LUA_PREDICTIONLIBNAME, predictionlib);
+  return 1;
+}
diff --git a/src/game/client/prediction.cpp b/src/game/client/prediction.cpp
index 18960ce..6e4f24c 100644
--- a/src/game/client/prediction.cpp
+++ b/src/game/client/prediction.cpp
@@ -768,6 +768,39 @@ void CPrediction::RunPreThink( C_BasePlayer *player )
 	// FIXME:  Do we need to set up a client side version of the gamerules???
 	// g_pGameRules->PlayerThink( player );
 
+#ifdef LUA_SDK
+	// Andrew; Yes. At least for mods using the Source Engine Lua SDK, we do.
+	//
+	//=========================================================================
+	// SOURCE ENGINE LUA SDK GAMERULES THINK
+	//
+	// Below, we call Think() on the global gamerules object. This needs to be
+	// done by our SDK, and our SDK only, simply because without this call,
+	// only GAME_LUA has a Think hook. This isn't helpful for many game logic
+	// situations, considering this SDK extends functionality for developers.
+	//
+	// The issue is that while this is fine to call, where we do it may not be.
+	// There's a specific chain of calls made during every frame, and depending
+	// on what scripters do in their hooks for the CLIENT_LUA Think hook, they
+	// could be unintentionally causing senarios to arise which do not behave
+	// well with other game events, or logic set out internally. In one case,
+	// someone's hook may not work at all, and in another, it may break
+	// prediction, or prevent critical events from being fired properly.
+	//
+	// In the end, caution will simply need to be taken when using this hook,
+	// and careful observation will need to be made when controlling things
+	// like a player's view for cinematic purposes, or the creation and
+	// placement of entities for a gamemode.
+	//
+	// This isn't the only client-side thinking hook we're providing, so, in
+	// worst-case scenarios, if functionality of something breaks, you may just
+	// need to implement your feature or write your logic in other calls to
+	// create harmony with the frame function call sequence.
+	//
+	//========================================================================= 
+	g_pGameRules->Think();
+#endif
+
 	player->PreThink();
 #endif
 }
diff --git a/src/game/client/scripted_controls/lButton.cpp b/src/game/client/scripted_controls/lButton.cpp
new file mode 100644
index 0000000..1bbe880
--- /dev/null
+++ b/src/game/client/scripted_controls/lButton.cpp
@@ -0,0 +1,513 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Basic button control
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#include <cbase.h>
+
+#include <vgui_int.h>
+#include <luamanager.h>
+#include <vgui_controls/lPanel.h>
+#include <lColor.h>
+
+#include <scripted_controls/lButton.h>
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include <tier0/memdbgon.h>
+
+using namespace vgui;
+
+//-----------------------------------------------------------------------------
+// Purpose: Constructor
+//-----------------------------------------------------------------------------
+LButton::LButton(Panel *parent, const char *panelName, const char *text, Panel *pActionSignalTarget, const char *pCmd, lua_State *L ) : Button(parent, panelName, text, pActionSignalTarget, pCmd)
+{
+#if defined( LUA_SDK )
+	m_lua_State = L;
+	m_nTableReference = LUA_NOREF;
+	m_nRefCount = 0;
+#endif // LUA_SDK
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Destructor
+//-----------------------------------------------------------------------------
+LButton::~LButton()
+{
+#if defined( LUA_SDK )
+	lua_unref( m_lua_State, m_nTableReference );
+#endif // LUA_SDK
+}
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_Button *lua_tobutton (lua_State *L, int idx) {
+  PHandle *phPanel = dynamic_cast<PHandle *>((PHandle *)lua_touserdata(L, idx));
+  if (phPanel == NULL)
+    return NULL;
+  return dynamic_cast<lua_Button *>(phPanel->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushbutton (lua_State *L, Button *pButton) {
+  LButton *plButton = dynamic_cast<LButton *>(pButton);
+  if (plButton)
+    ++plButton->m_nRefCount;
+  PHandle *phPanel = (PHandle *)lua_newuserdata(L, sizeof(PHandle));
+  phPanel->Set(pButton);
+  luaL_getmetatable(L, "Button");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_Button *luaL_checkbutton (lua_State *L, int narg) {
+  lua_Button *d = lua_tobutton(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "Button expected, got INVALID_PANEL");
+  return d;
+}
+
+
+static int Button_CanBeDefaultButton (lua_State *L) {
+  lua_pushboolean(L, luaL_checkbutton(L, 1)->CanBeDefaultButton());
+  return 1;
+}
+
+static int Button_ChainToAnimationMap (lua_State *L) {
+  luaL_checkbutton(L, 1)->ChainToAnimationMap();
+  return 0;
+}
+
+static int Button_ChainToMap (lua_State *L) {
+  luaL_checkbutton(L, 1)->ChainToMap();
+  return 0;
+}
+
+static int Button_DoClick (lua_State *L) {
+  luaL_checkbutton(L, 1)->DoClick();
+  return 0;
+}
+
+static int Button_DrawFocusBox (lua_State *L) {
+  luaL_checkbutton(L, 1)->DrawFocusBox(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Button_FireActionSignal (lua_State *L) {
+  luaL_checkbutton(L, 1)->FireActionSignal();
+  return 0;
+}
+
+static int Button_ForceDepressed (lua_State *L) {
+  luaL_checkbutton(L, 1)->ForceDepressed(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Button_GetButtonBgColor (lua_State *L) {
+  lua_pushcolor(L, luaL_checkbutton(L, 1)->GetButtonBgColor());
+  return 1;
+}
+
+static int Button_GetButtonFgColor (lua_State *L) {
+  lua_pushcolor(L, luaL_checkbutton(L, 1)->GetButtonFgColor());
+  return 1;
+}
+
+static int Button_GetPanelBaseClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkbutton(L, 1)->GetPanelBaseClassName());
+  return 1;
+}
+
+static int Button_GetPanelClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkbutton(L, 1)->GetPanelClassName());
+  return 1;
+}
+
+static int Button_GetRefTable (lua_State *L) {
+  LButton *plButton = dynamic_cast<LButton *>(luaL_checkbutton(L, 1));
+  if (plButton) {
+    if (plButton->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plButton->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plButton->m_nTableReference);
+  }
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+static int Button_IsArmed (lua_State *L) {
+  lua_pushboolean(L, luaL_checkbutton(L, 1)->IsArmed());
+  return 1;
+}
+
+static int Button_IsBlinking (lua_State *L) {
+  lua_pushboolean(L, luaL_checkbutton(L, 1)->IsBlinking());
+  return 1;
+}
+
+static int Button_IsDepressed (lua_State *L) {
+  lua_pushboolean(L, luaL_checkbutton(L, 1)->IsDepressed());
+  return 1;
+}
+
+static int Button_IsDrawingFocusBox (lua_State *L) {
+  lua_pushboolean(L, luaL_checkbutton(L, 1)->IsDrawingFocusBox());
+  return 1;
+}
+
+static int Button_IsMouseClickEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkbutton(L, 1)->IsMouseClickEnabled((MouseCode)luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int Button_IsSelected (lua_State *L) {
+  lua_pushboolean(L, luaL_checkbutton(L, 1)->IsSelected());
+  return 1;
+}
+
+static int Button_IsUseCaptureMouseEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkbutton(L, 1)->IsUseCaptureMouseEnabled());
+  return 1;
+}
+
+static int Button_KB_AddBoundKey (lua_State *L) {
+  luaL_checkbutton(L, 1)->KB_AddBoundKey(luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int Button_KB_ChainToMap (lua_State *L) {
+  luaL_checkbutton(L, 1)->KB_ChainToMap();
+  return 0;
+}
+
+static int Button_OnCursorEntered (lua_State *L) {
+  luaL_checkbutton(L, 1)->OnCursorEntered();
+  return 0;
+}
+
+static int Button_OnCursorExited (lua_State *L) {
+  luaL_checkbutton(L, 1)->OnCursorExited();
+  return 0;
+}
+
+static int Button_OnHotkey (lua_State *L) {
+  luaL_checkbutton(L, 1)->OnHotkey();
+  return 0;
+}
+
+static int Button_OnKillFocus (lua_State *L) {
+  luaL_checkbutton(L, 1)->OnKillFocus();
+  return 0;
+}
+
+static int Button_OnSetFocus (lua_State *L) {
+  luaL_checkbutton(L, 1)->OnSetFocus();
+  return 0;
+}
+
+static int Button_PerformLayout (lua_State *L) {
+  luaL_checkbutton(L, 1)->PerformLayout();
+  return 0;
+}
+
+static int Button_RecalculateDepressedState (lua_State *L) {
+  luaL_checkbutton(L, 1)->RecalculateDepressedState();
+  return 0;
+}
+
+static int Button_SetArmed (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetArmed(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Button_SetArmedColor (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetArmedColor(luaL_checkcolor(L, 2), luaL_checkcolor(L, 3));
+  return 0;
+}
+
+static int Button_SetArmedSound (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetArmedSound(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int Button_SetAsCurrentDefaultButton (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetAsCurrentDefaultButton(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Button_SetAsDefaultButton (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetAsDefaultButton(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Button_SetBlink (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetBlink(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Button_SetBlinkColor (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetBlinkColor(luaL_checkcolor(L, 2));
+  return 0;
+}
+
+static int Button_SetButtonActivationType (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetButtonActivationType((Button::ActivationType_t)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Button_SetButtonBorderEnabled (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetButtonBorderEnabled(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Button_SetDefaultColor (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetDefaultColor(luaL_checkcolor(L, 2), luaL_checkcolor(L, 3));
+  return 0;
+}
+
+static int Button_SetDepressedColor (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetDepressedColor(luaL_checkcolor(L, 2), luaL_checkcolor(L, 3));
+  return 0;
+}
+
+static int Button_SetDepressedSound (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetDepressedSound(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int Button_SetMouseClickEnabled (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetMouseClickEnabled((MouseCode)luaL_checkint(L, 2), luaL_checkboolean(L, 3));
+  return 0;
+}
+
+static int Button_SetReleasedSound (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetReleasedSound(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int Button_SetSelected (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetSelected(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Button_SetShouldPaint (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetShouldPaint(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Button_SetUseCaptureMouse (lua_State *L) {
+  luaL_checkbutton(L, 1)->SetUseCaptureMouse(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Button_ShouldPaint (lua_State *L) {
+  lua_pushboolean(L, luaL_checkbutton(L, 1)->ShouldPaint());
+  return 1;
+}
+
+static int Button_SizeToContents (lua_State *L) {
+  luaL_checkbutton(L, 1)->SizeToContents();
+  return 0;
+}
+
+static int Button___index (lua_State *L) {
+  Button *pButton = lua_tobutton(L, 1);
+  if (pButton == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  LButton *plButton = dynamic_cast<LButton *>(pButton);
+  if (plButton && plButton->m_nTableReference != LUA_NOREF) {
+    lua_getref(L, plButton->m_nTableReference);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      lua_getmetatable(L, 1);
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "Panel");
+        lua_pushvalue(L, 2);
+        lua_gettable(L, -2);
+      }
+    }
+  } else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      luaL_getmetatable(L, "Panel");
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+    }
+  }
+  return 1;
+}
+
+static int Button___newindex (lua_State *L) {
+  Button *pButton = lua_tobutton(L, 1);
+  if (pButton == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+  LButton *plButton = dynamic_cast<LButton *>(pButton);
+  if (plButton) {
+    if (plButton->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plButton->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plButton->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, luaL_checkstring(L, 2));
+	lua_pop(L, 1);
+    return 0;
+  } else {
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index a non-scripted panel", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+}
+
+static int Button___gc (lua_State *L) {
+  LButton *plButton = dynamic_cast<LButton *>(lua_tobutton(L, 1));
+  if (plButton) {
+    --plButton->m_nRefCount;
+	if (plButton->m_nRefCount <= 0) {
+      delete plButton;
+    }
+  }
+  return 0;
+}
+
+static int Button___eq (lua_State *L) {
+  lua_pushboolean(L, lua_tobutton(L, 1) == lua_tobutton(L, 2));
+  return 1;
+}
+
+static int Button___tostring (lua_State *L) {
+  Button *pButton = lua_tobutton(L, 1);
+  if (pButton == NULL)
+    lua_pushstring(L, "INVALID_PANEL");
+  else {
+    const char *pName = pButton->GetName();
+    if (Q_strcmp(pName, "") == 0)
+      pName = "(no name)";
+    lua_pushfstring(L, "Button: \"%s\"", pName);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg Buttonmeta[] = {
+  {"CanBeDefaultButton", Button_CanBeDefaultButton},
+  {"ChainToAnimationMap", Button_ChainToAnimationMap},
+  {"ChainToMap", Button_ChainToMap},
+  {"DoClick", Button_DoClick},
+  {"DrawFocusBox", Button_DrawFocusBox},
+  {"FireActionSignal", Button_FireActionSignal},
+  {"ForceDepressed", Button_ForceDepressed},
+  {"GetButtonBgColor", Button_GetButtonBgColor},
+  {"GetButtonFgColor", Button_GetButtonFgColor},
+  {"GetPanelBaseClassName", Button_GetPanelBaseClassName},
+  {"GetPanelClassName", Button_GetPanelClassName},
+  {"GetRefTable", Button_GetRefTable},
+  {"IsArmed", Button_IsArmed},
+  {"IsBlinking", Button_IsBlinking},
+  {"IsDepressed", Button_IsDepressed},
+  {"IsDrawingFocusBox", Button_IsDrawingFocusBox},
+  {"IsMouseClickEnabled", Button_IsMouseClickEnabled},
+  {"IsSelected", Button_IsSelected},
+  {"IsUseCaptureMouseEnabled", Button_IsUseCaptureMouseEnabled},
+  {"KB_AddBoundKey", Button_KB_AddBoundKey},
+  {"KB_ChainToMap", Button_KB_ChainToMap},
+  {"OnCursorEntered", Button_OnCursorEntered},
+  {"OnCursorExited", Button_OnCursorExited},
+  {"OnHotkey", Button_OnHotkey},
+  {"OnKillFocus", Button_OnKillFocus},
+  {"OnSetFocus", Button_OnSetFocus},
+  {"PerformLayout", Button_PerformLayout},
+  {"RecalculateDepressedState", Button_RecalculateDepressedState},
+  {"SetArmed", Button_SetArmed},
+  {"SetArmedColor", Button_SetArmedColor},
+  {"SetArmedSound", Button_SetArmedSound},
+  {"SetAsCurrentDefaultButton", Button_SetAsCurrentDefaultButton},
+  {"SetAsDefaultButton", Button_SetAsDefaultButton},
+  {"SetBlink", Button_SetBlink},
+  {"SetBlinkColor", Button_SetBlinkColor},
+  {"SetButtonActivationType", Button_SetButtonActivationType},
+  {"SetButtonBorderEnabled", Button_SetButtonBorderEnabled},
+  {"SetDefaultColor", Button_SetDefaultColor},
+  {"SetDepressedColor", Button_SetDepressedColor},
+  {"SetDepressedSound", Button_SetDepressedSound},
+  {"SetMouseClickEnabled", Button_SetMouseClickEnabled},
+  {"SetReleasedSound", Button_SetReleasedSound},
+  {"SetSelected", Button_SetSelected},
+  {"SetShouldPaint", Button_SetShouldPaint},
+  {"SetUseCaptureMouse", Button_SetUseCaptureMouse},
+  {"ShouldPaint", Button_ShouldPaint},
+  {"SizeToContents", Button_SizeToContents},
+  {"__index", Button___index},
+  {"__newindex", Button___newindex},
+  {"__gc", Button___gc},
+  {"__eq", Button___eq},
+  {"__tostring", Button___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_Button (lua_State *L) {
+  Button *pButton = new LButton(luaL_optpanel(L, 1, VGui_GetClientLuaRootPanel()), luaL_checkstring(L, 2), luaL_checkstring(L, 3), luaL_optpanel(L, 4, 0), luaL_optstring(L, 5, 0), L);
+  lua_pushbutton(L, pButton);
+  return 1;
+}
+
+
+static const luaL_Reg Button_funcs[] = {
+  {"Button", luasrc_Button},
+  {NULL, NULL}
+};
+
+
+/*
+** Open Button object
+*/
+LUALIB_API int luaopen_vgui_Button(lua_State *L) {
+  luaL_newmetatable(L, "Button");
+  luaL_register(L, NULL, Buttonmeta);
+  lua_pushstring(L, "panel");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "panel" */
+  luaL_register(L, "vgui", Button_funcs);
+  lua_pop(L, 2);
+  return 1;
+}
+
diff --git a/src/game/client/scripted_controls/lButton.h b/src/game/client/scripted_controls/lButton.h
new file mode 100644
index 0000000..e5c4fff
--- /dev/null
+++ b/src/game/client/scripted_controls/lButton.h
@@ -0,0 +1,63 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#ifndef LBUTTON_H
+#define LBUTTON_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include <vgui_controls/Button.h>
+
+namespace vgui
+{
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+class LButton : public Button
+{
+	DECLARE_CLASS_SIMPLE( LButton, Button );
+
+public:
+	// You can optionally pass in the panel to send the click message to and the name of the command to send to that panel.
+	LButton(Panel *parent, const char *panelName, const char *text, Panel *pActionSignalTarget=NULL, const char *pCmd=NULL, lua_State *L=NULL);
+	~LButton();
+
+public:
+#if defined( LUA_SDK )
+	lua_State          *m_lua_State;
+	int                m_nTableReference;
+	int                m_nRefCount;
+#endif
+};
+
+} // namespace vgui
+
+/* type for Button functions */
+typedef vgui::Button lua_Button;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_Button     *(lua_tobutton) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushbutton) (lua_State *L, lua_Button *pButton);
+
+
+
+LUALIB_API lua_Button *(luaL_checkbutton) (lua_State *L, int narg);
+
+#endif // LBUTTON_H
diff --git a/src/game/client/scripted_controls/lCheckButton.cpp b/src/game/client/scripted_controls/lCheckButton.cpp
new file mode 100644
index 0000000..a09e0e7
--- /dev/null
+++ b/src/game/client/scripted_controls/lCheckButton.cpp
@@ -0,0 +1,320 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#include <cbase.h>
+
+#include <vgui_int.h>
+#include <luamanager.h>
+#include <vgui_controls/lPanel.h>
+#include <lColor.h>
+
+#include <scripted_controls/lCheckButton.h>
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include <tier0/memdbgon.h>
+
+using namespace vgui;
+
+//-----------------------------------------------------------------------------
+// Purpose: Constructor
+//-----------------------------------------------------------------------------
+LCheckButton::LCheckButton(Panel *parent, const char *panelName, const char *text, lua_State *L) : CheckButton(parent, panelName, text)
+{
+#if defined( LUA_SDK )
+	m_lua_State = L;
+	m_nTableReference = LUA_NOREF;
+	m_nRefCount = 0;
+#endif // LUA_SDK
+}
+
+
+//-----------------------------------------------------------------------------
+// Purpose: Destructor
+//-----------------------------------------------------------------------------
+LCheckButton::~LCheckButton()
+{
+#if defined( LUA_SDK )
+	lua_unref( m_lua_State, m_nTableReference );
+#endif // LUA_SDK
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void LCheckButton::OnCheckButtonChecked()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_CHECKBUTTON_METHOD( "OnCheckButtonChecked" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CheckButton *lua_tocheckbutton (lua_State *L, int idx) {
+  PHandle *phPanel = dynamic_cast<PHandle *>((PHandle *)lua_touserdata(L, idx));
+  if (phPanel == NULL)
+    return NULL;
+  return dynamic_cast<lua_CheckButton *>(phPanel->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushcheckbutton (lua_State *L, CheckButton *pCheckButton) {
+  LCheckButton *plCheckButton = dynamic_cast<LCheckButton *>(pCheckButton);
+  if (plCheckButton)
+    ++plCheckButton->m_nRefCount;
+  PHandle *phPanel = (PHandle *)lua_newuserdata(L, sizeof(PHandle));
+  phPanel->Set(pCheckButton);
+  luaL_getmetatable(L, "CheckButton");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CheckButton *luaL_checkcheckbutton (lua_State *L, int narg) {
+  lua_CheckButton *d = lua_tocheckbutton(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "CheckButton expected, got INVALID_PANEL");
+  return d;
+}
+
+
+static int CheckButton_ChainToAnimationMap (lua_State *L) {
+  luaL_checkcheckbutton(L, 1)->ChainToAnimationMap();
+  return 0;
+}
+
+static int CheckButton_ChainToMap (lua_State *L) {
+  luaL_checkcheckbutton(L, 1)->ChainToMap();
+  return 0;
+}
+
+static int CheckButton_GetDisabledBgColor (lua_State *L) {
+  lua_pushcolor(L, luaL_checkcheckbutton(L, 1)->GetDisabledBgColor());
+  return 1;
+}
+
+static int CheckButton_GetDisabledFgColor (lua_State *L) {
+  lua_pushcolor(L, luaL_checkcheckbutton(L, 1)->GetDisabledFgColor());
+  return 1;
+}
+
+static int CheckButton_GetPanelBaseClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkcheckbutton(L, 1)->GetPanelBaseClassName());
+  return 1;
+}
+
+static int CheckButton_GetPanelClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkcheckbutton(L, 1)->GetPanelClassName());
+  return 1;
+}
+
+static int CheckButton_GetRefTable (lua_State *L) {
+  LCheckButton *plCheckButton = dynamic_cast<LCheckButton *>(luaL_checkcheckbutton(L, 1));
+  if (plCheckButton) {
+    if (plCheckButton->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plCheckButton->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plCheckButton->m_nTableReference);
+  }
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+static int CheckButton_KB_AddBoundKey (lua_State *L) {
+  luaL_checkcheckbutton(L, 1)->KB_AddBoundKey(luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int CheckButton_KB_ChainToMap (lua_State *L) {
+  luaL_checkcheckbutton(L, 1)->KB_ChainToMap();
+  return 0;
+}
+
+static int CheckButton_SetCheckButtonCheckable (lua_State *L) {
+  luaL_checkcheckbutton(L, 1)->SetCheckButtonCheckable(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CheckButton_SetSelected (lua_State *L) {
+  luaL_checkcheckbutton(L, 1)->SetSelected(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CheckButton___index (lua_State *L) {
+  CheckButton *pCheckButton = lua_tocheckbutton(L, 1);
+  if (pCheckButton == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  LCheckButton *plCheckButton = dynamic_cast<LCheckButton *>(pCheckButton);
+  if (plCheckButton && plCheckButton->m_nTableReference != LUA_NOREF) {
+    lua_getref(L, plCheckButton->m_nTableReference);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      lua_getmetatable(L, 1);
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "Button");
+        lua_pushvalue(L, 2);
+        lua_gettable(L, -2);
+        if (lua_isnil(L, -1)) {
+          lua_pop(L, 2);
+          luaL_getmetatable(L, "Panel");
+          lua_pushvalue(L, 2);
+          lua_gettable(L, -2);
+        }
+      }
+    }
+  } else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      luaL_getmetatable(L, "Button");
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "Panel");
+        lua_pushvalue(L, 2);
+        lua_gettable(L, -2);
+      }
+    }
+  }
+  return 1;
+}
+
+static int CheckButton___newindex (lua_State *L) {
+  CheckButton *pCheckButton = lua_tocheckbutton(L, 1);
+  if (pCheckButton == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+  LCheckButton *plCheckButton = dynamic_cast<LCheckButton *>(pCheckButton);
+  if (plCheckButton) {
+    if (plCheckButton->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plCheckButton->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plCheckButton->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, luaL_checkstring(L, 2));
+	lua_pop(L, 1);
+    return 0;
+  } else {
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index a non-scripted panel", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+}
+
+static int CheckButton___gc (lua_State *L) {
+  LCheckButton *plCheckButton = dynamic_cast<LCheckButton *>(lua_tocheckbutton(L, 1));
+  if (plCheckButton) {
+    --plCheckButton->m_nRefCount;
+	if (plCheckButton->m_nRefCount <= 0) {
+      delete plCheckButton;
+    }
+  }
+  return 0;
+}
+
+static int CheckButton___eq (lua_State *L) {
+  lua_pushboolean(L, lua_tocheckbutton(L, 1) == lua_tocheckbutton(L, 2));
+  return 1;
+}
+
+static int CheckButton___tostring (lua_State *L) {
+  CheckButton *pCheckButton = lua_tocheckbutton(L, 1);
+  if (pCheckButton == NULL)
+    lua_pushstring(L, "INVALID_PANEL");
+  else {
+    const char *pName = pCheckButton->GetName();
+    if (Q_strcmp(pName, "") == 0)
+      pName = "(no name)";
+    lua_pushfstring(L, "CheckButton: \"%s\"", pName);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg CheckButtonmeta[] = {
+  {"ChainToAnimationMap", CheckButton_ChainToAnimationMap},
+  {"ChainToMap", CheckButton_ChainToMap},
+  {"GetDisabledBgColor", CheckButton_GetDisabledBgColor},
+  {"GetDisabledFgColor", CheckButton_GetDisabledFgColor},
+  {"GetPanelBaseClassName", CheckButton_GetPanelBaseClassName},
+  {"GetPanelClassName", CheckButton_GetPanelClassName},
+  {"GetRefTable", CheckButton_GetRefTable},
+  {"KB_AddBoundKey", CheckButton_KB_AddBoundKey},
+  {"KB_ChainToMap", CheckButton_KB_ChainToMap},
+  {"SetCheckButtonCheckable", CheckButton_SetCheckButtonCheckable},
+  {"SetSelected", CheckButton_SetSelected},
+  {"__index", CheckButton___index},
+  {"__newindex", CheckButton___newindex},
+  {"__gc", CheckButton___gc},
+  {"__eq", CheckButton___eq},
+  {"__tostring", CheckButton___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_CheckButton (lua_State *L) {
+  CheckButton *pCheckButton = new LCheckButton(luaL_optpanel(L, 1, VGui_GetClientLuaRootPanel()), luaL_optstring(L, 2, NULL), luaL_optstring(L, 3, NULL), L);
+  lua_pushcheckbutton(L, pCheckButton);
+  return 1;
+}
+
+
+static const luaL_Reg CheckButton_funcs[] = {
+  {"CheckButton", luasrc_CheckButton},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CheckButton object
+*/
+LUALIB_API int luaopen_vgui_CheckButton(lua_State *L) {
+  luaL_newmetatable(L, "CheckButton");
+  luaL_register(L, NULL, CheckButtonmeta);
+  lua_pushstring(L, "panel");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "panel" */
+  luaL_register(L, "vgui", CheckButton_funcs);
+  lua_pop(L, 2);
+  return 1;
+}
diff --git a/src/game/client/scripted_controls/lCheckButton.h b/src/game/client/scripted_controls/lCheckButton.h
new file mode 100644
index 0000000..1cf9d7d
--- /dev/null
+++ b/src/game/client/scripted_controls/lCheckButton.h
@@ -0,0 +1,75 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef VGUI_LCHECKBUTTON_H
+#define VGUI_LCHECKBUTTON_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include <vgui_controls/CheckButton.h>
+
+namespace vgui
+{
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+class LCheckButton : public CheckButton
+{
+	DECLARE_CLASS_SIMPLE( LCheckButton, CheckButton );
+
+public:
+	LCheckButton(Panel *parent, const char *panelName, const char *text, lua_State *L);
+	virtual ~LCheckButton();
+
+protected:
+	MESSAGE_FUNC( OnCheckButtonChecked, "CheckButtonChecked" );
+
+public:
+#if defined( LUA_SDK )
+	lua_State *m_lua_State;
+	int m_nTableReference;
+	int m_nRefCount;
+#endif
+};
+
+} // namespace vgui
+
+#define BEGIN_LUA_CALL_CHECKBUTTON_METHOD(functionName) \
+  if (m_nTableReference >= 0) { \
+    lua_getref(m_lua_State, m_nTableReference); \
+    lua_getfield(m_lua_State, -1, functionName); \
+    lua_remove(m_lua_State, -2); \
+    if (lua_isfunction(m_lua_State, -1)) { \
+      int args = 0; \
+	  lua_pushcheckbutton(m_lua_State, this); \
+	  ++args;
+
+/* type for CheckButton functions */
+typedef vgui::CheckButton lua_CheckButton;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CheckButton     *(lua_tocheckbutton) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushcheckbutton) (lua_State *L, lua_CheckButton *pCheckButton);
+
+
+
+LUALIB_API lua_CheckButton *(luaL_checkcheckbutton) (lua_State *L, int narg);
+
+#endif // VGUI_LCHECKBUTTON_H
diff --git a/src/game/client/scripted_controls/lFrame.cpp b/src/game/client/scripted_controls/lFrame.cpp
new file mode 100644
index 0000000..46e947c
--- /dev/null
+++ b/src/game/client/scripted_controls/lFrame.cpp
@@ -0,0 +1,519 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#include <cbase.h>
+#include <vgui/IVGui.h>
+#include <vgui_int.h>
+#include <ienginevgui.h>
+#include <luamanager.h>
+#include <vgui_controls/lPanel.h>
+#include <LKeyValues.h>
+
+#include <scripted_controls/lFrame.h>
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include <tier0/memdbgon.h>
+
+using namespace vgui;
+
+//-----------------------------------------------------------------------------
+// Purpose: Constructor
+//-----------------------------------------------------------------------------
+LFrame::LFrame(Panel *parent, const char *panelName, bool showTaskbarIcon, lua_State *L) : Frame(parent, panelName, showTaskbarIcon)
+{
+#if defined( LUA_SDK )
+	m_lua_State = L;
+	m_nTableReference = LUA_NOREF;
+	m_nRefCount = 0;
+#endif // LUA_SDK
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Destructor
+//-----------------------------------------------------------------------------
+LFrame::~LFrame()
+{
+#if defined( LUA_SDK )
+	lua_unref( m_lua_State, m_nTableReference );
+#endif // LUA_SDK
+}
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_Frame *lua_toframe (lua_State *L, int idx) {
+  PHandle *phPanel = dynamic_cast<PHandle *>((PHandle *)lua_touserdata(L, idx));
+  if (phPanel == NULL)
+    return NULL;
+  return dynamic_cast<lua_Frame *>(phPanel->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushframe (lua_State *L, Frame *pFrame) {
+  LFrame *plFrame = dynamic_cast<LFrame *>(pFrame);
+  if (plFrame)
+    ++plFrame->m_nRefCount;
+  PHandle *phPanel = (PHandle *)lua_newuserdata(L, sizeof(PHandle));
+  phPanel->Set(pFrame);
+  luaL_getmetatable(L, "Frame");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_Frame *luaL_checkframe (lua_State *L, int narg) {
+  lua_Frame *d = lua_toframe(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "Frame expected, got INVALID_PANEL");
+  return d;
+}
+
+
+static int Frame_Activate (lua_State *L) {
+  luaL_checkframe(L, 1)->Activate();
+  return 0;
+}
+
+static int Frame_ActivateMinimized (lua_State *L) {
+  luaL_checkframe(L, 1)->ActivateMinimized();
+  return 0;
+}
+
+static int Frame_CanChainKeysToParent (lua_State *L) {
+  lua_pushboolean(L, luaL_checkframe(L, 1)->CanChainKeysToParent());
+  return 1;
+}
+
+static int Frame_CanStartDragging (lua_State *L) {
+  lua_pushboolean(L, luaL_checkframe(L, 1)->CanStartDragging(luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5)));
+  return 1;
+}
+
+static int Frame_ChainToAnimationMap (lua_State *L) {
+  luaL_checkframe(L, 1)->ChainToAnimationMap();
+  return 0;
+}
+
+static int Frame_ChainToMap (lua_State *L) {
+  luaL_checkframe(L, 1)->ChainToMap();
+  return 0;
+}
+
+static int Frame_Close (lua_State *L) {
+  luaL_checkframe(L, 1)->Close();
+  return 0;
+}
+
+static int Frame_CloseModal (lua_State *L) {
+  luaL_checkframe(L, 1)->CloseModal();
+  return 0;
+}
+
+static int Frame_DeletePanel (lua_State *L) {
+  luaL_checkframe(L, 1)->DeletePanel();
+  return 0;
+}
+
+static int Frame_DisableFadeEffect (lua_State *L) {
+  luaL_checkframe(L, 1)->DisableFadeEffect();
+  return 0;
+}
+
+static int Frame_DoModal (lua_State *L) {
+  luaL_checkframe(L, 1)->DoModal();
+  return 0;
+}
+
+static int Frame_FlashWindow (lua_State *L) {
+  luaL_checkframe(L, 1)->FlashWindow();
+  return 0;
+}
+
+static int Frame_FlashWindowStop (lua_State *L) {
+  luaL_checkframe(L, 1)->FlashWindowStop();
+  return 0;
+}
+
+static int Frame_GetBottomRightSize (lua_State *L) {
+  lua_pushinteger(L, luaL_checkframe(L, 1)->GetBottomRightSize());
+  return 1;
+}
+
+static int Frame_GetCaptionHeight (lua_State *L) {
+  lua_pushinteger(L, luaL_checkframe(L, 1)->GetCaptionHeight());
+  return 1;
+}
+
+static int Frame_GetClipToParent (lua_State *L) {
+  lua_pushboolean(L, luaL_checkframe(L, 1)->GetClipToParent());
+  return 1;
+}
+
+static int Frame_GetCornerSize (lua_State *L) {
+  lua_pushinteger(L, luaL_checkframe(L, 1)->GetCornerSize());
+  return 1;
+}
+
+static int Frame_GetDraggerSize (lua_State *L) {
+  lua_pushinteger(L, luaL_checkframe(L, 1)->GetDraggerSize());
+  return 1;
+}
+
+static int Frame_GetPanelBaseClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkframe(L, 1)->GetPanelBaseClassName());
+  return 1;
+}
+
+static int Frame_GetPanelClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkframe(L, 1)->GetPanelClassName());
+  return 1;
+}
+
+static int Frame_GetRefTable (lua_State *L) {
+  LFrame *plFrame = dynamic_cast<LFrame *>(luaL_checkframe(L, 1));
+  if (plFrame) {
+    if (plFrame->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plFrame->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plFrame->m_nTableReference);
+  }
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+static int Frame_IsMinimized (lua_State *L) {
+  lua_pushboolean(L, luaL_checkframe(L, 1)->IsMinimized());
+  return 1;
+}
+
+static int Frame_IsMoveable (lua_State *L) {
+  lua_pushboolean(L, luaL_checkframe(L, 1)->IsMoveable());
+  return 1;
+}
+
+static int Frame_IsSizeable (lua_State *L) {
+  lua_pushboolean(L, luaL_checkframe(L, 1)->IsSizeable());
+  return 1;
+}
+
+static int Frame_IsSmallCaption (lua_State *L) {
+  lua_pushboolean(L, luaL_checkframe(L, 1)->IsSmallCaption());
+  return 1;
+}
+
+static int Frame_KB_AddBoundKey (lua_State *L) {
+  luaL_checkframe(L, 1)->KB_AddBoundKey(luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int Frame_KB_ChainToMap (lua_State *L) {
+  luaL_checkframe(L, 1)->KB_ChainToMap();
+  return 0;
+}
+
+static int Frame_LoadControlSettings (lua_State *L) {
+  luaL_checkframe(L, 1)->LoadControlSettings(luaL_checkstring(L, 2), luaL_optstring(L, 3, NULL), luaL_optkeyvalues(L, 4, NULL));
+  return 0;
+}
+
+static int Frame_MoveToCenterOfScreen (lua_State *L) {
+  luaL_checkframe(L, 1)->MoveToCenterOfScreen();
+  return 0;
+}
+
+static int Frame_OnCommand (lua_State *L) {
+  luaL_checkframe(L, 1)->OnCommand(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int Frame_PlaceUnderCursor (lua_State *L) {
+  luaL_checkframe(L, 1)->PlaceUnderCursor();
+  return 0;
+}
+
+static int Frame_SetChainKeysToParent (lua_State *L) {
+  luaL_checkframe(L, 1)->SetChainKeysToParent(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetClipToParent (lua_State *L) {
+  luaL_checkframe(L, 1)->SetClipToParent(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetCloseButtonVisible (lua_State *L) {
+  luaL_checkframe(L, 1)->SetCloseButtonVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetDeleteSelfOnClose (lua_State *L) {
+  luaL_checkframe(L, 1)->SetDeleteSelfOnClose(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetImages (lua_State *L) {
+  luaL_checkframe(L, 1)->SetImages(luaL_checkstring(L, 2), luaL_optstring(L, 3, 0));
+  return 0;
+}
+
+static int Frame_SetMaximizeButtonVisible (lua_State *L) {
+  luaL_checkframe(L, 1)->SetMaximizeButtonVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetMenuButtonResponsive (lua_State *L) {
+  luaL_checkframe(L, 1)->SetMenuButtonResponsive(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetMenuButtonVisible (lua_State *L) {
+  luaL_checkframe(L, 1)->SetMenuButtonVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetMinimizeButtonVisible (lua_State *L) {
+  luaL_checkframe(L, 1)->SetMinimizeButtonVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetMinimizeToSysTrayButtonVisible (lua_State *L) {
+  luaL_checkframe(L, 1)->SetMinimizeToSysTrayButtonVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetMoveable (lua_State *L) {
+  luaL_checkframe(L, 1)->SetMoveable(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetSizeable (lua_State *L) {
+  luaL_checkframe(L, 1)->SetSizeable(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetSmallCaption (lua_State *L) {
+  luaL_checkframe(L, 1)->SetSmallCaption(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame_SetTitle (lua_State *L) {
+  luaL_checkframe(L, 1)->SetTitle(luaL_checkstring(L, 2), luaL_checkboolean(L, 3));
+  return 0;
+}
+
+static int Frame_SetTitleBarVisible (lua_State *L) {
+  luaL_checkframe(L, 1)->SetTitleBarVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Frame___index (lua_State *L) {
+  Frame *pFrame = lua_toframe(L, 1);
+  if (pFrame == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  LFrame *plFrame = dynamic_cast<LFrame *>(pFrame);
+  if (plFrame && plFrame->m_nTableReference != LUA_NOREF) {
+    lua_getref(L, plFrame->m_nTableReference);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      lua_getmetatable(L, 1);
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "EditablePanel");
+        lua_pushvalue(L, 2);
+        lua_gettable(L, -2);
+        if (lua_isnil(L, -1)) {
+          lua_pop(L, 2);
+          luaL_getmetatable(L, "Panel");
+          lua_pushvalue(L, 2);
+          lua_gettable(L, -2);
+        }
+      }
+    }
+  } else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      luaL_getmetatable(L, "EditablePanel");
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "Panel");
+        lua_pushvalue(L, 2);
+        lua_gettable(L, -2);
+      }
+    }
+  }
+  return 1;
+}
+
+static int Frame___newindex (lua_State *L) {
+  Frame *pFrame = lua_toframe(L, 1);
+  if (pFrame == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+  LFrame *plFrame = dynamic_cast<LFrame *>(pFrame);
+  if (plFrame) {
+    if (plFrame->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plFrame->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plFrame->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, luaL_checkstring(L, 2));
+	lua_pop(L, 1);
+    return 0;
+  } else {
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index a non-scripted panel", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+}
+
+static int Frame___gc (lua_State *L) {
+  LFrame *plFrame = dynamic_cast<LFrame *>(lua_toframe(L, 1));
+  if (plFrame) {
+    --plFrame->m_nRefCount;
+	if (plFrame->m_nRefCount <= 0) {
+      delete plFrame;
+    }
+  }
+  return 0;
+}
+
+static int Frame___eq (lua_State *L) {
+  lua_pushboolean(L, lua_toframe(L, 1) == lua_toframe(L, 2));
+  return 1;
+}
+
+static int Frame___tostring (lua_State *L) {
+  Frame *pFrame = lua_toframe(L, 1);
+  if (pFrame == NULL)
+    lua_pushstring(L, "INVALID_PANEL");
+  else {
+    const char *pName = pFrame->GetName();
+    if (Q_strcmp(pName, "") == 0)
+      pName = "(no name)";
+    lua_pushfstring(L, "Frame: \"%s\"", pName);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg Framemeta[] = {
+  {"Activate", Frame_Activate},
+  {"ActivateMinimized", Frame_ActivateMinimized},
+  {"CanChainKeysToParent", Frame_CanChainKeysToParent},
+  {"CanStartDragging", Frame_CanStartDragging},
+  {"ChainToAnimationMap", Frame_ChainToAnimationMap},
+  {"ChainToMap", Frame_ChainToMap},
+  {"Close", Frame_Close},
+  {"CloseModal", Frame_CloseModal},
+  {"DeletePanel", Frame_DeletePanel},
+  {"DisableFadeEffect", Frame_DisableFadeEffect},
+  {"DoModal", Frame_DoModal},
+  {"FlashWindow", Frame_FlashWindow},
+  {"FlashWindowStop", Frame_FlashWindowStop},
+  {"GetBottomRightSize", Frame_GetBottomRightSize},
+  {"GetCaptionHeight", Frame_GetCaptionHeight},
+  {"GetClipToParent", Frame_GetClipToParent},
+  {"GetCornerSize", Frame_GetCornerSize},
+  {"GetDraggerSize", Frame_GetDraggerSize},
+  {"GetPanelBaseClassName", Frame_GetPanelBaseClassName},
+  {"GetPanelClassName", Frame_GetPanelClassName},
+  {"GetRefTable", Frame_GetRefTable},
+  {"IsMinimized", Frame_IsMinimized},
+  {"IsMoveable", Frame_IsMoveable},
+  {"IsSizeable", Frame_IsSizeable},
+  {"IsSmallCaption", Frame_IsSmallCaption},
+  {"KB_AddBoundKey", Frame_KB_AddBoundKey},
+  {"KB_ChainToMap", Frame_KB_ChainToMap},
+  {"LoadControlSettings", Frame_LoadControlSettings},
+  {"MoveToCenterOfScreen", Frame_MoveToCenterOfScreen},
+  {"OnCommand", Frame_OnCommand},
+  {"PlaceUnderCursor", Frame_PlaceUnderCursor},
+  {"SetChainKeysToParent", Frame_SetChainKeysToParent},
+  {"SetClipToParent", Frame_SetClipToParent},
+  {"SetCloseButtonVisible", Frame_SetCloseButtonVisible},
+  {"SetDeleteSelfOnClose", Frame_SetDeleteSelfOnClose},
+  {"SetImages", Frame_SetImages},
+  {"SetMaximizeButtonVisible", Frame_SetMaximizeButtonVisible},
+  {"SetMenuButtonResponsive", Frame_SetMenuButtonResponsive},
+  {"SetMenuButtonVisible", Frame_SetMenuButtonVisible},
+  {"SetMinimizeButtonVisible", Frame_SetMinimizeButtonVisible},
+  {"SetMinimizeToSysTrayButtonVisible", Frame_SetMinimizeToSysTrayButtonVisible},
+  {"SetMoveable", Frame_SetMoveable},
+  {"SetSizeable", Frame_SetSizeable},
+  {"SetSmallCaption", Frame_SetSmallCaption},
+  {"SetTitle", Frame_SetTitle},
+  {"SetTitleBarVisible", Frame_SetTitleBarVisible},
+  {"__index", Frame___index},
+  {"__newindex", Frame___newindex},
+  {"__gc", Frame___gc},
+  {"__eq", Frame___eq},
+  {"__tostring", Frame___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_Frame (lua_State *L) {
+  Frame *pFrame = new LFrame(luaL_optpanel(L, 1, VGui_GetClientLuaRootPanel()), luaL_optstring(L, 2, NULL), luaL_optboolean(L, 3, true), L);
+  lua_pushframe(L, pFrame);
+  return 1;
+}
+
+
+static const luaL_Reg Frame_funcs[] = {
+  {"Frame", luasrc_Frame},
+  {NULL, NULL}
+};
+
+
+/*
+** Open Frame object
+*/
+LUALIB_API int luaopen_vgui_Frame(lua_State *L) {
+  luaL_newmetatable(L, "Frame");
+  luaL_register(L, NULL, Framemeta);
+  lua_pushstring(L, "panel");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "panel" */
+  luaL_register(L, "vgui", Frame_funcs);
+  lua_pop(L, 2);
+  return 1;
+}
\ No newline at end of file
diff --git a/src/game/client/scripted_controls/lFrame.h b/src/game/client/scripted_controls/lFrame.h
new file mode 100644
index 0000000..0a6b8d0
--- /dev/null
+++ b/src/game/client/scripted_controls/lFrame.h
@@ -0,0 +1,62 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef VGUI_LFRAME_H
+#define VGUI_LFRAME_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include <vgui_controls/Frame.h>
+
+namespace vgui
+{
+
+//-----------------------------------------------------------------------------
+// Purpose: Lua wrapper for a windowed frame
+//-----------------------------------------------------------------------------
+class LFrame : public Frame
+{
+	DECLARE_CLASS_SIMPLE( LFrame, Frame );
+
+public:
+	LFrame(Panel *parent, const char *panelName, bool showTaskbarIcon = true, lua_State *L = NULL);
+	virtual ~LFrame();
+
+public:
+#if defined( LUA_SDK )
+	lua_State *m_lua_State;
+	int m_nTableReference;
+	int m_nRefCount;
+#endif
+};
+
+} // namespace vgui
+
+/* type for Frame functions */
+typedef vgui::Frame lua_Frame;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_Frame     *(lua_toframe) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushframe) (lua_State *L, lua_Frame *pFrame);
+
+
+
+LUALIB_API lua_Frame *(luaL_checkframe) (lua_State *L, int narg);
+
+#endif // VGUI_LFRAME_H
diff --git a/src/game/client/scripted_controls/lPanel.cpp b/src/game/client/scripted_controls/lPanel.cpp
new file mode 100644
index 0000000..e493ead
--- /dev/null
+++ b/src/game/client/scripted_controls/lPanel.cpp
@@ -0,0 +1,490 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+
+#include <cbase.h>
+#include <vgui_int.h>
+#include <luamanager.h>
+#include <vgui_controls/lPanel.h>
+
+#include <scripted_controls/lPanel.h>
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include <tier0/memdbgon.h>
+
+using namespace vgui;
+
+//-----------------------------------------------------------------------------
+// Purpose: Constructor
+//-----------------------------------------------------------------------------
+LPanel::LPanel(Panel *parent, const char *panelName, lua_State *L) : Panel(parent, panelName)
+{
+#if defined( LUA_SDK )
+	m_lua_State = L;
+	m_nTableReference = LUA_NOREF;
+	m_nRefCount = 0;
+#endif // LUA_SDK
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Destructor
+//-----------------------------------------------------------------------------
+LPanel::~LPanel()
+{
+#if defined( LUA_SDK )
+	lua_unref( m_lua_State, m_nTableReference );
+#endif // LUA_SDK
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Screen size change notification handler
+//-----------------------------------------------------------------------------
+void LPanel::OnScreenSizeChanged(int nOldWide, int nOldTall)
+{
+	BaseClass::OnScreenSizeChanged(nOldWide, nOldTall);
+
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnScreenSizeChanged" );
+		lua_pushinteger( m_lua_State, nOldWide );
+		lua_pushinteger( m_lua_State, nOldTall );
+	END_LUA_CALL_PANEL_METHOD( 2, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void LPanel::PaintBorder()
+{
+	BaseClass::PaintBorder();
+
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "PaintBorder" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void LPanel::PaintBackground()
+{ 
+	BaseClass::PaintBackground();
+
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "PaintBackground" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void LPanel::Paint()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "Paint" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void LPanel::PostChildPaint()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "PostChildPaint" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Draws a black rectangle around the panel.
+//-----------------------------------------------------------------------------
+void LPanel::PaintBuildOverlay()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "PaintBuildOverlay" );
+	END_LUA_CALL_PANEL_METHOD( 0, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::PaintBuildOverlay();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void LPanel::OnChildAdded(VPANEL child)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnChildAdded" );
+		lua_pushpanel( m_lua_State, child );
+	END_LUA_CALL_PANEL_METHOD( 0, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnChildAdded(child);
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: default message handler
+//-----------------------------------------------------------------------------
+void LPanel::OnSizeChanged(int newWide, int newTall)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnSizeChanged" );
+		lua_pushinteger( m_lua_State, newWide );
+		lua_pushinteger( m_lua_State, newTall );
+	END_LUA_CALL_PANEL_METHOD( 2, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnSizeChanged(newWide, newTall);
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Called every frame the panel is visible, designed to be overridden
+//-----------------------------------------------------------------------------
+void LPanel::OnThink()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnThink" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+// input messages handlers (designed for override)
+void LPanel::OnCursorMoved(int x, int y)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnCursorMoved" );
+		lua_pushinteger( m_lua_State, x );
+		lua_pushinteger( m_lua_State, y );
+	END_LUA_CALL_PANEL_METHOD( 2, 0 );
+#endif
+}
+
+void LPanel::OnCursorEntered()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnCursorEntered" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+void LPanel::OnCursorExited()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnCursorExited" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+void LPanel::OnMousePressed(MouseCode code)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnMousePressed" );
+		lua_pushinteger( m_lua_State, code );
+	END_LUA_CALL_PANEL_METHOD( 1, 0 );
+#endif
+}
+
+void LPanel::OnMouseDoublePressed(MouseCode code)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnMouseDoublePressed" );
+		lua_pushinteger( m_lua_State, code );
+	END_LUA_CALL_PANEL_METHOD( 1, 0 );
+#endif
+}
+
+void LPanel::OnMouseTriplePressed(MouseCode code)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnMouseTriplePressed" );
+		lua_pushinteger( m_lua_State, code );
+	END_LUA_CALL_PANEL_METHOD( 1, 0 );
+#endif
+}
+
+void LPanel::OnMouseReleased(MouseCode code)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnMouseReleased" );
+		lua_pushinteger( m_lua_State, code );
+	END_LUA_CALL_PANEL_METHOD( 1, 0 );
+#endif
+}
+
+void LPanel::OnMouseWheeled(int delta)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnMouseWheeled" );
+		lua_pushinteger( m_lua_State, delta );
+	END_LUA_CALL_PANEL_METHOD( 1, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnMouseWheeled(delta);
+}
+
+// base implementation forwards Key messages to the Panel's parent - override to 'swallow' the input
+void LPanel::OnKeyCodePressed(KeyCode code)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnKeyCodePressed" );
+		lua_pushinteger( m_lua_State, code );
+	END_LUA_CALL_PANEL_METHOD( 1, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnKeyCodePressed(code);
+}
+
+void LPanel::OnKeyCodeTyped(KeyCode code)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnKeyCodeTyped" );
+		lua_pushinteger( m_lua_State, code );
+	END_LUA_CALL_PANEL_METHOD( 1, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnKeyCodeTyped(code);
+}
+
+void LPanel::OnKeyCodeReleased(KeyCode code)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnKeyCodeReleased" );
+		lua_pushinteger( m_lua_State, code );
+	END_LUA_CALL_PANEL_METHOD( 1, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnKeyCodeReleased(code);
+}
+
+void LPanel::OnKeyFocusTicked()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnKeyFocusTicked" );
+	END_LUA_CALL_PANEL_METHOD( 0, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnKeyFocusTicked();
+}
+
+void LPanel::OnMouseFocusTicked()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnMouseFocusTicked" );
+	END_LUA_CALL_PANEL_METHOD( 0, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnMouseFocusTicked();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Called after a panel requests focus to fix up the whole chain
+//-----------------------------------------------------------------------------
+void LPanel::OnRequestFocus(VPANEL subFocus, VPANEL defaultPanel)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnRequestFocus" );
+		lua_pushpanel( m_lua_State, subFocus );
+		lua_pushpanel( m_lua_State, defaultPanel );
+	END_LUA_CALL_PANEL_METHOD( 2, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnRequestFocus(subFocus, defaultPanel);
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Called when a panel loses it's mouse capture
+//-----------------------------------------------------------------------------
+void LPanel::OnMouseCaptureLost()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnMouseCaptureLost" );
+	END_LUA_CALL_PANEL_METHOD( 0, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnMouseCaptureLost();
+}
+
+void LPanel::PerformLayout()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "PerformLayout" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Called when a panel receives a command message from another panel
+//-----------------------------------------------------------------------------
+void LPanel::OnCommand(const char *command)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnCommand" );
+		lua_pushstring( m_lua_State, command );
+	END_LUA_CALL_PANEL_METHOD( 1, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+	BaseClass::OnCommand( command );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: panel gained focus message
+//-----------------------------------------------------------------------------
+void LPanel::OnSetFocus()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnSetFocus" );
+	END_LUA_CALL_PANEL_METHOD( 0, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnSetFocus();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: panel lost focus message
+//-----------------------------------------------------------------------------
+void LPanel::OnKillFocus()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnKillFocus" );
+	END_LUA_CALL_PANEL_METHOD( 0, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnKillFocus();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void LPanel::ApplySchemeSettings(IScheme *pScheme)
+{
+	BaseClass::ApplySchemeSettings(pScheme);
+
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "ApplySchemeSettings" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+
+//-----------------------------------------------------------------------------
+// Purpose: Loads panel details from the resource info
+//-----------------------------------------------------------------------------
+void LPanel::ApplySettings(KeyValues *inResourceData)
+{
+	BaseClass::ApplySettings( inResourceData );
+
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "ApplySettings" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: called whenever the panel moves
+//-----------------------------------------------------------------------------
+void LPanel::OnMove()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnMove" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: empty function
+//-----------------------------------------------------------------------------
+void LPanel::OnTick()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnTick" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Handles a message
+//			Dispatches the message to a set of message maps
+//-----------------------------------------------------------------------------
+void LPanel::OnMessage(const KeyValues *params, VPANEL ifromPanel)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnMessage" );
+		lua_pushpanel( m_lua_State, ifromPanel );
+	END_LUA_CALL_PANEL_METHOD( 1, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnMessage( params, ifromPanel );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Called to delete the panel
+//-----------------------------------------------------------------------------
+void LPanel::OnDelete()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PANEL_METHOD( "OnDelete" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+
+	BaseClass::OnDelete();
+}
+
+static int luasrc_Panel (lua_State *L) {
+  Panel *pPanel = new LPanel(luaL_optpanel(L, 1, VGui_GetClientLuaRootPanel()), luaL_optstring(L, 2, NULL), L);
+  lua_pushpanel(L, pPanel);
+  return 1;
+}
+
+
+static const luaL_Reg Panel_funcs[] = {
+  {"Panel", luasrc_Panel},
+  {NULL, NULL}
+};
+
+
+/*
+** Open Panel object
+*/
+LUALIB_API int luaopen_vgui_Panel(lua_State *L) {
+  luaL_register(L, "vgui", Panel_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
diff --git a/src/game/client/scripted_controls/lPanel.h b/src/game/client/scripted_controls/lPanel.h
new file mode 100644
index 0000000..55063df
--- /dev/null
+++ b/src/game/client/scripted_controls/lPanel.h
@@ -0,0 +1,109 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#ifndef LLPANEL_H
+#define LLPANEL_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+namespace vgui
+{
+
+//-----------------------------------------------------------------------------
+// Purpose: Base interface to all vgui windows
+//			All vgui controls that receive message and/or have a physical presence
+//			on screen are be derived from Panel.
+//			This is designed as an easy-access to the vgui-functionality; for more
+//			low-level access to vgui functions use the IPanel/IClientPanel interfaces directly
+//-----------------------------------------------------------------------------
+class LPanel : public Panel
+{
+	DECLARE_CLASS_SIMPLE( LPanel, Panel );
+
+public:
+	//-----------------------------------------------------------------------------
+	// CONSTRUCTORS
+	// these functions deal with the creation of the Panel
+	// the Panel automatically gets a handle to a vgui-internal panel, the ipanel(), upon construction
+	// vgui interfaces deal only with ipanel(), not Panel directly
+	LPanel(Panel *parent, const char *panelName, lua_State *L);
+
+	virtual ~LPanel();
+
+	virtual void OnMove();
+
+	// called when scheme settings need to be applied; called the first time before the panel is painted
+	virtual void ApplySchemeSettings(IScheme *pScheme);
+
+	// interface to build settings
+	// takes a group of settings and applies them to the control
+	virtual void ApplySettings(KeyValues *inResourceData);
+
+	// message handlers
+	// override to get access to the message
+	// override to get access to the message
+	virtual void OnMessage(const KeyValues *params, VPANEL fromPanel);	// called when panel receives message; must chain back
+	MESSAGE_FUNC_CHARPTR( OnCommand, "Command", command );	// called when a panel receives a command
+	MESSAGE_FUNC( OnMouseCaptureLost, "MouseCaptureLost" );	// called after the panel loses mouse capture
+	MESSAGE_FUNC( OnSetFocus, "SetFocus" );			// called after the panel receives the keyboard focus
+	MESSAGE_FUNC( OnKillFocus, "KillFocus" );		// called after the panel loses the keyboard focus
+	MESSAGE_FUNC( OnDelete, "Delete" );				// called to delete the panel; Panel::OnDelete() does simply { delete this; }
+	virtual void OnThink();							// called every frame before painting, but only if panel is visible
+	virtual void OnChildAdded(VPANEL child);		// called when a child has been added to this panel
+	virtual void OnSizeChanged(int newWide, int newTall);	// called after the size of a panel has been changed
+	
+	// called every frame if ivgui()->AddTickSignal() is called
+	MESSAGE_FUNC( OnTick, "Tick" );
+
+	// input messages
+	MESSAGE_FUNC_INT_INT( OnCursorMoved, "OnCursorMoved", x, y );
+	virtual void OnCursorEntered();
+	virtual void OnCursorExited();
+	virtual void OnMousePressed(MouseCode code);
+	virtual void OnMouseDoublePressed(MouseCode code);
+	virtual void OnMouseReleased(MouseCode code);
+	virtual void OnMouseWheeled(int delta);
+
+	// Trip pressing (e.g., select all text in a TextEntry) requires this to be enabled
+	virtual void OnMouseTriplePressed( MouseCode code );
+
+	// base implementation forwards Key messages to the Panel's parent 
+	// - override to 'swallow' the input
+	virtual void OnKeyCodePressed(KeyCode code);
+	virtual void OnKeyCodeTyped(KeyCode code);
+	virtual void OnKeyCodeReleased(KeyCode code);
+	virtual void OnKeyFocusTicked(); // every window gets key ticked events
+
+	// forwards mouse messages to the panel's parent
+	MESSAGE_FUNC( OnMouseFocusTicked, "OnMouseFocusTicked" );
+
+	// message handlers that don't go through the message pump
+	virtual void PaintBackground();
+	virtual void Paint();
+	virtual void PaintBorder();
+	virtual void PaintBuildOverlay();		// the extra drawing for when in build mode
+	virtual void PostChildPaint();
+	virtual void PerformLayout();
+
+protected:
+	MESSAGE_FUNC_ENUM_ENUM( OnRequestFocus, "OnRequestFocus", VPANEL, subFocus, VPANEL, defaultPanel);
+	MESSAGE_FUNC_INT_INT( OnScreenSizeChanged, "OnScreenSizeChanged", oldwide, oldtall );
+
+public:
+#if defined( LUA_SDK )
+	lua_State		*m_lua_State;
+	int				m_nTableReference;
+	int				m_nRefCount;
+#endif
+};
+
+} // namespace vgui
+
+
+#endif // LLPANEL_H
diff --git a/src/game/client/scripted_controls/lPropertyDialog.cpp b/src/game/client/scripted_controls/lPropertyDialog.cpp
new file mode 100644
index 0000000..3d4fbd7
--- /dev/null
+++ b/src/game/client/scripted_controls/lPropertyDialog.cpp
@@ -0,0 +1,456 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#include <cbase.h>
+#include <vgui/KeyCode.h>
+#include <vgui_int.h>
+#include <luamanager.h>
+#include <vgui_controls/lPanel.h>
+
+#include <scripted_controls/lPropertyDialog.h>
+#include <vgui_controls/PropertySheet.h>
+#include <vgui_controls/Button.h>
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include <tier0/memdbgon.h>
+
+using namespace vgui;
+
+//-----------------------------------------------------------------------------
+// Purpose: Constructor
+//-----------------------------------------------------------------------------
+LPropertyDialog::LPropertyDialog(Panel *parent, const char *panelName, lua_State *L) : PropertyDialog(parent, panelName)
+{
+#if defined( LUA_SDK )
+	m_lua_State = L;
+	m_nTableReference = LUA_NOREF;
+	m_nRefCount = 0;
+#endif // LUA_SDK
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Destructor
+//-----------------------------------------------------------------------------
+LPropertyDialog::~LPropertyDialog()
+{
+#if defined( LUA_SDK )
+	lua_unref( m_lua_State, m_nTableReference );
+#endif // LUA_SDK
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Sets up the sheet
+//-----------------------------------------------------------------------------
+void LPropertyDialog::PerformLayout()
+{
+	BaseClass::PerformLayout();
+
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PROPERTYDIALOG_METHOD( "PerformLayout" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Handles command text from the buttons
+//-----------------------------------------------------------------------------
+void LPropertyDialog::OnCommand(const char *command)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PROPERTYDIALOG_METHOD( "OnCommand" );
+		lua_pushstring( m_lua_State, command );
+	END_LUA_CALL_PANEL_METHOD( 1, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnCommand(command);
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: called when the Cancel button is pressed
+//-----------------------------------------------------------------------------
+void LPropertyDialog::OnCancel()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PROPERTYDIALOG_METHOD( "OnCancel" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : code - 
+//-----------------------------------------------------------------------------
+void LPropertyDialog::OnKeyCodeTyped(KeyCode code)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PROPERTYDIALOG_METHOD( "OnKeyCodeTyped" );
+		lua_pushinteger( m_lua_State, code );
+	END_LUA_CALL_PANEL_METHOD( 1, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnKeyCodeTyped(code);
+}
+
+
+//-----------------------------------------------------------------------------
+// Purpose: Command handler
+//-----------------------------------------------------------------------------
+bool LPropertyDialog::OnOK(bool applyOnly)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PROPERTYDIALOG_METHOD( "OnOK" );
+		lua_pushboolean( m_lua_State, applyOnly );
+	END_LUA_CALL_PANEL_METHOD( 1, 1 );
+
+	RETURN_LUA_PANEL_BOOLEAN();
+#endif
+
+    // the sheet should have the pages apply changes before we tell the world
+	_propertySheet->ApplyChanges();
+
+    // this should tell anybody who's watching us that we're done
+	PostActionSignal(new KeyValues("ApplyChanges"));
+
+	// default to closing
+	return true;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: enable/disable the apply button
+//-----------------------------------------------------------------------------
+void LPropertyDialog::EnableApplyButton(bool bEnable)
+{
+	_applyButton->SetEnabled(bEnable);
+	InvalidateLayout();
+}
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_PropertyDialog *lua_topropertydialog (lua_State *L, int idx) {
+  PHandle *phPanel = dynamic_cast<PHandle *>((PHandle *)lua_touserdata(L, idx));
+  if (phPanel == NULL)
+    return NULL;
+  return dynamic_cast<lua_PropertyDialog *>(phPanel->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushpropertydialog (lua_State *L, PropertyDialog *pDialog) {
+  LPropertyDialog *plDialog = dynamic_cast<LPropertyDialog *>(pDialog);
+  if (plDialog)
+    ++plDialog->m_nRefCount;
+  PHandle *phPanel = (PHandle *)lua_newuserdata(L, sizeof(PHandle));
+  phPanel->Set(pDialog);
+  luaL_getmetatable(L, "PropertyDialog");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_PropertyDialog *luaL_checkpropertydialog (lua_State *L, int narg) {
+  lua_PropertyDialog *d = lua_topropertydialog(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "PropertyDialog expected, got INVALID_PANEL");
+  return d;
+}
+
+
+static int PropertyDialog_AddPage (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->AddPage(luaL_checkpanel(L, 2), luaL_checkstring(L, 3));
+  return 0;
+}
+
+static int PropertyDialog_ApplyChanges (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->ApplyChanges();
+  return 0;
+}
+
+static int PropertyDialog_ChainToAnimationMap (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->ChainToAnimationMap();
+  return 0;
+}
+
+static int PropertyDialog_ChainToMap (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->ChainToMap();
+  return 0;
+}
+
+static int PropertyDialog_EnableApplyButton (lua_State *L) {
+  LPropertyDialog *plDialog = dynamic_cast<LPropertyDialog *>(luaL_checkpropertydialog(L, 1));
+  if (plDialog)
+    plDialog->EnableApplyButton(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int PropertyDialog_GetActivePage (lua_State *L) {
+  lua_pushpanel(L, luaL_checkpropertydialog(L, 1)->GetActivePage());
+  return 1;
+}
+
+static int PropertyDialog_GetPanelBaseClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkpropertydialog(L, 1)->GetPanelBaseClassName());
+  return 1;
+}
+
+static int PropertyDialog_GetPanelClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkpropertydialog(L, 1)->GetPanelClassName());
+  return 1;
+}
+
+static int PropertyDialog_GetRefTable (lua_State *L) {
+  LPropertyDialog *plDialog = dynamic_cast<LPropertyDialog *>(luaL_checkpropertydialog(L, 1));
+  if (plDialog) {
+    if (plDialog->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plDialog->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plDialog->m_nTableReference);
+  }
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+static int PropertyDialog_KB_AddBoundKey (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->KB_AddBoundKey(luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int PropertyDialog_KB_ChainToMap (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->KB_ChainToMap();
+  return 0;
+}
+
+static int PropertyDialog_ResetAllData (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->ResetAllData();
+  return 0;
+}
+
+static int PropertyDialog_SetApplyButtonText (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->SetApplyButtonText(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int PropertyDialog_SetApplyButtonVisible (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->SetApplyButtonVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int PropertyDialog_SetCancelButtonText (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->SetCancelButtonText(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int PropertyDialog_SetCancelButtonVisible (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->SetCancelButtonVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int PropertyDialog_SetOKButtonText (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->SetOKButtonText(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int PropertyDialog_SetOKButtonVisible (lua_State *L) {
+  luaL_checkpropertydialog(L, 1)->SetOKButtonVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int PropertyDialog___index (lua_State *L) {
+  PropertyDialog *pDialog = lua_topropertydialog(L, 1);
+  if (pDialog == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  LPropertyDialog *plDialog = dynamic_cast<LPropertyDialog *>(pDialog);
+  if (plDialog && plDialog->m_nTableReference != LUA_NOREF) {
+    lua_getref(L, plDialog->m_nTableReference);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      lua_getmetatable(L, 1);
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "Frame");
+        lua_pushvalue(L, 2);
+        lua_gettable(L, -2);
+        if (lua_isnil(L, -1)) {
+          lua_pop(L, 2);
+          luaL_getmetatable(L, "EditablePanel");
+          lua_pushvalue(L, 2);
+          lua_gettable(L, -2);
+          if (lua_isnil(L, -1)) {
+            lua_pop(L, 2);
+            luaL_getmetatable(L, "Panel");
+            lua_pushvalue(L, 2);
+            lua_gettable(L, -2);
+          }
+        }
+      }
+    }
+  } else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      luaL_getmetatable(L, "Frame");
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "EditablePanel");
+        lua_pushvalue(L, 2);
+        lua_gettable(L, -2);
+        if (lua_isnil(L, -1)) {
+          lua_pop(L, 2);
+          luaL_getmetatable(L, "Panel");
+          lua_pushvalue(L, 2);
+          lua_gettable(L, -2);
+        }
+      }
+    }
+  }
+  return 1;
+}
+
+static int PropertyDialog___newindex (lua_State *L) {
+  PropertyDialog *pDialog = lua_topropertydialog(L, 1);
+  if (pDialog == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+  LPropertyDialog *plDialog = dynamic_cast<LPropertyDialog *>(pDialog);
+  if (plDialog) {
+    if (plDialog->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plDialog->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plDialog->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, luaL_checkstring(L, 2));
+	lua_pop(L, 1);
+    return 0;
+  } else {
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index a non-scripted panel", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+}
+
+static int PropertyDialog___gc (lua_State *L) {
+  LPropertyDialog *plDialog = dynamic_cast<LPropertyDialog *>(lua_topropertydialog(L, 1));
+  if (plDialog) {
+    --plDialog->m_nRefCount;
+	if (plDialog->m_nRefCount <= 0) {
+      delete plDialog;
+    }
+  }
+  return 0;
+}
+
+static int PropertyDialog___eq (lua_State *L) {
+  lua_pushboolean(L, lua_topropertydialog(L, 1) == lua_topropertydialog(L, 2));
+  return 1;
+}
+
+static int PropertyDialog___tostring (lua_State *L) {
+  PropertyDialog *pDialog = lua_topropertydialog(L, 1);
+  if (pDialog == NULL)
+    lua_pushstring(L, "INVALID_PANEL");
+  else {
+    const char *pName = pDialog->GetName();
+    if (Q_strcmp(pName, "") == 0)
+      pName = "(no name)";
+    lua_pushfstring(L, "PropertyDialog: \"%s\"", pName);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg PropertyDialogmeta[] = {
+  {"AddPage", PropertyDialog_AddPage},
+  {"ApplyChanges", PropertyDialog_ApplyChanges},
+  {"ChainToAnimationMap", PropertyDialog_ChainToAnimationMap},
+  {"ChainToMap", PropertyDialog_ChainToMap},
+  {"EnableApplyButton", PropertyDialog_EnableApplyButton},
+  {"GetActivePage", PropertyDialog_GetActivePage},
+  {"GetPanelBaseClassName", PropertyDialog_GetPanelBaseClassName},
+  {"GetPanelClassName", PropertyDialog_GetPanelClassName},
+  {"GetRefTable", PropertyDialog_GetRefTable},
+  {"KB_AddBoundKey", PropertyDialog_KB_AddBoundKey},
+  {"KB_ChainToMap", PropertyDialog_KB_ChainToMap},
+  {"ResetAllData", PropertyDialog_ResetAllData},
+  {"SetApplyButtonText", PropertyDialog_SetApplyButtonText},
+  {"SetApplyButtonVisible", PropertyDialog_SetApplyButtonVisible},
+  {"SetCancelButtonText", PropertyDialog_SetCancelButtonText},
+  {"SetCancelButtonVisible", PropertyDialog_SetCancelButtonVisible},
+  {"SetOKButtonText", PropertyDialog_SetOKButtonText},
+  {"SetOKButtonVisible", PropertyDialog_SetOKButtonVisible},
+  {"__index", PropertyDialog___index},
+  {"__newindex", PropertyDialog___newindex},
+  {"__gc", PropertyDialog___gc},
+  {"__eq", PropertyDialog___eq},
+  {"__tostring", PropertyDialog___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_PropertyDialog (lua_State *L) {
+  PropertyDialog *pDialog = new LPropertyDialog(luaL_optpanel(L, 1, VGui_GetClientLuaRootPanel()), luaL_checkstring(L, 2), L);
+  lua_pushpropertydialog(L, pDialog);
+  return 1;
+}
+
+
+static const luaL_Reg PropertyDialog_funcs[] = {
+  {"PropertyDialog", luasrc_PropertyDialog},
+  {NULL, NULL}
+};
+
+
+/*
+** Open PropertyDialog object
+*/
+LUALIB_API int luaopen_vgui_PropertyDialog(lua_State *L) {
+  luaL_newmetatable(L, "PropertyDialog");
+  luaL_register(L, NULL, PropertyDialogmeta);
+  lua_pushstring(L, "panel");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "panel" */
+  luaL_register(L, "vgui", PropertyDialog_funcs);
+  lua_pop(L, 2);
+  return 1;
+}
diff --git a/src/game/client/scripted_controls/lPropertyDialog.h b/src/game/client/scripted_controls/lPropertyDialog.h
new file mode 100644
index 0000000..1075e91
--- /dev/null
+++ b/src/game/client/scripted_controls/lPropertyDialog.h
@@ -0,0 +1,88 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LPROPERTYDIALOG_H
+#define LPROPERTYDIALOG_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include <vgui_controls/PropertyDialog.h>
+
+namespace vgui
+{
+
+//-----------------------------------------------------------------------------
+// Purpose: Lua wrapper for a simple frame that holds a property sheet
+//-----------------------------------------------------------------------------
+class LPropertyDialog : public PropertyDialog
+{
+	DECLARE_CLASS_SIMPLE( LPropertyDialog, PropertyDialog );
+
+public:
+	LPropertyDialog(Panel *parent, const char *panelName, lua_State *L);
+	~LPropertyDialog();
+
+protected:
+	// Called when the OK button is pressed.  Simply closes the dialog.
+	virtual bool OnOK(bool applyOnly);
+
+	// called when the Cancel button is pressed
+	virtual void OnCancel();
+
+	// vgui overrides
+	virtual void PerformLayout();
+	virtual void OnCommand(const char *command);
+	virtual void OnKeyCodeTyped(KeyCode code);
+
+public:
+	void EnableApplyButton(bool bEnable);
+
+public:
+#if defined( LUA_SDK )
+	lua_State *m_lua_State;
+	int m_nTableReference;
+	int m_nRefCount;
+#endif
+};
+
+}; // vgui
+
+#define BEGIN_LUA_CALL_PROPERTYDIALOG_METHOD(functionName) \
+  if (m_nTableReference >= 0) { \
+    lua_getref(m_lua_State, m_nTableReference); \
+    lua_getfield(m_lua_State, -1, functionName); \
+    lua_remove(m_lua_State, -2); \
+    if (lua_isfunction(m_lua_State, -1)) { \
+      int args = 0; \
+	  lua_pushpropertydialog(m_lua_State, this); \
+	  ++args;
+
+/* type for PropertyDialog functions */
+typedef vgui::PropertyDialog lua_PropertyDialog;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_PropertyDialog     *(lua_topropertydialog) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushpropertydialog) (lua_State *L, lua_PropertyDialog *pDialog);
+
+
+
+LUALIB_API lua_PropertyDialog *(luaL_checkpropertydialog) (lua_State *L, int narg);
+
+
+#endif // LPROPERTYDIALOG_H
diff --git a/src/game/client/scripted_controls/lPropertyPage.cpp b/src/game/client/scripted_controls/lPropertyPage.cpp
new file mode 100644
index 0000000..30f9e61
--- /dev/null
+++ b/src/game/client/scripted_controls/lPropertyPage.cpp
@@ -0,0 +1,402 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#include <cbase.h>
+#include "vgui/KeyCode.h"
+#include <vgui_int.h>
+#include "luamanager.h"
+#include <vgui_controls/lPanel.h>
+
+#include "scripted_controls/LPropertyPage.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+using namespace vgui;
+
+//-----------------------------------------------------------------------------
+// Purpose: Constructor
+//-----------------------------------------------------------------------------
+LPropertyPage::LPropertyPage(Panel *parent, const char *panelName, lua_State *L) : PropertyPage(parent, panelName)
+{
+#if defined( LUA_SDK )
+	m_lua_State = L;
+	m_nTableReference = LUA_NOREF;
+	m_nRefCount = 0;
+#endif // LUA_SDK
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Destructor
+//-----------------------------------------------------------------------------
+LPropertyPage::~LPropertyPage()
+{
+#if defined( LUA_SDK )
+	lua_unref( m_lua_State, m_nTableReference );
+#endif // LUA_SDK
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Called when page is loaded.  Data should be reloaded from document into controls.
+//-----------------------------------------------------------------------------
+void LPropertyPage::OnResetData()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PROPERTYPAGE_METHOD( "OnResetData" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Called when the OK / Apply button is pressed.  Changed data should be written into document.
+//-----------------------------------------------------------------------------
+void LPropertyPage::OnApplyChanges()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PROPERTYPAGE_METHOD( "OnApplyChanges" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Designed to be overriden
+//-----------------------------------------------------------------------------
+void LPropertyPage::OnPageShow()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PROPERTYPAGE_METHOD( "OnPageShow" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Designed to be overriden
+//-----------------------------------------------------------------------------
+void LPropertyPage::OnPageHide()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PROPERTYPAGE_METHOD( "OnPageHide" );
+	END_LUA_CALL_PANEL_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : *pageTab - 
+//-----------------------------------------------------------------------------
+void LPropertyPage::OnPageTabActivated(Panel *pageTab)
+{
+	_pageTab = pageTab;
+
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PROPERTYPAGE_METHOD( "OnPageTabActivated" );
+		lua_pushpanel( m_lua_State, pageTab );
+	END_LUA_CALL_PANEL_METHOD( 1, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void LPropertyPage::OnKeyCodeTyped(KeyCode code)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_PROPERTYPAGE_METHOD( "OnKeyCodeTyped" );
+		lua_pushinteger( m_lua_State, code );
+	END_LUA_CALL_PANEL_METHOD( 1, 1 );
+
+	RETURN_LUA_PANEL_NONE();
+#endif
+
+	BaseClass::OnKeyCodeTyped(code);
+}
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_PropertyPage *lua_topropertypage (lua_State *L, int idx) {
+  PHandle *phPanel = dynamic_cast<PHandle *>((PHandle *)lua_touserdata(L, idx));
+  if (phPanel == NULL)
+    return NULL;
+  return dynamic_cast<lua_PropertyPage *>(phPanel->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushpropertypage (lua_State *L, PropertyPage *pPage) {
+  LPropertyPage *plPage = dynamic_cast<LPropertyPage *>(pPage);
+  if (plPage)
+    ++plPage->m_nRefCount;
+  PHandle *phPanel = (PHandle *)lua_newuserdata(L, sizeof(PHandle));
+  phPanel->Set(pPage);
+  luaL_getmetatable(L, "PropertyPage");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_PropertyPage *luaL_checkpropertypage (lua_State *L, int narg) {
+  lua_PropertyPage *d = lua_topropertypage(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "PropertyPage expected, got INVALID_PANEL");
+  return d;
+}
+
+
+static int PropertyPage_ChainToAnimationMap (lua_State *L) {
+  luaL_checkpropertypage(L, 1)->ChainToAnimationMap();
+  return 0;
+}
+
+static int PropertyPage_ChainToMap (lua_State *L) {
+  luaL_checkpropertypage(L, 1)->ChainToMap();
+  return 0;
+}
+
+static int PropertyPage_GetPanelBaseClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkpropertypage(L, 1)->GetPanelBaseClassName());
+  return 1;
+}
+
+static int PropertyPage_GetPanelClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkpropertypage(L, 1)->GetPanelClassName());
+  return 1;
+}
+
+static int PropertyPage_GetRefTable (lua_State *L) {
+  LPropertyPage *plPage = dynamic_cast<LPropertyPage *>(luaL_checkpropertypage(L, 1));
+  if (plPage) {
+    if (plPage->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plPage->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plPage->m_nTableReference);
+  }
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+static int PropertyPage_HasUserConfigSettings (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpropertypage(L, 1)->HasUserConfigSettings());
+  return 1;
+}
+
+static int PropertyPage_KB_AddBoundKey (lua_State *L) {
+  luaL_checkpropertypage(L, 1)->KB_AddBoundKey(luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int PropertyPage_KB_ChainToMap (lua_State *L) {
+  luaL_checkpropertypage(L, 1)->KB_ChainToMap();
+  return 0;
+}
+
+static int PropertyPage_OnApplyChanges (lua_State *L) {
+  luaL_checkpropertypage(L, 1)->OnApplyChanges();
+  return 0;
+}
+
+static int PropertyPage_OnKeyCodeTyped (lua_State *L) {
+  luaL_checkpropertypage(L, 1)->OnKeyCodeTyped((KeyCode)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int PropertyPage_OnPageHide (lua_State *L) {
+  luaL_checkpropertypage(L, 1)->OnPageHide();
+  return 0;
+}
+
+static int PropertyPage_OnPageShow (lua_State *L) {
+  luaL_checkpropertypage(L, 1)->OnPageShow();
+  return 0;
+}
+
+static int PropertyPage_OnResetData (lua_State *L) {
+  luaL_checkpropertypage(L, 1)->OnResetData();
+  return 0;
+}
+
+static int PropertyPage_SetVisible (lua_State *L) {
+  luaL_checkpropertypage(L, 1)->SetVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int PropertyPage___index (lua_State *L) {
+  PropertyPage *pPage = lua_topropertypage(L, 1);
+  if (pPage == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  LPropertyPage *plPage = dynamic_cast<LPropertyPage *>(pPage);
+  if (plPage && plPage->m_nTableReference != LUA_NOREF) {
+    lua_getref(L, plPage->m_nTableReference);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      lua_getmetatable(L, 1);
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "EditablePanel");
+        lua_pushvalue(L, 2);
+        lua_gettable(L, -2);
+        if (lua_isnil(L, -1)) {
+          lua_pop(L, 2);
+          luaL_getmetatable(L, "Panel");
+          lua_pushvalue(L, 2);
+          lua_gettable(L, -2);
+        }
+      }
+    }
+  } else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      luaL_getmetatable(L, "EditablePanel");
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "Panel");
+        lua_pushvalue(L, 2);
+        lua_gettable(L, -2);
+      }
+    }
+  }
+  return 1;
+}
+
+static int PropertyPage___newindex (lua_State *L) {
+  PropertyPage *pPage = lua_topropertypage(L, 1);
+  if (pPage == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+  LPropertyPage *plPage = dynamic_cast<LPropertyPage *>(pPage);
+  if (plPage) {
+    if (plPage->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plPage->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plPage->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, luaL_checkstring(L, 2));
+	lua_pop(L, 1);
+    return 0;
+  } else {
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index a non-scripted panel", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+}
+
+static int PropertyPage___gc (lua_State *L) {
+  LPropertyPage *plPage = dynamic_cast<LPropertyPage *>(lua_topropertypage(L, 1));
+  if (plPage) {
+    --plPage->m_nRefCount;
+	if (plPage->m_nRefCount <= 0) {
+      delete plPage;
+    }
+  }
+  return 0;
+}
+
+static int PropertyPage___eq (lua_State *L) {
+  lua_pushboolean(L, lua_topropertypage(L, 1) == lua_topropertypage(L, 2));
+  return 1;
+}
+
+static int PropertyPage___tostring (lua_State *L) {
+  PropertyPage *pPage = lua_topropertypage(L, 1);
+  if (pPage == NULL)
+    lua_pushstring(L, "INVALID_PANEL");
+  else {
+    const char *pName = pPage->GetName();
+    if (Q_strcmp(pName, "") == 0)
+      pName = "(no name)";
+    lua_pushfstring(L, "PropertyPage: \"%s\"", pName);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg PropertyPagemeta[] = {
+  {"ChainToAnimationMap", PropertyPage_ChainToAnimationMap},
+  {"ChainToMap", PropertyPage_ChainToMap},
+  {"GetPanelBaseClassName", PropertyPage_GetPanelBaseClassName},
+  {"GetPanelClassName", PropertyPage_GetPanelClassName},
+  {"GetRefTable", PropertyPage_GetRefTable},
+  {"HasUserConfigSettings", PropertyPage_HasUserConfigSettings},
+  {"KB_AddBoundKey", PropertyPage_KB_AddBoundKey},
+  {"KB_ChainToMap", PropertyPage_KB_ChainToMap},
+  {"OnApplyChanges", PropertyPage_OnApplyChanges},
+  {"OnKeyCodeTyped", PropertyPage_OnKeyCodeTyped},
+  {"OnPageHide", PropertyPage_OnPageHide},
+  {"OnPageShow", PropertyPage_OnPageShow},
+  {"OnResetData", PropertyPage_OnResetData},
+  {"SetVisible", PropertyPage_SetVisible},
+  {"__index", PropertyPage___index},
+  {"__newindex", PropertyPage___newindex},
+  {"__gc", PropertyPage___gc},
+  {"__eq", PropertyPage___eq},
+  {"__tostring", PropertyPage___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_PropertyPage (lua_State *L) {
+  PropertyPage *pPage = new LPropertyPage(luaL_optpanel(L, 1, VGui_GetClientLuaRootPanel()), luaL_checkstring(L, 2), L);
+  lua_pushpropertypage(L, pPage);
+  return 1;
+}
+
+
+static const luaL_Reg PropertyPage_funcs[] = {
+  {"PropertyPage", luasrc_PropertyPage},
+  {NULL, NULL}
+};
+
+
+/*
+** Open PropertyPage object
+*/
+LUALIB_API int luaopen_vgui_PropertyPage(lua_State *L) {
+  luaL_newmetatable(L, "PropertyPage");
+  luaL_register(L, NULL, PropertyPagemeta);
+  lua_pushstring(L, "panel");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "panel" */
+  luaL_register(L, "vgui", PropertyPage_funcs);
+  lua_pop(L, 2);
+  return 1;
+}
+
diff --git a/src/game/client/scripted_controls/lPropertyPage.h b/src/game/client/scripted_controls/lPropertyPage.h
new file mode 100644
index 0000000..e97f057
--- /dev/null
+++ b/src/game/client/scripted_controls/lPropertyPage.h
@@ -0,0 +1,94 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LPROPERTYPAGE_H
+#define LPROPERTYPAGE_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include <vgui_controls/PropertyPage.h>
+
+namespace vgui
+{
+
+//-----------------------------------------------------------------------------
+// Purpose: Lua wrapper for property page, as held by a set of property sheets
+//-----------------------------------------------------------------------------
+class LPropertyPage : public PropertyPage
+{
+	DECLARE_CLASS_SIMPLE( LPropertyPage, PropertyPage );
+
+public:
+	LPropertyPage(Panel *parent, const char *panelName, lua_State *L);
+	~LPropertyPage();
+
+	// Called when page is loaded.  Data should be reloaded from document into controls.
+	MESSAGE_FUNC( OnResetData, "ResetData" );
+
+	// Called when the OK / Apply button is pressed.  Changed data should be written into document.
+	MESSAGE_FUNC( OnApplyChanges, "ApplyChanges" );
+
+	// called when the page is shown/hidden
+	MESSAGE_FUNC( OnPageShow, "PageShow" );
+	MESSAGE_FUNC( OnPageHide, "PageHide" );
+
+	virtual void OnKeyCodeTyped(KeyCode code);
+	virtual bool HasUserConfigSettings() { return true; }
+
+protected:
+	// called to be notified of the tab button used to Activate this page
+	// if overridden this must be chained back to
+	MESSAGE_FUNC_PTR( OnPageTabActivated, "PageTabActivated", panel );
+
+private:
+	PHandle _pageTab;
+
+#if defined( LUA_SDK )
+public:
+	lua_State *m_lua_State;
+	int m_nTableReference;
+	int m_nRefCount;
+#endif
+};
+
+} // namespace vgui
+
+#define BEGIN_LUA_CALL_PROPERTYPAGE_METHOD(functionName) \
+  if (m_nTableReference >= 0) { \
+    lua_getref(m_lua_State, m_nTableReference); \
+    lua_getfield(m_lua_State, -1, functionName); \
+    lua_remove(m_lua_State, -2); \
+    if (lua_isfunction(m_lua_State, -1)) { \
+      int args = 0; \
+	  lua_pushpropertypage(m_lua_State, this); \
+	  ++args;
+
+/* type for PropertyPage functions */
+typedef vgui::PropertyPage lua_PropertyPage;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_PropertyPage     *(lua_topropertypage) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushpropertypage) (lua_State *L, lua_PropertyPage *pPage);
+
+
+
+LUALIB_API lua_PropertyPage *(luaL_checkpropertypage) (lua_State *L, int narg);
+
+
+#endif // LPROPERTYPAGE_H
diff --git a/src/game/client/scripted_controls/scriptedclientluapanel.cpp b/src/game/client/scripted_controls/scriptedclientluapanel.cpp
new file mode 100644
index 0000000..968a782
--- /dev/null
+++ b/src/game/client/scripted_controls/scriptedclientluapanel.cpp
@@ -0,0 +1,71 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Client DLL VGUI2 Viewport
+//
+// $Workfile:     $
+// $Date:         $
+//
+//-----------------------------------------------------------------------------
+// $Log: $
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#include "cbase.h"
+
+// our definition
+#include "scriptedclientluapanel.h"
+
+// lua hooks
+#ifdef LUA_SDK
+#include "luamanager.h"
+#endif
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+using namespace vgui;
+
+//================================================================
+CScriptedClientLuaPanel::CScriptedClientLuaPanel() : vgui::EditablePanel( NULL, "CScriptedClientLuaPanel")
+{
+	SetKeyBoardInputEnabled( false );
+	SetMouseInputEnabled( false );
+
+	SetProportional( true );
+}
+
+void CScriptedClientLuaPanel::CreateDefaultPanels( void )
+{
+	// Was a nice idea, but is called on game init and not level init
+#if 0
+	BEGIN_LUA_CALL_HOOK( "CreateDefaultPanels" );
+	END_LUA_CALL_HOOK( 0, 0 );
+#endif
+}
+
+
+//-----------------------------------------------------------------------------
+// Purpose: called when the VGUI subsystem starts up
+//			Creates the sub panels and initialises them
+//-----------------------------------------------------------------------------
+void CScriptedClientLuaPanel::Start( IGameUIFuncs *pGameUIFuncs, IGameEventManager2 * pGameEventManager )
+{
+	CreateDefaultPanels();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Sets the parent for each panel to use
+//-----------------------------------------------------------------------------
+void CScriptedClientLuaPanel::SetParent(vgui::VPANEL parent)
+{
+	EditablePanel::SetParent( parent );
+	// force ourselves to be proportional - when we set our parent above, if our new
+	// parent happened to be non-proportional (such as the vgui root panel), we got
+	// slammed to be nonproportional
+	EditablePanel::SetProportional( true );
+}
+
+void CScriptedClientLuaPanel::Paint()
+{
+}
diff --git a/src/game/client/scripted_controls/scriptedclientluapanel.h b/src/game/client/scripted_controls/scriptedclientluapanel.h
new file mode 100644
index 0000000..9d014da
--- /dev/null
+++ b/src/game/client/scripted_controls/scriptedclientluapanel.h
@@ -0,0 +1,35 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef SCRIPTEDCLIENTLUAPANEL_H
+#define SCRIPTEDCLIENTLUAPANEL_H
+
+#include <vgui_controls/Frame.h>
+
+using namespace vgui;
+
+//==============================================================================
+class CScriptedClientLuaPanel : public vgui::EditablePanel
+{
+	DECLARE_CLASS_SIMPLE( CScriptedClientLuaPanel, vgui::EditablePanel );
+
+public: 
+	CScriptedClientLuaPanel();
+
+	virtual void CreateDefaultPanels( void );
+
+	virtual void Start( IGameUIFuncs *pGameUIFuncs, IGameEventManager2 *pGameEventManager );
+	virtual void SetParent(vgui::VPANEL parent);
+
+protected:
+
+	virtual void Paint();
+
+};
+
+
+#endif
diff --git a/src/game/client/scripted_controls/scriptedhudviewport.cpp b/src/game/client/scripted_controls/scriptedhudviewport.cpp
new file mode 100644
index 0000000..6a8be47
--- /dev/null
+++ b/src/game/client/scripted_controls/scriptedhudviewport.cpp
@@ -0,0 +1,54 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Client DLL VGUI2 Viewport
+//
+// $Workfile:     $
+// $Date:         $
+//
+//-----------------------------------------------------------------------------
+// $Log: $
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#include "cbase.h"
+
+// our definition
+#include "scriptedhudviewport.h"
+
+// lua hooks
+#ifdef LUA_SDK
+#include "luamanager.h"
+#endif
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+using namespace vgui;
+
+//================================================================
+CScriptedHudViewport::CScriptedHudViewport() : vgui::EditablePanel( NULL, "CScriptedHudViewport")
+{
+	SetKeyBoardInputEnabled( false );
+	SetMouseInputEnabled( false );
+
+	SetProportional( true );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Sets the parent for each panel to use
+//-----------------------------------------------------------------------------
+void CScriptedHudViewport::SetParent(vgui::VPANEL parent)
+{
+	EditablePanel::SetParent( parent );
+	// force ourselves to be proportional - when we set our parent above, if our new
+	// parent happened to be non-proportional (such as the vgui root panel), we got
+	// slammed to be nonproportional
+	EditablePanel::SetProportional( true );
+}
+
+void CScriptedHudViewport::Paint()
+{
+	BEGIN_LUA_CALL_HOOK( "HudViewportPaint" );
+	END_LUA_CALL_HOOK( 0, 0 );
+}
diff --git a/src/game/client/scripted_controls/scriptedhudviewport.h b/src/game/client/scripted_controls/scriptedhudviewport.h
new file mode 100644
index 0000000..09d13e9
--- /dev/null
+++ b/src/game/client/scripted_controls/scriptedhudviewport.h
@@ -0,0 +1,32 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef SCRIPTEDHUDVIEWPORT_H
+#define SCRIPTEDHUDVIEWPORT_H
+
+#include <vgui_controls/Frame.h>
+
+using namespace vgui;
+
+//==============================================================================
+class CScriptedHudViewport : public vgui::EditablePanel
+{
+	DECLARE_CLASS_SIMPLE( CScriptedHudViewport, vgui::EditablePanel );
+
+public: 
+	CScriptedHudViewport();
+
+	virtual void SetParent(vgui::VPANEL parent);
+
+protected:
+
+	virtual void Paint();
+
+};
+
+
+#endif
diff --git a/src/game/client/spritemodel.cpp b/src/game/client/spritemodel.cpp
index e7af3fe..b84a42b 100644
--- a/src/game/client/spritemodel.cpp
+++ b/src/game/client/spritemodel.cpp
@@ -218,10 +218,12 @@ static unsigned int spriteOrientationCache = 0;
 bool CEngineSprite::Init( const char *pName )
 {
 	m_hAVIMaterial = AVIMATERIAL_INVALID;
+	m_hBIKMaterial = BIKMATERIAL_INVALID;
 	m_width = m_height = m_numFrames = 1;
 
 	const char *pExt = Q_GetFileExtension( pName );
 	bool bIsAVI = pExt && !Q_stricmp( pExt, "avi" );
+	bool bIsBIK = pExt && !Q_stricmp( pExt, "bik" );
 	if ( bIsAVI )
 	{
 		m_hAVIMaterial = avi->CreateAVIMaterial( pName, pName, "GAME" );
@@ -232,6 +234,16 @@ bool CEngineSprite::Init( const char *pName )
 		avi->GetFrameSize( m_hAVIMaterial, &m_width, &m_height );
 		m_numFrames = avi->GetFrameCount( m_hAVIMaterial );
 	}
+	else if ( bIsBIK )
+	{
+		m_hBIKMaterial = bik->CreateMaterial( pName, pName, "GAME" );
+		if (m_hBIKMaterial == BIKMATERIAL_INVALID )
+			return false;
+
+		m_material = bik->GetMaterial( m_hBIKMaterial );
+		bik->GetFrameSize( m_hBIKMaterial, &m_width, &m_height );
+		m_numFrames = bik->GetFrameCount( m_hBIKMaterial );
+	}
 	else
 	{
 		m_material = materials->FindMaterial( pName, TEXTURE_GROUP_CLIENT_EFFECTS );
@@ -298,6 +310,14 @@ bool CEngineSprite::IsAVI()
 	return ( m_hAVIMaterial != AVIMATERIAL_INVALID );
 }
 
+//-----------------------------------------------------------------------------
+// Is the sprite an BIK?
+//-----------------------------------------------------------------------------
+bool CEngineSprite::IsBIK()
+{
+	return ( m_hBIKMaterial != AVIMATERIAL_INVALID );
+}
+
 
 //-----------------------------------------------------------------------------
 // Returns the texture coordinate range	used to draw the sprite
@@ -310,6 +330,10 @@ void CEngineSprite::GetTexCoordRange( float *pMinU, float *pMinV, float *pMaxU,
 	{
 		avi->GetTexCoordRange( m_hAVIMaterial, pMaxU, pMaxV );
 	}
+	if ( IsBIK() )
+	{
+		bik->GetTexCoordRange( m_hBIKMaterial, pMaxU, pMaxV );
+	}
 	float flOOWidth = ( m_width != 0 ) ? 1.0f / m_width : 1.0f;
 	float flOOHeight = ( m_height!= 0 ) ? 1.0f / m_height : 1.0f;
 
@@ -361,6 +385,10 @@ void CEngineSprite::SetFrame( float frame )
 	{
 		avi->SetFrame( m_hAVIMaterial, frame );
 	}
+	else if ( IsBIK() )
+	{
+		bik->SetFrame( m_hBIKMaterial, frame );
+	}
 	else
 	{
 		IMaterialVar* pFrameVar = m_material->FindVarFast( "$frame", &frameCache );
diff --git a/src/game/client/vgui_int.cpp b/src/game/client/vgui_int.cpp
index 15aa7ec..e865e20 100644
--- a/src/game/client/vgui_int.cpp
+++ b/src/game/client/vgui_int.cpp
@@ -136,6 +136,11 @@ bool VGui_Startup( CreateInterfaceFn appSystemFactory )
 		return false; // c_vguiscreen.cpp needs this!
 	}
 
+#if defined( LUA_SDK )
+	// Create the root panel for our scripted GameUI state
+	VGUI_CreateGameUIRootPanel();
+#endif
+
 	VGui_OneTimeInit();
 
 	// Create any root panels for .dll
@@ -213,6 +218,10 @@ void VGui_Shutdown()
 		g_pClientMode->VGui_Shutdown();
 	}
 
+#if defined( LUA_SDK )
+	VGUI_DestroyGameUIRootPanel();
+#endif
+
 	// Make sure anything "marked for deletion"
 	//  actually gets deleted before this dll goes away
 	vgui::ivgui()->RunFrame();
diff --git a/src/game/client/vgui_int.h b/src/game/client/vgui_int.h
index c62c9e7..1ecd1ac 100644
--- a/src/game/client/vgui_int.h
+++ b/src/game/client/vgui_int.h
@@ -23,6 +23,12 @@ bool VGui_Startup( CreateInterfaceFn appSystemFactory );
 void VGui_Shutdown( void );
 void VGui_CreateGlobalPanels( void );
 vgui::VPANEL VGui_GetClientDLLRootPanel( void );
+#ifdef LUA_SDK
+vgui::Panel *VGui_GetGameUIPanel( void );
+vgui::Panel *VGui_GetClientLuaRootPanel( void );
+void VGUI_CreateGameUIRootPanel( void );
+void VGUI_DestroyGameUIRootPanel( void );
+#endif
 void VGUI_CreateClientDLLRootPanel( void );
 void VGUI_DestroyClientDLLRootPanel( void );
 void VGui_PreRender();
diff --git a/src/game/client/view.cpp b/src/game/client/view.cpp
index d14f9b3..f43b88b 100644
--- a/src/game/client/view.cpp
+++ b/src/game/client/view.cpp
@@ -879,6 +879,62 @@ void CViewRender::Render( vrect_t *rect )
 	render->PopView( GetFrustum() );
 }
 
+#if HL2SB
+void CViewRender::MP_PostSimulate()
+{
+	C_BasePlayer *pLocal = C_BasePlayer::GetLocalPlayer();
+	if ( !pLocal )
+		return;
+
+	//Tony; if the local player is in a vehicle, then we need to kill the bone cache, and re-calculate the view.
+	if ( !pLocal->IsInAVehicle() && !pLocal->GetVehicle())
+		return;
+
+	IClientVehicle *pVehicle = pLocal->GetVehicle();
+	Assert( pVehicle );
+	CBaseAnimating *pVehicleEntity = (CBaseAnimating*)pVehicle->GetVehicleEnt();
+	Assert( pVehicleEntity );
+
+	int nRole = pVehicle->GetPassengerRole( pLocal );
+
+	//Tony; we have to invalidate the bone cache in order for the attachment lookups to be correct!
+	pVehicleEntity->InvalidateBoneCache();
+	pVehicle->GetVehicleViewPosition( nRole, &m_View.origin, &m_View.angles, &m_View.fov );
+
+	//Tony; everything below is from SetupView - the things that should be recalculated.. are recalculated!
+	pLocal->CalcViewModelView( m_View.origin, m_View.angles );
+
+	// Compute the world->main camera transform
+	ComputeCameraVariables( m_View.origin, m_View.angles,
+		&g_vecVForward, &g_vecVRight, &g_vecVUp, &g_matCamInverse );
+
+	// set up the hearing origin...
+	AudioState_t audioState;
+	audioState.m_Origin = m_View.origin;
+	audioState.m_Angles = m_View.angles;
+	audioState.m_bIsUnderwater = pLocal && pLocal->AudioStateIsUnderwater( m_View.origin );
+
+	ToolFramework_SetupAudioState( audioState );
+
+	m_View.origin = audioState.m_Origin;
+	m_View.angles = audioState.m_Angles;
+
+	engine->SetAudioState( audioState );
+
+	g_vecPrevRenderOrigin = g_vecRenderOrigin;
+	g_vecPrevRenderAngles = g_vecRenderAngles;
+	g_vecRenderOrigin = m_View.origin;
+	g_vecRenderAngles = m_View.angles;
+
+#ifdef _DEBUG
+	s_DbgSetupOrigin = m_View.origin;
+	s_DbgSetupAngles = m_View.angles;
+#endif
+
+
+}
+#endif
+
 static void GetPos( const CCommand &args, Vector &vecOrigin, QAngle &angles )
 {
 	vecOrigin = MainViewOrigin();
diff --git a/src/game/client/viewrender.h b/src/game/client/viewrender.h
index 01509db..935fcb7 100644
--- a/src/game/client/viewrender.h
+++ b/src/game/client/viewrender.h
@@ -344,6 +344,10 @@ public:
 	virtual void	Render2DEffectsPostHUD( const CViewSetup &view );
 
 
+#ifdef HL2SB
+	virtual void    MP_PostSimulate();
+#endif
+
 	void			DisableFog( void );
 
 	// Called once per level change
diff --git a/src/game/server/ai_basenpc.cpp b/src/game/server/ai_basenpc.cpp
index df7aab8..982c605 100644
--- a/src/game/server/ai_basenpc.cpp
+++ b/src/game/server/ai_basenpc.cpp
@@ -639,7 +639,11 @@ void CAI_BaseNPC::Ignite( float flFlameLifetime, bool bNPCOnly, float flSize, bo
 #ifdef HL2_EPISODIC
 	if ( AI_IsSinglePlayer() )
 	{
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		if ( pPlayer->IRelationType( this ) != D_LI )
 		{
 			CNPC_Alyx *alyx = CNPC_Alyx::GetAlyx();
@@ -774,7 +778,11 @@ int CAI_BaseNPC::OnTakeDamage_Alive( const CTakeDamageInfo &info )
 		{
 			// See if the person that injured me is an NPC.
 			CAI_BaseNPC *pAttacker = dynamic_cast<CAI_BaseNPC *>( info.GetAttacker() );
+#ifdef HL2SB
+			CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 			CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 			if( pAttacker && pAttacker->IsAlive() && pPlayer )
 			{
@@ -3108,7 +3116,11 @@ void CAI_BaseNPC::UpdateEfficiency( bool bInPVS )
 
 	//---------------------------------
 
-	CBasePlayer *pPlayer = AI_GetSinglePlayer(); 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
+	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	static Vector vPlayerEyePosition;
 	static Vector vPlayerForward;
 	static int iPrevFrame = -1;
@@ -3352,7 +3364,11 @@ void CAI_BaseNPC::UpdateSleepState( bool bInPVS )
 {
 	if ( GetSleepState() > AISS_AWAKE )
 	{
+#ifdef HL2SB
+		CBasePlayer *pLocalPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pLocalPlayer = AI_GetSinglePlayer();
+#endif
 		if ( !pLocalPlayer )
 		{
 			if ( gpGlobals->maxClients > 1 )
@@ -3552,7 +3568,11 @@ void CAI_BaseNPC::RebalanceThinks()
 
 		int i;
 
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		Vector vPlayerForward;
 		Vector vPlayerEyePosition;
 
@@ -3833,7 +3853,11 @@ void CAI_BaseNPC::SetPlayerAvoidState( void )
 
 		GetPlayerAvoidBounds( &vMins, &vMaxs );
 
+#ifdef HL2SB
+		CBasePlayer *pLocalPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pLocalPlayer = AI_GetSinglePlayer();
+#endif
 
 		if ( pLocalPlayer )
 		{
@@ -4808,14 +4832,22 @@ void CAI_BaseNPC::RunAI( void )
 		}
 	}
 
+#ifdef HL2SB
+	if( ai_debug_loners.GetBool() && !IsInSquad() )
+#else
 	if( ai_debug_loners.GetBool() && !IsInSquad() && AI_IsSinglePlayer() )
+#endif
 	{
 		Vector right;
 		Vector vecPoint;
 
 		vecPoint = EyePosition() + Vector( 0, 0, 12 );
 
+#ifdef HL2SB
+		UTIL_GetNearestPlayer( GetAbsOrigin() )->GetVectors( NULL, &right, NULL );
+#else
 		UTIL_GetLocalPlayer()->GetVectors( NULL, &right, NULL );
+#endif
 
 		NDebugOverlay::Line( vecPoint, vecPoint + Vector( 0, 0, 64 ), 255, 0, 0, false , 0.1 );
 		NDebugOverlay::Line( vecPoint, vecPoint + Vector( 0, 0, 32 ) + right * 32, 255, 0, 0, false , 0.1 );
@@ -8657,7 +8689,12 @@ void CAI_BaseNPC::DrawDebugGeometryOverlays(void)
 
 		info.SetDamage( m_iHealth );
 		info.SetAttacker( this );
+#ifdef HL2SB
+		// Fix for multiplayer
+		info.SetInflictor( (CBaseEntity *)this );
+#else
 		info.SetInflictor( ( AI_IsSinglePlayer() ) ? (CBaseEntity *)AI_GetSinglePlayer() : (CBaseEntity *)this );
+#endif
 		info.SetDamageType( DMG_GENERIC );
 
 		m_debugOverlays &= ~OVERLAY_NPC_KILL_BIT;
@@ -9888,7 +9925,11 @@ CBaseEntity *CAI_BaseNPC::FindNamedEntity( const char *name, IEntityFindFilter *
 {
 	if ( !stricmp( name, "!player" ))
 	{
+#ifdef HL2SB
+		return ( CBaseEntity * )AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		return ( CBaseEntity * )AI_GetSinglePlayer();
+#endif
 	}
 	else if ( !stricmp( name, "!enemy" ) )
 	{
@@ -9903,7 +9944,11 @@ CBaseEntity *CAI_BaseNPC::FindNamedEntity( const char *name, IEntityFindFilter *
 	{
 		// FIXME: look at CBaseEntity *CNPCSimpleTalker::FindNearestFriend(bool fPlayer)
 		// punt for now
+#ifdef HL2SB
+		return ( CBaseEntity * )AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		return ( CBaseEntity * )AI_GetSinglePlayer();
+#endif
 	}
 	else if (!stricmp( name, "self" ))
 	{
@@ -9923,7 +9968,11 @@ CBaseEntity *CAI_BaseNPC::FindNamedEntity( const char *name, IEntityFindFilter *
 		{
 			DevMsg( "ERROR: \"player\" is no longer used, use \"!player\" in vcd instead!\n" );
 		}
+#ifdef HL2SB
+		return ( CBaseEntity * )AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		return ( CBaseEntity * )AI_GetSinglePlayer();
+#endif
 	}
 	else
 	{
@@ -11896,7 +11945,11 @@ bool CAI_BaseNPC::CineCleanup()
 			{
 				SetLocalOrigin( origin );
 
+#ifdef HL2SB
+				int drop = UTIL_DropToFloor( this, MASK_NPCSOLID, AI_GetNearestVisiblePlayer( this ) );
+#else
 				int drop = UTIL_DropToFloor( this, MASK_NPCSOLID, UTIL_GetLocalPlayer() );
+#endif
 
 				// Origin in solid?  Set to org at the end of the sequence
 				if ( ( drop < 0 ) || sv_test_scripted_sequences.GetBool() )
@@ -11973,7 +12026,11 @@ void CAI_BaseNPC::Teleport( const Vector *newPosition, const QAngle *newAngles,
 
 bool CAI_BaseNPC::FindSpotForNPCInRadius( Vector *pResult, const Vector &vStartPos, CAI_BaseNPC *pNPC, float radius, bool bOutOfPlayerViewcone )
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( pNPC->GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	QAngle fan;
 
 	fan.x = 0;
@@ -12497,11 +12554,15 @@ bool CAI_BaseNPC::IsPlayerAlly( CBasePlayer *pPlayer )
 	{
 		// in multiplayer mode we need a valid pPlayer 
 		// or override this virtual function
+#ifndef HL2SB
 		if ( !AI_IsSinglePlayer() )
 			return false;
 
 		// NULL means single player mode
 		pPlayer = UTIL_GetLocalPlayer();
+#else
+		pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#endif
 	}
 
 	return ( !pPlayer || IRelationType( pPlayer ) == D_LI ); 
@@ -12795,7 +12856,11 @@ bool CAI_BaseNPC::FindNearestValidGoalPos( const Vector &vTestPoint, Vector *pRe
 
 	if ( vCandidate != vec3_invalid )
 	{
+#ifdef HL2SB
+		AI_Waypoint_t *pPathToPoint = GetPathfinder()->BuildRoute( GetAbsOrigin(), vCandidate, AI_GetNearestPlayer( GetAbsOrigin() ), 5*12, NAV_NONE, true );
+#else
 		AI_Waypoint_t *pPathToPoint = GetPathfinder()->BuildRoute( GetAbsOrigin(), vCandidate, AI_GetSinglePlayer(), 5*12, NAV_NONE, true );
+#endif
 		if ( pPathToPoint )
 		{
 			GetPathfinder()->UnlockRouteNodes( pPathToPoint );
diff --git a/src/game/server/ai_basenpc_schedule.cpp b/src/game/server/ai_basenpc_schedule.cpp
index 905e885..b9ad1af 100644
--- a/src/game/server/ai_basenpc_schedule.cpp
+++ b/src/game/server/ai_basenpc_schedule.cpp
@@ -3363,7 +3363,11 @@ void CAI_BaseNPC::RunTask( const Task_t *pTask )
 	case TASK_FACE_PLAYER:
 		{
 			// Get edict for one player
+#ifdef HL2SB
+			CBasePlayer *pPlayer = AI_GetNearestVisiblePlayer( this );
+#else
 			CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 			if ( pPlayer )
 			{
 				GetMotor()->SetIdealYawToTargetAndUpdate( pPlayer->GetAbsOrigin(), AI_KEEP_YAW_SPEED );
@@ -3661,7 +3665,11 @@ void CAI_BaseNPC::RunTask( const Task_t *pTask )
 
 						if( pHint )
 						{
+#ifdef HL2SB
+							CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 							CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 							Vector vecGoal = pHint->GetAbsOrigin();
 
 							if( vecGoal.DistToSqr(GetAbsOrigin()) < vecGoal.DistToSqr(pPlayer->GetAbsOrigin()) )
diff --git a/src/game/server/ai_behavior_fear.cpp b/src/game/server/ai_behavior_fear.cpp
index f4d0c8d..d47b595 100644
--- a/src/game/server/ai_behavior_fear.cpp
+++ b/src/game/server/ai_behavior_fear.cpp
@@ -318,7 +318,11 @@ void CAI_FearBehavior::GatherConditions()
 	//  -I haven't seen the player in 2 seconds
 	//
 	// Here's the distance check:
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer(GetAbsOrigin());
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if( pPlayer != NULL && GetAbsOrigin().DistToSqr(pPlayer->GetAbsOrigin()) >= Square( ai_fear_player_dist.GetFloat() * 1.5f )  )
 	{
 		SetCondition(COND_FEAR_SEPARATED_FROM_PLAYER);
@@ -457,7 +461,13 @@ CAI_Hint *CAI_FearBehavior::FindFearWithdrawalDest()
 
 	hintCriteria.AddHintType( HINT_PLAYER_ALLY_FEAR_DEST );
 	hintCriteria.SetFlag( bits_HINT_NODE_VISIBLE_TO_PLAYER | bits_HINT_NOT_CLOSE_TO_ENEMY /*| bits_HINT_NODE_IN_VIEWCONE | bits_HINT_NPC_IN_NODE_FOV*/ );
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestVisiblePlayer( pOuter );
+	if( pPlayer )
+		hintCriteria.AddIncludePosition( pPlayer->GetAbsOrigin(), ( ai_fear_player_dist.GetFloat() ) );
+#else
 	hintCriteria.AddIncludePosition( AI_GetSinglePlayer()->GetAbsOrigin(), ( ai_fear_player_dist.GetFloat() ) );
+#endif
 
 	pHint = CAI_HintManager::FindHint( pOuter, hintCriteria );
 
diff --git a/src/game/server/ai_behavior_follow.cpp b/src/game/server/ai_behavior_follow.cpp
index cc74821..24addae 100644
--- a/src/game/server/ai_behavior_follow.cpp
+++ b/src/game/server/ai_behavior_follow.cpp
@@ -22,6 +22,10 @@
 	#include "info_darknessmode_lightsource.h"
 #endif
 
+#ifdef HL2SB
+	#include "hl2mp_gamerules.h"
+#endif
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -764,7 +768,11 @@ void CAI_FollowBehavior::GatherConditions( void )
 
 #ifdef HL2_EPISODIC
 	// Let followers know if the player is lit in the darkness
+#ifndef HL2SB
 	if ( GetFollowTarget()->IsPlayer() && HL2GameRules()->IsAlyxInDarknessMode() )
+#else
+	if ( GetFollowTarget()->IsPlayer() && HL2MPRules()->IsAlyxInDarknessMode() )
+#endif
 	{
 		if ( LookerCouldSeeTargetInDarkness( GetOuter(), GetFollowTarget() ) )
 		{
@@ -848,7 +856,11 @@ bool CAI_FollowBehavior::ShouldMoveToFollowTarget()
 		return false;
 
 #ifdef HL2_EPISODIC
+#ifndef HL2SB
 	if ( HL2GameRules()->IsAlyxInDarknessMode() )
+#else
+	if ( HL2MPRules()->IsAlyxInDarknessMode() )
+#endif
 	{
 		// If we're in darkness mode, the player needs to be lit by
 		// darkness, but we don't need line of sight to him.
@@ -1968,7 +1980,11 @@ void CAI_FollowBehavior::BuildScheduleTestBits()
 
 #ifdef HL2_EPISODIC
 		// In Alyx darkness mode, break on the player turning their flashlight off
+#ifndef HL2SB
 		if ( HL2GameRules()->IsAlyxInDarknessMode() )
+#else
+		if ( HL2MPRules()->IsAlyxInDarknessMode() )
+#endif
 		{
 			if ( IsCurSchedule(SCHED_FOLLOW, false) || IsCurSchedule(SCHED_MOVE_TO_FACE_FOLLOW_TARGET, false) ||
 				 IsCurSchedule(SCHED_FACE_FOLLOW_TARGET, false) )
@@ -2130,6 +2146,16 @@ void CAI_FollowGoal::EnableGoal( CAI_BaseNPC *pAI )
 		return;
 	
 	CBaseEntity *pGoalEntity = GetGoalEntity();
+#ifdef HL2SB
+	if ( !pGoalEntity )
+	{
+		if ( pAI->IRelationType(UTIL_GetNearestPlayer(pAI->GetAbsOrigin())) == D_LI )
+		{
+			pGoalEntity = UTIL_GetNearestPlayer(pAI->GetAbsOrigin());
+			SetGoalEntity( pGoalEntity );
+		}
+	}
+#else
 	if ( !pGoalEntity && AI_IsSinglePlayer() )
 	{
 		if ( pAI->IRelationType(UTIL_GetLocalPlayer()) == D_LI )
@@ -2138,6 +2164,7 @@ void CAI_FollowGoal::EnableGoal( CAI_BaseNPC *pAI )
 			SetGoalEntity( pGoalEntity );
 		}
 	}
+#endif
 
 	if ( pGoalEntity )
 		pBehavior->SetFollowGoal( this );
diff --git a/src/game/server/ai_behavior_lead.cpp b/src/game/server/ai_behavior_lead.cpp
index fcdccd4..8ad03db 100644
--- a/src/game/server/ai_behavior_lead.cpp
+++ b/src/game/server/ai_behavior_lead.cpp
@@ -147,10 +147,17 @@ void CAI_LeadBehavior::LeadPlayer( const AI_LeadArgs_t &leadArgs, CAI_LeadBehavi
 {
 #ifndef CSTRIKE_DLL
 	CAI_PlayerAlly *pOuter = dynamic_cast<CAI_PlayerAlly*>(GetOuter());
+#ifdef HL2SB
+	if ( pOuter )
+	{
+		pOuter->SetSpeechTarget( UTIL_GetNearestPlayer( pOuter->GetAbsOrigin() ) );
+	}
+#else
 	if ( pOuter && AI_IsSinglePlayer() )
 	{
 		pOuter->SetSpeechTarget( UTIL_GetLocalPlayer() );
 	}
+#endif
 #endif
 
 	if( SetGoal( leadArgs ) )
@@ -178,8 +185,10 @@ void CAI_LeadBehavior::StopLeading( void )
 
 bool CAI_LeadBehavior::CanSelectSchedule()
 {
+#ifndef HL2SB
  	if ( !AI_GetSinglePlayer() || AI_GetSinglePlayer()->IsDead() )
 		return false;
+#endif
 
 	bool fAttacked = ( HasCondition( COND_LIGHT_DAMAGE ) || HasCondition( COND_HEAVY_DAMAGE ) );
 	bool fNonCombat = ( GetNpcState() == NPC_STATE_IDLE || GetNpcState() == NPC_STATE_ALERT );
@@ -191,7 +200,14 @@ bool CAI_LeadBehavior::CanSelectSchedule()
 
 void CAI_LeadBehavior::BeginScheduleSelection()
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestVisiblePlayer( GetOuter() );
+	if( !pPlayer )
+		pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+	SetTarget( pPlayer );
+#else
 	SetTarget( AI_GetSinglePlayer() );
+#endif
 	CAI_Expresser *pExpresser = GetOuter()->GetExpresser();
 	if ( pExpresser )
 		pExpresser->ClearSpokeConcept( TLK_LEAD_ARRIVAL );
@@ -325,7 +341,15 @@ bool CAI_LeadBehavior::PlayerIsAheadOfMe( bool bForce )
 	m_bInitialAheadTest = false;
 
 	Vector vecClosestPoint;
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+	if( !pPlayer )
+		return false;
+
+	if ( GetClosestPointOnRoute( pPlayer->GetAbsOrigin(), &vecClosestPoint ) )
+#else
 	if ( GetClosestPointOnRoute( AI_GetSinglePlayer()->GetAbsOrigin(), &vecClosestPoint ) )
+#endif
 	{
 		// If the closest point is not right next to me, then 
 		// the player is somewhere ahead of me on the route.
@@ -352,7 +376,11 @@ void CAI_LeadBehavior::GatherConditions( void )
 		}
 
 		// We have to collect data about the person we're leading around.
+#ifdef HL2SB
+		CBaseEntity *pFollower = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBaseEntity *pFollower = AI_GetSinglePlayer();
+#endif
 
 		if( pFollower )
 		{
@@ -535,7 +563,11 @@ int CAI_LeadBehavior::SelectSchedule()
 		// Player's here, but does he have the weapon we want him to have?
 		if ( m_weaponname != NULL_STRING )
 		{
+#ifdef HL2SB
+			CBasePlayer *pFollower = AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
 			CBasePlayer *pFollower = AI_GetSinglePlayer();
+#endif
 			if ( pFollower && !pFollower->Weapon_OwnsThisType( STRING(m_weaponname) ) )
 			{
 				// If the safety timeout has run out, just give the player the weapon
@@ -564,7 +596,11 @@ int CAI_LeadBehavior::SelectSchedule()
 			else
 			{
 				// We have to collect data about the person we're leading around.
+#ifdef HL2SB
+				CBaseEntity *pFollower = AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
 				CBaseEntity *pFollower = AI_GetSinglePlayer();
+#endif
 				if( pFollower )
 				{
 					float flFollowerDist = ( WorldSpaceCenter() - pFollower->WorldSpaceCenter() ).Length();
@@ -828,7 +864,11 @@ void CAI_LeadBehavior::StartTask( const Task_t *pTask )
 
 		case TASK_LEAD_RETRIEVE_WAIT:
 		{
+#ifdef HL2SB
+			m_MoveMonitor.SetMark( AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() ), 24 );
+#else
 			m_MoveMonitor.SetMark( AI_GetSinglePlayer(), 24 );
+#endif
 			ChainStartTask( TASK_WAIT_INDEFINITE );
 			break;
 		}
diff --git a/src/game/server/ai_behavior_passenger.cpp b/src/game/server/ai_behavior_passenger.cpp
index 4589bef..5544e6e 100644
--- a/src/game/server/ai_behavior_passenger.cpp
+++ b/src/game/server/ai_behavior_passenger.cpp
@@ -205,7 +205,11 @@ void CAI_PassengerBehavior::AddPhysicsPush( float force )
 //-----------------------------------------------------------------------------
 bool CAI_PassengerBehavior::IsPassengerHostile( void )
 {
-	CBaseEntity *pPlayer = AI_GetSinglePlayer();
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
+	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	
 	// If the player hates or fears the passenger, they're hostile
 	if ( GetOuter()->IRelationType( pPlayer ) == D_HT || GetOuter()->IRelationType( pPlayer ) == D_FR )
@@ -220,7 +224,11 @@ bool CAI_PassengerBehavior::IsPassengerHostile( void )
 void CAI_PassengerBehavior::InitVehicleState( void )
 {
 	// Set the player's state
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	m_vehicleState.m_bPlayerInVehicle = ( pPlayer && pPlayer->IsInAVehicle() && pPlayer->GetServerVehicle() == m_hVehicle->GetServerVehicle() );
 
 	// Update our vehicle state so we don't confuse our previous velocity on the first frame!
@@ -1283,7 +1291,11 @@ void CAI_PassengerBehavior::GatherVehicleStateConditions( void )
 	ClearCondition( COND_PASSENGER_PLAYER_ENTERED_VEHICLE );
 	ClearCondition( COND_PASSENGER_PLAYER_EXITED_VEHICLE );
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer )
 	{
 		if ( pPlayer->IsInAVehicle() && pPlayer->GetVehicle() == m_hVehicle->GetServerVehicle() )
diff --git a/src/game/server/ai_behavior_standoff.cpp b/src/game/server/ai_behavior_standoff.cpp
index 6380d3d..4e5b34a 100644
--- a/src/game/server/ai_behavior_standoff.cpp
+++ b/src/game/server/ai_behavior_standoff.cpp
@@ -716,7 +716,11 @@ Vector CAI_StandoffBehavior::GetStandoffGoalPosition()
 	}
 	else if( PlayerIsLeading() )
 	{
+#ifdef HL2SB
+		return UTIL_GetNearestPlayer( GetOuter()->GetAbsOrigin() )->GetAbsOrigin();
+#else
 		return UTIL_GetLocalPlayer()->GetAbsOrigin();
+#endif
 	}
 	else
 	{
@@ -768,7 +772,11 @@ void CAI_StandoffBehavior::UpdateBattleLines()
 			if ( m_params.fPlayerIsBattleline )
 			{
 				const float DIST_PLAYER_PLANE = 180;
+#ifdef HL2SB
+				CBaseEntity *pPlayer = UTIL_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
 				CBaseEntity *pPlayer = UTIL_GetLocalPlayer();
+#endif
 				
 				BattleLine_t playerLine;
 
@@ -999,7 +1007,11 @@ void CAI_StandoffBehavior::OnChangeTacticalConstraints()
 
 bool CAI_StandoffBehavior::PlayerIsLeading()
 {
+#ifdef HL2SB
+	CBaseEntity *pPlayer = AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
 	CBaseEntity *pPlayer = AI_GetSinglePlayer();
+#endif
 	return ( pPlayer && GetOuter()->IRelationType( pPlayer ) == D_LI );
 }
 
@@ -1007,7 +1019,11 @@ bool CAI_StandoffBehavior::PlayerIsLeading()
 
 CBaseEntity *CAI_StandoffBehavior::GetPlayerLeader()
 {
+#ifdef HL2SB
+	CBaseEntity *pPlayer = AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
 	CBaseEntity *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer && GetOuter()->IRelationType( pPlayer ) == D_LI )
 		return pPlayer;
 	return NULL;
diff --git a/src/game/server/ai_eventresponse.cpp b/src/game/server/ai_eventresponse.cpp
index 99262ae..183a67e 100644
--- a/src/game/server/ai_eventresponse.cpp
+++ b/src/game/server/ai_eventresponse.cpp
@@ -72,8 +72,13 @@ void CNPCEventResponseSystem::TriggerEvent( const char *pResponse, bool bForce,
 //-----------------------------------------------------------------------------
 void CNPCEventResponseSystem::FrameUpdatePreEntityThink()
 {
+#ifdef HL2SB
+ 	if ( !m_ActiveEvents.Count() || !UTIL_GetLocalPlayer() )
+		return;
+#else
  	if ( !m_ActiveEvents.Count() || !AI_IsSinglePlayer() || !UTIL_GetLocalPlayer() )
 		return;
+#endif
 
 	if ( m_flNextEventPoll > gpGlobals->curtime )
 		return;
diff --git a/src/game/server/ai_hint.cpp b/src/game/server/ai_hint.cpp
index aabdcb4..f16c86e 100644
--- a/src/game/server/ai_hint.cpp
+++ b/src/game/server/ai_hint.cpp
@@ -1343,7 +1343,13 @@ bool CAI_Hint::HintMatchesCriteria( CAI_BaseNPC *pNPC, const CHintCriteria &hint
 
 	if ( hintCriteria.HasFlag(bits_HINT_HAS_LOS_TO_PLAYER|bits_HAS_EYEPOSITION_LOS_TO_PLAYER) )
 	{
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestVisiblePlayer( this );
+		if( !pPlayer )
+			pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 		if( pPlayer != NULL )
 		{
diff --git a/src/game/server/ai_network.h b/src/game/server/ai_network.h
index 86c6c06..5b1a4ad 100644
--- a/src/game/server/ai_network.h
+++ b/src/game/server/ai_network.h
@@ -120,7 +120,11 @@ public:
 			static int warningCount = 0;
 			if ( ++warningCount < 10 )
 			{
+				// Andrew; we don't care about this in HL2SB mainly due to the
+				// Sandbox gamemode.
+#ifndef HL2SB
 				AssertMsg2( 0, "Node (%i) out of range (%i total)\n", id, m_iNumNodes ); 
+#endif
 			}
 		}
 		return NULL; 
diff --git a/src/game/server/ai_planesolver.cpp b/src/game/server/ai_planesolver.cpp
index 09f3c64..e424efc 100644
--- a/src/game/server/ai_planesolver.cpp
+++ b/src/game/server/ai_planesolver.cpp
@@ -351,7 +351,12 @@ void CAI_PlaneSolver::GenerateObstacleNpcs( const AILocalMoveGoal_t &goal, float
 			}
 		}
 
+#ifdef HL2SB
+		// Zeh Matt: Ugly but pretty much fail safe due to our overload :)
+		CBaseEntity *pPlayer = AI_GetNearestPlayer(m_pNpc ? m_pNpc->GetAbsOrigin() : NULL);
+#else
 		CBaseEntity *pPlayer = UTIL_PlayerByIndex( 1 );
+#endif
 		if ( pPlayer )
 		{
 			Vector mins, maxs;
diff --git a/src/game/server/ai_playerally.cpp b/src/game/server/ai_playerally.cpp
index 80ab241..0f9b4d1 100644
--- a/src/game/server/ai_playerally.cpp
+++ b/src/game/server/ai_playerally.cpp
@@ -366,13 +366,24 @@ void CAI_PlayerAlly::DisplayDeathMessage( void )
 	if ( npc_ally_deathmessage.GetBool() == 0 )
 		return;
 
-	CBaseEntity *pPlayer = AI_GetSinglePlayer();
-
+#ifdef HL2SB
+	for( int i = 1; i <= gpGlobals->maxClients; i++ )
+	{
+		CBasePlayer *pPlayer = UTIL_PlayerByIndex(i);
+		if ( pPlayer )	
+		{
+			UTIL_ShowMessageAll( GetDeathMessageText() );
+			ToBasePlayer(pPlayer)->NotifySinglePlayerGameEnding();
+		}
+	}
+#else
+	CBasePlayer *pPlayer = AI_GetSinglePlayer();
 	if ( pPlayer )	
 	{
 		UTIL_ShowMessage( GetDeathMessageText(), ToBasePlayer( pPlayer ) );
 		ToBasePlayer(pPlayer)->NotifySinglePlayerGameEnding();
 	}
+#endif 
 
 	CBaseEntity *pReload = CreatePlayerLoadSave( GetAbsOrigin(), 1.5f, 8.0f, 4.5f );
 
@@ -406,7 +417,11 @@ void CAI_PlayerAlly::GatherConditions( void )
 		SetCondition( COND_TALKER_CLIENTUNSEEN );
 	}
 
+#ifdef HL2SB
+	CBasePlayer *pLocalPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pLocalPlayer = AI_GetSinglePlayer();
+#endif
 
 	if ( !pLocalPlayer )
 	{
@@ -459,7 +474,11 @@ void CAI_PlayerAlly::GatherEnemyConditions( CBaseEntity *pEnemy )
 		{
 			if( Classify() == CLASS_PLAYER_ALLY_VITAL && hl2_episodic.GetBool() )
 			{
+#ifdef HL2SB
+				CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 				CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 				if( pPlayer )
 				{
@@ -1004,7 +1023,11 @@ void CAI_PlayerAlly::StartTask( const Task_t *pTask )
 			if ( HasCondition( COND_PLAYER_PUSHING ) && AI_IsSinglePlayer() )
 			{
 				// @TODO (toml 10-22-04): cope with multiplayer push
+#ifdef HL2SB
+				GetMotor()->SetIdealYawToTarget( UTIL_GetNearestPlayer( GetAbsOrigin() )->WorldSpaceCenter() );
+#else
 				GetMotor()->SetIdealYawToTarget( UTIL_GetLocalPlayer()->WorldSpaceCenter() );
+#endif
 			}
 			BaseClass::StartTask( pTask );
 			break;
@@ -1171,7 +1194,11 @@ void CAI_PlayerAlly::Event_Killed( const CTakeDamageInfo &info )
 	// notify the player
 	if ( IsInPlayerSquad() )
 	{
+#ifdef HL2SB
+		CBasePlayer *player = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *player = AI_GetSinglePlayer();
+#endif
 		if ( player )
 		{
 			variant_t emptyVariant;
@@ -1458,7 +1485,11 @@ bool CAI_PlayerAlly::IsOkToSpeak( ConceptCategory_t category, bool fRespondingTo
 		}
 
 		// Don't talk if we're too far from the player
-		CBaseEntity *pPlayer = AI_GetSinglePlayer();
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
+		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		if ( pPlayer )
 		{
 			float flDist = sv_npc_talker_maxdist.GetFloat();
diff --git a/src/game/server/ai_relationship.cpp b/src/game/server/ai_relationship.cpp
index 356b55c..e0ba127 100644
--- a/src/game/server/ai_relationship.cpp
+++ b/src/game/server/ai_relationship.cpp
@@ -191,7 +191,11 @@ void CAI_Relationship::ApplyRelationship( CBaseEntity *pActivator, CBaseEntity *
 	
 	// The player spawns slightly after the NPCs, meaning that if we don't wait, the
 	// player will miss any relationships placed on them.
+#ifdef HL2SB
+	if ( UTIL_GetLocalPlayer() )
+#else
 	if ( AI_IsSinglePlayer() && !UTIL_GetLocalPlayer() )
+#endif
 	{
 		SetThink( &CAI_Relationship::ApplyRelationshipThink );
 		SetNextThink( gpGlobals->curtime );
diff --git a/src/game/server/ai_scriptconditions.cpp b/src/game/server/ai_scriptconditions.cpp
index 0a2472d..1fce103 100644
--- a/src/game/server/ai_scriptconditions.cpp
+++ b/src/game/server/ai_scriptconditions.cpp
@@ -290,15 +290,24 @@ bool CAI_ScriptConditions::EvalActorSeeTarget( const EvalArgs_t &args )
 
 bool CAI_ScriptConditions::EvalPlayerActorProximity( const EvalArgs_t &args )
 {
+#ifndef HL2SB
 	return ( !args.pActor || m_PlayerActorProxTester.Check( args.pPlayer, args.pActor ) );
+#else
+	return ( !args.pActor || !args.pPlayer || m_PlayerActorProxTester.Check( args.pPlayer, args.pActor ) );
+#endif
 }
 
 //-----------------------------------------------------------------------------
 
 bool CAI_ScriptConditions::EvalPlayerTargetProximity( const EvalArgs_t &args )
 {
+#ifndef HL2SB
 	return ( !args.pTarget || 
 		m_PlayerTargetProxTester.Check( args.pPlayer, args.pTarget ) );
+#else
+	return ( !args.pTarget || !args.pPlayer || 
+		m_PlayerTargetProxTester.Check( args.pPlayer, args.pTarget ) );
+#endif
 }
 
 
@@ -335,7 +344,11 @@ bool CAI_ScriptConditions::EvalPlayerActorLOS( const EvalArgs_t &args )
 		return true;
 	}
 
+#ifndef HL2SB
 	return ( !args.pActor || PlayerHasLineOfSight( args.pPlayer, args.pActor, m_fPlayerActorLOS == TRS_FALSE ) );
+#else
+	return ( !args.pActor || !args.pPlayer || PlayerHasLineOfSight( args.pPlayer, args.pActor, m_fPlayerActorLOS == TRS_FALSE ) );
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -348,7 +361,11 @@ bool CAI_ScriptConditions::EvalPlayerTargetLOS( const EvalArgs_t &args )
 		return true;
 	}
 
+#ifndef HL2SB
 	return ( !args.pTarget || PlayerHasLineOfSight( args.pPlayer, args.pTarget, m_fPlayerTargetLOS == TRS_FALSE ) );
+#else
+	return ( !args.pTarget || !args.pPlayer || PlayerHasLineOfSight( args.pPlayer, args.pTarget, m_fPlayerTargetLOS == TRS_FALSE ) );
+#endif
 }
 
 bool CAI_ScriptConditions::EvalActorInPVS( const EvalArgs_t &args )
@@ -474,11 +491,13 @@ void CAI_ScriptConditions::EvaluationThink()
 	int iActorsDone = 0;
 
 #ifdef HL2_DLL
+#ifndef HL2SB
 	if( AI_GetSinglePlayer()->GetFlags() & FL_NOTARGET )
 	{
 		ScrCondDbgMsg( ("%s WARNING: Player is NOTARGET. This will affect all LOS conditiosn involving the player!\n", GetDebugName()) );
 	}
 #endif
+#endif
 
 
 	for ( int i = 0; i < m_ElementList.Count(); )
diff --git a/src/game/server/ai_scriptconditions.h b/src/game/server/ai_scriptconditions.h
index 831874a..bf264b7 100644
--- a/src/game/server/ai_scriptconditions.h
+++ b/src/game/server/ai_scriptconditions.h
@@ -170,7 +170,11 @@ private:
 #ifndef HL2_EPISODIC
 	CBaseEntity *GetActor()		{ return m_hActor.Get();			}
 #endif
+#ifdef HL2SB
+	CBasePlayer *GetPlayer()	{ return UTIL_GetNearestPlayer( GetAbsOrigin() );	}
+#else
 	CBasePlayer *GetPlayer()	{ return UTIL_GetLocalPlayer();	}
+#endif
 
 	//---------------------------------
 
diff --git a/src/game/server/ai_speech.cpp b/src/game/server/ai_speech.cpp
index c5d721d..5784357 100644
--- a/src/game/server/ai_speech.cpp
+++ b/src/game/server/ai_speech.cpp
@@ -307,13 +307,23 @@ AI_Response *CAI_Expresser::SpeakFindResponse( AIConcept_t concept, const char *
 		}
 	}
 
+	CBaseFlex *pOuter = GetOuter();
+#ifdef HL2SB
+	if( !pOuter )
+		return NULL;
+#endif
+
 	// Let our outer fill in most match criteria
-	GetOuter()->ModifyOrAppendCriteria( set );
+	pOuter->ModifyOrAppendCriteria( set );
 
 	// Append local player criteria to set, but not if this is a player doing the talking
-	if ( !GetOuter()->IsPlayer() )
+	if ( !pOuter->IsPlayer() )
 	{
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( pOuter->GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
+#endif
 		if( pPlayer )
 			pPlayer->ModifyOrAppendPlayerCriteria( set );
 	}
@@ -930,7 +940,11 @@ void CAI_ExpresserHost_NPC_DoModifyOrAppendCriteria( CAI_BaseNPC *pSpeaker, AI_C
 		set.AppendCriteria( "weapon", "none" );
 	}
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( pSpeaker->GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer )
 	{
 		Vector distance = pPlayer->GetAbsOrigin() - pSpeaker->GetAbsOrigin();
diff --git a/src/game/server/ai_utils.h b/src/game/server/ai_utils.h
index a89a9f5..a828fe0 100644
--- a/src/game/server/ai_utils.h
+++ b/src/game/server/ai_utils.h
@@ -23,14 +23,49 @@
 
 inline CBasePlayer *AI_GetSinglePlayer()
 {
+#ifdef HL2SB
+	CBasePlayer *pHostPlayer = UTIL_GetListenServerHost();
+	if ( pHostPlayer != NULL )
+		return pHostPlayer;
+
+	for( int iClient = 1; iClient <= gpGlobals->maxClients; ++iClient )
+	{
+		CBasePlayer *pEnt = UTIL_PlayerByIndex( iClient );
+		if(!pEnt || !pEnt->IsPlayer())
+			continue;
+
+		// Return the first player we can get a hold of.
+		return pEnt;
+	}
+#else
 	if ( gpGlobals->maxClients > 1 )
 	{
 		return NULL;
 	}
+#endif
 	
 	return UTIL_GetLocalPlayer();
 }
 
+#ifdef HL2SB
+// Andrew; these have been moved to UTIL_* functions, since we use them outside
+// of the scope of AI_
+inline CBasePlayer *AI_GetNearestPlayer( const Vector& pos )
+{
+	return UTIL_GetNearestPlayer( pos );
+}
+
+inline CBasePlayer *AI_GetNearestPlayer( const CBaseEntity* pEntity )
+{
+	return pEntity ? AI_GetNearestPlayer( pEntity->GetAbsOrigin() ) : AI_GetNearestPlayer( vec3_origin );
+}
+
+inline CBasePlayer *AI_GetNearestVisiblePlayer( CBaseEntity *pEntity, int mask = MASK_BLOCKLOS )
+{
+	return UTIL_GetNearestVisiblePlayer( pEntity, mask );
+}
+#endif
+
 inline bool AI_IsSinglePlayer()
 {
 	return ( gpGlobals->maxClients == 1 );
diff --git a/src/game/server/baseanimating.cpp b/src/game/server/baseanimating.cpp
index 3d0822d..0646a67 100644
--- a/src/game/server/baseanimating.cpp
+++ b/src/game/server/baseanimating.cpp
@@ -1178,7 +1178,9 @@ void CBaseAnimating::HandleAnimEvent( animevent_t *pEvent )
 float CBaseAnimating::SetPoseParameter( CStudioHdr *pStudioHdr, const char *szName, float flValue )
 {
 	int poseParam = LookupPoseParameter( pStudioHdr, szName );
+#ifndef HL2SB
 	AssertMsg2(poseParam >= 0, "SetPoseParameter called with invalid argument %s by %s", szName, GetDebugName());
+#endif
 	return SetPoseParameter( pStudioHdr, poseParam, flValue );
 }
 
diff --git a/src/game/server/baseanimating.h b/src/game/server/baseanimating.h
index 8a18397..24d1e6a 100644
--- a/src/game/server/baseanimating.h
+++ b/src/game/server/baseanimating.h
@@ -385,10 +385,16 @@ private:
 	CNetworkArray( float, m_flPoseParameter, NUM_POSEPAREMETERS );	// must be private so manual mode works!
 	CNetworkArray( float, m_flEncodedController, NUM_BONECTRLS );		// bone controller setting (0..1)
 
+#ifdef HL2SB
+public:
+#endif
 	// Client-side animation (useful for looping animation objects)
 	CNetworkVar( bool, m_bClientSideAnimation );
 	CNetworkVar( bool, m_bClientSideFrameReset );
 
+#ifdef HL2SB
+private:
+#endif
 	CNetworkVar( int, m_nNewSequenceParity );
 	CNetworkVar( int, m_nResetEventsParity );
 
diff --git a/src/game/server/basecombatcharacter.cpp b/src/game/server/basecombatcharacter.cpp
index 63d8f67..e347668 100644
--- a/src/game/server/basecombatcharacter.cpp
+++ b/src/game/server/basecombatcharacter.cpp
@@ -49,6 +49,10 @@
 	#include "portal_shareddefs.h"
 #endif
 
+#ifdef HL2SB
+#include "hl2mp_gamerules.h"
+#endif
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -1478,7 +1482,11 @@ bool CBaseCombatCharacter::BecomeRagdoll( const CTakeDamageInfo &info, const Vec
 
 #ifdef HL2_EPISODIC
 	// Burning corpses are server-side in episodic, if we're in darkness mode
+#ifndef HL2SB
 	if ( IsOnFire() && HL2GameRules()->IsAlyxInDarknessMode() )
+#else
+	if ( IsOnFire() && HL2MPRules()->IsAlyxInDarknessMode() )
+#endif
 	{
 		CBaseEntity *pRagdoll = CreateServerRagdoll( this, m_nForceBone, newinfo, COLLISION_GROUP_DEBRIS );
 		FixupBurningServerRagdoll( pRagdoll );
@@ -1489,7 +1497,11 @@ bool CBaseCombatCharacter::BecomeRagdoll( const CTakeDamageInfo &info, const Vec
 
 #ifdef HL2_DLL	
 	// Mega physgun requires everything to be a server-side ragdoll
+#ifndef HL2SB
 	if ( m_bForceServerRagdoll == true || ( HL2GameRules()->MegaPhyscannonActive() == true ) && !IsPlayer() && Classify() != CLASS_PLAYER_ALLY_VITAL && Classify() != CLASS_PLAYER_ALLY )
+#else
+	if ( m_bForceServerRagdoll == true || ( HL2MPRules()->MegaPhyscannonActive() == true ) && !IsPlayer() && Classify() != CLASS_PLAYER_ALLY_VITAL && Classify() != CLASS_PLAYER_ALLY )
+#endif
 	{
 		if ( CanBecomeServerRagdoll() == false )
 			return false;
@@ -2987,7 +2999,11 @@ void CBaseCombatCharacter::VPhysicsShadowCollision( int index, gamevcollisioneve
 	float flOtherAttackerTime = 0.0f;
 
 #ifdef HL2_DLL
+#ifndef HL2SB
 	if ( HL2GameRules()->MegaPhyscannonActive() == true )
+#else
+	if ( HL2MPRules()->MegaPhyscannonActive() == true )
+#endif
 	{
 		flOtherAttackerTime = 1.0f;
 	}
@@ -3131,7 +3147,11 @@ CBaseEntity *CBaseCombatCharacter::FindMissTarget( void )
 	CBaseEntity *pMissCandidates[ MAX_MISS_CANDIDATES ];
 	int numMissCandidates = 0;
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 	CBaseEntity *pEnts[256];
 	Vector		radius( 100, 100, 100);
 	Vector		vecSource = GetAbsOrigin();
diff --git a/src/game/server/baseentity.cpp b/src/game/server/baseentity.cpp
index 26d2177..0120721 100644
--- a/src/game/server/baseentity.cpp
+++ b/src/game/server/baseentity.cpp
@@ -61,6 +61,9 @@
 #include "ModelSoundsCache.h"
 #include "env_debughistory.h"
 #include "tier1/utlstring.h"
+#ifdef LUA_SDK
+#include "luamanager.h"
+#endif
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
@@ -341,6 +344,10 @@ CBaseEntity::CBaseEntity( bool bServerOnly )
 #ifndef _XBOX
 	AddEFlags( EFL_USE_PARTITION_WHEN_NOT_SOLID );
 #endif
+
+#if defined( LUA_SDK )
+	m_nTableReference = LUA_NOREF;
+#endif
 }
 
 extern bool g_bDisableEhandleAccess;
@@ -375,6 +382,10 @@ CBaseEntity::~CBaseEntity( )
 		// Remove this entity from the ent list (NOTE:  This Makes EHANDLES go NULL)
 		gEntList.RemoveEntity( GetRefEHandle() );
 	}
+
+#if defined( LUA_SDK )
+	lua_unref( L, m_nTableReference );
+#endif
 }
 
 void CBaseEntity::PostConstructor( const char *szClassname )
@@ -795,12 +806,20 @@ void CBaseEntity::DrawDebugGeometryOverlays(void)
 			NDebugOverlay::EntityBounds(this, 255, 255, 255, 0, 0 );
 		}
 	}
+#ifdef HL2SB
+	if ( m_debugOverlays & OVERLAY_AUTOAIM_BIT && (GetFlags()&FL_AIMTARGET) && AI_GetNearestPlayer( GetAbsOrigin() ) != NULL )
+#else
 	if ( m_debugOverlays & OVERLAY_AUTOAIM_BIT && (GetFlags()&FL_AIMTARGET) && AI_GetSinglePlayer() != NULL )
+#endif
 	{
 		// Crude, but it gets the point across.
 		Vector vecCenter = GetAutoAimCenter();
 		Vector vecRight, vecUp, vecDiag;
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		float radius = GetAutoAimRadius();
 
 		QAngle angles = pPlayer->EyeAngles();
@@ -6414,7 +6433,11 @@ void CBaseEntity::DispatchResponse( const char *conceptName )
 	ModifyOrAppendCriteria( set );
 
 	// Append local player criteria to set,too
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 	if( pPlayer )
 		pPlayer->ModifyOrAppendPlayerCriteria( set );
 
@@ -6480,7 +6503,11 @@ void CBaseEntity::DumpResponseCriteria( void )
 	ModifyOrAppendCriteria( set );
 
 	// Append local player criteria to set,too
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 	if ( pPlayer )
 	{
 		pPlayer->ModifyOrAppendPlayerCriteria( set );
@@ -6941,7 +6968,11 @@ bool CBaseEntity::SUB_AllowedToFade( void )
 
 	// on Xbox, allow these to fade out
 #ifndef _XBOX
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = ( AI_IsSinglePlayer() ) ? UTIL_GetLocalPlayer() : NULL;
+#endif
 
 	if ( pPlayer && pPlayer->FInViewCone( this ) )
 		return false;
diff --git a/src/game/server/baseentity.h b/src/game/server/baseentity.h
index 028e5f0..ae5b66a 100644
--- a/src/game/server/baseentity.h
+++ b/src/game/server/baseentity.h
@@ -803,6 +803,14 @@ public:
 	// used so we know when things are no longer touching
 	int			touchStamp;			
 
+#if defined( LUA_SDK )
+	// Andrew; This is used to determine an entity's reference in Lua's LUA_REGISTRYINDEX.
+	// I'd rather do this than create a struct and pass that to each bounded function, plus it'll save some perf for massive executions, like Think funcs.
+	int				m_nTableReference;
+	// Henry; There's an IsPlayer and IsWorld and such, why not an IsWeapon?
+	virtual bool	IsWeapon( void ) const { return false; }
+#endif
+
 protected:
 
 	// think function handling
diff --git a/src/game/server/baseflex.cpp b/src/game/server/baseflex.cpp
index 6a6554c..5b881e9 100644
--- a/src/game/server/baseflex.cpp
+++ b/src/game/server/baseflex.cpp
@@ -1197,7 +1197,11 @@ bool CBaseFlex::ProcessFlexAnimationSceneEvent( CSceneEventInfo *info, CChoreoSc
 					// only check occasionally
 					else if (info->m_flNext <= gpGlobals->curtime)
 					{
+#ifdef HL2SB
+						CBasePlayer *pPlayer = AI_GetNearestVisiblePlayer( this );
+#else
 						CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 
 						// if not in view, disable
 						info->m_bHasArrived = (pPlayer && !pPlayer->FInViewCone( this ) );
@@ -2706,7 +2710,11 @@ void CFlexCycler::Think( void )
 	Vector forward, right, up;
 	GetVectors( &forward, &right, &up );
 
+#ifdef HL2SB
+	CBaseEntity *pPlayer = (CBaseEntity *)UTIL_GetNearestPlayer(GetAbsOrigin());
+#else
 	CBaseEntity *pPlayer = (CBaseEntity *)UTIL_GetLocalPlayer();
+#endif
 	if (pPlayer)
 	{
 		if (pPlayer->GetSmoothedVelocity().Length() != 0 && DotProduct( forward, pPlayer->EyePosition() - EyePosition()) > 0.5)
diff --git a/src/game/server/basescriptedtrigger.cpp b/src/game/server/basescriptedtrigger.cpp
new file mode 100644
index 0000000..f823ffa
--- /dev/null
+++ b/src/game/server/basescriptedtrigger.cpp
@@ -0,0 +1,261 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: Spawn and use functions for editor-placed triggers.
+//
+//===========================================================================//
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "lbaseentity_shared.h"
+#include "filters.h"
+#include "basescriptedtrigger.h"
+#include "saverestore_utlvector.h"
+#include "iservervehicle.h"
+#include "ai_behavior_follow.h"
+#include "ai_behavior_lead.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+// Global Savedata for base trigger
+BEGIN_DATADESC( CBaseScriptedTrigger )
+
+	// Keyfields
+	DEFINE_KEYFIELD( m_iFilterName,	FIELD_STRING,	"filtername" ),
+	DEFINE_FIELD( m_hFilter,	FIELD_EHANDLE ),
+	DEFINE_KEYFIELD( m_bDisabled,		FIELD_BOOLEAN,	"StartDisabled" ),
+	DEFINE_UTLVECTOR( m_hTouchingEntities, FIELD_EHANDLE ),
+
+	// Inputs	
+	DEFINE_INPUTFUNC( FIELD_VOID, "Enable", InputEnable ),
+	DEFINE_INPUTFUNC( FIELD_VOID, "Disable", InputDisable ),
+	DEFINE_INPUTFUNC( FIELD_VOID, "Toggle", InputToggle ),
+	DEFINE_INPUTFUNC( FIELD_VOID, "TouchTest", InputTouchTest ),
+
+	DEFINE_INPUTFUNC( FIELD_VOID, "StartTouch", InputStartTouch ),
+	DEFINE_INPUTFUNC( FIELD_VOID, "EndTouch", InputEndTouch ),
+
+	// Outputs
+	DEFINE_OUTPUT( m_OnStartTouch, "OnStartTouch"),
+	DEFINE_OUTPUT( m_OnStartTouchAll, "OnStartTouchAll"),
+	DEFINE_OUTPUT( m_OnEndTouch, "OnEndTouch"),
+	DEFINE_OUTPUT( m_OnEndTouchAll, "OnEndTouchAll"),
+	DEFINE_OUTPUT( m_OnTouching, "OnTouching" ),
+	DEFINE_OUTPUT( m_OnNotTouching, "OnNotTouching" ),
+
+END_DATADESC()
+
+
+static CUtlDict< CEntityFactory<CBaseScriptedTrigger>*, unsigned short > m_TriggerFactoryDatabase;
+
+void RegisterScriptedTrigger( const char *className )
+{
+	if ( EntityFactoryDictionary()->FindFactory( className ) )
+	{
+		return;
+	}
+
+	unsigned short lookup = m_TriggerFactoryDatabase.Find( className );
+	if ( lookup != m_TriggerFactoryDatabase.InvalidIndex() )
+	{
+		return;
+	}
+
+	CEntityFactory<CBaseScriptedTrigger> *pFactory = new CEntityFactory<CBaseScriptedTrigger>( className );
+
+	lookup = m_TriggerFactoryDatabase.Insert( className, pFactory );
+	Assert( lookup != m_TriggerFactoryDatabase.InvalidIndex() );
+}
+
+void ResetTriggerFactoryDatabase( void )
+{
+	for ( int i=m_TriggerFactoryDatabase.First(); i != m_TriggerFactoryDatabase.InvalidIndex(); i=m_TriggerFactoryDatabase.Next( i ) )
+	{
+		delete m_TriggerFactoryDatabase[ i ];
+	}
+	m_TriggerFactoryDatabase.RemoveAll();
+}
+
+
+CBaseScriptedTrigger::CBaseScriptedTrigger( void )
+{
+#ifdef LUA_SDK
+	m_nTableReference = LUA_NOREF;
+#endif
+}
+
+CBaseScriptedTrigger::~CBaseScriptedTrigger( void )
+{
+#ifdef LUA_SDK
+	lua_unref( L, m_nTableReference );
+#endif
+}
+
+void CBaseScriptedTrigger::LoadScriptedTrigger( void )
+{
+	lua_getglobal( L, "entity" );
+	if ( lua_istable( L, -1 ) )
+	{
+		lua_getfield( L, -1, "get" );
+		if ( lua_isfunction( L, -1 ) )
+		{
+			lua_remove( L, -2 );
+			lua_pushstring( L, GetClassname() );
+			luasrc_pcall( L, 1, 1, 0 );
+		}
+		else
+		{
+			lua_pop( L, 2 );
+		}
+	}
+	else
+	{
+		lua_pop( L, 1 );
+	}
+}
+
+void CBaseScriptedTrigger::InitScriptedTrigger( void )
+{
+#if defined ( LUA_SDK )
+#if 0
+	// Let the instance reinitialize itself for the client.
+	if ( m_nTableReference != LUA_NOREF )
+		return;
+#endif
+
+	SetThink( &CBaseScriptedTrigger::Think );
+	SetNextThink( gpGlobals->curtime );
+
+	SetTouch( &CBaseScriptedTrigger::Touch );
+
+	char className[ 255 ];
+ 	Q_strncpy( className, GetClassname(), sizeof( className ) );
+ 	Q_strlower( className );
+	SetClassname( className );
+
+	lua_getglobal( L, "entity" );
+	if ( lua_istable( L, -1 ) )
+	{
+		lua_getfield( L, -1, "get" );
+		if ( lua_isfunction( L, -1 ) )
+		{
+			lua_remove( L, -2 );
+			lua_pushstring( L, className );
+			luasrc_pcall( L, 1, 1, 0 );
+		}
+		else
+		{
+			lua_pop( L, 2 );
+		}
+	}
+	else
+	{
+		lua_pop( L, 1 );
+	}
+
+	if ( m_nTableReference == LUA_NOREF )
+	{
+		LoadScriptedTrigger();
+		m_nTableReference = luaL_ref( L, LUA_REGISTRYINDEX );
+	}
+	else
+	{
+		lua_getglobal( L, "table" );
+		if ( lua_istable( L, -1 ) )
+		{
+			lua_getfield( L, -1, "merge" );
+			if ( lua_isfunction( L, -1 ) )
+			{
+				lua_remove( L, -2 );
+				lua_getref( L, m_nTableReference );
+				LoadScriptedTrigger();
+				luasrc_pcall( L, 2, 0, 0 );
+			}
+			else
+			{
+				lua_pop( L, 2 );
+			}
+		}
+		else
+		{
+			lua_pop( L, 1 );
+		}
+	}
+
+	BEGIN_LUA_CALL_TRIGGER_METHOD( "Initialize" );
+	END_LUA_CALL_TRIGGER_METHOD( 0, 0 );
+#endif
+}
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+void CBaseScriptedTrigger::Spawn()
+{
+	BaseClass::Spawn();
+
+	InitScriptedTrigger();
+}
+
+
+//-----------------------------------------------------------------------------
+// Purpose: Returns true if this entity passes the filter criteria, false if not.
+// Input  : pOther - The entity to be filtered.
+//-----------------------------------------------------------------------------
+bool CBaseScriptedTrigger::PassesTriggerFilters(CBaseEntity *pOther)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_TRIGGER_METHOD( "PassesTriggerFilters" );
+		lua_pushentity( L, pOther );
+	END_LUA_CALL_TRIGGER_METHOD( 1, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
+	return BaseClass::PassesTriggerFilters( pOther );
+}
+
+void CBaseScriptedTrigger::Think()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_TRIGGER_METHOD( "Think" );
+	END_LUA_CALL_TRIGGER_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Called when an entity starts touching us.
+// Input  : pOther - The entity that is touching us.
+//-----------------------------------------------------------------------------
+void CBaseScriptedTrigger::StartTouch(CBaseEntity *pOther)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_TRIGGER_METHOD( "StartTouch" );
+		lua_pushentity( L, pOther );
+	END_LUA_CALL_TRIGGER_METHOD( 1, 0 );
+#endif
+}
+
+
+void CBaseScriptedTrigger::Touch(CBaseEntity *pOther)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_TRIGGER_METHOD( "Touch" );
+		lua_pushentity( L, pOther );
+	END_LUA_CALL_TRIGGER_METHOD( 1, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Called when an entity stops touching us.
+// Input  : pOther - The entity that was touching us.
+//-----------------------------------------------------------------------------
+void CBaseScriptedTrigger::EndTouch(CBaseEntity *pOther)
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_TRIGGER_METHOD( "EndTouch" );
+		lua_pushentity( L, pOther );
+	END_LUA_CALL_TRIGGER_METHOD( 1, 0 );
+#endif
+}
+
+
diff --git a/src/game/server/basescriptedtrigger.h b/src/game/server/basescriptedtrigger.h
new file mode 100644
index 0000000..7c49c6e
--- /dev/null
+++ b/src/game/server/basescriptedtrigger.h
@@ -0,0 +1,49 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef BASESCRIPTEDTRIGGER_H
+#define BASESCRIPTEDTRIGGER_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include "triggers.h"
+#include "entityoutput.h"
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+class CBaseScriptedTrigger : public CBaseTrigger
+{
+	DECLARE_CLASS( CBaseScriptedTrigger, CBaseTrigger );
+public:
+	CBaseScriptedTrigger();
+	~CBaseScriptedTrigger();
+	
+	void LoadScriptedTrigger( void );
+	void InitScriptedTrigger( void );
+	void Think();	
+
+	void Spawn( void );
+
+	virtual bool PassesTriggerFilters(CBaseEntity *pOther);
+	virtual void StartTouch(CBaseEntity *pOther);
+	virtual void Touch(CBaseEntity *pOther);
+	virtual void EndTouch(CBaseEntity *pOther);
+
+	// by default, triggers don't deal with TraceAttack
+	void TraceAttack(CBaseEntity *pAttacker, float flDamage, const Vector &vecDir, trace_t *ptr, int bitsDamageType) {}
+
+protected:
+
+	DECLARE_DATADESC();
+};
+
+void RegisterScriptedTrigger( const char *szClassname );
+void ResetTriggerFactoryDatabase( void );
+
+#endif // BASESCRIPTEDTRIGGER_H
diff --git a/src/game/server/client.cpp b/src/game/server/client.cpp
index 66727e7..cebf698 100644
--- a/src/game/server/client.cpp
+++ b/src/game/server/client.cpp
@@ -44,6 +44,11 @@
 #include "weapon_physcannon.h"
 #endif
 
+#ifdef LUA_SDK
+#include "luamanager.h"
+#include "lbaseplayer_shared.h"
+#endif
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -143,6 +148,32 @@ void Host_Say( edict_t *pEdict, const CCommand &args, bool teamonly )
 		pPlayer = ((CBasePlayer *)CBaseEntity::Instance( pEdict ));
 		Assert( pPlayer );
 
+#if defined ( LUA_SDK )
+		BEGIN_LUA_CALL_HOOK( "Host_Say" );
+			lua_pushplayer( L, pPlayer );
+			lua_pushstring( L, p );
+			lua_pushboolean( L, teamonly );
+		END_LUA_CALL_HOOK( 3, 1 );
+
+		// Andrew; this is just a continuation of RETURN_LUA_NONE().
+		if ( lua_isboolean( L, -1 ) )
+		{
+			bool res = (bool)luaL_checkboolean( L, -1 );
+			lua_pop( L, 1 );
+			if ( !res )
+				return;
+		}
+		else if ( lua_isstring( L, -1 ) )
+		{
+			p = (char *)luaL_checkstring( L, -1 );
+			lua_pop( L, 1 );
+		}
+		else
+		{
+			lua_pop( L, 1 );
+		}
+#endif
+
 		// make sure the text has valid content
 		p = CheckChatText( pPlayer, p );
 	}
@@ -941,7 +972,9 @@ void CC_Player_PhysSwap( void )
 
 			if ( !Q_stricmp( strWeaponName, "weapon_physcannon" ) )
 			{
+#ifndef HL2SB
 				PhysCannonForceDrop( pWeapon, NULL );
+#endif
 				pPlayer->SelectLastItem();
 			}
 			else
diff --git a/src/game/server/colorcorrectionvolume.cpp b/src/game/server/colorcorrectionvolume.cpp
index fac4b7b..d0860d4 100644
--- a/src/game/server/colorcorrectionvolume.cpp
+++ b/src/game/server/colorcorrectionvolume.cpp
@@ -162,7 +162,11 @@ void CColorCorrectionVolume::Spawn( void )
 
 bool CColorCorrectionVolume::PassesTriggerFilters( CBaseEntity *pEntity )
 {
+#ifdef HL2SB
+	if( pEntity && pEntity->IsPlayer() )
+#else
 	if( pEntity == UTIL_GetLocalPlayer() )
+#endif
 		return true;
 
 	return false;
diff --git a/src/game/server/effects.cpp b/src/game/server/effects.cpp
index fdeed8e..440fadb 100644
--- a/src/game/server/effects.cpp
+++ b/src/game/server/effects.cpp
@@ -1130,7 +1130,11 @@ Vector CBlood::BloodPosition( CBaseEntity *pActivator )
 		}
 		else
 		{
+#ifdef HL2SB
+			player = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 			player = UTIL_GetLocalPlayer();
+#endif
 		}
 
 		if ( player )
diff --git a/src/game/server/entitylist.cpp b/src/game/server/entitylist.cpp
index 0d7973c..ae26bea 100644
--- a/src/game/server/entitylist.cpp
+++ b/src/game/server/entitylist.cpp
@@ -18,6 +18,11 @@
 #include "globalstate.h"
 #include "datacache/imdlcache.h"
 
+#ifdef LUA_SDK
+#include "luamanager.h"
+#include "lbaseentity_shared.h"
+#endif // LUA_SDK
+
 #ifdef HL2_DLL
 #include "npc_playercompanion.h"
 #endif // HL2_DLL
@@ -199,11 +204,17 @@ public:
 			// only copy out entities that will simulate or think this frame
 			if ( m_simThinkList[i].nextThinkTick <= gpGlobals->tickcount )
 			{
+				// FIXME: Why isn't a check for this done so entities can be
+				// removed from the list and later just request simulation?
+#ifndef HL2SB
 				Assert(m_simThinkList[i].nextThinkTick>=0);
+#endif
 				int entinfoIndex = m_simThinkList[i].entEntry;
 				const CEntInfo *pInfo = gEntList.GetEntInfoPtrByIndex( entinfoIndex );
 				pList[out] = (CBaseEntity *)pInfo->m_pEntity;
+#ifndef HL2SB
 				Assert(m_simThinkList[i].nextThinkTick==0 || pList[out]->GetFirstThinkTick()==m_simThinkList[i].nextThinkTick);
+#endif
 				Assert( gEntList.IsEntityPtr( pList[out] ) );
 				out++;
 			}
@@ -239,7 +250,9 @@ public:
 				if ( pEntity->IsEFlagSet(EFL_NO_GAME_PHYSICS_SIMULATION) )
 				{
 					m_simThinkList[m_entinfoIndex[index]].nextThinkTick = pEntity->GetFirstThinkTick();
+#ifndef HL2SB
 					Assert(m_simThinkList[m_entinfoIndex[index]].nextThinkTick>=0);
+#endif
 				}
 			}
 			else
@@ -248,7 +261,9 @@ public:
 				if ( pEntity->IsEFlagSet(EFL_NO_GAME_PHYSICS_SIMULATION) )
 				{
 					m_simThinkList[m_entinfoIndex[index]].nextThinkTick = pEntity->GetFirstThinkTick();
+#ifndef HL2SB
 					Assert(m_simThinkList[m_entinfoIndex[index]].nextThinkTick>=0);
+#endif
 				}
 				else
 				{
@@ -1310,6 +1325,11 @@ void CNotifyList::LevelShutdownPreEntity( void )
 
 void CNotifyList::OnEntityCreated( CBaseEntity *pEntity )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "OnEntityCreated" );
+		lua_pushentity( L, pEntity );
+	END_LUA_CALL_HOOK( 1, 0 );
+#endif
 }
 
 void CNotifyList::OnEntityDeleted( CBaseEntity *pEntity )
diff --git a/src/game/server/env_zoom.cpp b/src/game/server/env_zoom.cpp
index 82fc819..ce25924 100644
--- a/src/game/server/env_zoom.cpp
+++ b/src/game/server/env_zoom.cpp
@@ -11,6 +11,10 @@
 #include "hl2_player.h"
 #endif
 
+#ifdef HL2SB
+#include "hl2mp_player.h"
+#endif
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -74,7 +78,11 @@ float GetZoomOwnerDesiredFOV( CBaseEntity *pZoomOwner )
 //-----------------------------------------------------------------------------
 void CEnvZoom::InputZoom( inputdata_t &inputdata )
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 
 	if ( pPlayer )
 	{
@@ -82,9 +90,15 @@ void CEnvZoom::InputZoom( inputdata_t &inputdata )
 #ifdef HL2_DLL
 		if ( pPlayer == pPlayer->GetFOVOwner() )
 		{
+#ifdef HL2SB
+			CHL2MP_Player *pHLMPPlayer = static_cast<CHL2MP_Player*>( pPlayer );
+
+			pHLMPPlayer->StopZooming();
+#else
 			CHL2_Player *pHLPlayer = static_cast<CHL2_Player*>( pPlayer );
 
 			pHLPlayer->StopZooming();
+#endif
 		}
 #endif
 
@@ -105,7 +119,11 @@ void CEnvZoom::InputZoom( inputdata_t &inputdata )
 //-----------------------------------------------------------------------------
 void CEnvZoom::InputUnZoom( inputdata_t &inputdata )
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 
 	if ( pPlayer )
 	{
diff --git a/src/game/server/envhudhint.cpp b/src/game/server/envhudhint.cpp
index 601787a..79fbe41 100644
--- a/src/game/server/envhudhint.cpp
+++ b/src/game/server/envhudhint.cpp
@@ -76,7 +76,11 @@ void CEnvHudHint::InputShowHudHint( inputdata_t &inputdata )
 	}
 	else
 	{
+#ifdef HL2SB
+		pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 		pPlayer = UTIL_GetLocalPlayer();
+#endif
 	}
 
 	if ( pPlayer )
@@ -105,7 +109,11 @@ void CEnvHudHint::InputHideHudHint( inputdata_t &inputdata )
 	}
 	else
 	{
+#ifdef HL2SB
+		pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 		pPlayer = UTIL_GetLocalPlayer();
+#endif
 	}
 
 	if ( pPlayer )
diff --git a/src/game/server/envmessage.cpp b/src/game/server/envmessage.cpp
index 51b2d89..fe4216b 100644
--- a/src/game/server/envmessage.cpp
+++ b/src/game/server/envmessage.cpp
@@ -105,7 +105,11 @@ void CMessage::InputShowMessage( inputdata_t &inputdata )
 		}
 		else
 		{
+#ifdef HL2SB
+			pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin());
+#else
 			pPlayer = (gpGlobals->maxClients > 1) ? NULL : UTIL_GetLocalPlayer();
+#endif
 		}
 
 		if ( pPlayer && pPlayer->IsPlayer() )
@@ -219,12 +223,18 @@ void CCredits::RollOutroCredits()
 {
 	sv_unlockedchapters.SetValue( "15" );
 	
+#ifndef HL2SB
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
 
 	CSingleUserRecipientFilter user( pPlayer );
 	user.MakeReliable();
 
 	UserMessageBegin( user, "CreditsMsg" );
+#else
+	CReliableBroadcastRecipientFilter filter;
+
+	UserMessageBegin( filter, "CreditsMsg" );
+#endif
 		WRITE_BYTE( 3 );
 	MessageEnd();
 }
@@ -241,20 +251,32 @@ void CCredits::InputRollOutroCredits( inputdata_t &inputdata )
 
 void CCredits::InputShowLogo( inputdata_t &inputdata )
 {
+#ifndef HL2SB
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
 
 	CSingleUserRecipientFilter user( pPlayer );
 	user.MakeReliable();
+#else
+	CReliableBroadcastRecipientFilter filter;
+#endif
 
 	if ( m_flLogoLength )
 	{
+#ifndef HL2SB
 		UserMessageBegin( user, "LogoTimeMsg" );
+#else
+		UserMessageBegin( filter, "LogoTimeMsg" );
+#endif
 			WRITE_FLOAT( m_flLogoLength );
 		MessageEnd();
 	}
 	else
 	{
+#ifndef HL2SB
 		UserMessageBegin( user, "CreditsMsg" );
+#else
+		UserMessageBegin( filter, "CreditsMsg" );
+#endif
 			WRITE_BYTE( 1 );
 		MessageEnd();
 	}
@@ -267,12 +289,18 @@ void CCredits::InputSetLogoLength( inputdata_t &inputdata )
 
 void CCredits::InputRollCredits( inputdata_t &inputdata )
 {
+#ifndef HL2SB
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
 
 	CSingleUserRecipientFilter user( pPlayer );
 	user.MakeReliable();
 
 	UserMessageBegin( user, "CreditsMsg" );
+#else
+	CReliableBroadcastRecipientFilter filter;
+
+	UserMessageBegin( filter, "CreditsMsg" );
+#endif
 		WRITE_BYTE( 2 );
 	MessageEnd();
 }
diff --git a/src/game/server/envmicrophone.cpp b/src/game/server/envmicrophone.cpp
index 11e114d..106799a 100644
--- a/src/game/server/envmicrophone.cpp
+++ b/src/game/server/envmicrophone.cpp
@@ -448,8 +448,10 @@ MicrophoneResult_t CEnvMicrophone::SoundPlayed( int entindex, const char *soundn
 	Msg("%s heard %s: ", STRING(GetEntityName()), soundname );
 #endif
 
+#ifndef HL2SB
 	if ( !CanHearSound( entindex, soundlevel, flVolume, pOrigin ) )
 		return MicrophoneResult_Ok;
+#endif
 
 	// We've heard it. Play it out our speaker. If our speaker's gone away, we're done.
 	if ( !m_hSpeaker )
diff --git a/src/game/server/episodic/ai_behavior_passenger_companion.cpp b/src/game/server/episodic/ai_behavior_passenger_companion.cpp
index c8d5b64..a071752 100644
--- a/src/game/server/episodic/ai_behavior_passenger_companion.cpp
+++ b/src/game/server/episodic/ai_behavior_passenger_companion.cpp
@@ -778,7 +778,11 @@ bool CAI_PassengerBehaviorCompanion::CanEnterVehicleImmediately( int *pResultSeq
 		return false;
 
 	// If the player can see us, then we can't enter immediately anyway
-	CBasePlayer *pPlayer = AI_GetSinglePlayer();	
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
+	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer == NULL )
 		return false;
 
@@ -1112,7 +1116,11 @@ bool CAI_PassengerBehaviorCompanion::FindPathToVehicleEntryPoint( void )
 //-----------------------------------------------------------------------------
 bool CAI_PassengerBehaviorCompanion::CanExitAtPosition( const Vector &vecTestPos )
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer == NULL )
 		return false;
 
@@ -1834,7 +1842,11 @@ bool CAI_PassengerBehaviorCompanion::CanFidget( void )
 		return false;
 
 	// Must be visible to the player
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetOuter()->EyePosition() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer && pPlayer->FInViewCone( GetOuter()->EyePosition() ) == false )
 		return false;
 
diff --git a/src/game/server/episodic/npc_hunter.cpp b/src/game/server/episodic/npc_hunter.cpp
index 4d523a0..5034516 100644
--- a/src/game/server/episodic/npc_hunter.cpp
+++ b/src/game/server/episodic/npc_hunter.cpp
@@ -811,7 +811,11 @@ void CHunterFlechette::SeekThink()
 //-----------------------------------------------------------------------------
 void CHunterFlechette::DopplerThink()
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( !pPlayer )
 		return;
 
@@ -2304,8 +2308,13 @@ void CNPC_Hunter::GatherConditions()
 						if ( timeDrawnArrow != gpGlobals->curtime )
 						{
 							timeDrawnArrow = gpGlobals->curtime;
+#ifdef HL2SB
+							Vector vEndpoint( vecFuturePos.x, vecFuturePos.y, UTIL_GetNearestPlayer( GetAbsOrigin() )->WorldSpaceCenter().z - 24 );
+							NDebugOverlay::HorzArrow( UTIL_GetNearestPlayer( GetAbsOrigin() )->WorldSpaceCenter() - Vector(0, 0, 24), vEndpoint, hunter_dodge_warning_width.GetFloat(), 255, 0, 0, 64, true, .1 );
+#else
 							Vector vEndpoint( vecFuturePos.x, vecFuturePos.y, UTIL_GetLocalPlayer()->WorldSpaceCenter().z - 24 );
 							NDebugOverlay::HorzArrow( UTIL_GetLocalPlayer()->WorldSpaceCenter() - Vector(0, 0, 24), vEndpoint, hunter_dodge_warning_width.GetFloat(), 255, 0, 0, 64, true, .1 );
+#endif
 						}
 					}
 				}
@@ -2330,8 +2339,13 @@ void CNPC_Hunter::GatherConditions()
 				if ( timeDrawnArrow != gpGlobals->curtime )
 				{
 					timeDrawnArrow = gpGlobals->curtime;
+#ifdef HL2SB
+					Vector vEndpoint( vecFuturePos.x, vecFuturePos.y, UTIL_GetNearestPlayer( GetAbsOrigin() )->WorldSpaceCenter().z - 24 );
+					NDebugOverlay::HorzArrow( UTIL_GetNearestPlayer( GetAbsOrigin() )->WorldSpaceCenter() - Vector(0, 0, 24), vEndpoint, hunter_dodge_warning_width.GetFloat(), 127, 127, 127, 64, true, .1 );
+#else
 					Vector vEndpoint( vecFuturePos.x, vecFuturePos.y, UTIL_GetLocalPlayer()->WorldSpaceCenter().z - 24 );
 					NDebugOverlay::HorzArrow( UTIL_GetLocalPlayer()->WorldSpaceCenter() - Vector(0, 0, 24), vEndpoint, hunter_dodge_warning_width.GetFloat(), 127, 127, 127, 64, true, .1 );
+#endif
 				}
 			}
 
@@ -2408,7 +2422,11 @@ void CNPC_Hunter::ManageSiegeTargets()
 	}
 
 	m_flTimeNextSiegeTargetAttack = gpGlobals->curtime + (hunter_siege_frequency.GetFloat() * RandomFloat( 0.8f, 1.2f) );
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 	// Start by assuming we are not going to create a siege target
 	bool bCreateSiegeTarget = false;
@@ -3033,7 +3051,11 @@ int CNPC_Hunter::SelectSchedule()
 				}
 				else
 				{
+#ifdef HL2SB
+					SetTarget( UTIL_GetNearestPlayer( GetAbsOrigin() ) );
+#else
 					SetTarget( UTIL_GetLocalPlayer() );
+#endif
 					return SCHED_TARGET_FACE;
 				}
 			}
@@ -3065,7 +3087,11 @@ int CNPC_Hunter::SelectSchedule()
 		}
 		else
 		{
+#ifdef HL2SB
+			SetTarget( UTIL_GetNearestPlayer( GetAbsOrigin() ) );
+#else
 			SetTarget( UTIL_GetLocalPlayer() );
+#endif
 			return SCHED_TARGET_FACE;
 		}
 
@@ -5792,7 +5818,11 @@ void CNPC_Hunter::Event_Killed( const CTakeDamageInfo &info )
 			m_EscortBehavior.GetEscortTarget()->AlertSound();
 			if ( info.GetAttacker() && info.GetAttacker()->IsPlayer() )
 			{
+#ifdef HL2SB
+				m_EscortBehavior.GetEscortTarget()->UpdateEnemyMemory( UTIL_GetNearestPlayer( GetAbsOrigin() ), UTIL_GetNearestPlayer( GetAbsOrigin() )->GetAbsOrigin(), this );
+#else
 				m_EscortBehavior.GetEscortTarget()->UpdateEnemyMemory( UTIL_GetLocalPlayer(), UTIL_GetLocalPlayer()->GetAbsOrigin(), this );
+#endif
 			}
 		}
 	}
diff --git a/src/game/server/episodic/vehicle_hl2buggy.cpp b/src/game/server/episodic/vehicle_hl2buggy.cpp
index b0e54f2..d7c5485 100644
--- a/src/game/server/episodic/vehicle_hl2buggy.cpp
+++ b/src/game/server/episodic/vehicle_hl2buggy.cpp
@@ -274,8 +274,13 @@ float CPropHL2Buggy::GetUprightStrength( void )
 //-----------------------------------------------------------------------------
 void CPropHL2Buggy::Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value )
 {
+#ifndef HL2SB
 	// Fall back and get in the vehicle instead, skip giving ammo
 	BaseClass::BaseClass::Use( pActivator, pCaller, useType, value );
+#else
+	// Andrew; don't skip giving ammo with the jeep
+	BaseClass::Use( pActivator, pCaller, useType, value );
+#endif
 }
 
 #define	MIN_WHEEL_DUST_SPEED	5
diff --git a/src/game/server/episodic/vehicle_jeep_episodic.cpp b/src/game/server/episodic/vehicle_jeep_episodic.cpp
index 8a4f543..95433d8 100644
--- a/src/game/server/episodic/vehicle_jeep_episodic.cpp
+++ b/src/game/server/episodic/vehicle_jeep_episodic.cpp
@@ -455,7 +455,11 @@ void CPropJeepEpisodic::Spawn( void )
 
 	SetBlocksLOS( false );
 
+#ifdef HL2SB
+	CBasePlayer	*pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer	*pPlayer = UTIL_GetLocalPlayer();
+#endif
 	if ( pPlayer != NULL )
 	{
 		pPlayer->m_Local.m_iHideHUD |= HIDEHUD_VEHICLE_CROSSHAIR;
@@ -718,8 +722,21 @@ void CPropJeepEpisodic::CreateCargoTrigger( void )
 //-----------------------------------------------------------------------------
 void CPropJeepEpisodic::Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value )
 {
+#ifdef HL2SB
+	// Andrew; don't skip giving ammo with the jeep if we're the buggy
+	if ( !strcmp( STRING( GetModelName() ), "models/buggy.mdl" ) )
+	{
+		BaseClass::Use( pActivator, pCaller, useType, value );
+	}
+	else
+	{
+		// Fall back and get in the vehicle instead, skip giving ammo
+		BaseClass::BaseClass::Use( pActivator, pCaller, useType, value );
+	}
+#else
 	// Fall back and get in the vehicle instead, skip giving ammo
 	BaseClass::BaseClass::Use( pActivator, pCaller, useType, value );
+#endif
 }
 
 #define	MIN_WHEEL_DUST_SPEED	5
@@ -954,7 +971,11 @@ void CPropJeepEpisodic::UpdateRadar( bool forceUpdate )
 
 	//Msg("Server detected %d objects\n", m_iNumRadarContacts );
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	CSingleUserRecipientFilter filter(pPlayer);
 	UserMessageBegin( filter, "UpdateJalopyRadar" );
 	WRITE_BYTE( 0 ); // end marker
@@ -1127,7 +1148,11 @@ CBaseEntity *CPropJeepEpisodic::OnFailedPhysGunPickup( Vector vPhysgunPos )
 	{
 		// Player's forward direction
 		Vector vecPlayerForward;
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		if ( pPlayer == NULL )
 			return NULL;
 
@@ -1352,6 +1377,12 @@ void CPropJeepEpisodic::DriveVehicle( float flFrameTime, CUserCmd *ucmd, int iBu
 //-----------------------------------------------------------------------------
 void CPropJeepEpisodic::CreateHazardLights( void )
 {
+	// How about no.
+#ifdef HL2SB
+	if ( strcmp( STRING( GetModelName() ), "models/vehicle.mdl" ) )
+		return;
+#endif
+
 	static const char *s_szAttach[NUM_HAZARD_LIGHTS] =
 	{
 		"rearlight_r",
@@ -1588,7 +1619,11 @@ int	CPropJeepEpisodic::DrawDebugTextOverlays( void )
 void CPropJeepEpisodic::InputOutsideTransition( inputdata_t &inputdata )
 {
 	// Teleport into the new map
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	Vector vecTeleportPos;
 	QAngle vecTeleportAngles;
 
diff --git a/src/game/server/episodic/weapon_striderbuster.cpp b/src/game/server/episodic/weapon_striderbuster.cpp
index 6f38888..54407cc 100644
--- a/src/game/server/episodic/weapon_striderbuster.cpp
+++ b/src/game/server/episodic/weapon_striderbuster.cpp
@@ -646,7 +646,12 @@ void CWeaponStriderBuster::Detonate( void )
 	if ( !m_bDud && pVictim )
 	{
 		// Kill the strider (with magic effect)
+#ifdef HL2SB
+		// Andrew; this is terrible. Find a way to fix this.
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		CTakeDamageInfo info( pPlayer, this, RandomVector( -100.0f, 100.0f ), GetAbsOrigin(), pVictim->GetHealth(), DMG_GENERIC );
 		pVictim->TakeDamage( info );
 
diff --git a/src/game/server/fogcontroller.cpp b/src/game/server/fogcontroller.cpp
index 8b8a32b..e4543f4 100644
--- a/src/game/server/fogcontroller.cpp
+++ b/src/game/server/fogcontroller.cpp
@@ -387,5 +387,19 @@ void CFogSystem::LevelInitPostEntity( void )
 			pPlayer->InitFogController();
 		}
 	}
+#ifdef HL2SB
+	else
+	{
+		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
+		{
+			CBasePlayer *pPlayer = UTIL_PlayerByIndex( i );
+
+			if ( pPlayer && ( pPlayer->m_Local.m_PlayerFog.m_hCtrl.Get() == NULL ) )
+			{
+				pPlayer->InitFogController();
+			}
+		}
+	}
+#endif
 }
 
diff --git a/src/game/server/gameinterface.cpp b/src/game/server/gameinterface.cpp
index 5374d12..f738233 100644
--- a/src/game/server/gameinterface.cpp
+++ b/src/game/server/gameinterface.cpp
@@ -85,6 +85,17 @@
 #include "tier3/tier3.h"
 #include "serverbenchmark_base.h"
 
+#ifdef LUA_SDK
+#include "luamanager.h"
+#include "luacachefile.h"
+#include "mountaddons.h"
+#endif
+
+#ifdef HL2SB
+#include "mountsteamcontent.h"
+#include "ticketfix.h"
+#endif
+
 #ifdef CSTRIKE_DLL // BOTPORT: TODO: move these ifdefs out
 #include "bot/bot.h"
 #endif
@@ -618,6 +629,17 @@ bool CServerGameDLL::DLLInit( CreateInterfaceFn appSystemFactory,
 	//Tony; mount an extra appId if it exists.
 	MountAdditionalContent();
 
+#if defined ( HL2SB )
+	//Andrew; then mount everything the user wants to use.
+	MountUserContent();
+
+	// Finally, load all of the player's addons.
+	MountAddons();
+
+	// Fixes the issue where the external ip is not matching the local ip.
+	PatchTicketValidation();
+#endif
+
 	// cache the globals
 	gpGlobals = pGlobals;
 
@@ -755,6 +777,11 @@ void CServerGameDLL::DLLShutdown( void )
 	}
 #endif
 
+#ifdef HL2SB
+	//Andrew; fixes the "CNet Encrypt:0" issue in 2007-based mods.
+	SteamAPI_Shutdown();
+#endif
+
 	DisconnectTier3Libraries();
 	DisconnectTier2Libraries();
 	ConVar_Unregister();
@@ -893,6 +920,33 @@ bool CServerGameDLL::IsRestoring()
 bool CServerGameDLL::LevelInit( const char *pMapName, char const *pMapEntities, char const *pOldLevel, char const *pLandmarkName, bool loadGame, bool background )
 {
 	VPROF("CServerGameDLL::LevelInit");
+#if defined ( LUA_SDK )
+	lcf_recursivedeletefile( LUA_PATH_CACHE );
+
+	// Add Lua environment
+	luasrc_init();
+
+	luasrc_dofolder( L, LUA_PATH_EXTENSIONS );
+	luasrc_dofolder( L, LUA_PATH_MODULES );
+	luasrc_dofolder( L, LUA_PATH_GAME_SHARED );
+	luasrc_dofolder( L, LUA_PATH_GAME_SERVER );
+
+	luasrc_LoadWeapons();
+	luasrc_LoadEntities();
+	// luasrc_LoadEffects();
+
+	//Andrew; loadup base gamemode.
+	luasrc_LoadGamemode( LUA_BASE_GAMEMODE );
+
+	luasrc_LoadGamemode( gamemode.GetString() );
+	luasrc_SetGamemode( gamemode.GetString() );
+
+	if ( gpGlobals->maxClients > 1 )
+	{
+		// load LCF into stringtable
+		lcf_preparecachefile();
+	}
+#endif
 	ResetWindspeed();
 	UpdateChapterRestrictions( pMapName );
 
@@ -997,6 +1051,17 @@ bool CServerGameDLL::LevelInit( const char *pMapName, char const *pMapEntities,
 	// clear any pending autosavedangerous
 	m_fAutoSaveDangerousTime = 0.0f;
 	m_fAutoSaveDangerousMinHealthToCommit = 0.0f;
+
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "LevelInit" );
+		lua_pushstring( L, pMapName );
+		lua_pushstring( L, pMapEntities );
+		lua_pushstring( L, pOldLevel );
+		lua_pushstring( L, pLandmarkName );
+		lua_pushboolean( L, loadGame );
+		lua_pushboolean( L, background );
+	END_LUA_CALL_HOOK( 6, 0 );
+#endif
 	return true;
 }
 
@@ -1072,6 +1137,14 @@ void CServerGameDLL::ServerActivate( edict_t *pEdictList, int edictCount, int cl
 #if defined ( SDK_DLL )
 	SDKGameRules()->ServerActivate();
 #endif
+
+//Andrew; call activate on the gamemode
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "ServerActivate" );
+		lua_pushinteger( L, edictCount );
+		lua_pushinteger( L, clientMax );
+	END_LUA_CALL_HOOK( 2, 0 );
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -1226,7 +1299,11 @@ void CServerGameDLL::Think( bool finalTick )
 	if ( m_fAutoSaveDangerousTime != 0.0f && m_fAutoSaveDangerousTime < gpGlobals->curtime )
 	{
 		// The safety timer for a dangerous auto save has expired
+#ifdef HL2SB
+		CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#else
 		CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
+#endif
 
 		if ( pPlayer && ( pPlayer->GetDeathTime() == 0.0f || pPlayer->GetDeathTime() > gpGlobals->curtime )
 			&& !pPlayer->IsSinglePlayerGameEnding()
@@ -1252,6 +1329,14 @@ void CServerGameDLL::OnQueryCvarValueFinished( QueryCvarCookie_t iCookie, edict_
 // Called when a level is shutdown (including changing levels)
 void CServerGameDLL::LevelShutdown( void )
 {
+#if defined ( LUA_SDK )
+	if (g_bLuaInitialized)
+	{
+		BEGIN_LUA_CALL_HOOK( "LevelShutdown" );
+		END_LUA_CALL_HOOK( 0, 0 );
+	}
+#endif
+
 	MDLCACHE_CRITICAL_SECTION();
 	IGameSystem::LevelShutdownPreEntityAllSystems();
 
@@ -1267,6 +1352,10 @@ void CServerGameDLL::LevelShutdown( void )
 	CBaseEntity::SetAllowPrecache( false );
 
 	g_nCurrentChapterIndex = -1;
+
+#if defined ( LUA_SDK )
+	luasrc_shutdown();
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -1676,6 +1765,16 @@ void CServerGameDLL::PreSaveGameLoaded( char const *pSaveName, bool bInGame )
 //-----------------------------------------------------------------------------
 bool CServerGameDLL::ShouldHideServer( void )
 {
+#if defined ( LUA_SDK )
+	if ( g_bLuaInitialized )
+	{
+		BEGIN_LUA_CALL_HOOK( "ShouldHideServer" );
+		END_LUA_CALL_HOOK( 0, 1 );
+
+		RETURN_LUA_BOOLEAN();
+	}
+#endif
+
 	if ( g_pcv_commentary && g_pcv_commentary->GetBool() )
 		return true;
 
@@ -2367,8 +2466,16 @@ void CServerGameClients::ClientActive( edict_t *pEdict, bool bLoadGame )
 
 	// Tell the sound controller to check looping sounds
 	CBasePlayer *pPlayer = ( CBasePlayer * )CBaseEntity::Instance( pEdict );
+#ifdef HL2SB
+	if( pPlayer )
+	{
+		CSoundEnvelopeController::GetController().CheckLoopingSoundsForPlayer( pPlayer );
+		SceneManager_ClientActive( pPlayer );
+	}
+#else
 	CSoundEnvelopeController::GetController().CheckLoopingSoundsForPlayer( pPlayer );
 	SceneManager_ClientActive( pPlayer );
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -2849,6 +2956,12 @@ void CServerGameClients::GetBugReportInfo( char *buf, int buflen )
 //-----------------------------------------------------------------------------
 void CServerGameClients::NetworkIDValidated( const char *pszUserName, const char *pszNetworkID )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "NetworkIDValidated" );
+		lua_pushstring( L, pszUserName );
+		lua_pushstring( L, pszNetworkID );
+	END_LUA_CALL_HOOK( 2, 0 );
+#endif
 }
 
 
diff --git a/src/game/server/gib.cpp b/src/game/server/gib.cpp
index c112a14..3c59b0c 100644
--- a/src/game/server/gib.cpp
+++ b/src/game/server/gib.cpp
@@ -400,7 +400,11 @@ bool CGib::SUB_AllowedToFade( void )
 			return false;
 	}
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = ( AI_IsSinglePlayer() ) ? UTIL_GetLocalPlayer() : NULL;
+#endif
 
 	if ( pPlayer && pPlayer->FInViewCone( this ) && m_bForceRemove == false )
 	{
diff --git a/src/game/server/hl2/ai_behavior_actbusy.cpp b/src/game/server/hl2/ai_behavior_actbusy.cpp
index 857d067..8f5ab74 100644
--- a/src/game/server/hl2/ai_behavior_actbusy.cpp
+++ b/src/game/server/hl2/ai_behavior_actbusy.cpp
@@ -502,7 +502,11 @@ CAI_Hint *CAI_ActBusyBehavior::FindCombatActBusyHintNode()
 {
 	Assert( IsCombatActBusy() );
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 	if( !pPlayer )
 		return NULL;
@@ -547,7 +551,11 @@ CAI_Hint *CAI_ActBusyBehavior::FindCombatActBusyTeleportHintNode()
 {
 	Assert( IsCombatActBusy() );
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetOuter()->GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 	if( !pPlayer )
 		return NULL;
@@ -1168,7 +1176,11 @@ int CAI_ActBusyBehavior::SelectScheduleWhileNotBusy( int iBase )
 		{
 			if( IsCombatActBusy() )
 			{
+#ifdef HL2SB
+				if ( m_hActBusyGoal->IsCombatActBusyTeleportAllowed() && m_iNumConsecutivePathFailures >= 2 && !AI_GetNearestPlayer(GetOuter()->GetAbsOrigin())->FInViewCone(GetOuter()) ) 
+#else
 				if ( m_hActBusyGoal->IsCombatActBusyTeleportAllowed() && m_iNumConsecutivePathFailures >= 2 && !AI_GetSinglePlayer()->FInViewCone(GetOuter()) ) 
+#endif
 				{
 					// Looks like I've tried several times to find a path to a valid hint node and
 					// haven't been able to. This means I'm on a patch of node graph that simply
diff --git a/src/game/server/hl2/antlion_maker.cpp b/src/game/server/hl2/antlion_maker.cpp
index 51dec0d..f053e05 100644
--- a/src/game/server/hl2/antlion_maker.cpp
+++ b/src/game/server/hl2/antlion_maker.cpp
@@ -1172,7 +1172,11 @@ void CAntlionTemplateMaker::FindNodesCloseToPlayer( void )
 {
 	SetContextThink( &CAntlionTemplateMaker::FindNodesCloseToPlayer, gpGlobals->curtime + random->RandomFloat( 0.75, 1.75 ), s_pBlockedEffectsThinkContext );
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 	if ( pPlayer == NULL )
 		 return;
@@ -1259,7 +1263,11 @@ void CAntlionTemplateMaker::BlockedCheckFunc( void )
 			if ( pNode )
 			{
 				Vector vHintPos;
+#ifdef HL2SB
+				pNode->GetPosition( AI_GetNearestPlayer( GetAbsOrigin() ), &vHintPos );
+#else
 				pNode->GetPosition( AI_GetSinglePlayer(), &vHintPos );
+#endif
 
 				CBaseEntity*	pList[20];
 				int count = UTIL_EntitiesInBox( pList, 20, vHintPos + NAI_Hull::Mins( HULL_MEDIUM ), vHintPos + NAI_Hull::Maxs( HULL_MEDIUM ), 0 );
diff --git a/src/game/server/hl2/combine_mine.cpp b/src/game/server/hl2/combine_mine.cpp
index 7916da9..4faeb82 100644
--- a/src/game/server/hl2/combine_mine.cpp
+++ b/src/game/server/hl2/combine_mine.cpp
@@ -873,7 +873,11 @@ float CBounceBomb::FindNearestNPC()
 	}
 
 	// finally, check the player.
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 
 	if( pPlayer && !(pPlayer->GetFlags() & FL_NOTARGET) )
 	{
diff --git a/src/game/server/hl2/func_tank.cpp b/src/game/server/hl2/func_tank.cpp
index 3839c95..f7f8562 100644
--- a/src/game/server/hl2/func_tank.cpp
+++ b/src/game/server/hl2/func_tank.cpp
@@ -75,14 +75,14 @@ BEGIN_DATADESC( CFuncTank )
 	DEFINE_KEYFIELD( m_iBulletDamageVsPlayer, FIELD_INTEGER, "bullet_damage_vs_player" ),
 	DEFINE_KEYFIELD( m_iszMaster, FIELD_STRING, "master" ),
 	
-#ifdef HL2_EPISODIC	
+// #ifdef HL2_EPISODIC	
 	DEFINE_KEYFIELD( m_iszAmmoType, FIELD_STRING, "ammotype" ),
 	DEFINE_FIELD( m_iAmmoType, FIELD_INTEGER ),
-#else
+// #else
 	DEFINE_FIELD( m_iSmallAmmoType, FIELD_INTEGER ),
 	DEFINE_FIELD( m_iMediumAmmoType, FIELD_INTEGER ),
 	DEFINE_FIELD( m_iLargeAmmoType, FIELD_INTEGER ),
-#endif // HL2_EPISODIC
+// #endif // HL2_EPISODIC
 
 	DEFINE_KEYFIELD( m_soundStartRotate, FIELD_SOUNDNAME, "rotatestartsound" ),
 	DEFINE_KEYFIELD( m_soundStopRotate, FIELD_SOUNDNAME, "rotatestopsound" ),
@@ -733,13 +733,13 @@ void CFuncTank::Spawn( void )
 {
 	Precache();
 
-#ifdef HL2_EPISODIC
+// #ifdef HL2_EPISODIC
 	m_iAmmoType = GetAmmoDef()->Index( STRING( m_iszAmmoType ) );
-#else
+// #else
 	m_iSmallAmmoType	= GetAmmoDef()->Index("Pistol");
 	m_iMediumAmmoType	= GetAmmoDef()->Index("SMG1");
 	m_iLargeAmmoType	= GetAmmoDef()->Index("AR2");
-#endif // HL2_EPISODIC
+// #endif // HL2_EPISODIC
 
 	SetMoveType( MOVETYPE_PUSH );  // so it doesn't get pushed by anything
 	SetSolid( SOLID_VPHYSICS );
@@ -800,6 +800,9 @@ void CFuncTank::Spawn( void )
 			if ( pProp )
 			{
 				pProp->m_bUseHitboxesForRenderBox = true;
+#ifdef HL2SB
+				pProp->m_bClientSideAnimation = false;
+#endif
 			}
 		}
 	}
@@ -2149,6 +2152,9 @@ void CFuncTank::DoMuzzleFlash( void )
 			CEffectData data;
 			data.m_nAttachmentIndex = m_nBarrelAttachment;
 			data.m_nEntIndex = pAnim->entindex();
+#ifdef HL2SB
+			pAnim->GetAttachment( m_nBarrelAttachment, data.m_vOrigin );
+#endif
 			
 			// FIXME: Create a custom entry here!
 			DispatchEffect( "ChopperMuzzleFlash", data );
@@ -2160,6 +2166,9 @@ void CFuncTank::DoMuzzleFlash( void )
 			data.m_nAttachmentIndex = m_nBarrelAttachment;
 			data.m_flScale = 1.0f;
 			data.m_fFlags = MUZZLEFLASH_COMBINE;
+#ifdef HL2SB
+			pAnim->GetAttachment( m_nBarrelAttachment, data.m_vOrigin );
+#endif
 
 			DispatchEffect( "MuzzleFlash", data );
 		}
@@ -2427,6 +2436,10 @@ LINK_ENTITY_TO_CLASS( func_tank, CFuncTankGun );
 //-----------------------------------------------------------------------------
 void CFuncTankGun::Fire( int bulletCount, const Vector &barrelEnd, const Vector &forward, CBaseEntity *pAttacker, bool bIgnoreSpread )
 {
+#ifdef HL2SB
+	IPredictionSystem::SuppressHostEvents( NULL );
+#endif
+
 	int i;
 
 	FireBulletsInfo_t info;
@@ -2449,7 +2462,7 @@ void CFuncTankGun::Fire( int bulletCount, const Vector &barrelEnd, const Vector
 	info.m_pAttacker = pAttacker;
 	info.m_pAdditionalIgnoreEnt = GetParent();
 
-#ifdef HL2_EPISODIC
+#if !defined( HL2SB ) && defined( HL2_EPISODIC )
 	if ( m_iAmmoType != -1 )
 	{
 		for ( i = 0; i < bulletCount; i++ )
@@ -2480,6 +2493,10 @@ void CFuncTankGun::Fire( int bulletCount, const Vector &barrelEnd, const Vector
 
 		default:
 		case TANK_BULLET_NONE:
+#ifdef HL2SB
+			info.m_iAmmoType = m_iAmmoType;
+			FireBullets( info );
+#endif
 			break;
 		}
 	}
@@ -2953,6 +2970,9 @@ void CFuncTankAirboatGun::DoMuzzleFlash( void )
 		data.m_nEntIndex = m_hAirboatGunModel->entindex();
 		data.m_nAttachmentIndex = m_nGunBarrelAttachment;
 		data.m_flScale = 1.0f;
+#ifdef HL2SB
+		m_hAirboatGunModel->GetAttachment( m_nGunBarrelAttachment, data.m_vOrigin );
+#endif
 		DispatchEffect( "AirboatMuzzleFlash", data );
 	}
 }
@@ -4205,7 +4225,11 @@ void CFuncTankCombineCannon::FuncTankPostThink()
 			AddSpawnFlags( SF_TANK_AIM_AT_POS );
 
 			Vector vecTargetPosition = GetTargetPosition();
+#ifdef HL2SB
+			CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 			CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 			Vector vecToPlayer = pPlayer->WorldSpaceCenter() - GetAbsOrigin();
 			vecToPlayer.NormalizeInPlace();
 
@@ -4352,6 +4376,24 @@ void CFuncTankCombineCannon::Fire( int bulletCount, const Vector &barrelEnd, con
 void CFuncTankCombineCannon::MakeTracer( const Vector &vecTracerSrc, const trace_t &tr, int iTracerType )
 {
 	// If the shot passed near the player, shake the screen.
+#ifdef HL2SB
+	int			i;
+	for ( i = 1; i <= gpGlobals->maxClients; i++ )
+	{
+		CBaseEntity *pPlayer = UTIL_PlayerByIndex( i );
+		Vector vecPlayer = pPlayer->EyePosition();
+
+		Vector vecNearestPoint = PointOnLineNearestPoint( vecTracerSrc, tr.endpos, vecPlayer );
+
+		float flDist = vecPlayer.DistTo( vecNearestPoint );
+
+		if( flDist >= 10.0f && flDist <= 120.0f )
+		{
+			// Don't shake the screen if we're hit (within 10 inches), but do shake if a shot otherwise comes within 10 feet.
+			UTIL_ScreenShake( vecNearestPoint, 10, 60, 0.3, 120.0f, SHAKE_START, false );
+		}
+	}
+#else
 	if( AI_IsSinglePlayer() )
 	{
 		Vector vecPlayer = AI_GetSinglePlayer()->EyePosition();
@@ -4366,6 +4408,7 @@ void CFuncTankCombineCannon::MakeTracer( const Vector &vecTracerSrc, const trace
 			UTIL_ScreenShake( vecNearestPoint, 10, 60, 0.3, 120.0f, SHAKE_START, false );
 		}
 	}
+#endif
 
 	// Send the railgun effect
 	DispatchParticleEffect( "Weapon_Combine_Ion_Cannon", vecTracerSrc, tr.endpos, vec3_angle, NULL );
diff --git a/src/game/server/hl2/func_tank.h b/src/game/server/hl2/func_tank.h
index 510f591..d26268f 100644
--- a/src/game/server/hl2/func_tank.h
+++ b/src/game/server/hl2/func_tank.h
@@ -237,14 +237,14 @@ protected:
 	int						m_iBulletDamage; // 0 means use Bullet type's default damage
 	int						m_iBulletDamageVsPlayer; // Damage vs player. 0 means use m_iBulletDamage
 
-#ifdef HL2_EPISODIC
+// #ifdef HL2_EPISODIC
 	string_t				m_iszAmmoType;		// The name of the ammodef that we use when we fire. Bullet damage still comes from keyvalues.
 	int						m_iAmmoType;		// The cached index of the ammodef that we use when we fire.
-#else
+// #else
 	int						m_iSmallAmmoType;
 	int						m_iMediumAmmoType;
 	int						m_iLargeAmmoType;
-#endif // HL2_EPISODIC
+// #endif // HL2_EPISODIC
 
 	int						m_spread;		// firing spread
 
diff --git a/src/game/server/hl2/grenade_spit.cpp b/src/game/server/hl2/grenade_spit.cpp
index efd77a9..8f357f8 100644
--- a/src/game/server/hl2/grenade_spit.cpp
+++ b/src/game/server/hl2/grenade_spit.cpp
@@ -238,7 +238,11 @@ void CGrenadeSpit::Think( void )
 		return;
 	
 	// Add a doppler effect to the balls as they travel
+#ifdef HL2SB
+	CBaseEntity *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBaseEntity *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer != NULL )
 	{
 		Vector dir;
diff --git a/src/game/server/hl2/hl2_player.cpp b/src/game/server/hl2/hl2_player.cpp
index 5680add..90137ba 100644
--- a/src/game/server/hl2/hl2_player.cpp
+++ b/src/game/server/hl2/hl2_player.cpp
@@ -51,6 +51,12 @@
 #include "npc_alyx_episodic.h"
 #endif
 
+#ifdef LUA_SDK
+#include "luamanager.h"
+#include "lbasecombatweapon_shared.h"
+#include "lbaseplayer_shared.h"
+#endif
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -2638,6 +2644,13 @@ bool CHL2_Player::Weapon_CanUse( CBaseCombatWeapon *pWeapon )
 //-----------------------------------------------------------------------------
 void CHL2_Player::Weapon_Equip( CBaseCombatWeapon *pWeapon )
 {
+#if LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "Weapon_Equip" );
+		lua_pushplayer( L, this );
+		lua_pushweapon( L, pWeapon );
+	END_LUA_CALL_HOOK( 2, 0 );
+#endif
+
 #if	HL2_SINGLE_PRIMARY_WEAPON_MODE
 
 	if ( pWeapon->GetSlot() == WEAPON_PRIMARY_SLOT )
diff --git a/src/game/server/hl2/item_dynamic_resupply.cpp b/src/game/server/hl2/item_dynamic_resupply.cpp
index f2ce6f0..c5e8ecb 100644
--- a/src/game/server/hl2/item_dynamic_resupply.cpp
+++ b/src/game/server/hl2/item_dynamic_resupply.cpp
@@ -291,7 +291,11 @@ void CItem_DynamicResupply::InputKill( inputdata_t &data )
 //-----------------------------------------------------------------------------
 void CItem_DynamicResupply::InputCalculateType( inputdata_t &data )
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 	SpawnDynamicItem( pPlayer );
 }
 
diff --git a/src/game/server/hl2/item_healthkit.cpp b/src/game/server/hl2/item_healthkit.cpp
index 7ff743b..cfef14c 100644
--- a/src/game/server/hl2/item_healthkit.cpp
+++ b/src/game/server/hl2/item_healthkit.cpp
@@ -78,7 +78,11 @@ bool CHealthKit::MyTouch( CBasePlayer *pPlayer )
 		CPASAttenuationFilter filter( pPlayer, "HealthKit.Touch" );
 		EmitSound( filter, pPlayer->entindex(), "HealthKit.Touch" );
 
+#ifndef HL2SB
 		if ( g_pGameRules->ItemShouldRespawn( this ) )
+#else
+		if ( g_pGameRules->ItemShouldRespawn( this ) == GR_ITEM_RESPAWN_YES )
+#endif
 		{
 			Respawn();
 		}
@@ -131,7 +135,11 @@ public:
 			CPASAttenuationFilter filter( pPlayer, "HealthVial.Touch" );
 			EmitSound( filter, pPlayer->entindex(), "HealthVial.Touch" );
 
+#ifndef HL2SB
 			if ( g_pGameRules->ItemShouldRespawn( this ) )
+#else
+			if ( g_pGameRules->ItemShouldRespawn( this ) == GR_ITEM_RESPAWN_YES )
+#endif
 			{
 				Respawn();
 			}
diff --git a/src/game/server/hl2/lhl2_player.cpp b/src/game/server/hl2/lhl2_player.cpp
new file mode 100644
index 0000000..edbbbb8
--- /dev/null
+++ b/src/game/server/hl2/lhl2_player.cpp
@@ -0,0 +1,51 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose:		Player for HL2.
+//
+//=============================================================================//
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "lhl2mp_player_shared.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+#include "luamanager.h"
+#include "lhl2mp_player_shared.h"
+#include "lbaseentity_shared.h"
+#ifdef CLIENT_DLL
+#include "lc_baseanimating.h"
+#else
+#include "lbaseanimating.h"
+#endif
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int CHL2MP_Player_GetPlayerModelType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkhl2mpplayer(L, 1)->GetPlayerModelType());
+  return 1;
+}
+
+
+static const luaL_Reg CHL2MP_Playermeta[] = {
+  {"GetPlayerModelType", CHL2MP_Player_GetPlayerModelType},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CHL2MP_Player object
+*/
+LUALIB_API int luaopen_CHL2MP_Player (lua_State *L) {
+  luaL_getmetatable(L, "CHL2MP_Player");
+  if (lua_isnoneornil(L, -1)) {
+    lua_pop(L, 1);
+    luaL_newmetatable(L, "CHL2MP_Player");
+  }
+  luaL_register(L, NULL, CHL2MP_Playermeta);
+  return 1;
+}
+
diff --git a/src/game/server/hl2/npc_alyx_episodic.cpp b/src/game/server/hl2/npc_alyx_episodic.cpp
index 61c604c..ed2f28a 100644
--- a/src/game/server/hl2/npc_alyx_episodic.cpp
+++ b/src/game/server/hl2/npc_alyx_episodic.cpp
@@ -36,6 +36,9 @@
 #include "ai_interactions.h"
 #include "weapon_flaregun.h"
 #include "env_debughistory.h"
+#ifdef HL2SB
+#include "hl2mp_gamerules.h"
+#endif
 
 extern Vector PointOnLineNearestPoint(const Vector& vStartPos, const Vector& vEndPos, const Vector& vPoint);
 
@@ -891,7 +894,11 @@ void CNPC_Alyx::AnalyzeGunfireSound( CSound *pSound )
 
 	CBaseEntity *pSoundTarget = pSound->m_hTarget.Get();
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 	Assert( pPlayer != NULL );
 
@@ -914,7 +921,11 @@ void CNPC_Alyx::AnalyzeGunfireSound( CSound *pSound )
 //-----------------------------------------------------------------------------
 bool CNPC_Alyx::IsValidEnemy( CBaseEntity *pEnemy )
 {
+#ifndef HL2SB
 	if ( HL2GameRules()->IsAlyxInDarknessMode() )
+#else
+	if ( HL2MPRules()->IsAlyxInDarknessMode() )
+#endif
 	{
 		if ( !CanSeeEntityInDarkness( pEnemy ) )
 			return false;
@@ -1029,7 +1040,11 @@ void CNPC_Alyx::EnemyIgnited( CAI_BaseNPC *pVictim )
 //-----------------------------------------------------------------------------
 void CNPC_Alyx::CombineBallSocketed( int iNumBounces )
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	
 	if ( !pPlayer || !FVisible(pPlayer) )
 	{
@@ -1175,7 +1190,11 @@ void CNPC_Alyx::DoCustomSpeechAI( void )
 {
 	BaseClass::DoCustomSpeechAI();
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 	if ( HasCondition(COND_NEW_ENEMY) && GetEnemy() )
 	{
@@ -1206,7 +1225,11 @@ void CNPC_Alyx::DoCustomSpeechAI( void )
 
 	// Darkness mode speech
 	ClearCondition( COND_ALYX_IN_DARK );
+#ifndef HL2SB
  	if ( HL2GameRules()->IsAlyxInDarknessMode() )
+#else
+ 	if ( HL2MPRules()->IsAlyxInDarknessMode() )
+#endif
 	{
 		// Even though the darkness light system will take flares into account when Alyx
 		// says she's lost the player in the darkness, players still think she's silly
@@ -1299,7 +1322,11 @@ void CNPC_Alyx::DoCustomSpeechAI( void )
 			{
 				m_SpeechWatch_LostPlayer.Set( 5,8 );
 				m_SpeechWatch_LostPlayer.Start();
+#ifdef HL2SB
+				m_MoveMonitor.SetMark( AI_GetNearestPlayer( GetAbsOrigin() ), 48 );
+#else
 				m_MoveMonitor.SetMark( AI_GetSinglePlayer(), 48 );
+#endif
 			}
 			else if ( m_SpeechWatch_LostPlayer.Expired() )
 			{
@@ -1308,7 +1335,11 @@ void CNPC_Alyx::DoCustomSpeechAI( void )
 					( !pPlayer || pPlayer->GetAbsOrigin().DistToSqr(GetAbsOrigin()) > ALYX_DARKNESS_LOST_PLAYER_DIST ) )
 				{
 					// only speak if player hasn't moved.
+#ifdef HL2SB
+					if ( m_MoveMonitor.TargetMoved( AI_GetNearestPlayer( GetAbsOrigin() ) ) )
+#else
 					if ( m_MoveMonitor.TargetMoved( AI_GetSinglePlayer() ) )
+#endif
 					{
 						SpeakIfAllowed( "TLK_DARKNESS_LOSTPLAYER" );
 						m_SpeechWatch_LostPlayer.Set(10);
@@ -1388,7 +1419,11 @@ void CNPC_Alyx::DoCustomSpeechAI( void )
 	{
 		// If we've left darkness mode, or if the player has blinded me with 
 		// the flashlight, don't bother speaking the found player line.
+#ifndef HL2SB
 		if ( !m_bIsFlashlightBlind && HL2GameRules()->IsAlyxInDarknessMode() && m_bDarknessSpeechAllowed )
+#else
+		if ( !m_bIsFlashlightBlind && HL2MPRules()->IsAlyxInDarknessMode() && m_bDarknessSpeechAllowed )
+#endif
 		{
 			if ( HasCondition(COND_SEE_PLAYER) && !HasCondition( COND_TALKER_PLAYER_DEAD ) )
 			{
@@ -1537,7 +1572,11 @@ bool CNPC_Alyx::FInViewCone( CBaseEntity *pEntity )
 	}
 
 	// Else, fall through...
+#ifndef HL2SB
  	if ( HL2GameRules()->IsAlyxInDarknessMode() )
+#else
+ 	if ( HL2MPRules()->IsAlyxInDarknessMode() )
+#endif
 	{
 		if ( CanSeeEntityInDarkness( pEntity ) )
 			return true;
@@ -1576,7 +1615,11 @@ bool CNPC_Alyx::CanSeeEntityInDarkness( CBaseEntity *pEntity )
 //-----------------------------------------------------------------------------
 bool CNPC_Alyx::QuerySeeEntity( CBaseEntity *pEntity, bool bOnlyHateOrFearIfNPC)
 {
+#ifdef HL2SB
+	if ( HL2MPRules()->IsAlyxInDarknessMode() )
+#else
 	if ( HL2GameRules()->IsAlyxInDarknessMode() )
+#endif
 	{
 		if ( !CanSeeEntityInDarkness( pEntity ) )
 			return false;
@@ -1700,7 +1743,11 @@ int CNPC_Alyx::SelectSchedule( void )
 {
     // If we're in darkness mode, and the player has the flashlight off, and we hear a zombie footstep,
 	// and the player isn't nearby, deliberately turn away from the zombie to let the zombie grab me.
+#ifdef HL2SB
+	if ( HL2MPRules()->IsAlyxInDarknessMode() && m_NPCState == NPC_STATE_ALERT )
+#else
 	if ( HL2GameRules()->IsAlyxInDarknessMode() && m_NPCState == NPC_STATE_ALERT )
+#endif
 	{
 		if ( HasCondition ( COND_HEAR_COMBAT ) && !HasCondition(COND_SEE_PLAYER) )
 		{
@@ -1857,7 +1904,11 @@ int CNPC_Alyx::TranslateSchedule( int scheduleType )
 
 	case SCHED_HIDE_AND_RELOAD:
 		{
+#ifndef HL2SB
 			if ( HL2GameRules()->IsAlyxInDarknessMode() )
+#else
+			if ( HL2MPRules()->IsAlyxInDarknessMode() )
+#endif
 				return SCHED_RELOAD;
 
 			// If I don't have a ranged attacker as an enemy, don't try to hide
@@ -2263,7 +2314,11 @@ int CNPC_Alyx::OnTakeDamage_Alive( const CTakeDamageInfo &info )
 
 	int taken = BaseClass::OnTakeDamage_Alive(info);
 
+#ifndef HL2SB
 	if ( taken && HL2GameRules()->IsAlyxInDarknessMode() && !HasCondition( COND_TALKER_PLAYER_DEAD ) )
+#else
+	if ( taken && HL2MPRules()->IsAlyxInDarknessMode() && !HasCondition( COND_TALKER_PLAYER_DEAD ) )
+#endif
 	{
 		if ( !HasCondition(COND_SEE_ENEMY) && (info.GetDamageType() & (DMG_SLASH | DMG_CLUB) ) )
 		{
@@ -2634,7 +2689,11 @@ bool CNPC_Alyx::CanBeBlindedByFlashlight( bool bCheckLightSources )
 {
 	// Can't be blinded if we're not in alyx darkness mode
  	/*
+#ifndef HL2SB
 	if ( !HL2GameRules()->IsAlyxInDarknessMode() )
+#else
+	if ( !HL2MPRules()->IsAlyxInDarknessMode() )
+#endif
 		return false;
 	*/
 
@@ -2687,7 +2746,11 @@ bool CNPC_Alyx::PlayerFlashlightOnMyEyes( CBasePlayer *pPlayer )
 	float flDist = VectorNormalize( vecToEyes ); 
 
 	// We can be blinded in daylight, but only at close range
+#ifndef HL2SB
 	if ( HL2GameRules()->IsAlyxInDarknessMode() == false )
+#else
+	if ( HL2MPRules()->IsAlyxInDarknessMode() == false )
+#endif
 	{
 		if ( flDist > (8*12.0f) )
 			return false;
@@ -3288,7 +3351,11 @@ void CNPC_Alyx::InputVehiclePunted( inputdata_t &inputdata )
 //-----------------------------------------------------------------------------
 void CNPC_Alyx::InputOutsideTransition( inputdata_t &inputdata )
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer && pPlayer->IsInAVehicle() )
 	{
 		if ( ShouldAlwaysTransition() == false )
diff --git a/src/game/server/hl2/npc_antlion.cpp b/src/game/server/hl2/npc_antlion.cpp
index 7866fb4..08cffbe 100644
--- a/src/game/server/hl2/npc_antlion.cpp
+++ b/src/game/server/hl2/npc_antlion.cpp
@@ -4022,7 +4022,11 @@ bool CNPC_Antlion::CorpseGib( const CTakeDamageInfo &info )
 void CNPC_Antlion::Touch( CBaseEntity *pOther )
 {
 	//See if the touching entity is a vehicle
+#ifdef HL2SB
+	CBasePlayer *pPlayer = ToBasePlayer( AI_GetNearestPlayer( GetAbsOrigin() ) );
+#else
 	CBasePlayer *pPlayer = ToBasePlayer( AI_GetSinglePlayer() );
+#endif
 	
 	// FIXME: Technically we'll want to check to see if a vehicle has touched us with the player OR NPC driver
 
diff --git a/src/game/server/hl2/npc_antlionguard.cpp b/src/game/server/hl2/npc_antlionguard.cpp
index 8465d1d..21252db 100644
--- a/src/game/server/hl2/npc_antlionguard.cpp
+++ b/src/game/server/hl2/npc_antlionguard.cpp
@@ -1604,7 +1604,11 @@ public:
 //-----------------------------------------------------------------------------
 void CNPC_AntlionGuard::Footstep( bool bHeavy )
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	Assert( pPlayer != NULL );
 	if ( pPlayer == NULL )
 		return;
diff --git a/src/game/server/hl2/npc_attackchopper.cpp b/src/game/server/hl2/npc_attackchopper.cpp
index f3a32f7..2ec642f 100644
--- a/src/game/server/hl2/npc_attackchopper.cpp
+++ b/src/game/server/hl2/npc_attackchopper.cpp
@@ -5564,7 +5564,11 @@ void CGrenadeHelicopter::OnPhysGunDrop( CBasePlayer *pPhysGunUser, PhysGunDrop_t
 bool CGrenadeHelicopter::IsThrownByPlayer()
 {
 	// if player is the owner and we're set to explode on contact, then the player threw this grenade.
+#ifdef HL2SB
+	return ( ( GetOwnerEntity() == UTIL_GetNearestPlayer( GetAbsOrigin() ) ) && m_bExplodeOnContact );
+#else
 	return ( ( GetOwnerEntity() == UTIL_GetLocalPlayer() ) && m_bExplodeOnContact );
+#endif
 }
 
 //-----------------------------------------------------------------------------
diff --git a/src/game/server/hl2/npc_basescanner.cpp b/src/game/server/hl2/npc_basescanner.cpp
index f935d07..8c12bec 100644
--- a/src/game/server/hl2/npc_basescanner.cpp
+++ b/src/game/server/hl2/npc_basescanner.cpp
@@ -1294,7 +1294,11 @@ void CNPC_BaseScanner::DiveBombSoundThink()
 	pPhysicsObject->GetPosition( &vecPosition, NULL );
 	pPhysicsObject->GetVelocity( &vecVelocity, NULL );
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer )
 	{
 		Vector vecDelta;
diff --git a/src/game/server/hl2/npc_basezombie.cpp b/src/game/server/hl2/npc_basezombie.cpp
index 998b1bb..07068ac 100644
--- a/src/game/server/hl2/npc_basezombie.cpp
+++ b/src/game/server/hl2/npc_basezombie.cpp
@@ -43,7 +43,11 @@
 #include "vstdlib/random.h"
 #include "engine/IEngineSound.h"
 #include "props.h"
+#ifndef HL2SB
 #include "hl2_gamerules.h"
+#else
+#include "hl2mp_gamerules.h"
+#endif
 #include "weapon_physcannon.h"
 #include "ammodef.h"
 #include "vehicle_base.h"
@@ -949,7 +953,11 @@ int CNPC_BaseZombie::OnTakeDamage_Alive( const CTakeDamageInfo &inputInfo )
 //-----------------------------------------------------------------------------
 void CNPC_BaseZombie::MakeAISpookySound( float volume, float duration )
 {
+#ifndef HL2SB
 	if ( HL2GameRules()->IsAlyxInDarknessMode() )
+#else
+	if ( HL2MPRules()->IsAlyxInDarknessMode() )
+#endif
 	{
 		CSoundEnt::InsertSound( SOUND_COMBAT, EyePosition(), volume, duration, this, SOUNDENT_CHANNEL_SPOOKY_NOISE );
 	}
@@ -1054,7 +1062,11 @@ bool CNPC_BaseZombie::ShouldIgniteZombieGib( void )
 #ifdef HL2_EPISODIC
 	// If we're in darkness mode, don't ignite giblets, because we don't want to
 	// pay the perf cost of multiple dynamic lights per giblet.
+#ifndef HL2SB
 	return ( IsOnFire() && !HL2GameRules()->IsAlyxInDarknessMode() );
+#else
+	return ( IsOnFire() && !HL2MPRules()->IsAlyxInDarknessMode() );
+#endif
 #else
 	return IsOnFire();
 #endif 
@@ -1206,7 +1218,11 @@ void CNPC_BaseZombie::Ignite( float flFlameLifetime, bool bNPCOnly, float flSize
 	BaseClass::Ignite( flFlameLifetime, bNPCOnly, flSize, bCalledByLevelDesigner );
 
 #ifdef HL2_EPISODIC
+#ifndef HL2SB
 	if ( HL2GameRules()->IsAlyxInDarknessMode() == true && GetEffectEntity() != NULL )
+#else
+	if ( HL2MPRules()->IsAlyxInDarknessMode() == true && GetEffectEntity() != NULL )
+#endif
 	{
 		GetEffectEntity()->AddEffects( EF_DIMLIGHT );
 	}
diff --git a/src/game/server/hl2/npc_citizen17.cpp b/src/game/server/hl2/npc_citizen17.cpp
index 48ddd29..dbfcea2 100644
--- a/src/game/server/hl2/npc_citizen17.cpp
+++ b/src/game/server/hl2/npc_citizen17.cpp
@@ -195,8 +195,10 @@ public:
 
 	void InputOutsideTransition( inputdata_t &inputdata )
 	{
+#ifndef HL2SB
 		if ( !AI_IsSinglePlayer() )
 			return;
+#endif
 
 		m_bNotInTransition = true;
 
@@ -212,7 +214,11 @@ public:
 					bool bHadGag = pAllyNpc->HasSpawnFlags(SF_NPC_GAG);
 
 					pAllyNpc->AddSpawnFlags(SF_NPC_GAG);
+#ifdef HL2SB
+					pAllyNpc->TargetOrder( UTIL_GetNearestPlayer( pAllyNpc->GetAbsOrigin() ), &pAllyNpc, 1 );
+#else
 					pAllyNpc->TargetOrder( UTIL_GetLocalPlayer(), &pAllyNpc, 1 );
+#endif
 					if ( !bHadGag )
 						pAllyNpc->RemoveSpawnFlags(SF_NPC_GAG);
 				}
@@ -548,9 +554,15 @@ void CNPC_Citizen::PostNPCInit()
 	}
 	else
 	{
+#ifdef HL2SB
+		if ( ( m_spawnflags & SF_CITIZEN_FOLLOW ) )
+		{
+			m_FollowBehavior.SetFollowTarget( UTIL_GetNearestPlayer( GetAbsOrigin() ) );
+#else
 		if ( ( m_spawnflags & SF_CITIZEN_FOLLOW ) && AI_IsSinglePlayer() )
 		{
 			m_FollowBehavior.SetFollowTarget( UTIL_GetLocalPlayer() );
+#endif
 			m_FollowBehavior.SetParameters( AIF_SIMPLE );
 		}
 	}
@@ -897,7 +909,11 @@ void CNPC_Citizen::GatherConditions()
 	if( IsInPlayerSquad() && hl2_episodic.GetBool() )
 	{
 		// Leave the player squad if someone has made me neutral to player.
+#ifdef HL2SB
+		if( IRelationType(UTIL_GetNearestPlayer(GetAbsOrigin())) == D_NU )
+#else
 		if( IRelationType(UTIL_GetLocalPlayer()) == D_NU )
+#endif
 		{
 			RemoveFromPlayerSquad();
 		}
@@ -930,7 +946,11 @@ void CNPC_Citizen::GatherConditions()
 	// assume the player is 'staring' and wants health.
 	if( CanHeal() )
 	{
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 		if ( !pPlayer )
 		{
@@ -993,7 +1013,11 @@ void CNPC_Citizen::PredictPlayerPush()
 
 	BaseClass::PredictPlayerPush();
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin());
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 	if ( !bHadPlayerPush && HasCondition( COND_PLAYER_PUSHING ) && 
 		 pPlayer->FInViewCone( this ) && CanHeal() )
 	{
@@ -1439,7 +1463,11 @@ bool CNPC_Citizen::ShouldDeferToFollowBehavior()
 //-----------------------------------------------------------------------------
 int CNPC_Citizen::TranslateSchedule( int scheduleType ) 
 {
+#ifdef HL2SB
+	CBasePlayer *pLocalPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pLocalPlayer = AI_GetSinglePlayer();
+#endif
 
 	switch( scheduleType )
 	{
@@ -1494,7 +1522,11 @@ int CNPC_Citizen::TranslateSchedule( int scheduleType )
 			}
 			else
 			{
-				CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#ifdef HL2SB
+				CBaseEntity *pPlayer = AI_GetNearestVisiblePlayer( this );
+#else
+				CBaseEntity *pPlayer = AI_GetSinglePlayer();
+#endif
 				if ( pPlayer && GetEnemy() && ( ( GetEnemy()->GetAbsOrigin() - 
 					pPlayer->GetAbsOrigin() ).LengthSqr() < RPG_SAFE_DISTANCE * RPG_SAFE_DISTANCE ) )
 				{
@@ -1767,7 +1799,11 @@ void CNPC_Citizen::RunTask( const Task_t *pTask )
 					}
 
 					Vector vecEnemyPos = GetEnemy()->BodyTarget(GetAbsOrigin(), false);
+#ifdef HL2SB
+					CBasePlayer *pPlayer = AI_GetNearestVisiblePlayer( this );
+#else
 					CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 					if ( pPlayer && ( ( vecEnemyPos - pPlayer->GetAbsOrigin() ).LengthSqr() < RPG_SAFE_DISTANCE * RPG_SAFE_DISTANCE ) )
 					{
 						m_bRPGAvoidPlayer = true;
@@ -2334,7 +2370,11 @@ bool CNPC_Citizen::CanJoinPlayerSquad()
 	if ( !CanBeUsedAsAFriend() )
 		return false;
 
+#ifdef HL2SB
+	if ( IRelationType( UTIL_GetNearestPlayer( GetAbsOrigin() ) ) != D_LI )
+#else
 	if ( IRelationType( UTIL_GetLocalPlayer() ) != D_LI )
+#endif
 		return false;
 
 	return true;
@@ -2363,7 +2403,11 @@ bool CNPC_Citizen::IsCommandMoving()
 {
 	if ( AI_IsSinglePlayer() && IsInPlayerSquad() )
 	{
+#ifdef HL2SB
+		if ( m_FollowBehavior.GetFollowTarget() == UTIL_GetNearestPlayer( GetAbsOrigin() ) ||
+#else
 		if ( m_FollowBehavior.GetFollowTarget() == UTIL_GetLocalPlayer() ||
+#endif
 			 IsFollowingCommandPoint() )
 		{
 			return ( m_FollowBehavior.IsMovingToFollowTarget() );
@@ -2376,10 +2420,17 @@ bool CNPC_Citizen::IsCommandMoving()
 //-----------------------------------------------------------------------------
 bool CNPC_Citizen::ShouldAutoSummon()
 {
+#ifdef HL2SB
+	if ( !IsFollowingCommandPoint() || !IsInPlayerSquad() )
+		return false;
+
+	CHL2MP_Player *pPlayer = (CHL2MP_Player *)UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	if ( !AI_IsSinglePlayer() || !IsFollowingCommandPoint() || !IsInPlayerSquad() )
 		return false;
 
 	CHL2_Player *pPlayer = (CHL2_Player *)UTIL_GetLocalPlayer();
+#endif
 	
 	float distMovedSq = ( pPlayer->GetAbsOrigin() - m_vAutoSummonAnchor ).LengthSqr();
 	float moveTolerance = player_squad_autosummon_move_tolerance.GetFloat() * 12;
@@ -2507,7 +2558,11 @@ bool CNPC_Citizen::SpeakCommandResponse( AIConcept_t concept, const char *modifi
 						   CFmtStr( "numselected:%d,"
 									"useradio:%d%s",
 									( GetSquad() ) ? GetSquad()->NumMembers() : 1,
+#ifdef HL2SB
+									ShouldSpeakRadio( AI_GetNearestPlayer( GetAbsOrigin() ) ),
+#else
 									ShouldSpeakRadio( AI_GetSinglePlayer() ),
+#endif
 									( modifiers ) ? CFmtStr(",%s", modifiers).operator const char *() : "" ) );
 }
 
@@ -2550,8 +2605,10 @@ bool CNPC_Citizen::TargetOrder( CBaseEntity *pTarget, CAI_BaseNPC **Allies, int
 //-----------------------------------------------------------------------------
 void CNPC_Citizen::MoveOrder( const Vector &vecDest, CAI_BaseNPC **Allies, int numAllies )
 {
+#ifndef HL2SB
 	if ( !AI_IsSinglePlayer() )
 		return;
+#endif
 
 	if( hl2_episodic.GetBool() && m_iszDenyCommandConcept != NULL_STRING )
 	{
@@ -2559,7 +2616,11 @@ void CNPC_Citizen::MoveOrder( const Vector &vecDest, CAI_BaseNPC **Allies, int n
 		return;
 	}
 
+#ifdef HL2SB
+	CHL2MP_Player *pPlayer = (CHL2MP_Player *)UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CHL2_Player *pPlayer = (CHL2_Player *)UTIL_GetLocalPlayer();
+#endif
 
 	m_AutoSummonTimer.Set( player_squad_autosummon_time.GetFloat() );
 	m_vAutoSummonAnchor = pPlayer->GetAbsOrigin();
@@ -2649,7 +2710,11 @@ void CNPC_Citizen::CommanderUse( CBaseEntity *pActivator, CBaseEntity *pCaller,
 		return;
 	}
 	
+#ifdef HL2SB
+	if ( pActivator == UTIL_GetNearestPlayer( GetAbsOrigin() ) )
+#else
 	if ( pActivator == UTIL_GetLocalPlayer() )
+#endif
 	{
 		// Don't say hi after you've been addressed by the player
 		SetSpokeConcept( TLK_HELLO, NULL );	
@@ -2752,8 +2817,10 @@ void CNPC_Citizen::RemoveFromPlayerSquad()
 //-----------------------------------------------------------------------------
 void CNPC_Citizen::TogglePlayerSquadState()
 {
+#ifndef HL2SB
 	if ( !AI_IsSinglePlayer() )
 		return;
+#endif
 
 	if ( !IsInPlayerSquad() )
 	{
@@ -2763,7 +2830,11 @@ void CNPC_Citizen::TogglePlayerSquadState()
 		{
 			SpeakCommandResponse( TLK_COMMANDED );
 		}
+#ifdef HL2SB
+		else if ( m_FollowBehavior.GetFollowTarget() == UTIL_GetNearestPlayer( GetAbsOrigin() ) )
+#else
 		else if ( m_FollowBehavior.GetFollowTarget() == UTIL_GetLocalPlayer() )
+#endif
 		{
 			SpeakCommandResponse( TLK_STARTFOLLOW );
 		}
@@ -2788,10 +2859,17 @@ struct SquadCandidate_t
 
 void CNPC_Citizen::UpdatePlayerSquad()
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+	if ( !pPlayer )
+		return;
+
+#else
 	if ( !AI_IsSinglePlayer() )
 		return;
 
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 	if ( ( pPlayer->GetAbsOrigin().AsVector2D() - GetAbsOrigin().AsVector2D() ).LengthSqr() < Square(20*12) )
 		m_flTimeLastCloseToPlayer = gpGlobals->curtime;
 
@@ -3131,7 +3209,11 @@ void CNPC_Citizen::FixupPlayerSquad()
 	}
 	else
 	{
+#ifdef HL2SB
+		m_FollowBehavior.SetFollowTarget( UTIL_GetNearestPlayer( GetAbsOrigin() ) );
+#else
 		m_FollowBehavior.SetFollowTarget( UTIL_GetLocalPlayer() );
+#endif
 		m_FollowBehavior.SetParameters( AIF_SIMPLE );
 	}
 }
@@ -3180,10 +3262,17 @@ void CNPC_Citizen::UpdateFollowCommandPoint()
 		{
 			if ( IsFollowingCommandPoint() )
 				ClearFollowTarget();
+#ifdef HL2SB
+			if ( m_FollowBehavior.GetFollowTarget() != UTIL_GetNearestPlayer( GetAbsOrigin() ) )
+			{
+				DevMsg( "Expected to be following nearest player, but not\n" );
+				m_FollowBehavior.SetFollowTarget( UTIL_GetNearestPlayer( GetAbsOrigin() ) );
+#else
 			if ( m_FollowBehavior.GetFollowTarget() != UTIL_GetLocalPlayer() )
 			{
 				DevMsg( "Expected to be following player, but not\n" );
 				m_FollowBehavior.SetFollowTarget( UTIL_GetLocalPlayer() );
+#endif
 				m_FollowBehavior.SetParameters( AIF_SIMPLE );
 			}
 		}
@@ -3228,8 +3317,10 @@ int __cdecl SquadSortFunc( const SquadMemberInfo_t *pLeft, const SquadMemberInfo
 
 CAI_BaseNPC *CNPC_Citizen::GetSquadCommandRepresentative()
 {
+#ifndef HL2SB
 	if ( !AI_IsSinglePlayer() )
 		return NULL;
+#endif
 
 	if ( IsInPlayerSquad() )
 	{
@@ -3242,7 +3333,11 @@ CAI_BaseNPC *CNPC_Citizen::GetSquadCommandRepresentative()
 			hCurrent = NULL;
 
 			CUtlVectorFixed<SquadMemberInfo_t, MAX_SQUAD_MEMBERS> candidates;
+#ifdef HL2SB
+			CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 			CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 
 			if ( pPlayer )
 			{
@@ -3728,7 +3823,11 @@ void	CNPC_Citizen::TossHealthKit(CBaseCombatCharacter *pThrowAt, const Vector &o
 //-----------------------------------------------------------------------------
 void	CNPC_Citizen::InputForceHealthKitToss( inputdata_t &inputdata )
 {
+#ifdef HL2SB
+	TossHealthKit( UTIL_GetNearestPlayer( GetAbsOrigin() ), Vector(48.0f, 0.0f, 0.0f)  );
+#else
 	TossHealthKit( UTIL_GetLocalPlayer(), Vector(48.0f, 0.0f, 0.0f)  );
+#endif
 }
 
 #endif
@@ -3751,7 +3850,11 @@ bool CNPC_Citizen::ShouldLookForHealthItem()
 		return false;
 
 	// Player is hurt, don't steal his health.
+#ifdef HL2SB
+	if( AI_IsSinglePlayer() && UTIL_GetNearestPlayer( GetAbsOrigin() )->GetHealth() <= UTIL_GetNearestPlayer( GetAbsOrigin() )->GetHealth() * 0.75f )
+#else
 	if( AI_IsSinglePlayer() && UTIL_GetLocalPlayer()->GetHealth() <= UTIL_GetLocalPlayer()->GetHealth() * 0.75f )
+#endif
 		return false;
 
 	// Wait till you're standing still.
@@ -4152,7 +4255,11 @@ void CCitizenResponseSystem::ResponseThink()
 					float flNearestDist = (CITIZEN_RESPONSE_DISTANCE * CITIZEN_RESPONSE_DISTANCE);
 					CBaseEntity *pNearestCitizen = NULL;
 					CBaseEntity *pCitizen = NULL;
+#ifdef HL2SB
+					CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 					CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 					while ( (pCitizen = gEntList.FindEntityByClassname( pCitizen, "npc_citizen" ) ) != NULL)
 					{
 						float flDistToPlayer = (pPlayer->WorldSpaceCenter() - pCitizen->WorldSpaceCenter()).LengthSqr();
diff --git a/src/game/server/hl2/npc_combine.cpp b/src/game/server/hl2/npc_combine.cpp
index f9ee79b..f64885d 100644
--- a/src/game/server/hl2/npc_combine.cpp
+++ b/src/game/server/hl2/npc_combine.cpp
@@ -756,7 +756,11 @@ void CNPC_Combine::StartTask( const Task_t *pTask )
 	case TASK_COMBINE_SIGNAL_BEST_SOUND:
 		if( IsInSquad() && GetSquad()->NumMembers() > 1 )
 		{
+#ifdef HL2SB
+			CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 			CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 			if( pPlayer && OccupyStrategySlot( SQUAD_SLOT_EXCLUSIVE_HANDSIGN ) && pPlayer->FInViewCone( this ) )
 			{
diff --git a/src/game/server/hl2/npc_combines.cpp b/src/game/server/hl2/npc_combines.cpp
index 66b3ea8..5de01e6 100644
--- a/src/game/server/hl2/npc_combines.cpp
+++ b/src/game/server/hl2/npc_combines.cpp
@@ -21,7 +21,11 @@
 #include "Sprite.h"
 #include "soundenvelope.h"
 #include "weapon_physcannon.h"
+#ifndef HL2SB
 #include "hl2_gamerules.h"
+#else
+#include "hl2mp_gamerules.h"
+#endif
 #include "gameweaponmanager.h"
 #include "vehicle_base.h"
 
@@ -339,22 +343,42 @@ void CNPC_CombineS::Event_Killed( const CTakeDamageInfo &info )
 			}
 		}
 
+#ifndef HL2SB
 		CHalfLife2 *pHL2GameRules = static_cast<CHalfLife2 *>(g_pGameRules);
+#else
+		CHL2MPRules *pHL2MPRules = static_cast<CHL2MPRules *>(g_pGameRules);
+#endif
 
 		// Attempt to drop health
+#ifndef HL2SB
 		if ( pHL2GameRules->NPC_ShouldDropHealth( pPlayer ) )
+#else
+		if ( pHL2MPRules->NPC_ShouldDropHealth( pPlayer ) )
+#endif
 		{
 			DropItem( "item_healthvial", WorldSpaceCenter()+RandomVector(-4,4), RandomAngle(0,360) );
+#ifndef HL2SB
 			pHL2GameRules->NPC_DroppedHealth();
+#else
+			pHL2MPRules->NPC_DroppedHealth();
+#endif
 		}
 		
 		if ( HasSpawnFlags( SF_COMBINE_NO_GRENADEDROP ) == false )
 		{
 			// Attempt to drop a grenade
+#ifndef HL2SB
 			if ( pHL2GameRules->NPC_ShouldDropGrenade( pPlayer ) )
+#else
+			if ( pHL2MPRules->NPC_ShouldDropGrenade( pPlayer ) )
+#endif
 			{
 				DropItem( "weapon_frag", WorldSpaceCenter()+RandomVector(-4,4), RandomAngle(0,360) );
+#ifndef HL2SB
 				pHL2GameRules->NPC_DroppedGrenade();
+#else
+				pHL2MPRules->NPC_DroppedGrenade();
+#endif
 			}
 		}
 	}
diff --git a/src/game/server/hl2/npc_dog.cpp b/src/game/server/hl2/npc_dog.cpp
index c7db992..3dd4591 100644
--- a/src/game/server/hl2/npc_dog.cpp
+++ b/src/game/server/hl2/npc_dog.cpp
@@ -340,7 +340,11 @@ void CNPC_Dog::SetPlayerAvoidState( void )
 		physfollower_t *pBone;
 		int i;
 
+#ifdef HL2SB
+		CBasePlayer *pLocalPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pLocalPlayer = AI_GetSinglePlayer();
+#endif
 
 		if ( pLocalPlayer )
 		{
@@ -832,7 +836,11 @@ void CNPC_Dog::ThrowObject( const char *pAttachmentName )
 			}
 				
 			if ( m_hThrowTarget == NULL )
+#ifdef HL2SB
+				 m_hThrowTarget = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 				 m_hThrowTarget = AI_GetSinglePlayer();
+#endif
 
 			Vector vThrowDirection;
 
@@ -1385,7 +1393,11 @@ void CNPC_Dog::RunTask( const Task_t *pTask )
 
 				SetAim( m_hPhysicsEnt->WorldSpaceCenter() - GetAbsOrigin() );
 
+#ifdef HL2SB
+				CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 				CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 				float flDistanceToPlayer = flDistance;
 
@@ -1519,7 +1531,11 @@ void CNPC_Dog::SetupThrowTarget( void )
 {
 	if ( m_hThrowTarget == NULL )
 	{
+#ifdef HL2SB
+		m_hThrowTarget = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		m_hThrowTarget = AI_GetSinglePlayer();
+#endif
 	}
 
 	SetTarget( m_hThrowTarget );
@@ -1674,7 +1690,11 @@ void CNPC_Dog::StartTask( const Task_t *pTask )
 		m_flNextSwat = gpGlobals->curtime + pTask->flTaskData;
 
 		if ( m_hThrowTarget == NULL )
+#ifdef HL2SB
+			m_hThrowTarget = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 			m_hThrowTarget = AI_GetSinglePlayer();
+#endif
 
 		TaskComplete();
 		break;
diff --git a/src/game/server/hl2/npc_enemyfinder.cpp b/src/game/server/hl2/npc_enemyfinder.cpp
index 7281307..7bdf94b 100644
--- a/src/game/server/hl2/npc_enemyfinder.cpp
+++ b/src/game/server/hl2/npc_enemyfinder.cpp
@@ -416,7 +416,11 @@ bool CNPC_EnemyFinder::ShouldAlwaysThink()
 	if ( BaseClass::ShouldAlwaysThink() )
 		return true;
 		
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer && IRelationType( pPlayer ) == D_HT )
 	{
 		float playerDistSqr = GetAbsOrigin().DistToSqr( pPlayer->GetAbsOrigin() );
@@ -673,7 +677,11 @@ bool CNPC_EnemyFinderCombineCannon::IsValidEnemy( CBaseEntity *pTarget )
 	}
 
 	/*
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	int iPlayerRelationPriority = -1;
 
 	if( pPlayer != NULL )
diff --git a/src/game/server/hl2/npc_headcrab.cpp b/src/game/server/hl2/npc_headcrab.cpp
index 5087068..8b13ce0 100644
--- a/src/game/server/hl2/npc_headcrab.cpp
+++ b/src/game/server/hl2/npc_headcrab.cpp
@@ -30,7 +30,11 @@
 #include "world.h"
 #include "npc_bullseye.h"
 #include "physics_npc_solver.h"
+#ifndef HL2SB
 #include "hl2_gamerules.h"
+#else
+#include "hl2mp_gamerules.h"
+#endif
 #include "decals.h"
 
 // memdbgon must be the last include file in a .cpp file!!!
@@ -1304,7 +1308,11 @@ void CBaseHeadcrab::JumpFromCanister()
 
 void CBaseHeadcrab::DropFromCeiling( void )
 {
+#ifndef HL2SB
 	if ( HL2GameRules()->IsAlyxInDarknessMode() )
+#else
+	if ( HL2MPRules()->IsAlyxInDarknessMode() )
+#endif
 	{
 		if ( IsHangingFromCeiling() )
 		{
@@ -1320,7 +1328,11 @@ void CBaseHeadcrab::DropFromCeiling( void )
 				{
 					SetSchedule( SCHED_HEADCRAB_CEILING_DROP );
 
-					CBaseEntity *pPlayer = AI_GetSinglePlayer();
+#ifdef HL2SB
+					CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
+					CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 					if ( pPlayer )
 					{
@@ -1879,7 +1891,11 @@ int CBaseHeadcrab::SelectSchedule( void )
 
 	if ( IsHangingFromCeiling() )
 	{
+#ifndef HL2SB
 		if ( HL2GameRules()->IsAlyxInDarknessMode() == false && ( HasCondition( COND_CAN_RANGE_ATTACK1 ) || HasCondition( COND_NEW_ENEMY ) ) )
+#else
+		if ( HL2MPRules()->IsAlyxInDarknessMode() == false && ( HasCondition( COND_CAN_RANGE_ATTACK1 ) || HasCondition( COND_NEW_ENEMY ) ) )
+#endif
 			return SCHED_HEADCRAB_CEILING_DROP;
 
 		if ( HasCondition( COND_LIGHT_DAMAGE ) || HasCondition( COND_HEAVY_DAMAGE ) )
@@ -2058,7 +2074,11 @@ void CBaseHeadcrab::Ignite( float flFlameLifetime, bool bNPCOnly, float flSize,
 	if( !bWasOnFire )
 	{
 #ifdef HL2_EPISODIC
+#ifndef HL2SB
 		if ( HL2GameRules()->IsAlyxInDarknessMode() == true )
+#else
+		if ( HL2MPRules()->IsAlyxInDarknessMode() == true )
+#endif
 		{
 			GetEffectEntity()->AddEffects( EF_DIMLIGHT );
 		}
diff --git a/src/game/server/hl2/npc_metropolice.cpp b/src/game/server/hl2/npc_metropolice.cpp
index a743da2..34a65d8 100644
--- a/src/game/server/hl2/npc_metropolice.cpp
+++ b/src/game/server/hl2/npc_metropolice.cpp
@@ -18,7 +18,11 @@
 #include "hl2_player.h"
 #include "iservervehicle.h"
 #include "items.h"
+#ifndef HL2SB
 #include "hl2_gamerules.h"
+#else
+#include "hl2mp_gamerules.h"
+#endif
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
@@ -2883,7 +2887,7 @@ void CNPC_MetroPolice::OnAnimEventShove( void )
 //-----------------------------------------------------------------------------
 void CNPC_MetroPolice::OnAnimEventBatonOn( void )
 {
-#ifndef HL2MP
+#if !defined( HL2MP ) || defined( HL2SB )
 
 	CWeaponStunStick *pStick = dynamic_cast<CWeaponStunStick *>(GetActiveWeapon());
 
@@ -2900,7 +2904,7 @@ void CNPC_MetroPolice::OnAnimEventBatonOn( void )
 //-----------------------------------------------------------------------------
 void CNPC_MetroPolice::OnAnimEventBatonOff( void )
 {
-#ifndef HL2MP
+#if !defined( HL2MP ) || defined( HL2SB )
 
 	CWeaponStunStick *pStick = dynamic_cast<CWeaponStunStick *>(GetActiveWeapon());
 	
@@ -3101,13 +3105,25 @@ void CNPC_MetroPolice::Event_Killed( const CTakeDamageInfo &info )
 
 	if ( pPlayer != NULL )
 	{
+#ifndef HL2SB
 		CHalfLife2 *pHL2GameRules = static_cast<CHalfLife2 *>(g_pGameRules);
+#else
+		CHL2MPRules *pHL2MPRules = static_cast<CHL2MPRules *>(g_pGameRules);
+#endif
 
 		// Attempt to drop health
+#ifndef HL2SB
 		if ( pHL2GameRules->NPC_ShouldDropHealth( pPlayer ) )
+#else
+		if ( pHL2MPRules->NPC_ShouldDropHealth( pPlayer ) )
+#endif
 		{
 			DropItem( "item_healthvial", WorldSpaceCenter()+RandomVector(-4,4), RandomAngle(0,360) );
+#ifndef HL2SB
 			pHL2GameRules->NPC_DroppedHealth();
+#else
+			pHL2MPRules->NPC_DroppedHealth();
+#endif
 		}
 	}
 
@@ -4006,7 +4022,11 @@ void CNPC_MetroPolice::AdministerJustice( void )
 //-----------------------------------------------------------------------------
 int CNPC_MetroPolice::SelectSchedule( void )
 {
+#ifdef HL2SB
+	if ( !GetEnemy() && HasCondition( COND_IN_PVS ) && AI_GetNearestPlayer( GetAbsOrigin() ) && !AI_GetNearestPlayer( GetAbsOrigin() )->IsAlive() )
+#else
 	if ( !GetEnemy() && HasCondition( COND_IN_PVS ) && AI_GetSinglePlayer() && !AI_GetSinglePlayer()->IsAlive() )
+#endif
 	{
 		return SCHED_PATROL_WALK;
 	}
@@ -5051,7 +5071,7 @@ bool CNPC_MetroPolice::HasBaton( void )
 //-----------------------------------------------------------------------------
 bool CNPC_MetroPolice::BatonActive( void )
 {
-#ifndef HL2MP
+#if !defined( HL2MP ) || defined( HL2SB )
 
 	CWeaponStunStick *pStick = dynamic_cast<CWeaponStunStick *>(GetActiveWeapon());
 
@@ -5111,7 +5131,11 @@ void CNPC_MetroPolice::VPhysicsCollision( int index, gamevcollisionevent_t *pEve
 
 	if ( pEvent->pObjects[otherIndex]->GetGameFlags() & FVPHYSICS_PLAYER_HELD )
 	{
+#ifdef HL2SB
+		CHL2MP_Player *pPlayer = dynamic_cast<CHL2MP_Player *>(AI_GetNearestPlayer( GetAbsOrigin() ));
+#else
 		CHL2_Player *pPlayer = dynamic_cast<CHL2_Player *>(UTIL_PlayerByIndex( 1 ));
+#endif
 
 		// See if it's being held by the player
 		if ( pPlayer != NULL && pPlayer->IsHoldingEntity( pHitEntity ) )
diff --git a/src/game/server/hl2/npc_playercompanion.cpp b/src/game/server/hl2/npc_playercompanion.cpp
index b2ddfe4..8224126 100644
--- a/src/game/server/hl2/npc_playercompanion.cpp
+++ b/src/game/server/hl2/npc_playercompanion.cpp
@@ -234,7 +234,7 @@ void CNPC_PlayerCompanion::Spawn()
 
 	m_AnnounceAttackTimer.Set( 10, 30 );
 
-#ifdef HL2_EPISODIC
+#if !defined( HL2SB ) && defined( HL2_EPISODIC )
 	// We strip this flag because it's been made obsolete by the StartScripting behavior
 	if ( HasSpawnFlags( SF_NPC_ALTCOLLISION ) )
 	{
@@ -243,7 +243,7 @@ void CNPC_PlayerCompanion::Spawn()
 	}
 
 	m_hFlare = NULL;
-#endif // HL2_EPISODIC
+#endif // !HL2SB && HL2_EPISODIC
 
 	BaseClass::Spawn();
 }
@@ -260,14 +260,14 @@ int CNPC_PlayerCompanion::Restore( IRestore &restore )
 		m_StandoffBehavior.SetActive( false );
 	}
 
-#ifdef HL2_EPISODIC
+#if !defined( HL2SB ) && defined( HL2_EPISODIC )
 	// We strip this flag because it's been made obsolete by the StartScripting behavior
 	if ( HasSpawnFlags( SF_NPC_ALTCOLLISION ) )
 	{
 		Warning( "NPC %s using alternate collision! -- DISABLED\n", STRING( GetEntityName() ) );
 		RemoveSpawnFlags( SF_NPC_ALTCOLLISION );
 	}
-#endif // HL2_EPISODIC
+#endif // !HL2SB && HL2_EPISODIC
 
 	return baseResult;
 }
@@ -348,9 +348,15 @@ void CNPC_PlayerCompanion::GatherConditions()
 {
 	BaseClass::GatherConditions();
 
+#ifndef HL2SB
 	if ( AI_IsSinglePlayer() )
 	{
+#endif
+#ifdef HL2SB
+		CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 
 		if ( Classify() == CLASS_PLAYER_ALLY_VITAL )
 		{
@@ -438,7 +444,9 @@ void CNPC_PlayerCompanion::GatherConditions()
 				m_flBoostSpeed *= mult;
 			}
 		}
+#ifndef HL2SB
 	}
+#endif
 
 	// Update our readiness if we're 
 	if ( IsReadinessCapable() )
@@ -496,9 +504,15 @@ void CNPC_PlayerCompanion::GatherConditions()
 		DoCustomSpeechAI();
 	}
 
+#ifdef HL2SB
+	if ( hl2_episodic.GetBool() && !GetEnemy() && HasCondition( COND_HEAR_PLAYER ) )
+	{
+		Vector los = ( UTIL_GetNearestPlayer( GetAbsOrigin() )->EyePosition() - EyePosition() );
+#else
 	if ( AI_IsSinglePlayer() && hl2_episodic.GetBool() && !GetEnemy() && HasCondition( COND_HEAR_PLAYER ) )
 	{
 		Vector los = ( UTIL_GetLocalPlayer()->EyePosition() - EyePosition() );
+#endif
 		los.z = 0;
 		VectorNormalize( los );
 
@@ -514,7 +528,11 @@ void CNPC_PlayerCompanion::GatherConditions()
 //-----------------------------------------------------------------------------
 void CNPC_PlayerCompanion::DoCustomSpeechAI( void )
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	
 	// Don't allow this when we're getting in the car
 #ifdef HL2_EPISODIC
@@ -547,7 +565,11 @@ void CNPC_PlayerCompanion::DoCustomSpeechAI( void )
 //-----------------------------------------------------------------------------
 void CNPC_PlayerCompanion::PredictPlayerPush()
 {
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer && pPlayer->GetSmoothedVelocity().LengthSqr() >= Square(140))
 	{
 		Vector predictedPosition = pPlayer->WorldSpaceCenter() + pPlayer->GetSmoothedVelocity() * .4;
@@ -970,9 +992,13 @@ int CNPC_PlayerCompanion::TranslateSchedule( int scheduleType )
 
 			if( CanReload() && pWeapon->UsesClipsForAmmo1() && pWeapon->Clip1() < ( pWeapon->GetMaxClip1() * .5 ) && OccupyStrategySlot( SQUAD_SLOT_EXCLUSIVE_RELOAD ) )
 			{
+#ifdef HL2SB
+					CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 				if ( AI_IsSinglePlayer() )
 				{
 					CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 					pWeapon = pPlayer->GetActiveWeapon();
 					if( pWeapon && pWeapon->UsesClipsForAmmo1() && 
 						pWeapon->Clip1() < ( pWeapon->GetMaxClip1() * .75 ) &&
@@ -980,7 +1006,9 @@ int CNPC_PlayerCompanion::TranslateSchedule( int scheduleType )
 					{
 						SpeakIfAllowed( TLK_PLRELOAD );
 					}
+#ifndef HL2SB
 				}
+#endif
 				return SCHED_RELOAD;
 			}
 		}
@@ -1153,10 +1181,14 @@ void CNPC_PlayerCompanion::RunTask( const Task_t *pTask )
 
 		case TASK_PC_GET_PATH_OFF_COMPANION:
 			{
+#ifdef HL2SB
+				GetNavigator()->SetAllowBigStep( UTIL_GetNearestPlayer( GetAbsOrigin() ) );
+#else
 				if ( AI_IsSinglePlayer() )
 				{
 					GetNavigator()->SetAllowBigStep( UTIL_GetLocalPlayer() );
 				}
+#endif
 				ChainRunTask( TASK_MOVE_AWAY_PATH, 48 );
 			}
 			break;
@@ -1513,7 +1545,11 @@ void CNPC_PlayerCompanion::Touch( CBaseEntity *pOther )
 		if ( m_afMemory & bits_MEMORY_PROVOKED )
 			return;
 			
+#ifdef HL2SB
+		TestPlayerPushing( ( pOther->IsPlayer() ) ? pOther : AI_GetNearestPlayer( GetAbsOrigin() ) );
+#else
 		TestPlayerPushing( ( pOther->IsPlayer() ) ? pOther : AI_GetSinglePlayer() );
+#endif
 	}
 }
 
@@ -1897,7 +1933,11 @@ bool CNPC_PlayerCompanion::PickTacticalLookTarget( AILookTargetArgs_t *pArgs )
 		// 1/3rd chance to authoritatively look at player
 		if( random->RandomInt( 0, 2 ) == 0 )
 		{
+#ifdef HL2SB
+			pArgs->hTarget = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 			pArgs->hTarget = AI_GetSinglePlayer();
+#endif
 			return true;
 		}
 	}
@@ -2784,7 +2824,11 @@ void CNPC_PlayerCompanion::OnFriendDamaged( CBaseCombatCharacter *pSquadmate, CB
 			}
 		}
 
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		if ( pPlayer && IsInPlayerSquad() && ( pPlayer->GetAbsOrigin().AsVector2D() - GetAbsOrigin().AsVector2D() ).LengthSqr() < Square( 25*12 ) && IsAllowedToSpeak( TLK_WATCHOUT ) )
 		{
 			if ( !pPlayer->FInViewCone( pAttacker ) )
@@ -3084,8 +3128,10 @@ bool CNPC_PlayerCompanion::ShouldAlwaysTransition( void )
 //-----------------------------------------------------------------------------
 void CNPC_PlayerCompanion::InputOutsideTransition( inputdata_t &inputdata )
 {
+#ifndef HL2SB
 	if ( !AI_IsSinglePlayer() )
 		return;
+#endif
 
 	// Must want to do this
 	if ( ShouldAlwaysTransition() == false )
@@ -3095,7 +3141,11 @@ void CNPC_PlayerCompanion::InputOutsideTransition( inputdata_t &inputdata )
 	if ( IsInAVehicle() )
 		return;
 
+#ifdef HL2SB
+	CBaseEntity *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBaseEntity *pPlayer = UTIL_GetLocalPlayer();
+#endif
 	const Vector &playerPos = pPlayer->GetAbsOrigin();
 
 	// Mark us as already having succeeded if we're vital or always meant to come with the player
@@ -3684,7 +3734,11 @@ bool CNPC_PlayerCompanion::IsNavigationUrgent( void )
 		// could not see the player but the player could in fact see them.  Now the NPC's facing is
 		// irrelevant and the player's viewcone is more authorative. -- jdw
 
+#ifdef HL2SB
+		CBasePlayer *pLocalPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pLocalPlayer = AI_GetSinglePlayer();
+#endif
 		if ( pLocalPlayer->FInViewCone( EyePosition() ) )
 			return false;
 
diff --git a/src/game/server/hl2/npc_scanner.cpp b/src/game/server/hl2/npc_scanner.cpp
index 925fd4e..90a9c4c 100644
--- a/src/game/server/hl2/npc_scanner.cpp
+++ b/src/game/server/hl2/npc_scanner.cpp
@@ -682,7 +682,11 @@ CBaseEntity* CNPC_CScanner::BestInspectTarget(void)
 
 	if ( m_bOnlyInspectPlayers )
 	{
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		if ( !pPlayer )
 			return NULL;
 
diff --git a/src/game/server/hl2/npc_strider.cpp b/src/game/server/hl2/npc_strider.cpp
index 528f5ee..3f41ab5 100644
--- a/src/game/server/hl2/npc_strider.cpp
+++ b/src/game/server/hl2/npc_strider.cpp
@@ -3129,7 +3129,11 @@ int CNPC_Strider::OnTakeDamage_Alive( const CTakeDamageInfo &info )
 			{
 				// See if the person that injured me is an NPC.
 				CAI_BaseNPC *pAttacker = dynamic_cast<CAI_BaseNPC *>( info.GetAttacker() );
+#ifdef HL2SB
+				CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 				CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 				if( pAttacker && pAttacker->IsAlive() && pPlayer )
 				{
@@ -3351,7 +3355,11 @@ bool CNPC_Strider::BecomeRagdoll( const CTakeDamageInfo &info, const Vector &for
 	{
 		// Otherwise just keel over
 		CRagdollProp *pRagdoll = NULL;
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		if ( pPlayer && mat_dxlevel.GetInt() > 0 )
 		{
 			int dxlevel = mat_dxlevel.GetInt();
diff --git a/src/game/server/hl2/npc_turret_floor.cpp b/src/game/server/hl2/npc_turret_floor.cpp
index fd70d59..efe227b 100644
--- a/src/game/server/hl2/npc_turret_floor.cpp
+++ b/src/game/server/hl2/npc_turret_floor.cpp
@@ -1890,7 +1890,11 @@ QAngle CNPC_FloorTurret::PreferredCarryAngles( void )
 	static QAngle g_prefAngles;
 
 	Vector vecUserForward;
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	pPlayer->EyeVectors( &vecUserForward );
 
 	// If we're looking up, then face directly forward
diff --git a/src/game/server/hl2/npc_vortigaunt_episodic.cpp b/src/game/server/hl2/npc_vortigaunt_episodic.cpp
index 07ac5c0..7f4e679 100644
--- a/src/game/server/hl2/npc_vortigaunt_episodic.cpp
+++ b/src/game/server/hl2/npc_vortigaunt_episodic.cpp
@@ -442,7 +442,11 @@ void CNPC_Vortigaunt::RunTask( const Task_t *pTask )
 	case TASK_VORTIGAUNT_WAIT_FOR_PLAYER:
 	{
 		// Wait for the player to get near (before starting the bugbait sequence)
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		if ( pPlayer != NULL )
 		{
 			GetMotor()->SetIdealYawToTargetAndUpdate( pPlayer->GetAbsOrigin(), AI_KEEP_YAW_SPEED );
@@ -640,7 +644,11 @@ int CNPC_Vortigaunt::RangeAttack1Conditions( float flDot, float flDist )
 		if ( ( GetAbsOrigin() - GetEnemy()->GetAbsOrigin() ).LengthSqr() < Square( AntlionWorkerBurstRadius() ) )
 			return COND_TOO_CLOSE_TO_ATTACK;
 
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		if ( pPlayer && ( pPlayer->GetAbsOrigin() - GetEnemy()->GetAbsOrigin() ).LengthSqr() < Square( AntlionWorkerBurstRadius() ) )
 		{
 			// Warn the player to get away!
@@ -897,7 +905,11 @@ void CNPC_Vortigaunt::HandleAnimEvent( animevent_t *pEvent )
 				// HACK: If we've still failed, just spawn it on the player 
 				if ( i == iNumAttempts )
 				{
-					CBasePlayer	*pPlayer = AI_GetSinglePlayer();
+#ifdef HL2SB
+					CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
+					CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 					if ( pPlayer )
 					{
 						vecSpawnOrigin = pPlayer->WorldSpaceCenter();
@@ -1686,7 +1698,11 @@ void CNPC_Vortigaunt::MaintainHealSchedule( void )
 		return;
 
 	// For now, we only heal the player
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 	if ( pPlayer == NULL )
 		return;
 
@@ -2343,7 +2359,11 @@ Disposition_t CNPC_Vortigaunt::IRelationType( CBaseEntity *pTarget )
 bool CNPC_Vortigaunt::HealGestureHasLOS( void )
 {
 	//For now the player is always our target
-	CBaseEntity *pTargetEnt = AI_GetSinglePlayer();
+#ifdef HL2SB
+	CBasePlayer *pTargetEnt = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
+	CBasePlayer *pTargetEnt = AI_GetSinglePlayer();
+#endif
 	if ( pTargetEnt == NULL )
 		return false;
 
diff --git a/src/game/server/hl2/npc_zombine.cpp b/src/game/server/hl2/npc_zombine.cpp
index 1faaf1f..ed764ac 100644
--- a/src/game/server/hl2/npc_zombine.cpp
+++ b/src/game/server/hl2/npc_zombine.cpp
@@ -27,7 +27,11 @@
 #include "props.h"
 #include "physics_npc_solver.h"
 #include "hl2_player.h"
+#ifndef HL2SB
 #include "hl2_gamerules.h"
+#else
+#include "hl2mp_gamerules.h"
+#endif
 
 #include "basecombatweapon.h"
 #include "basegrenade_shared.h"
@@ -411,7 +415,11 @@ void CNPC_Zombine::GatherGrenadeConditions( void )
 	if ( m_ActBusyBehavior.IsActive() )
 		return;
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 	if ( pPlayer && pPlayer->FVisible( this ) )
 	{
@@ -610,11 +618,19 @@ bool CNPC_Zombine::AllowedToSprint( void )
 
 	int iChance = SPRINT_CHANCE_VALUE;
 
+#ifdef HL2SB
+	CHL2MP_Player *pPlayer = dynamic_cast <CHL2MP_Player*> ( AI_GetNearestPlayer( GetAbsOrigin() ) );
+#else
 	CHL2_Player *pPlayer = dynamic_cast <CHL2_Player*> ( AI_GetSinglePlayer() );
+#endif
 
 	if ( pPlayer )
 	{
+#ifndef HL2SB
 		if ( HL2GameRules()->IsAlyxInDarknessMode() && pPlayer->FlashlightIsOn() == false )
+#else
+		if ( HL2MPRules()->IsAlyxInDarknessMode() && pPlayer->FlashlightIsOn() == false )
+#endif
 		{
 			iChance = SPRINT_CHANCE_VALUE_DARKNESS;
 		}
diff --git a/src/game/server/hl2/proto_sniper.cpp b/src/game/server/hl2/proto_sniper.cpp
index f46ea10..b5486e9 100644
--- a/src/game/server/hl2/proto_sniper.cpp
+++ b/src/game/server/hl2/proto_sniper.cpp
@@ -837,7 +837,11 @@ void CProtoSniper::PaintTarget( const Vector &vecTarget, float flPaintTime )
 //-----------------------------------------------------------------------------
 bool CProtoSniper::IsPlayerAllySniper()
 {
-	CBaseEntity *pPlayer = AI_GetSinglePlayer();
+#ifdef HL2SB
+	CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
+	CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 
 	return IRelationType( pPlayer ) == D_LI;
 }
@@ -1368,7 +1372,11 @@ void CProtoSniper::Event_KilledOther( CBaseEntity *pVictim, const CTakeDamageInf
 {
 	if( pVictim && pVictim->IsPlayer() )
 	{
+		// Andrew; In HL2SB, we're never satisfied by killing just a single
+		// player.
+#ifndef HL2SB
 		m_bKilledPlayer = true;
+#endif
 	}
 }
 
@@ -1395,7 +1403,19 @@ int CProtoSniper::SelectSchedule ( void )
 		return SCHED_RELOAD;
 	}
 
+#ifdef HL2SB
+	// Andrew; check to see if a player even exists first!
+	if( !AI_GetSinglePlayer() )
+	{
+		// Look for an enemy.
+		SetEnemy( NULL );
+		return SCHED_PSNIPER_SCAN;
+	}
+
+	if( !AI_GetNearestPlayer( GetAbsOrigin() )->IsAlive() && m_bKilledPlayer )
+#else
 	if( !AI_GetSinglePlayer()->IsAlive() && m_bKilledPlayer )
+#endif
 	{
 		if( HasCondition(COND_IN_PVS) )
 		{
@@ -1960,7 +1980,11 @@ void CProtoSniper::StartTask( const Task_t *pTask )
 	{
 	case TASK_SNIPER_PLAYER_DEAD:
 		{
+#ifdef HL2SB
+			m_hSweepTarget = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 			m_hSweepTarget = AI_GetSinglePlayer();
+#endif
 			SetWait( 4.0f );
 			LaserOn( m_hSweepTarget->GetAbsOrigin(), vec3_origin );
 		}
@@ -2605,10 +2629,18 @@ Vector CProtoSniper::LeadTarget( CBaseEntity *pTarget )
 CBaseEntity *CProtoSniper::PickDeadPlayerTarget()
 {
 	const int iSearchSize = 32;
-	CBaseEntity *pTarget = AI_GetSinglePlayer();
+#ifdef HL2SB
+	CBasePlayer *pTarget = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
+	CBasePlayer *pTarget = AI_GetSinglePlayer();
+#endif
 	CBaseEntity *pEntities[ iSearchSize ];
 
+#ifdef HL2SB
+	int iNumEntities = UTIL_EntitiesInSphere( pEntities, iSearchSize, AI_GetNearestPlayer( GetAbsOrigin() )->GetAbsOrigin(), 180.0f, 0 );
+#else
 	int iNumEntities = UTIL_EntitiesInSphere( pEntities, iSearchSize, AI_GetSinglePlayer()->GetAbsOrigin(), 180.0f, 0 );
+#endif
 
 	// Not very robust, but doesn't need to be. Randomly select a nearby object in the list that isn't an NPC.
 	if( iNumEntities > 0 )
diff --git a/src/game/server/hl2/script_intro.cpp b/src/game/server/hl2/script_intro.cpp
index 5c7d276..6bb3eba 100644
--- a/src/game/server/hl2/script_intro.cpp
+++ b/src/game/server/hl2/script_intro.cpp
@@ -233,7 +233,11 @@ void CScriptIntro::InputSetFOVBlendTime( inputdata_t &inputdata )
 	else
 	{
 		// If we weren't blending, then we need to construct a proper starting point from scratch
+#ifdef HL2SB
+		CBasePlayer *pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = AI_GetSinglePlayer();
+#endif
 		if ( pPlayer )
 		{
 			m_iStartFOV = ( m_iFOV ) ? m_iFOV : pPlayer->GetFOV();
diff --git a/src/game/server/hl2/vehicle_airboat.cpp b/src/game/server/hl2/vehicle_airboat.cpp
index 0812787..18a6a26 100644
--- a/src/game/server/hl2/vehicle_airboat.cpp
+++ b/src/game/server/hl2/vehicle_airboat.cpp
@@ -1568,6 +1568,10 @@ void CPropAirboat::FireGun( )
 	Vector	vecGunPosition;
 	Vector vecForward;
 	GetAttachment( m_nGunBarrelAttachment, vecGunPosition, &vecForward );
+
+#ifdef HL2SB
+	CDisablePredictionFiltering disabler;
+#endif
 	
 	// NOTE: For the airboat, unable to fire really means the aim is clamped
 	Vector vecAimPoint;
diff --git a/src/game/server/hl2/vehicle_jeep.cpp b/src/game/server/hl2/vehicle_jeep.cpp
index 4468acb..4111e2c 100644
--- a/src/game/server/hl2/vehicle_jeep.cpp
+++ b/src/game/server/hl2/vehicle_jeep.cpp
@@ -143,9 +143,9 @@ IMPLEMENT_SERVERCLASS_ST( CPropJeep, DT_PropJeep )
 END_SEND_TABLE();
 
 // This is overriden for the episodic jeep
-#ifndef HL2_EPISODIC
+// #ifndef HL2_EPISODIC
 LINK_ENTITY_TO_CLASS( prop_vehicle_jeep, CPropJeep );
-#endif
+// #endif
 
 //-----------------------------------------------------------------------------
 // Purpose: 
@@ -676,7 +676,11 @@ void CPropJeep::Think( void )
 {
 	BaseClass::Think();
 
+#ifdef HL2SB
+	CBasePlayer	*pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer	*pPlayer = UTIL_GetLocalPlayer();
+#endif
 
 	if ( m_bEngineLocked )
 	{
@@ -894,6 +898,10 @@ void CPropJeep::FireCannon( void )
 	if ( m_bUnableToFire )
 		return;
 
+#ifdef HL2SB
+	CDisablePredictionFiltering disabler;
+#endif
+
 	m_flCannonTime = gpGlobals->curtime + 0.2f;
 	m_bCannonCharging = false;
 
@@ -928,6 +936,10 @@ void CPropJeep::FireCannon( void )
 //-----------------------------------------------------------------------------
 void CPropJeep::FireChargedCannon( void )
 {
+#ifdef HL2SB
+	CDisablePredictionFiltering disabler;
+#endif
+
 	bool penetrated = false;
 
 	m_bCannonCharging	= false;
diff --git a/src/game/server/hl2mp/hl2mp_bot_temp.cpp b/src/game/server/hl2mp/hl2mp_bot_temp.cpp
index bf47ab3..9cd80d2 100644
--- a/src/game/server/hl2mp/hl2mp_bot_temp.cpp
+++ b/src/game/server/hl2mp/hl2mp_bot_temp.cpp
@@ -21,7 +21,8 @@
 void ClientPutInServer( edict_t *pEdict, const char *playername );
 void Bot_Think( CHL2MP_Player *pBot );
 
-#ifdef DEBUG
+// Andrew; for the Lua SDK, we provide bots for testing purposes.
+#if defined( DEBUG ) || defined( LUA_SDK )
 
 ConVar bot_forcefireweapon( "bot_forcefireweapon", "", 0, "Force bots with the specified weapon to fire." );
 ConVar bot_forceattack2( "bot_forceattack2", "0", 0, "When firing, use attack2." );
diff --git a/src/game/server/hl2mp/hl2mp_client.cpp b/src/game/server/hl2mp/hl2mp_client.cpp
index a3490df..e32de0e 100644
--- a/src/game/server/hl2mp/hl2mp_client.cpp
+++ b/src/game/server/hl2mp/hl2mp_client.cpp
@@ -85,17 +85,29 @@ void ClientPutInServer( edict_t *pEdict, const char *playername )
 {
 	// Allocate a CBaseTFPlayer for pev, and call spawn
 	CHL2MP_Player *pPlayer = CHL2MP_Player::CreatePlayer( "player", pEdict );
+#ifdef HL2SB
+	if( pPlayer )
+		pPlayer->SetPlayerName( playername );
+#else
 	pPlayer->SetPlayerName( playername );
+#endif
 }
 
 
 void ClientActive( edict_t *pEdict, bool bLoadGame )
 {
 	// Can't load games in CS!
+#ifndef HL2SB
 	Assert( !bLoadGame );
+#endif
 
 	CHL2MP_Player *pPlayer = ToHL2MPPlayer( CBaseEntity::Instance( pEdict ) );
+#ifdef HL2SB
+	if( pPlayer )
+		FinishClientPutInServer( pPlayer );
+#else
 	FinishClientPutInServer( pPlayer );
+#endif
 }
 
 
@@ -111,7 +123,11 @@ const char *GetGameDescription()
 	if ( g_pGameRules ) // this function may be called before the world has spawned, and the game rules initialized
 		return g_pGameRules->GetGameDescription();
 	else
+#ifndef HL2SB
 		return "Half-Life 2 Deathmatch";
+#else
+		return "Half-Life 2 Sandbox";
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -181,7 +197,7 @@ void GameStartFrame( void )
 
 	gpGlobals->teamplay = (teamplay.GetInt() != 0);
 
-#ifdef DEBUG
+#if defined( DEBUG ) || defined( LUA_SDK )
 	extern void Bot_RunAll();
 	Bot_RunAll();
 #endif
diff --git a/src/game/server/hl2mp/hl2mp_player.cpp b/src/game/server/hl2mp/hl2mp_player.cpp
index 3e78f3c..8df259f 100644
--- a/src/game/server/hl2mp/hl2mp_player.cpp
+++ b/src/game/server/hl2mp/hl2mp_player.cpp
@@ -23,6 +23,12 @@
 #include "GameStats.h"
 #include "tier0/vprof.h"
 #include "bone_setup.h"
+#ifdef LUA_SDK
+#include "luamanager.h"
+#include "lbaseentity_shared.h"
+#include "lhl2mp_player_shared.h"
+#include "ltakedamageinfo.h"
+#endif
 
 #include "engine/IEngineSound.h"
 #include "SoundEmitterSystem/isoundemittersystembase.h"
@@ -50,6 +56,18 @@ LINK_ENTITY_TO_CLASS( player, CHL2MP_Player );
 LINK_ENTITY_TO_CLASS( info_player_combine, CPointEntity );
 LINK_ENTITY_TO_CLASS( info_player_rebel, CPointEntity );
 
+// Andrew; we may end up using other game content - these allow us to use other
+// maps besides deathmatch ones.
+#ifdef HL2SB
+
+LINK_ENTITY_TO_CLASS( info_player_counterterrorist, CPointEntity );
+LINK_ENTITY_TO_CLASS( info_player_terrorist, CPointEntity );
+
+LINK_ENTITY_TO_CLASS( info_player_allies, CPointEntity );
+LINK_ENTITY_TO_CLASS( info_player_axis, CPointEntity );
+
+#endif
+
 extern void SendProxy_Origin( const SendProp *pProp, const void *pStruct, const void *pData, DVariant *pOut, int iElement, int objectID );
 
 BEGIN_SEND_TABLE_NOBASE( CHL2MP_Player, DT_HL2MPLocalPlayerExclusive )
@@ -97,6 +115,26 @@ END_SEND_TABLE()
 BEGIN_DATADESC( CHL2MP_Player )
 END_DATADESC()
 
+#ifdef HL2SB
+const char *g_ppszRandomCitizenModels[] = 
+{
+	"models/player/humans/group03/male_01.mdl",
+	"models/player/humans/group03/male_02.mdl",
+	"models/player/humans/group03/female_01.mdl",
+	"models/player/humans/group03/male_03.mdl",
+	"models/player/humans/group03/female_02.mdl",
+	"models/player/humans/group03/male_04.mdl",
+	"models/player/humans/group03/female_03.mdl",
+	"models/player/humans/group03/male_05.mdl",
+	"models/player/humans/group03/female_04.mdl",
+	"models/player/humans/group03/male_06.mdl",
+	"models/player/humans/group03/female_06.mdl",
+	"models/player/humans/group03/male_07.mdl",
+	"models/player/humans/group03/female_07.mdl",
+	"models/player/humans/group03/male_08.mdl",
+	"models/player/humans/group03/male_09.mdl",
+};
+#else
 const char *g_ppszRandomCitizenModels[] = 
 {
 	"models/humans/group03/male_01.mdl",
@@ -115,7 +153,17 @@ const char *g_ppszRandomCitizenModels[] =
 	"models/humans/group03/male_08.mdl",
 	"models/humans/group03/male_09.mdl",
 };
+#endif
 
+#ifdef HL2SB
+const char *g_ppszRandomCombineModels[] =
+{
+	"models/player/combine_soldier.mdl",
+	"models/player/combine_soldier_prisonguard.mdl",
+	"models/player/combine_super_soldier.mdl",
+	"models/player/police.mdl",
+};
+#else
 const char *g_ppszRandomCombineModels[] =
 {
 	"models/combine_soldier.mdl",
@@ -123,6 +171,7 @@ const char *g_ppszRandomCombineModels[] =
 	"models/combine_super_soldier.mdl",
 	"models/police.mdl",
 };
+#endif
 
 
 #define MAX_COMBINE_MODELS 4
@@ -237,6 +286,11 @@ void CHL2MP_Player::GiveAllItems( void )
 
 void CHL2MP_Player::GiveDefaultItems( void )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "GiveDefaultItems" );
+		lua_pushhl2mpplayer( L, this );
+	END_LUA_CALL_HOOK( 1, 0 );
+#else
 	EquipSuit();
 
 	CBasePlayer::GiveAmmo( 255,	"Pistol");
@@ -271,6 +325,7 @@ void CHL2MP_Player::GiveDefaultItems( void )
 	{
 		Weapon_Switch( Weapon_OwnsThisType( "weapon_physcannon" ) );
 	}
+#endif
 }
 
 void CHL2MP_Player::PickDefaultSpawnTeam( void )
@@ -288,7 +343,11 @@ void CHL2MP_Player::PickDefaultSpawnTeam( void )
 				{
 					char szReturnString[512];
 
+#ifdef HL2SB
+					Q_snprintf( szReturnString, sizeof (szReturnString ), "cl_playermodel models/player/combine_soldier.mdl\n" );
+#else
 					Q_snprintf( szReturnString, sizeof (szReturnString ), "cl_playermodel models/combine_soldier.mdl\n" );
+#endif
 					engine->ClientCommand ( edict(), szReturnString );
 				}
 
@@ -387,7 +446,35 @@ void CHL2MP_Player::Spawn(void)
 
 void CHL2MP_Player::PickupObject( CBaseEntity *pObject, bool bLimitMassAndSize )
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "PlayerPickupObject" );
+		lua_pushhl2mpplayer( L, this );
+		lua_pushentity( L, pObject );
+		lua_pushboolean( L, bLimitMassAndSize );
+	END_LUA_CALL_HOOK( 3, 1 );
+
+	RETURN_LUA_NONE();
+#endif
+
+#ifdef HL2SB
+	// can't pick up what you're standing on
+	if ( GetGroundEntity() == pObject )
+		return;
+	
+	if ( bLimitMassAndSize == true )
+	{
+		if ( CBasePlayer::CanPickupObject( pObject, 35, 128 ) == false )
+			 return;
+	}
+
+	// Can't be picked up if NPCs are on me
+	if ( pObject->HasNPCsOnIt() )
+		return;
+
+	PlayerPickupObject( this, pObject );
+#else
 	
+#endif
 }
 
 bool CHL2MP_Player::ValidatePlayerModel( const char *pModel )
@@ -425,7 +512,11 @@ void CHL2MP_Player::SetPlayerTeamModel( void )
 
 	if ( modelIndex == -1 || ValidatePlayerModel( szModelName ) == false )
 	{
+#ifdef HL2SB
+		szModelName = "models/player/Combine_Soldier.mdl";
+#else
 		szModelName = "models/Combine_Soldier.mdl";
+#endif
 		m_iModelType = TEAM_COMBINE;
 
 		char szReturnString[512];
@@ -436,7 +527,11 @@ void CHL2MP_Player::SetPlayerTeamModel( void )
 
 	if ( GetTeamNumber() == TEAM_COMBINE )
 	{
+#ifdef HL2SB
+		if ( Q_stristr( szModelName, "models/player/human") )
+#else
 		if ( Q_stristr( szModelName, "models/human") )
+#endif
 		{
 			int nHeads = ARRAYSIZE( g_ppszRandomCombineModels );
 		
@@ -448,7 +543,11 @@ void CHL2MP_Player::SetPlayerTeamModel( void )
 	}
 	else if ( GetTeamNumber() == TEAM_REBELS )
 	{
+#ifdef HL2SB
+		if ( !Q_stristr( szModelName, "models/player/human") )
+#else
 		if ( !Q_stristr( szModelName, "models/human") )
+#endif
 		{
 			int nHeads = ARRAYSIZE( g_ppszRandomCitizenModels );
 
@@ -472,13 +571,37 @@ void CHL2MP_Player::SetPlayerModel( void )
 
 	szModelName = engine->GetClientConVarValue( engine->IndexOfEdict( edict() ), "cl_playermodel" );
 
+#ifdef HL2SB
+	//Andrew; Map our requested player model to the new model/player path.
+	char file[_MAX_PATH];
+	Q_strncpy( file, szModelName, sizeof(file) );
+	if ( Q_strnicmp( file, "models/player/", 14 ) )
+	{
+		char *substring = strstr( file, "models/" );
+		if ( substring )
+		{
+			// replace with new directory
+			const char *dirname = substring + strlen("models/");
+			*substring = 0;
+			char destpath[_MAX_PATH];
+			// player
+			Q_snprintf( destpath, sizeof(destpath), "models/player/%s", dirname);
+			szModelName = destpath;
+		}
+	}
+#endif
+
 	if ( ValidatePlayerModel( szModelName ) == false )
 	{
 		char szReturnString[512];
 
 		if ( ValidatePlayerModel( pszCurrentModelName ) == false )
 		{
+#ifdef HL2SB
+			pszCurrentModelName = "models/player/Combine_Soldier.mdl";
+#else
 			pszCurrentModelName = "models/Combine_Soldier.mdl";
+#endif
 		}
 
 		Q_snprintf( szReturnString, sizeof (szReturnString ), "cl_playermodel %s\n", pszCurrentModelName );
@@ -512,7 +635,11 @@ void CHL2MP_Player::SetPlayerModel( void )
 			szModelName = g_ppszRandomCitizenModels[0];
 		}
 
+#ifdef HL2SB
+		if ( Q_stristr( szModelName, "models/player/human") )
+#else
 		if ( Q_stristr( szModelName, "models/human") )
+#endif
 		{
 			m_iModelType = TEAM_REBELS;
 		}
@@ -526,7 +653,11 @@ void CHL2MP_Player::SetPlayerModel( void )
 
 	if ( modelIndex == -1 )
 	{
+#ifdef HL2SB
+		szModelName = "models/player/Combine_Soldier.mdl";
+#else
 		szModelName = "models/Combine_Soldier.mdl";
+#endif
 		m_iModelType = TEAM_COMBINE;
 
 		char szReturnString[512];
@@ -543,7 +674,11 @@ void CHL2MP_Player::SetPlayerModel( void )
 
 void CHL2MP_Player::SetupPlayerSoundsByModel( const char *pModelName )
 {
+#ifdef HL2SB
+	if ( Q_stristr( pModelName, "models/player/human") )
+#else
 	if ( Q_stristr( pModelName, "models/human") )
+#endif
 	{
 		m_iPlayerSoundType = (int)PLAYER_SOUNDS_CITIZEN;
 	}
@@ -566,11 +701,29 @@ bool CHL2MP_Player::Weapon_Switch( CBaseCombatWeapon *pWeapon, int viewmodelinde
 
 void CHL2MP_Player::PreThink( void )
 {
+#ifdef HL2SB
+	//Andrew; See http://forums.steampowered.com/forums/showthread.php?t=1372727
+	QAngle vOldAngles = GetLocalAngles();
+	QAngle vTempAngles = GetLocalAngles();
+
+	vTempAngles = EyeAngles();
+
+	if ( vTempAngles[PITCH] > 180.0f )
+	{
+		vTempAngles[PITCH] -= 360.0f;
+	}
+
+	SetLocalAngles( vTempAngles );
+#endif
+
 	BaseClass::PreThink();
 	State_PreThink();
 
 	//Reset bullet force accumulator, only lasts one frame
 	m_vecTotalBulletForce = vec3_origin;
+#ifdef HL2SB
+	SetLocalAngles( vOldAngles );
+#endif
 }
 
 void CHL2MP_Player::PostThink( void )
@@ -593,6 +746,12 @@ void CHL2MP_Player::PostThink( void )
 
 void CHL2MP_Player::PlayerDeathThink()
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "PlayerDeathThink" );
+		lua_pushhl2mpplayer( L, this );
+	END_LUA_CALL_HOOK( 1, 0 );
+#endif
+
 	if( !IsObserver() )
 	{
 		BaseClass::PlayerDeathThink();
@@ -843,6 +1002,15 @@ bool CHL2MP_Player::ClientCommand( const CCommand &args )
 
 void CHL2MP_Player::CheatImpulseCommands( int iImpulse )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "CheatImpulseCommands" );
+		lua_pushhl2mpplayer( L, this );
+		lua_pushinteger( L, iImpulse );
+	END_LUA_CALL_HOOK( 2, 1 );
+
+	RETURN_LUA_NONE();
+#endif
+
 	switch ( iImpulse )
 	{
 		case 101:
@@ -1102,6 +1270,17 @@ int CHL2MP_Player::OnTakeDamage( const CTakeDamageInfo &inputInfo )
 
 void CHL2MP_Player::DeathSound( const CTakeDamageInfo &info )
 {
+#if defined ( LUA_SDK )
+	CTakeDamageInfo lInfo = info;
+
+	BEGIN_LUA_CALL_HOOK( "PlayerDeathSound" );
+		lua_pushhl2mpplayer( L, this );
+		lua_pushdamageinfo( L, lInfo );
+	END_LUA_CALL_HOOK( 2, 1 );
+
+	RETURN_LUA_NONE();
+#endif
+
 	if ( m_hRagdoll && m_hRagdoll->GetBaseAnimating()->IsDissolving() )
 		 return;
 
@@ -1134,6 +1313,14 @@ void CHL2MP_Player::DeathSound( const CTakeDamageInfo &info )
 
 CBaseEntity* CHL2MP_Player::EntSelectSpawnPoint( void )
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "PlayerEntSelectSpawnPoint" );
+		lua_pushhl2mpplayer( L, this );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_ENTITY();
+#endif
+
 	CBaseEntity *pSpot = NULL;
 	CBaseEntity *pLastSpawnPoint = g_pLastSpawn;
 	edict_t		*player = edict();
@@ -1154,10 +1341,86 @@ CBaseEntity* CHL2MP_Player::EntSelectSpawnPoint( void )
 
 		if ( gEntList.FindEntityByClassname( NULL, pSpawnpointName ) == NULL )
 		{
+			// Andrew; this could be neater, or the entire function could be
+			// rewritten to pool together our various point classes and select
+			// one randomly. For now, we'll prefer spawnpoints by appid if we
+			// can't find anything from deathmatch.
+#ifdef HL2SB
+			if ( GetTeamNumber() == TEAM_COMBINE )
+			{
+				pSpawnpointName = "info_player_terrorist";
+				pLastSpawnPoint = g_pLastCombineSpawn;
+			}
+			else if ( GetTeamNumber() == TEAM_REBELS )
+			{
+				pSpawnpointName = "info_player_counterterrorist";
+				pLastSpawnPoint = g_pLastRebelSpawn;
+			}
+
+			// try once more for dod
+			if ( gEntList.FindEntityByClassname( NULL, pSpawnpointName ) == NULL )
+			{
+				if ( GetTeamNumber() == TEAM_COMBINE )
+				{
+					pSpawnpointName = "info_player_axis";
+					pLastSpawnPoint = g_pLastCombineSpawn;
+				}
+				else if ( GetTeamNumber() == TEAM_REBELS )
+				{
+					pSpawnpointName = "info_player_allies";
+					pLastSpawnPoint = g_pLastRebelSpawn;
+				}
+
+				// three strikes, you're out!
+				if ( gEntList.FindEntityByClassname( NULL, pSpawnpointName ) == NULL )
+				{
+					pSpawnpointName = "info_player_deathmatch";
+					pLastSpawnPoint = g_pLastSpawn;
+				}
+			}
+#else
 			pSpawnpointName = "info_player_deathmatch";
 			pLastSpawnPoint = g_pLastSpawn;
+#endif
+		}
+	}
+#ifdef HL2SB
+	else
+	{
+		if ( random->RandomInt(0,1) )
+		{
+			pSpawnpointName = "info_player_terrorist";
+			pLastSpawnPoint = g_pLastCombineSpawn;
+		}
+		else
+		{
+			pSpawnpointName = "info_player_counterterrorist";
+			pLastSpawnPoint = g_pLastRebelSpawn;
+		}
+
+		// try once more for dod
+		if ( gEntList.FindEntityByClassname( NULL, pSpawnpointName ) == NULL )
+		{
+			if ( random->RandomInt(0,1) )
+			{
+				pSpawnpointName = "info_player_axis";
+				pLastSpawnPoint = g_pLastCombineSpawn;
+			}
+			else
+			{
+				pSpawnpointName = "info_player_allies";
+				pLastSpawnPoint = g_pLastRebelSpawn;
+			}
+
+			// three strikes, you're out!
+			if ( gEntList.FindEntityByClassname( NULL, pSpawnpointName ) == NULL )
+			{
+				pSpawnpointName = "info_player_deathmatch";
+				pLastSpawnPoint = g_pLastSpawn;
+			}
 		}
 	}
+#endif
 
 	pSpot = pLastSpawnPoint;
 	// Randomize the start spot
@@ -1202,6 +1465,22 @@ CBaseEntity* CHL2MP_Player::EntSelectSpawnPoint( void )
 		goto ReturnSpot;
 	}
 
+#ifdef HL2SB
+	// If startspot is set, (re)spawn there.
+	if ( !gpGlobals->startspot || !strlen(STRING(gpGlobals->startspot)))
+	{
+		pSpot = FindPlayerStart( "info_player_start" );
+		if ( pSpot )
+			goto ReturnSpot;
+	}
+	else
+	{
+		pSpot = gEntList.FindEntityByName( NULL, gpGlobals->startspot );
+		if ( pSpot )
+			goto ReturnSpot;
+	}
+
+#else
 	if ( !pSpot  )
 	{
 		pSpot = gEntList.FindEntityByClassname( pSpot, "info_player_start" );
@@ -1209,6 +1488,7 @@ CBaseEntity* CHL2MP_Player::EntSelectSpawnPoint( void )
 		if ( pSpot )
 			goto ReturnSpot;
 	}
+#endif
 
 ReturnSpot:
 
diff --git a/src/game/server/item_world.cpp b/src/game/server/item_world.cpp
index c019306..47208e3 100644
--- a/src/game/server/item_world.cpp
+++ b/src/game/server/item_world.cpp
@@ -225,10 +225,16 @@ extern int gEvilImpulse101;
 //-----------------------------------------------------------------------------
 void CItem::ActivateWhenAtRest()
 {
+	// Andrew; This doesn't work in HL2SB, default to HL2MP spawn behavior.
+#if !defined( HL2SB )
 	RemoveSolidFlags( FSOLID_TRIGGER );
 	m_bActivateWhenAtRest = true;
 	SetThink( &CItem::ComeToRest );
 	SetNextThink( gpGlobals->curtime + 0.5f );
+#else
+	SetThink( &CItem::FallThink );
+	SetNextThink( gpGlobals->curtime + 0.1f );
+#endif
 }
 
 
diff --git a/src/game/server/lbaseanimating.cpp b/src/game/server/lbaseanimating.cpp
new file mode 100644
index 0000000..3b7091c
--- /dev/null
+++ b/src/game/server/lbaseanimating.cpp
@@ -0,0 +1,564 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Base class for all animating characters and objects.
+//
+//=============================================================================//
+
+#define lbaseanimating_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "lbaseanimating.h"
+#include "mathlib/lvector.h"
+#include "lvphysics_interface.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CBaseAnimating *lua_toanimating (lua_State *L, int idx) {
+  CBaseHandle *hEntity = dynamic_cast<CBaseHandle *>((CBaseHandle *)lua_touserdata(L, idx));
+  if (hEntity == NULL)
+    return NULL;
+  return dynamic_cast<lua_CBaseAnimating *>(hEntity->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushanimating (lua_State *L, CBaseAnimating *pEntity) {
+  CBaseHandle *hEntity = (CBaseHandle *)lua_newuserdata(L, sizeof(CBaseHandle));
+  hEntity->Set(pEntity);
+  luaL_getmetatable(L, "CBaseAnimating");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CBaseAnimating *luaL_checkanimating (lua_State *L, int narg) {
+  lua_CBaseAnimating *d = lua_toanimating(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "CBaseAnimating expected, got NULL entity");
+  return d;
+}
+
+
+static int CBaseAnimating_CalculateIKLocks (lua_State *L) {
+  luaL_checkanimating(L, 1)->CalculateIKLocks(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_ComputeEntitySpaceHitboxSurroundingBox (lua_State *L) {
+  Vector pVecWorldMins, pVecWorldMaxs;
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->ComputeEntitySpaceHitboxSurroundingBox(&pVecWorldMins, &pVecWorldMaxs));
+  lua_pushvector(L, pVecWorldMins);
+  lua_pushvector(L, pVecWorldMaxs);
+  return 3;
+}
+
+static int CBaseAnimating_ComputeHitboxSurroundingBox (lua_State *L) {
+  Vector pVecWorldMins, pVecWorldMaxs;
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->ComputeHitboxSurroundingBox(&pVecWorldMins, &pVecWorldMaxs));
+  lua_pushvector(L, pVecWorldMins);
+  lua_pushvector(L, pVecWorldMaxs);
+  return 3;
+}
+
+static int CBaseAnimating_DoMuzzleFlash (lua_State *L) {
+  luaL_checkanimating(L, 1)->DoMuzzleFlash();
+  return 0;
+}
+
+static int CBaseAnimating_FindBodygroupByName (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->FindBodygroupByName(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_FindTransitionSequence (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->FindTransitionSequence(luaL_checkinteger(L, 2), luaL_checkinteger(L, 3), NULL));
+  return 1;
+}
+
+static int CBaseAnimating_GetAnimTimeInterval (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetAnimTimeInterval());
+  return 1;
+}
+
+static int CBaseAnimating_GetAttachment (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+      {
+        if (lua_gettop(L) <= 3)
+          lua_pushboolean(L, luaL_checkanimating(L, 1)->GetAttachment(luaL_checkint(L, 2), luaL_checkvector(L, 3)));
+        else
+          lua_pushboolean(L, luaL_checkanimating(L, 1)->GetAttachment(luaL_checkint(L, 2), luaL_checkvector(L, 3), luaL_checkangle(L, 4)));
+        break;
+      }
+	case LUA_TSTRING:
+	default:
+      {
+        if (lua_gettop(L) <= 3)
+          lua_pushboolean(L, luaL_checkanimating(L, 1)->GetAttachment(luaL_checkstring(L, 2), luaL_checkvector(L, 3)));
+        else
+          lua_pushboolean(L, luaL_checkanimating(L, 1)->GetAttachment(luaL_checkstring(L, 2), luaL_checkvector(L, 3), luaL_checkangle(L, 4)));
+        break;
+	  }
+  }
+  return 1;
+}
+
+static int CBaseAnimating_GetAttachmentLocal (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->GetAttachmentLocal(luaL_checkint(L, 2), luaL_checkvector(L, 3), luaL_checkangle(L, 4)));
+  return 1;
+}
+
+static int CBaseAnimating_GetBaseAnimating (lua_State *L) {
+  lua_pushanimating(L, luaL_checkanimating(L, 1)->GetBaseAnimating());
+  return 1;
+}
+
+static int CBaseAnimating_GetBodygroup (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetBodygroup(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetBodygroupCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetBodygroupCount(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetBodygroupName (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetBodygroupName(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetBonePosition (lua_State *L) {
+  Vector origin;
+  QAngle angles;
+  luaL_checkanimating(L, 1)->GetBonePosition(luaL_checkinteger(L, 2), origin, angles);
+  lua_pushvector(L, origin);
+  lua_pushangle(L, angles);
+  return 2;
+}
+
+static int CBaseAnimating_GetCycle (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetCycle());
+  return 1;
+}
+
+static int CBaseAnimating_GetFlexDescFacs (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetFlexDescFacs(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetHitboxSet (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetHitboxSet());
+  return 1;
+}
+
+static int CBaseAnimating_GetHitboxSetCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetHitboxSetCount());
+  return 1;
+}
+
+static int CBaseAnimating_GetHitboxSetName (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetHitboxSetName());
+  return 1;
+}
+
+static int CBaseAnimating_GetModelWidthScale (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetModelWidthScale());
+  return 1;
+}
+
+static int CBaseAnimating_GetNumBodyGroups (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetNumBodyGroups());
+  return 1;
+}
+
+static int CBaseAnimating_GetNumFlexControllers (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetNumFlexControllers());
+  return 1;
+}
+
+static int CBaseAnimating_GetPlaybackRate (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetPlaybackRate());
+  return 1;
+}
+
+static int CBaseAnimating_GetPoseParameter (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetPoseParameter(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetPoseParameterRange (lua_State *L) {
+  float minValue, maxValue;
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->GetPoseParameterRange(luaL_checkinteger(L, 2), minValue, maxValue));
+  lua_pushnumber(L, minValue);
+  lua_pushnumber(L, maxValue);
+  return 3;
+}
+
+static int CBaseAnimating_GetSequence (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetSequence());
+  return 1;
+}
+
+static int CBaseAnimating_GetSequenceActivity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->GetSequenceActivity(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetSequenceActivityName (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetSequenceActivityName(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetSequenceGroundSpeed (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->GetSequenceGroundSpeed(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_GetSequenceLinearMotion (lua_State *L) {
+  Vector pVec;
+  luaL_checkanimating(L, 1)->GetSequenceLinearMotion(luaL_checkinteger(L, 2), &pVec);
+  lua_pushvector(L, pVec);
+  return 1;
+}
+
+static int CBaseAnimating_GetSequenceName (lua_State *L) {
+  lua_pushstring(L, luaL_checkanimating(L, 1)->GetSequenceName(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_InvalidateBoneCache (lua_State *L) {
+  luaL_checkanimating(L, 1)->InvalidateBoneCache();
+  return 0;
+}
+
+static int CBaseAnimating_InvalidateMdlCache (lua_State *L) {
+  luaL_checkanimating(L, 1)->InvalidateMdlCache();
+  return 0;
+}
+
+static int CBaseAnimating_IsActivityFinished (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsActivityFinished());
+  return 1;
+}
+
+static int CBaseAnimating_IsOnFire (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsOnFire());
+  return 1;
+}
+
+static int CBaseAnimating_IsRagdoll (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsRagdoll());
+  return 1;
+}
+
+static int CBaseAnimating_IsSequenceFinished (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsSequenceFinished());
+  return 1;
+}
+
+static int CBaseAnimating_IsSequenceLooping (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->IsSequenceLooping(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_LookupActivity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->LookupActivity(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_LookupAttachment (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->LookupAttachment(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_LookupBone (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->LookupBone(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_LookupPoseParameter (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->LookupPoseParameter(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_LookupSequence (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->LookupSequence(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_ResetSequence (lua_State *L) {
+  luaL_checkanimating(L, 1)->ResetSequence(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_ResetSequenceInfo (lua_State *L) {
+  luaL_checkanimating(L, 1)->ResetSequenceInfo();
+  return 0;
+}
+
+static int CBaseAnimating_SelectWeightedSequence (lua_State *L) {
+  lua_pushinteger(L, luaL_checkanimating(L, 1)->SelectWeightedSequence((Activity)luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseAnimating_SequenceDuration (lua_State *L) {
+  switch(lua_type(L, 2)) {
+    case LUA_TNONE:
+    default:
+      lua_pushnumber(L, luaL_checkanimating(L, 1)->SequenceDuration());
+      break;
+    case LUA_TNUMBER:
+      lua_pushnumber(L, luaL_checkanimating(L, 1)->SequenceDuration(luaL_checkint(L, 2)));
+      break;
+  }
+  return 1;
+}
+
+static int CBaseAnimating_SequenceLoops (lua_State *L) {
+  lua_pushboolean(L, luaL_checkanimating(L, 1)->SequenceLoops());
+  return 1;
+}
+
+static int CBaseAnimating_SetBoneController (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->SetBoneController(luaL_checkinteger(L, 2), luaL_checknumber(L, 3)));
+  return 1;
+}
+
+static int CBaseAnimating_SetCycle (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetCycle(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetHitboxSet (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetHitboxSet(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetHitboxSetByName (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetHitboxSetByName(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetModelWidthScale (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetModelWidthScale(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetPlaybackRate (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetPlaybackRate(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_SetPoseParameter (lua_State *L) {
+  lua_pushnumber(L, luaL_checkanimating(L, 1)->SetPoseParameter(luaL_checkinteger(L, 2), luaL_checknumber(L, 3)));
+  return 1;
+}
+
+static int CBaseAnimating_SetSequence (lua_State *L) {
+  luaL_checkanimating(L, 1)->SetSequence(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_StudioFrameAdvance (lua_State *L) {
+  luaL_checkanimating(L, 1)->StudioFrameAdvance();
+  return 0;
+}
+
+static int CBaseAnimating_TransferDissolveFrom (lua_State *L) {
+  luaL_checkanimating(L, 1)->TransferDissolveFrom(luaL_checkanimating(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating_UseClientSideAnimation (lua_State *L) {
+  luaL_checkanimating(L, 1)->UseClientSideAnimation();
+  return 0;
+}
+
+static int CBaseAnimating_VPhysicsUpdate (lua_State *L) {
+  luaL_checkanimating(L, 1)->VPhysicsUpdate(luaL_checkphysicsobject(L, 2));
+  return 0;
+}
+
+static int CBaseAnimating___index (lua_State *L) {
+  CBaseAnimating *pEntity = lua_toanimating(L, 1);
+  if (pEntity == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  if (pEntity->m_nTableReference != LUA_NOREF) {
+    lua_getref(L, pEntity->m_nTableReference);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      lua_getmetatable(L, 1);
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "CBaseEntity");
+        lua_pushvalue(L, 2);
+        lua_gettable(L, -2);
+      }
+    }
+  }
+  else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      luaL_getmetatable(L, "CBaseEntity");
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+    }
+  }
+  return 1;
+}
+
+static int CBaseAnimating___newindex (lua_State *L) {
+  CBaseAnimating *pEntity = lua_toanimating(L, 1);
+  if (pEntity == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "m_bClientSideAnimation") == 0)
+    pEntity->m_bClientSideAnimation = (bool)luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_nBody") == 0)
+    pEntity->m_nBody = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_nHitboxSet") == 0)
+    pEntity->m_nHitboxSet = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_nSkin") == 0)
+    pEntity->m_nSkin = luaL_checkint(L, 3);
+  else {
+    if (pEntity->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      pEntity->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, pEntity->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, field);
+	lua_pop(L, 1);
+  }
+  return 0;
+}
+
+static int CBaseAnimating___eq (lua_State *L) {
+  lua_pushboolean(L, lua_toanimating(L, 1) == lua_toanimating(L, 2));
+  return 1;
+}
+
+static int CBaseAnimating___tostring (lua_State *L) {
+  CBaseAnimating *pEntity = lua_toanimating(L, 1);
+  if (pEntity == NULL)
+    lua_pushstring(L, "NULL");
+  else
+    lua_pushfstring(L, "CBaseAnimating: %d \"%s\"", pEntity->entindex(), pEntity->GetClassname());
+  return 1;
+}
+
+
+static const luaL_Reg CBaseAnimatingmeta[] = {
+  {"CalculateIKLocks", CBaseAnimating_CalculateIKLocks},
+  {"ComputeEntitySpaceHitboxSurroundingBox", CBaseAnimating_ComputeEntitySpaceHitboxSurroundingBox},
+  {"ComputeHitboxSurroundingBox", CBaseAnimating_ComputeHitboxSurroundingBox},
+  {"DoMuzzleFlash", CBaseAnimating_DoMuzzleFlash},
+  {"FindBodygroupByName", CBaseAnimating_FindBodygroupByName},
+  {"FindTransitionSequence", CBaseAnimating_FindTransitionSequence},
+  {"GetAnimTimeInterval", CBaseAnimating_GetAnimTimeInterval},
+  {"GetAttachment", CBaseAnimating_GetAttachment},
+  {"GetAttachmentLocal", CBaseAnimating_GetAttachmentLocal},
+  {"GetBaseAnimating", CBaseAnimating_GetBaseAnimating},
+  {"GetBodygroup", CBaseAnimating_GetBodygroup},
+  {"GetBodygroupCount", CBaseAnimating_GetBodygroupCount},
+  {"GetBodygroupName", CBaseAnimating_GetBodygroupName},
+  {"GetBonePosition", CBaseAnimating_GetBonePosition},
+  {"GetCycle", CBaseAnimating_GetCycle},
+  {"GetFlexDescFacs", CBaseAnimating_GetFlexDescFacs},
+  {"GetHitboxSet", CBaseAnimating_GetHitboxSet},
+  {"GetHitboxSetCount", CBaseAnimating_GetHitboxSetCount},
+  {"GetHitboxSetName", CBaseAnimating_GetHitboxSetName},
+  {"GetModelWidthScale", CBaseAnimating_GetModelWidthScale},
+  {"GetNumBodyGroups", CBaseAnimating_GetNumBodyGroups},
+  {"GetNumFlexControllers", CBaseAnimating_GetNumFlexControllers},
+  {"GetPlaybackRate", CBaseAnimating_GetPlaybackRate},
+  {"GetPoseParameter", CBaseAnimating_GetPoseParameter},
+  {"GetPoseParameterRange", CBaseAnimating_GetPoseParameterRange},
+  {"GetSequence", CBaseAnimating_GetSequence},
+  {"GetSequenceActivity", CBaseAnimating_GetSequenceActivity},
+  {"GetSequenceActivityName", CBaseAnimating_GetSequenceActivityName},
+  {"GetSequenceGroundSpeed", CBaseAnimating_GetSequenceGroundSpeed},
+  {"GetSequenceLinearMotion", CBaseAnimating_GetSequenceLinearMotion},
+  {"GetSequenceName", CBaseAnimating_GetSequenceName},
+  {"InvalidateBoneCache", CBaseAnimating_InvalidateBoneCache},
+  {"InvalidateMdlCache", CBaseAnimating_InvalidateMdlCache},
+  {"IsActivityFinished", CBaseAnimating_IsActivityFinished},
+  {"IsOnFire", CBaseAnimating_IsOnFire},
+  {"IsRagdoll", CBaseAnimating_IsRagdoll},
+  {"IsSequenceFinished", CBaseAnimating_IsSequenceFinished},
+  {"IsSequenceLooping", CBaseAnimating_IsSequenceLooping},
+  {"LookupActivity", CBaseAnimating_LookupActivity},
+  {"LookupAttachment", CBaseAnimating_LookupAttachment},
+  {"LookupBone", CBaseAnimating_LookupBone},
+  {"LookupPoseParameter", CBaseAnimating_LookupPoseParameter},
+  {"LookupSequence", CBaseAnimating_LookupSequence},
+  {"ResetSequence", CBaseAnimating_ResetSequence},
+  {"ResetSequenceInfo", CBaseAnimating_ResetSequenceInfo},
+  {"SelectWeightedSequence", CBaseAnimating_SelectWeightedSequence},
+  {"SequenceDuration", CBaseAnimating_SequenceDuration},
+  {"SequenceLoops", CBaseAnimating_SequenceLoops},
+  {"SetBoneController", CBaseAnimating_SetBoneController},
+  {"SetCycle", CBaseAnimating_SetCycle},
+  {"SetHitboxSet", CBaseAnimating_SetHitboxSet},
+  {"SetHitboxSetByName", CBaseAnimating_SetHitboxSetByName},
+  {"SetModelWidthScale", CBaseAnimating_SetModelWidthScale},
+  {"SetPlaybackRate", CBaseAnimating_SetPlaybackRate},
+  {"SetPoseParameter", CBaseAnimating_SetPoseParameter},
+  {"SetSequence", CBaseAnimating_SetSequence},
+  {"StudioFrameAdvance", CBaseAnimating_StudioFrameAdvance},
+  {"TransferDissolveFrom", CBaseAnimating_TransferDissolveFrom},
+  {"UseClientSideAnimation", CBaseAnimating_UseClientSideAnimation},
+  {"VPhysicsUpdate", CBaseAnimating_VPhysicsUpdate},
+  {"__index", CBaseAnimating___index},
+  {"__newindex", CBaseAnimating___newindex},
+  {"__eq", CBaseAnimating___eq},
+  {"__tostring", CBaseAnimating___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CBaseAnimating object
+*/
+LUALIB_API int luaopen_CBaseAnimating (lua_State *L) {
+  luaL_newmetatable(L, "CBaseAnimating");
+  luaL_register(L, NULL, CBaseAnimatingmeta);
+  lua_pushstring(L, "entity");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "entity" */
+  lua_pop(L, 1);
+  return 1;
+}
+
diff --git a/src/game/server/lbaseanimating.h b/src/game/server/lbaseanimating.h
new file mode 100644
index 0000000..b8a3150
--- /dev/null
+++ b/src/game/server/lbaseanimating.h
@@ -0,0 +1,35 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+//=============================================================================//
+
+#ifndef LBASEANIMATING_H
+#define LBASEANIMATING_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for CBaseAnimating functions */
+typedef CBaseAnimating lua_CBaseAnimating;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CBaseAnimating     *(lua_toanimating) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushanimating) (lua_State *L, lua_CBaseAnimating *pEntity);
+
+
+
+LUALIB_API lua_CBaseAnimating *(luaL_checkanimating) (lua_State *L, int narg);
+
+
+#endif // LBASEANIMATING_H
diff --git a/src/game/server/lbaseentity.cpp b/src/game/server/lbaseentity.cpp
new file mode 100644
index 0000000..42e5afb
--- /dev/null
+++ b/src/game/server/lbaseentity.cpp
@@ -0,0 +1,783 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: The base class from which all game entities are derived.
+//
+//===========================================================================//
+
+#define lbaseentity_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "lbaseentity_shared.h"
+#include "ltakedamageinfo.h"
+#include "mathlib/lvector.h"
+#include "items.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int CBaseEntity_RecalcHasPlayerChildBit (lua_State *L) {
+  luaL_checkentity(L, 1)->RecalcHasPlayerChildBit();
+  return 0;
+}
+
+static int CBaseEntity_DoesHavePlayerChild (lua_State *L) {
+  luaL_checkentity(L, 1)->DoesHavePlayerChild();
+  return 1;
+}
+
+static int CBaseEntity_SetNavIgnore (lua_State *L) {
+  luaL_checkentity(L, 1)->SetNavIgnore(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_ClearNavIgnore (lua_State *L) {
+  luaL_checkentity(L, 1)->ClearNavIgnore();
+  return 0;
+}
+
+static int CBaseEntity_IsNavIgnored (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsNavIgnored());
+  return 1;
+}
+
+static int CBaseEntity_SetTransmitState (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->SetTransmitState(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_GetTransmitState (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetTransmitState());
+  return 1;
+}
+
+static int CBaseEntity_UpdateTransmitState (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->UpdateTransmitState());
+  return 1;
+}
+
+static int CBaseEntity_IncrementTransmitStateOwnedCounter (lua_State *L) {
+  luaL_checkentity(L, 1)->IncrementTransmitStateOwnedCounter();
+  return 0;
+}
+
+static int CBaseEntity_DecrementTransmitStateOwnedCounter (lua_State *L) {
+  luaL_checkentity(L, 1)->DecrementTransmitStateOwnedCounter();
+  return 0;
+}
+
+static int CBaseEntity_DetectInSkybox (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->DetectInSkybox());
+  return 1;
+}
+
+static int CBaseEntity_GetEntitySkybox (lua_State *L) {
+  lua_pushentity(L, (CBaseEntity *)luaL_checkentity(L, 1)->GetEntitySkybox());
+  return 1;
+}
+
+static int CBaseEntity_PostConstructor (lua_State *L) {
+  luaL_checkentity(L, 1)->PostConstructor(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_PostClientActive (lua_State *L) {
+  luaL_checkentity(L, 1)->PostClientActive();
+  return 0;
+}
+
+static int CBaseEntity_ValidateEntityConnections (lua_State *L) {
+  luaL_checkentity(L, 1)->ValidateEntityConnections();
+  return 0;
+}
+
+static int CBaseEntity_PostClientMessagesSent (lua_State *L) {
+  luaL_checkentity(L, 1)->PostClientMessagesSent();
+  return 0;
+}
+
+static int CBaseEntity_SetName (lua_State *L) {
+  luaL_checkentity(L, 1)->SetName(MAKE_STRING( luaL_checkstring(L, 2) ));
+  return 0;
+}
+
+static int CBaseEntity_GetEntityName (lua_State *L) {
+  lua_pushstring(L, STRING( luaL_checkentity(L, 1)->GetEntityName()));
+  return 1;
+}
+
+static int CBaseEntity_NameMatches (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->NameMatches(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_ClassMatches (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->ClassMatches(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_GetSpawnFlags (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetSpawnFlags());
+  return 1;
+}
+
+static int CBaseEntity_AddSpawnFlags (lua_State *L) {
+  luaL_checkentity(L, 1)->AddSpawnFlags(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_RemoveSpawnFlags (lua_State *L) {
+  luaL_checkentity(L, 1)->RemoveSpawnFlags(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_ClearSpawnFlags (lua_State *L) {
+  luaL_checkentity(L, 1)->ClearSpawnFlags();
+  return 0;
+}
+
+static int CBaseEntity_HasSpawnFlags (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->HasSpawnFlags(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_MakeDormant (lua_State *L) {
+  luaL_checkentity(L, 1)->MakeDormant();
+  return 0;
+}
+
+static int CBaseEntity_RemoveDeferred (lua_State *L) {
+  luaL_checkentity(L, 1)->RemoveDeferred();
+  return 0;
+}
+
+static int CBaseEntity_AcceptInput (lua_State *L) {
+  variant_t emptyVariant;
+  lua_pushboolean(L, luaL_checkentity(L, 1)->AcceptInput(luaL_checkstring(L, 2), lua_toentity(L, 3), lua_toentity(L, 4), emptyVariant, luaL_checkint(L, 5)));
+  return 1;
+}
+
+static int CBaseEntity_GetInputDispatchEffectPosition (lua_State *L) {
+  Vector pVector;
+  QAngle pAngle;
+  luaL_checkentity(L, 1)->GetInputDispatchEffectPosition(luaL_checkstring(L, 2), pVector, pAngle);
+  lua_pushvector(L, pVector);
+  lua_pushangle(L, pAngle);
+  return 2;
+}
+
+static int CBaseEntity_EntityText (lua_State *L) {
+  luaL_checkentity(L, 1)->EntityText(luaL_checkinteger(L, 2), luaL_checkstring(L, 3), luaL_checknumber(L, 4), luaL_checkinteger(L, 5), luaL_checkinteger(L, 6), luaL_checkinteger(L, 7), luaL_checkinteger(L, 8));
+  return 0;
+}
+
+static int CBaseEntity_DrawDebugGeometryOverlays (lua_State *L) {
+  luaL_checkentity(L, 1)->DrawDebugGeometryOverlays();
+  return 0;
+}
+
+static int CBaseEntity_DrawDebugTextOverlays (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->DrawDebugTextOverlays());
+  return 1;
+}
+
+static int CBaseEntity_DrawTimedOverlays (lua_State *L) {
+  luaL_checkentity(L, 1)->DrawTimedOverlays();
+  return 0;
+}
+
+static int CBaseEntity_DrawBBoxOverlay (lua_State *L) {
+  luaL_checkentity(L, 1)->DrawBBoxOverlay(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_DrawAbsBoxOverlay (lua_State *L) {
+  luaL_checkentity(L, 1)->DrawAbsBoxOverlay();
+  return 0;
+}
+
+static int CBaseEntity_DrawRBoxOverlay (lua_State *L) {
+  luaL_checkentity(L, 1)->DrawRBoxOverlay();
+  return 0;
+}
+
+static int CBaseEntity_SendDebugPivotOverlay (lua_State *L) {
+  luaL_checkentity(L, 1)->SendDebugPivotOverlay();
+  return 0;
+}
+
+static int CBaseEntity_AddTimedOverlay (lua_State *L) {
+  luaL_checkentity(L, 1)->AddTimedOverlay(luaL_checkstring(L, 2), luaL_checkinteger(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_RequiredEdictIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->RequiredEdictIndex());
+  return 1;
+}
+
+static int CBaseEntity_MoveDone (lua_State *L) {
+  luaL_checkentity(L, 1)->MoveDone();
+  return 0;
+}
+
+static int CBaseEntity_Instance (lua_State *L) {
+  lua_pushentity(L, CBaseEntity::Instance(luaL_checkinteger(L, 1)));
+  return 1;
+}
+
+static int CBaseEntity_AddContext (lua_State *L) {
+  luaL_checkentity(L, 1)->AddContext(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_DispatchResponse (lua_State *L) {
+  luaL_checkentity(L, 1)->DispatchResponse(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_Classify (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->Classify());
+  return 1;
+}
+
+static int CBaseEntity_DeathNotice (lua_State *L) {
+  luaL_checkentity(L, 1)->DeathNotice(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_ShouldAttractAutoAim (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->ShouldAttractAutoAim(luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_GetAutoAimRadius (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetAutoAimRadius());
+  return 1;
+}
+
+static int CBaseEntity_GetAutoAimCenter (lua_State *L) {
+  lua_pushvector(L, luaL_checkentity(L, 1)->GetAutoAimCenter());
+  return 1;
+}
+
+static int CBaseEntity_PassesDamageFilter (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->PassesDamageFilter(luaL_checkdamageinfo(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_CanBeHitByMeleeAttack (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->CanBeHitByMeleeAttack(luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_OnTakeDamage (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->OnTakeDamage(luaL_checkdamageinfo(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_TakeDamage (lua_State *L) {
+  luaL_checkentity(L, 1)->TakeDamage(luaL_checkdamageinfo(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_TakeHealth (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->TakeHealth(luaL_checkinteger(L, 2), luaL_checkinteger(L, 3)));
+  return 1;
+}
+
+static int CBaseEntity_Event_Killed (lua_State *L) {
+  luaL_checkentity(L, 1)->Event_Killed(luaL_checkdamageinfo(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_Event_KilledOther (lua_State *L) {
+  luaL_checkentity(L, 1)->Event_KilledOther(luaL_checkentity(L, 2), luaL_checkdamageinfo(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_IsTriggered (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsTriggered(luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_GetDelay (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetDelay());
+  return 1;
+}
+
+static int CBaseEntity_IsMoving (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsMoving());
+  return 1;
+}
+
+static int CBaseEntity_IsWorld (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsWorld());
+  return 1;
+}
+
+static int CBaseEntity_AddPoints (lua_State *L) {
+  luaL_checkentity(L, 1)->AddPoints(luaL_checkinteger(L, 2), luaL_checkboolean(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_AddPointsToTeam (lua_State *L) {
+  luaL_checkentity(L, 1)->AddPointsToTeam(luaL_checkinteger(L, 2), luaL_checkboolean(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_OnControls (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->OnControls(luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_HasTarget (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->HasTarget(MAKE_STRING( luaL_checkstring(L, 2) )));
+  return 1;
+}
+
+static int CBaseEntity_IsNetClient (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsNetClient());
+  return 1;
+}
+
+static int CBaseEntity_IsTemplate (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsTemplate());
+  return 1;
+}
+
+static int CBaseEntity_IsViewable (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsViewable());
+  return 1;
+}
+
+static int CBaseEntity_IsInAnyTeam (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsInAnyTeam());
+  return 1;
+}
+
+static int CBaseEntity_TeamID (lua_State *L) {
+  lua_pushstring(L, luaL_checkentity(L, 1)->TeamID());
+  return 1;
+}
+
+static int CBaseEntity_CanStandOn (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->CanStandOn(luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_GetEnemy (lua_State *L) {
+  lua_pushentity(L, luaL_checkentity(L, 1)->GetEnemy());
+  return 1;
+}
+
+static int CBaseEntity_VelocityPunch (lua_State *L) {
+  luaL_checkentity(L, 1)->VelocityPunch(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_GetNextTarget (lua_State *L) {
+  lua_pushentity(L, luaL_checkentity(L, 1)->GetNextTarget());
+  return 1;
+}
+
+static int CBaseEntity_Use (lua_State *L) {
+  luaL_checkentity(L, 1)->Use(luaL_checkentity(L, 2), luaL_checkentity(L, 3), (USE_TYPE)luaL_checkinteger(L, 4), luaL_checknumber(L, 5));
+  return 0;
+}
+
+static int CBaseEntity_StartTouch (lua_State *L) {
+  luaL_checkentity(L, 1)->StartTouch(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_Touch (lua_State *L) {
+  luaL_checkentity(L, 1)->Touch(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_EndTouch (lua_State *L) {
+  luaL_checkentity(L, 1)->EndTouch(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_StartBlocked (lua_State *L) {
+  luaL_checkentity(L, 1)->StartBlocked(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_Blocked (lua_State *L) {
+  luaL_checkentity(L, 1)->Blocked(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_EndBlocked (lua_State *L) {
+  luaL_checkentity(L, 1)->EndBlocked();
+  return 0;
+}
+
+static int CBaseEntity_PhysicsTouchTriggers (lua_State *L) {
+  luaL_checkentity(L, 1)->PhysicsTouchTriggers();
+  return 0;
+}
+
+static int CBaseEntity_SUB_DoNothing (lua_State *L) {
+  luaL_checkentity(L, 1)->SUB_DoNothing();
+  return 0;
+}
+
+static int CBaseEntity_SUB_StartFadeOut (lua_State *L) {
+  luaL_checkentity(L, 1)->SUB_StartFadeOut(luaL_optnumber(L, 2, 10.0f), luaL_optboolean(L, 3, true));
+  return 0;
+}
+
+static int CBaseEntity_SUB_StartFadeOutInstant (lua_State *L) {
+  luaL_checkentity(L, 1)->SUB_StartFadeOutInstant();
+  return 0;
+}
+
+static int CBaseEntity_SUB_FadeOut (lua_State *L) {
+  luaL_checkentity(L, 1)->SUB_FadeOut();
+  return 0;
+}
+
+static int CBaseEntity_SUB_Vanish (lua_State *L) {
+  luaL_checkentity(L, 1)->SUB_Vanish();
+  return 0;
+}
+
+static int CBaseEntity_SUB_CallUseToggle (lua_State *L) {
+  luaL_checkentity(L, 1)->SUB_CallUseToggle();
+  return 0;
+}
+
+static int CBaseEntity_SUB_PerformFadeOut (lua_State *L) {
+  luaL_checkentity(L, 1)->SUB_PerformFadeOut();
+  return 0;
+}
+
+static int CBaseEntity_SUB_AllowedToFade (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->SUB_AllowedToFade());
+  return 1;
+}
+
+static int CBaseEntity_Teleport (lua_State *L) {
+  luaL_checkentity(L, 1)->Teleport(&luaL_checkvector(L, 2), &luaL_checkangle(L, 3), &luaL_checkvector(L, 4));
+  return 0;
+}
+
+static int CBaseEntity_ShouldToggle (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->ShouldToggle((USE_TYPE)luaL_checkinteger(L, 2), luaL_checkinteger(L, 3)));
+  return 1;
+}
+
+static int CBaseEntity_Respawn (lua_State *L) {
+  lua_pushentity(L, luaL_checkentity(L, 1)->Respawn());
+  return 1;
+}
+
+static int CBaseEntity_TraceAttackToTriggers (lua_State *L) {
+  luaL_checkentity(L, 1)->TraceAttackToTriggers(luaL_checkdamageinfo(L, 2), luaL_checkvector(L, 3), luaL_checkvector(L, 4), luaL_checkvector(L, 5));
+  return 0;
+}
+
+static int CBaseEntity_Intersects (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->Intersects(luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_IsLockedByMaster (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsLockedByMaster());
+  return 1;
+}
+
+static int CBaseEntity_SetMaxHealth (lua_State *L) {
+  luaL_checkentity(L, 1)->SetMaxHealth(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_DumpResponseCriteria (lua_State *L) {
+  luaL_checkentity(L, 1)->DumpResponseCriteria();
+  return 0;
+}
+
+static int CBaseEntity_Create (lua_State *L) {
+  lua_pushentity(L, CBaseEntity::Create(luaL_checkstring(L, 1), luaL_checkvector(L, 2), luaL_checkangle(L, 3), luaL_optentity(L, 4, NULL)));
+  return 1;
+}
+
+static int CBaseEntity_CreateNoSpawn (lua_State *L) {
+  lua_pushentity(L, CBaseEntity::CreateNoSpawn(luaL_checkstring(L, 1), luaL_checkvector(L, 2), luaL_checkangle(L, 3), luaL_optentity(L, 4, NULL)));
+  return 1;
+}
+
+static int CBaseEntity_GetDamageType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetDamageType());
+  return 1;
+}
+
+static int CBaseEntity_GetDamage (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetDamage());
+  return 1;
+}
+
+static int CBaseEntity_SetDamage (lua_State *L) {
+  luaL_checkentity(L, 1)->SetDamage(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_BodyTarget (lua_State *L) {
+  lua_pushvector(L, luaL_checkentity(L, 1)->BodyTarget(luaL_checkvector(L, 2), luaL_optboolean(L, 3, true)));
+  return 1;
+}
+
+static int CBaseEntity_HeadTarget (lua_State *L) {
+  lua_pushvector(L, luaL_checkentity(L, 1)->HeadTarget(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_GetSmoothedVelocity (lua_State *L) {
+  lua_pushvector(L, luaL_checkentity(L, 1)->GetSmoothedVelocity());
+  return 1;
+}
+
+static int CBaseEntity_GetVelocity (lua_State *L) {
+  Vector vVelocity;
+  AngularImpulse vAngVelocity;
+  luaL_checkentity(L, 1)->GetVelocity(&vVelocity, &vAngVelocity);
+  lua_pushvector(L, vVelocity);
+  lua_pushvector(L, (Vector &)vAngVelocity);
+  return 2;
+}
+
+static int CBaseEntity_GetFriction (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetFriction());
+  return 1;
+}
+
+static int CBaseEntity_FVisible (lua_State *L) {
+  if (lua_isuserdata(L, 2) && luaL_checkudata(L, 2, "Vector"))
+	lua_pushboolean(L, luaL_checkentity(L, 1)->FVisible(luaL_checkvector(L, 2), luaL_optinteger(L, 3, MASK_BLOCKLOS)));
+  else
+	lua_pushboolean(L, luaL_checkentity(L, 1)->FVisible(luaL_checkentity(L, 2), luaL_optinteger(L, 3, MASK_BLOCKLOS)));
+  return 1;
+}
+
+static int CBaseEntity_GetReceivedDamageScale (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetReceivedDamageScale(luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_GetGroundVelocityToApply (lua_State *L) {
+  Vector vecGroundVel;
+  luaL_checkentity(L, 1)->GetGroundVelocityToApply(vecGroundVel);
+  lua_pushvector(L, vecGroundVel);
+  return 1;
+}
+
+static int CBaseEntity_PhysicsSplash (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->PhysicsSplash(luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checknumber(L, 4), luaL_checknumber(L, 5)));
+  return 1;
+}
+
+static int CBaseEntity_Splash (lua_State *L) {
+  luaL_checkentity(L, 1)->Splash();
+  return 0;
+}
+
+static int CBaseEntity_ClearSolidFlags (lua_State *L) {
+  luaL_checkentity(L, 1)->ClearSolidFlags();
+  return 0;
+}
+
+static int CBaseEntity_SetElasticity (lua_State *L) {
+  luaL_checkentity(L, 1)->SetElasticity(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetShadowCastDistance (lua_State *L) {
+  if (!lua_isnoneornil(L, 3))
+	luaL_checkentity(L, 1)->SetShadowCastDistance(luaL_checknumber(L, 2), luaL_checknumber(L, 3));
+  else
+	luaL_checkentity(L, 1)->SetShadowCastDistance(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_GetLocalTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetLocalTime());
+  return 1;
+}
+
+static int CBaseEntity_IncrementLocalTime (lua_State *L) {
+  luaL_checkentity(L, 1)->IncrementLocalTime(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_GetMoveDoneTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetMoveDoneTime());
+  return 1;
+}
+
+static int CBaseEntity_SetMoveDoneTime (lua_State *L) {
+  luaL_checkentity(L, 1)->SetMoveDoneTime(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_GetSoundEmissionOrigin (lua_State *L) {
+  lua_pushvector(L, luaL_checkentity(L, 1)->GetSoundEmissionOrigin());
+  return 1;
+}
+
+static int CBaseEntity_IsItem (lua_State *L) {
+  CItem *pItem = dynamic_cast<CItem *>(luaL_checkentity(L, 1));
+
+  if( pItem )
+  {
+    lua_pushboolean(L, true);
+  }
+  else
+  {
+    lua_pushboolean(L, false);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg CBaseEntitymeta[] = {
+  {"RecalcHasPlayerChildBit", CBaseEntity_RecalcHasPlayerChildBit},
+  {"DoesHavePlayerChild", CBaseEntity_DoesHavePlayerChild},
+  {"SetNavIgnore", CBaseEntity_SetNavIgnore},
+  {"ClearNavIgnore", CBaseEntity_ClearNavIgnore},
+  {"IsNavIgnored", CBaseEntity_IsNavIgnored},
+  {"SetTransmitState", CBaseEntity_SetTransmitState},
+  {"GetTransmitState", CBaseEntity_GetTransmitState},
+  {"UpdateTransmitState", CBaseEntity_UpdateTransmitState},
+  {"IncrementTransmitStateOwnedCounter", CBaseEntity_IncrementTransmitStateOwnedCounter},
+  {"DecrementTransmitStateOwnedCounter", CBaseEntity_DecrementTransmitStateOwnedCounter},
+  {"DetectInSkybox", CBaseEntity_DetectInSkybox},
+  {"GetEntitySkybox", CBaseEntity_GetEntitySkybox},
+  {"PostConstructor", CBaseEntity_PostConstructor},
+  {"PostClientActive", CBaseEntity_PostClientActive},
+  {"ValidateEntityConnections", CBaseEntity_ValidateEntityConnections},
+  {"PostClientMessagesSent", CBaseEntity_PostClientMessagesSent},
+  {"SetName", CBaseEntity_SetName},
+  {"GetEntityName", CBaseEntity_GetEntityName},
+  {"NameMatches", CBaseEntity_NameMatches},
+  {"ClassMatches", CBaseEntity_ClassMatches},
+  {"GetSpawnFlags", CBaseEntity_GetSpawnFlags},
+  {"AddSpawnFlags", CBaseEntity_AddSpawnFlags},
+  {"RemoveSpawnFlags", CBaseEntity_RemoveSpawnFlags},
+  {"ClearSpawnFlags", CBaseEntity_ClearSpawnFlags},
+  {"HasSpawnFlags", CBaseEntity_HasSpawnFlags},
+  {"MakeDormant", CBaseEntity_MakeDormant},
+  {"RemoveDeferred", CBaseEntity_RemoveDeferred},
+  {"AcceptInput", CBaseEntity_AcceptInput},
+  {"GetInputDispatchEffectPosition", CBaseEntity_GetInputDispatchEffectPosition},
+  {"EntityText", CBaseEntity_EntityText},
+  {"DrawDebugGeometryOverlays", CBaseEntity_DrawDebugGeometryOverlays},
+  {"DrawDebugTextOverlays", CBaseEntity_DrawDebugTextOverlays},
+  {"DrawTimedOverlays", CBaseEntity_DrawTimedOverlays},
+  {"DrawBBoxOverlay", CBaseEntity_DrawBBoxOverlay},
+  {"DrawAbsBoxOverlay", CBaseEntity_DrawAbsBoxOverlay},
+  {"DrawRBoxOverlay", CBaseEntity_DrawRBoxOverlay},
+  {"SendDebugPivotOverlay", CBaseEntity_SendDebugPivotOverlay},
+  {"AddTimedOverlay", CBaseEntity_AddTimedOverlay},
+  {"RequiredEdictIndex", CBaseEntity_RequiredEdictIndex},
+  {"MoveDone", CBaseEntity_MoveDone},
+  {"Instance", CBaseEntity_Instance},
+  {"AddContext", CBaseEntity_AddContext},
+  {"DispatchResponse", CBaseEntity_DispatchResponse},
+  {"Classify", CBaseEntity_Classify},
+  {"DeathNotice", CBaseEntity_DeathNotice},
+  {"ShouldAttractAutoAim", CBaseEntity_ShouldAttractAutoAim},
+  {"GetAutoAimRadius", CBaseEntity_GetAutoAimRadius},
+  {"GetAutoAimCenter", CBaseEntity_GetAutoAimCenter},
+  {"PassesDamageFilter", CBaseEntity_PassesDamageFilter},
+  {"CanBeHitByMeleeAttack", CBaseEntity_CanBeHitByMeleeAttack},
+  {"OnTakeDamage", CBaseEntity_OnTakeDamage},
+  {"TakeDamage", CBaseEntity_TakeDamage},
+  {"TakeHealth", CBaseEntity_TakeHealth},
+  {"Event_Killed", CBaseEntity_Event_Killed},
+  {"Event_KilledOther", CBaseEntity_Event_KilledOther},
+  {"IsTriggered", CBaseEntity_IsTriggered},
+  {"GetDelay", CBaseEntity_GetDelay},
+  {"IsMoving", CBaseEntity_IsMoving},
+  {"IsWorld", CBaseEntity_IsWorld},
+  {"AddPoints", CBaseEntity_AddPoints},
+  {"AddPointsToTeam", CBaseEntity_AddPointsToTeam},
+  {"OnControls", CBaseEntity_OnControls},
+  {"HasTarget", CBaseEntity_HasTarget},
+  {"IsNetClient", CBaseEntity_IsNetClient},
+  {"IsTemplate", CBaseEntity_IsTemplate},
+  {"IsViewable", CBaseEntity_IsViewable},
+  {"IsInAnyTeam", CBaseEntity_IsInAnyTeam},
+  {"TeamID", CBaseEntity_TeamID},
+  {"CanStandOn", CBaseEntity_CanStandOn},
+  {"GetEnemy", CBaseEntity_GetEnemy},
+  {"VelocityPunch", CBaseEntity_VelocityPunch},
+  {"GetNextTarget", CBaseEntity_GetNextTarget},
+  {"Use", CBaseEntity_Use},
+  {"StartTouch", CBaseEntity_StartTouch},
+  {"Touch", CBaseEntity_Touch},
+  {"EndTouch", CBaseEntity_EndTouch},
+  {"StartBlocked", CBaseEntity_StartBlocked},
+  {"Blocked", CBaseEntity_Blocked},
+  {"EndBlocked", CBaseEntity_EndBlocked},
+  {"PhysicsTouchTriggers", CBaseEntity_PhysicsTouchTriggers},
+  {"SUB_DoNothing", CBaseEntity_SUB_DoNothing},
+  {"SUB_StartFadeOut", CBaseEntity_SUB_StartFadeOut},
+  {"SUB_StartFadeOutInstant", CBaseEntity_SUB_StartFadeOutInstant},
+  {"SUB_FadeOut", CBaseEntity_SUB_FadeOut},
+  {"SUB_Vanish", CBaseEntity_SUB_Vanish},
+  {"SUB_CallUseToggle", CBaseEntity_SUB_CallUseToggle},
+  {"SUB_PerformFadeOut", CBaseEntity_SUB_PerformFadeOut},
+  {"SUB_AllowedToFade", CBaseEntity_SUB_AllowedToFade},
+  {"Teleport", CBaseEntity_Teleport},
+  {"ShouldToggle", CBaseEntity_ShouldToggle},
+  {"Respawn", CBaseEntity_Respawn},
+  {"TraceAttackToTriggers", CBaseEntity_TraceAttackToTriggers},
+  {"Intersects", CBaseEntity_Intersects},
+  {"IsLockedByMaster", CBaseEntity_IsLockedByMaster},
+  {"SetMaxHealth", CBaseEntity_SetMaxHealth},
+  {"DumpResponseCriteria", CBaseEntity_DumpResponseCriteria},
+  {"Create", CBaseEntity_Create},
+  {"CreateNoSpawn", CBaseEntity_CreateNoSpawn},
+  {"GetDamageType", CBaseEntity_GetDamageType},
+  {"GetDamage", CBaseEntity_GetDamage},
+  {"SetDamage", CBaseEntity_SetDamage},
+  {"BodyTarget", CBaseEntity_BodyTarget},
+  {"HeadTarget", CBaseEntity_HeadTarget},
+  {"GetSmoothedVelocity", CBaseEntity_GetSmoothedVelocity},
+  {"GetVelocity", CBaseEntity_GetVelocity},
+  {"GetFriction", CBaseEntity_GetFriction},
+  {"FVisible", CBaseEntity_FVisible},
+  {"GetReceivedDamageScale", CBaseEntity_GetReceivedDamageScale},
+  {"GetGroundVelocityToApply", CBaseEntity_GetGroundVelocityToApply},
+  {"PhysicsSplash", CBaseEntity_PhysicsSplash},
+  {"Splash", CBaseEntity_Splash},
+  {"ClearSolidFlags", CBaseEntity_ClearSolidFlags},
+  {"SetElasticity", CBaseEntity_SetElasticity},
+  {"SetShadowCastDistance", CBaseEntity_SetShadowCastDistance},
+  {"GetLocalTime", CBaseEntity_GetLocalTime},
+  {"IncrementLocalTime", CBaseEntity_IncrementLocalTime},
+  {"GetMoveDoneTime", CBaseEntity_GetMoveDoneTime},
+  {"SetMoveDoneTime", CBaseEntity_SetMoveDoneTime},
+  {"GetSoundEmissionOrigin", CBaseEntity_GetSoundEmissionOrigin},
+  {"IsItem", CBaseEntity_IsItem},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CBaseEntity object
+*/
+LUALIB_API int luaopen_CBaseEntity (lua_State *L) {
+  luaL_getmetatable(L, "CBaseEntity");
+  if (lua_isnoneornil(L, -1)) {
+    lua_pop(L, 1);
+    luaL_newmetatable(L, "CBaseEntity");
+  }
+  luaL_register(L, NULL, CBaseEntitymeta);
+  return 1;
+}
+
diff --git a/src/game/server/lbaseentity.h b/src/game/server/lbaseentity.h
new file mode 100644
index 0000000..c9ceab2
--- /dev/null
+++ b/src/game/server/lbaseentity.h
@@ -0,0 +1,17 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LBASEENTITY_H
+#define LBASEENTITY_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+LUALIB_API int luaopen_CBaseEntity(lua_State *L);
+
+
+#endif // LBASEENTITY_H
diff --git a/src/game/server/lentitylist.cpp b/src/game/server/lentitylist.cpp
new file mode 100644
index 0000000..4639ade
--- /dev/null
+++ b/src/game/server/lentitylist.cpp
@@ -0,0 +1,200 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define lentitylist_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lbaseentity_shared.h"
+#include "mathlib/lVector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int gEntList_AddPostClientMessageEntity (lua_State *L) {
+  gEntList.AddPostClientMessageEntity(luaL_checkentity(L, 1));
+  return 0;
+}
+
+static int gEntList_CleanupDeleteList (lua_State *L) {
+  gEntList.CleanupDeleteList();
+  return 0;
+}
+
+static int gEntList_Clear (lua_State *L) {
+  gEntList.Clear();
+  return 0;
+}
+
+static int gEntList_FindEntityByClassname (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityByClassname(lua_toentity(L, 1), luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int gEntList_FindEntityByClassnameNearest (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityByClassnameNearest(luaL_checkstring(L, 1), luaL_checkvector(L, 2), luaL_checknumber(L, 3), luaL_optint(L, 4, BRUSHPRECISION_NORMAL)));
+  return 1;
+}
+
+static int gEntList_FindEntityByClassnameWithin (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityByClassnameWithin(lua_toentity(L, 1), luaL_checkstring(L, 2), luaL_checkvector(L, 3), luaL_checknumber(L, 4), luaL_optint(L, 5, BRUSHPRECISION_NORMAL)));
+  return 1;
+}
+
+static int gEntList_FindEntityByModel (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityByModel(lua_toentity(L, 1), luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int gEntList_FindEntityByName (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityByName(lua_toentity(L, 1), luaL_checkstring(L, 2), luaL_optentity(L, 3, 0), luaL_optentity(L, 4, 0), luaL_optentity(L, 5, 0)));
+  return 1;
+}
+
+static int gEntList_FindEntityByNameNearest (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityByNameNearest(luaL_checkstring(L, 1), luaL_checkvector(L, 2), luaL_checknumber(L, 3), luaL_optentity(L, 4, 0), luaL_optentity(L, 5, 0), luaL_optentity(L, 6, 0), luaL_optint(L, 7, BRUSHPRECISION_NORMAL)));
+  return 1;
+}
+
+static int gEntList_FindEntityByNameWithin (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityByNameWithin(lua_toentity(L, 1), luaL_checkstring(L, 2), luaL_checkvector(L, 3), luaL_checknumber(L, 4), luaL_optentity(L, 5, 0), luaL_optentity(L, 6, 0), luaL_optentity(L, 7, 0), luaL_optint(L, 7, BRUSHPRECISION_NORMAL)));
+  return 1;
+}
+
+static int gEntList_FindEntityByTarget (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityByTarget(lua_toentity(L, 1), luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int gEntList_FindEntityClassNearestFacing (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityClassNearestFacing(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checknumber(L, 3), (char *)luaL_checkstring(L, 4)));
+  return 1;
+}
+
+static int gEntList_FindEntityGeneric (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityGeneric(lua_toentity(L, 1), luaL_checkstring(L, 2), luaL_optentity(L, 3, 0), luaL_optentity(L, 4, 0), luaL_optentity(L, 5, 0)));
+  return 1;
+}
+
+static int gEntList_FindEntityGenericNearest (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityGenericNearest(luaL_checkstring(L, 1), luaL_checkvector(L, 2), luaL_checknumber(L, 3), luaL_optentity(L, 4, 0), luaL_optentity(L, 5, 0), luaL_optentity(L, 6, 0), luaL_optint(L, 7, BRUSHPRECISION_NORMAL)));
+  return 1;
+}
+
+static int gEntList_FindEntityGenericWithin (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityGenericWithin(lua_toentity(L, 1), luaL_checkstring(L, 2), luaL_checkvector(L, 3), luaL_checknumber(L, 4), luaL_optentity(L, 5, 0), luaL_optentity(L, 6, 0), luaL_optentity(L, 7, 0), luaL_optint(L, 8, BRUSHPRECISION_NORMAL)));
+  return 1;
+}
+
+static int gEntList_FindEntityInSphere (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityInSphere(lua_toentity(L, 1), luaL_checkvector(L, 2), luaL_checknumber(L, 3)));
+  return 1;
+}
+
+static int gEntList_FindEntityNearestFacing (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityNearestFacing(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checknumber(L, 3)));
+  return 1;
+}
+
+static int gEntList_FindEntityProcedural (lua_State *L) {
+  lua_pushentity(L, gEntList.FindEntityProcedural(luaL_checkstring(L, 1), luaL_optentity(L, 2, 0), luaL_optentity(L, 3, 0), luaL_optentity(L, 4, 0)));
+  return 1;
+}
+
+static int gEntList_FirstEnt (lua_State *L) {
+  lua_pushentity(L, gEntList.FirstEnt());
+  return 1;
+}
+
+static int gEntList_IsClearingEntities (lua_State *L) {
+  lua_pushboolean(L, gEntList.IsClearingEntities());
+  return 1;
+}
+
+static int gEntList_NextEnt (lua_State *L) {
+  lua_pushentity(L, gEntList.NextEnt(lua_toentity(L, 1)));
+  return 1;
+}
+
+static int gEntList_NotifyCreateEntity (lua_State *L) {
+  gEntList.NotifyCreateEntity(luaL_checkentity(L, 1));
+  return 0;
+}
+
+static int gEntList_NotifySpawn (lua_State *L) {
+  gEntList.NotifySpawn(luaL_checkentity(L, 1));
+  return 0;
+}
+
+static int gEntList_NumberOfEdicts (lua_State *L) {
+  lua_pushinteger(L, gEntList.NumberOfEdicts());
+  return 1;
+}
+
+static int gEntList_NumberOfEntities (lua_State *L) {
+  lua_pushinteger(L, gEntList.NumberOfEntities());
+  return 1;
+}
+
+static int gEntList_PostClientMessagesSent (lua_State *L) {
+  gEntList.PostClientMessagesSent();
+  return 0;
+}
+
+static int gEntList_ReportEntityFlagsChanged (lua_State *L) {
+  gEntList.ReportEntityFlagsChanged(luaL_checkentity(L, 1), (unsigned int)luaL_checkinteger(L, 2), (unsigned int)luaL_checkinteger(L, 3));
+  return 0;
+}
+
+static int gEntList_ResetDeleteList (lua_State *L) {
+  lua_pushinteger(L, gEntList.ResetDeleteList());
+  return 1;
+}
+
+
+static const luaL_Reg gEntListlib[] = {
+  {"AddPostClientMessageEntity",   gEntList_AddPostClientMessageEntity},
+  {"CleanupDeleteList",   gEntList_CleanupDeleteList},
+  {"Clear",   gEntList_Clear},
+  {"FindEntityByClassname",   gEntList_FindEntityByClassname},
+  {"FindEntityByClassnameNearest",   gEntList_FindEntityByClassnameNearest},
+  {"FindEntityByClassnameWithin",   gEntList_FindEntityByClassnameWithin},
+  {"FindEntityByModel",   gEntList_FindEntityByModel},
+  {"FindEntityByName",   gEntList_FindEntityByName},
+  {"FindEntityByNameNearest",   gEntList_FindEntityByNameNearest},
+  {"FindEntityByNameWithin",   gEntList_FindEntityByNameWithin},
+  {"FindEntityByTarget",   gEntList_FindEntityByTarget},
+  {"FindEntityClassNearestFacing",   gEntList_FindEntityClassNearestFacing},
+  {"FindEntityGeneric",   gEntList_FindEntityGeneric},
+  {"FindEntityGenericNearest",   gEntList_FindEntityGenericNearest},
+  {"FindEntityGenericWithin",   gEntList_FindEntityGenericWithin},
+  {"FindEntityInSphere",   gEntList_FindEntityInSphere},
+  {"FindEntityNearestFacing",   gEntList_FindEntityNearestFacing},
+  {"FindEntityProcedural",   gEntList_FindEntityProcedural},
+  {"FirstEnt",   gEntList_FirstEnt},
+  {"IsClearingEntities",   gEntList_IsClearingEntities},
+  {"NextEnt",   gEntList_NextEnt},
+  {"NotifyCreateEntity",   gEntList_NotifyCreateEntity},
+  {"NotifySpawn",   gEntList_NotifySpawn},
+  {"NumberOfEdicts",   gEntList_NumberOfEdicts},
+  {"NumberOfEntities",   gEntList_NumberOfEntities},
+  {"PostClientMessagesSent",   gEntList_PostClientMessagesSent},
+  {"ReportEntityFlagsChanged",   gEntList_ReportEntityFlagsChanged},
+  {"ResetDeleteList",   gEntList_ResetDeleteList},
+  {NULL, NULL}
+};
+
+
+/*
+** Open gEntList library
+*/
+LUALIB_API int luaopen_gEntList (lua_State *L) {
+  luaL_register(L, LUA_ENTLISTLIBNAME, gEntListlib);
+  return 1;
+}
+
diff --git a/src/game/server/lplayer.cpp b/src/game/server/lplayer.cpp
new file mode 100644
index 0000000..f6a385c
--- /dev/null
+++ b/src/game/server/lplayer.cpp
@@ -0,0 +1,609 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: Functions dealing with the player.
+//
+//===========================================================================//
+
+#define lplayer_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "lbasecombatweapon_shared.h"
+#include "lbaseentity_shared.h"
+#include "lbaseplayer_shared.h"
+#include "ltakedamageinfo.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int CBasePlayer_GiveAmmo (lua_State *L) {
+  switch(lua_type(L, 3)) {
+    case LUA_TNUMBER:
+      lua_pushinteger(L, luaL_checkplayer(L, 1)->GiveAmmo(luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_optboolean(L, 4, false)));
+      break;
+    case LUA_TSTRING:
+      lua_pushinteger(L, luaL_checkplayer(L, 1)->GiveAmmo(luaL_checkint(L, 2), luaL_checkstring(L, 3), luaL_optboolean(L, 4, false)));
+      break;
+    default:
+      lua_pushinteger(L, luaL_checkplayer(L, 1)->GiveAmmo(luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_optboolean(L, 4, false)));
+      break;
+  }
+  return 1;
+}
+
+static int CBasePlayer_SetBodyPitch (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetBodyPitch(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_CreateViewModel (lua_State *L) {
+  luaL_checkplayer(L, 1)->CreateViewModel(luaL_optinteger(L, 2, 0));
+  return 0;
+}
+
+static int CBasePlayer_HideViewModels (lua_State *L) {
+  luaL_checkplayer(L, 1)->HideViewModels();
+  return 0;
+}
+
+static int CBasePlayer_DestroyViewModels (lua_State *L) {
+  luaL_checkplayer(L, 1)->DestroyViewModels();
+  return 0;
+}
+
+static int CBasePlayer_RequiredEdictIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->RequiredEdictIndex());
+  return 1;
+}
+
+static int CBasePlayer_LockPlayerInPlace (lua_State *L) {
+  luaL_checkplayer(L, 1)->LockPlayerInPlace();
+  return 0;
+}
+
+static int CBasePlayer_UnlockPlayer (lua_State *L) {
+  luaL_checkplayer(L, 1)->UnlockPlayer();
+  return 0;
+}
+
+static int CBasePlayer_DrawDebugGeometryOverlays (lua_State *L) {
+  luaL_checkplayer(L, 1)->DrawDebugGeometryOverlays();
+  return 0;
+}
+
+static int CBasePlayer_UpdateTransmitState (lua_State *L) {
+  luaL_checkplayer(L, 1)->UpdateTransmitState();
+  return 0;
+}
+
+static int CBasePlayer_ForceRespawn (lua_State *L) {
+  luaL_checkplayer(L, 1)->ForceRespawn();
+  return 0;
+}
+
+static int CBasePlayer_InitialSpawn (lua_State *L) {
+  luaL_checkplayer(L, 1)->InitialSpawn();
+  return 0;
+}
+
+static int CBasePlayer_InitHUD (lua_State *L) {
+  luaL_checkplayer(L, 1)->InitHUD();
+  return 0;
+}
+
+static int CBasePlayer_PlayerDeathThink (lua_State *L) {
+  luaL_checkplayer(L, 1)->PlayerDeathThink();
+  return 0;
+}
+
+static int CBasePlayer_Jump (lua_State *L) {
+  luaL_checkplayer(L, 1)->Jump();
+  return 0;
+}
+
+static int CBasePlayer_Duck (lua_State *L) {
+  luaL_checkplayer(L, 1)->Duck();
+  return 0;
+}
+
+static int CBasePlayer_ForceSimulation (lua_State *L) {
+  luaL_checkplayer(L, 1)->ForceSimulation();
+  return 0;
+}
+
+static int CBasePlayer_TakeHealth (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->TakeHealth(luaL_checknumber(L, 2), luaL_checkinteger(L, 3)));
+  return 1;
+}
+
+static int CBasePlayer_DamageEffect (lua_State *L) {
+  luaL_checkplayer(L, 1)->DamageEffect(luaL_checknumber(L, 2), luaL_checkinteger(L, 3));
+  return 0;
+}
+
+static int CBasePlayer_PauseBonusProgress (lua_State *L) {
+  luaL_checkplayer(L, 1)->PauseBonusProgress(luaL_optboolean(L, 2, true));
+  return 0;
+}
+
+static int CBasePlayer_SetBonusProgress (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetBonusProgress(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SetBonusChallenge (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetBonusChallenge(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_GetBonusProgress (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetBonusProgress());
+  return 1;
+}
+
+static int CBasePlayer_GetBonusChallenge (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetBonusChallenge());
+  return 1;
+}
+
+static int CBasePlayer_SnapEyeAngles (lua_State *L) {
+  luaL_checkplayer(L, 1)->SnapEyeAngles(luaL_checkangle(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_BodyAngles (lua_State *L) {
+  lua_pushangle(L, luaL_checkplayer(L, 1)->BodyAngles());
+  return 1;
+}
+
+static int CBasePlayer_BodyTarget (lua_State *L) {
+  lua_pushvector(L, luaL_checkplayer(L, 1)->BodyTarget(luaL_checkvector(L, 2), luaL_checkboolean(L, 3)));
+  return 1;
+}
+
+static int CBasePlayer_ShouldFadeOnDeath (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->ShouldFadeOnDeath());
+  return 1;
+}
+
+static int CBasePlayer_OnTakeDamage_Alive (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->OnTakeDamage_Alive(luaL_checkdamageinfo(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_Event_Killed (lua_State *L) {
+  luaL_checkplayer(L, 1)->Event_Killed(luaL_checkdamageinfo(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_Event_KilledOther (lua_State *L) {
+  luaL_checkplayer(L, 1)->Event_KilledOther(luaL_checkentity(L, 2), luaL_checkdamageinfo(L, 3));
+  return 0;
+}
+
+static int CBasePlayer_Event_Dying (lua_State *L) {
+  luaL_checkplayer(L, 1)->Event_Dying();
+  return 0;
+}
+
+static int CBasePlayer_IsNetClient (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsNetClient());
+  return 1;
+}
+
+static int CBasePlayer_IsFakeClient (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsFakeClient());
+  return 1;
+}
+
+static int CBasePlayer_GetClientIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetClientIndex());
+  return 1;
+}
+
+static int CBasePlayer_SetPlayerName (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetPlayerName(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_GetNetworkIDString (lua_State *L) {
+  lua_pushstring(L, luaL_checkplayer(L, 1)->GetNetworkIDString());
+  return 1;
+}
+
+static int CBasePlayer_ShowViewModel (lua_State *L) {
+  luaL_checkplayer(L, 1)->ShowViewModel(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_ShowCrosshair (lua_State *L) {
+  luaL_checkplayer(L, 1)->ShowCrosshair(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_PackDeadPlayerItems (lua_State *L) {
+  luaL_checkplayer(L, 1)->PackDeadPlayerItems();
+  return 0;
+}
+
+static int CBasePlayer_RemoveAllItems (lua_State *L) {
+  luaL_checkplayer(L, 1)->RemoveAllItems(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_IsDead (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsDead());
+  return 1;
+}
+
+static int CBasePlayer_HasPhysicsFlag (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->HasPhysicsFlag(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_Weapon_CanUse (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->Weapon_CanUse(luaL_checkweapon(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_Weapon_Equip (lua_State *L) {
+  luaL_checkplayer(L, 1)->Weapon_Equip(luaL_checkweapon(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_Weapon_Drop (lua_State *L) {
+  luaL_checkplayer(L, 1)->Weapon_Drop(luaL_checkweapon(L, 2), &luaL_optvector(L, 3, NULL), &luaL_optvector(L, 4, NULL));
+  return 0;
+}
+
+static int CBasePlayer_Weapon_DropSlot (lua_State *L) {
+  luaL_checkplayer(L, 1)->Weapon_DropSlot(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_Weapon_GetLast (lua_State *L) {
+  lua_pushweapon(L, luaL_checkplayer(L, 1)->Weapon_GetLast());
+  return 1;
+}
+
+static int CBasePlayer_HasAnyAmmoOfType (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->HasAnyAmmoOfType(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_RumbleEffect (lua_State *L) {
+  luaL_checkplayer(L, 1)->RumbleEffect(luaL_checkinteger(L, 2), luaL_checkinteger(L, 3), luaL_checkinteger(L, 4));
+  return 0;
+}
+
+static int CBasePlayer_IsOnLadder (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsOnLadder());
+  return 1;
+}
+
+static int CBasePlayer_SetFlashlightEnabled (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetFlashlightEnabled(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_FlashlightIsOn (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->FlashlightIsOn());
+  return 1;
+}
+
+static int CBasePlayer_FlashlightTurnOn (lua_State *L) {
+  luaL_checkplayer(L, 1)->FlashlightTurnOn();
+  return 0;
+}
+
+static int CBasePlayer_FlashlightTurnOff (lua_State *L) {
+  luaL_checkplayer(L, 1)->FlashlightTurnOff();
+  return 0;
+}
+
+static int CBasePlayer_IsIlluminatedByFlashlight (lua_State *L) {
+  float flDot;
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsIlluminatedByFlashlight(luaL_checkentity(L, 2), &flDot));
+  lua_pushnumber(L, flDot);
+  return 2;
+}
+
+static int CBasePlayer_UpdatePlayerSound (lua_State *L) {
+  luaL_checkplayer(L, 1)->UpdatePlayerSound();
+  return 0;
+}
+
+static int CBasePlayer_DeathSound (lua_State *L) {
+  luaL_checkplayer(L, 1)->DeathSound(luaL_checkdamageinfo(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_Classify (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->Classify());
+  return 1;
+}
+
+static int CBasePlayer_SetWeaponAnimType (lua_State *L) {
+  // Huh?
+  // luaL_checkplayer(L, 1)->SetWeaponAnimType(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_ImpulseCommands (lua_State *L) {
+  luaL_checkplayer(L, 1)->ImpulseCommands();
+  return 0;
+}
+
+static int CBasePlayer_CheatImpulseCommands (lua_State *L) {
+  luaL_checkplayer(L, 1)->CheatImpulseCommands(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_NotifySinglePlayerGameEnding (lua_State *L) {
+  luaL_checkplayer(L, 1)->NotifySinglePlayerGameEnding();
+  return 0;
+}
+
+static int CBasePlayer_IsSinglePlayerGameEnding (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsSinglePlayerGameEnding());
+  return 1;
+}
+
+static int CBasePlayer_StartObserverMode (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->StartObserverMode(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_StopObserverMode (lua_State *L) {
+  luaL_checkplayer(L, 1)->StopObserverMode();
+  return 0;
+}
+
+static int CBasePlayer_ModeWantsSpectatorGUI (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->ModeWantsSpectatorGUI(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_FindNextObserverTarget (lua_State *L) {
+  lua_pushentity(L, luaL_checkplayer(L, 1)->FindNextObserverTarget(luaL_checkboolean(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_GetNextObserverSearchStartPoint (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetNextObserverSearchStartPoint(luaL_checkboolean(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_IsValidObserverTarget (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsValidObserverTarget(luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_CheckObserverSettings (lua_State *L) {
+  luaL_checkplayer(L, 1)->CheckObserverSettings();
+  return 0;
+}
+
+static int CBasePlayer_JumptoPosition (lua_State *L) {
+  luaL_checkplayer(L, 1)->JumptoPosition(luaL_checkvector(L, 2), luaL_checkangle(L, 3));
+  return 0;
+}
+
+static int CBasePlayer_ForceObserverMode (lua_State *L) {
+  luaL_checkplayer(L, 1)->ForceObserverMode(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_ValidateCurrentObserverTarget (lua_State *L) {
+  luaL_checkplayer(L, 1)->ValidateCurrentObserverTarget();
+  return 0;
+}
+
+static int CBasePlayer_StartReplayMode (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->StartReplayMode(luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checkinteger(L, 4)));
+  return 1;
+}
+
+static int CBasePlayer_StopReplayMode (lua_State *L) {
+  luaL_checkplayer(L, 1)->StopReplayMode();
+  return 0;
+}
+
+static int CBasePlayer_GetDelayTicks (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetDelayTicks());
+  return 1;
+}
+
+static int CBasePlayer_GetReplayEntity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetReplayEntity());
+  return 1;
+}
+
+static int CBasePlayer_CreateCorpse (lua_State *L) {
+  luaL_checkplayer(L, 1)->CreateCorpse();
+  return 0;
+}
+
+static int CBasePlayer_EntSelectSpawnPoint (lua_State *L) {
+  lua_pushentity(L, luaL_checkplayer(L, 1)->EntSelectSpawnPoint());
+  return 1;
+}
+
+static int CBasePlayer_GetVehicleAnalogControlBias (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetVehicleAnalogControlBias());
+  return 1;
+}
+
+static int CBasePlayer_SetVehicleAnalogControlBias (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetVehicleAnalogControlBias(luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_OnVehicleStart (lua_State *L) {
+  luaL_checkplayer(L, 1)->OnVehicleStart();
+  return 0;
+}
+
+static int CBasePlayer_GetVehicleEntity (lua_State *L) {
+  lua_pushentity(L, luaL_checkplayer(L, 1)->GetVehicleEntity());
+  return 1;
+}
+
+static int CBasePlayer_BumpWeapon (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->BumpWeapon(luaL_checkweapon(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_RemovePlayerItem (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->RemovePlayerItem(luaL_checkweapon(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_HasNamedPlayerItem (lua_State *L) {
+  lua_pushentity(L, luaL_checkplayer(L, 1)->HasNamedPlayerItem(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_HasWeapons (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->HasWeapons());
+  return 1;
+}
+
+static int CBasePlayer_GiveNamedItem (lua_State *L) {
+  lua_pushentity(L, luaL_checkplayer(L, 1)->GiveNamedItem(luaL_checkstring(L, 2), luaL_optinteger(L, 3, 0)));
+  return 1;
+}
+
+static int CBasePlayer_EnableControl (lua_State *L) {
+  luaL_checkplayer(L, 1)->EnableControl(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_CheckTrainUpdate (lua_State *L) {
+  luaL_checkplayer(L, 1)->CheckTrainUpdate();
+  return 0;
+}
+
+static int CBasePlayer_EquipSuit (lua_State *L) {
+  luaL_checkplayer(L, 1)->EquipSuit(luaL_optboolean(L, 2, true));
+  return 0;
+}
+
+static int CBasePlayer_RemoveSuit (lua_State *L) {
+  luaL_checkplayer(L, 1)->RemoveSuit();
+  return 0;
+}
+
+
+static const luaL_Reg CBasePlayermeta[] = {
+  {"GiveAmmo", CBasePlayer_GiveAmmo},
+  {"SetBodyPitch", CBasePlayer_SetBodyPitch},
+  {"CreateViewModel", CBasePlayer_CreateViewModel},
+  {"HideViewModels", CBasePlayer_HideViewModels},
+  {"DestroyViewModels", CBasePlayer_DestroyViewModels},
+  {"RequiredEdictIndex", CBasePlayer_RequiredEdictIndex},
+  {"LockPlayerInPlace", CBasePlayer_LockPlayerInPlace},
+  {"UnlockPlayer", CBasePlayer_UnlockPlayer},
+  {"DrawDebugGeometryOverlays", CBasePlayer_DrawDebugGeometryOverlays},
+  {"UpdateTransmitState", CBasePlayer_UpdateTransmitState},
+  {"ForceRespawn", CBasePlayer_ForceRespawn},
+  {"InitialSpawn", CBasePlayer_InitialSpawn},
+  {"InitHUD", CBasePlayer_InitHUD},
+  {"PlayerDeathThink", CBasePlayer_PlayerDeathThink},
+  {"Jump", CBasePlayer_Jump},
+  {"Duck", CBasePlayer_Duck},
+  {"ForceSimulation", CBasePlayer_ForceSimulation},
+  {"TakeHealth", CBasePlayer_TakeHealth},
+  {"DamageEffect", CBasePlayer_DamageEffect},
+  {"PauseBonusProgress", CBasePlayer_PauseBonusProgress},
+  {"SetBonusProgress", CBasePlayer_SetBonusProgress},
+  {"SetBonusChallenge", CBasePlayer_SetBonusChallenge},
+  {"GetBonusProgress", CBasePlayer_GetBonusProgress},
+  {"GetBonusChallenge", CBasePlayer_GetBonusChallenge},
+  {"SnapEyeAngles", CBasePlayer_SnapEyeAngles},
+  {"BodyAngles", CBasePlayer_BodyAngles},
+  {"BodyTarget", CBasePlayer_BodyTarget},
+  {"ShouldFadeOnDeath", CBasePlayer_ShouldFadeOnDeath},
+  {"OnTakeDamage_Alive", CBasePlayer_OnTakeDamage_Alive},
+  {"Event_Killed", CBasePlayer_Event_Killed},
+  {"Event_KilledOther", CBasePlayer_Event_KilledOther},
+  {"Event_Dying", CBasePlayer_Event_Dying},
+  {"IsNetClient", CBasePlayer_IsNetClient},
+  {"IsFakeClient", CBasePlayer_IsFakeClient},
+  {"GetClientIndex", CBasePlayer_GetClientIndex},
+  {"SetPlayerName", CBasePlayer_SetPlayerName},
+  {"GetNetworkIDString", CBasePlayer_GetNetworkIDString},
+  {"ShowViewModel", CBasePlayer_ShowViewModel},
+  {"ShowCrosshair", CBasePlayer_ShowCrosshair},
+  {"PackDeadPlayerItems", CBasePlayer_PackDeadPlayerItems},
+  {"RemoveAllItems", CBasePlayer_RemoveAllItems},
+  {"IsDead", CBasePlayer_IsDead},
+  {"HasPhysicsFlag", CBasePlayer_HasPhysicsFlag},
+  {"Weapon_CanUse", CBasePlayer_Weapon_CanUse},
+  {"Weapon_Equip", CBasePlayer_Weapon_Equip},
+  {"Weapon_Drop", CBasePlayer_Weapon_Drop},
+  {"Weapon_DropSlot", CBasePlayer_Weapon_DropSlot},
+  {"Weapon_GetLast", CBasePlayer_Weapon_GetLast},
+  {"HasAnyAmmoOfType", CBasePlayer_HasAnyAmmoOfType},
+  {"RumbleEffect", CBasePlayer_RumbleEffect},
+  {"IsOnLadder", CBasePlayer_IsOnLadder},
+  {"SetFlashlightEnabled", CBasePlayer_SetFlashlightEnabled},
+  {"FlashlightIsOn", CBasePlayer_FlashlightIsOn},
+  {"FlashlightTurnOn", CBasePlayer_FlashlightTurnOn},
+  {"FlashlightTurnOff", CBasePlayer_FlashlightTurnOff},
+  {"IsIlluminatedByFlashlight", CBasePlayer_IsIlluminatedByFlashlight},
+  {"UpdatePlayerSound", CBasePlayer_UpdatePlayerSound},
+  {"DeathSound", CBasePlayer_DeathSound},
+  {"Classify", CBasePlayer_Classify},
+  {"SetWeaponAnimType", CBasePlayer_SetWeaponAnimType},
+  {"ImpulseCommands", CBasePlayer_ImpulseCommands},
+  {"CheatImpulseCommands", CBasePlayer_CheatImpulseCommands},
+  {"NotifySinglePlayerGameEnding", CBasePlayer_NotifySinglePlayerGameEnding},
+  {"IsSinglePlayerGameEnding", CBasePlayer_IsSinglePlayerGameEnding},
+  {"StartObserverMode", CBasePlayer_StartObserverMode},
+  {"StopObserverMode", CBasePlayer_StopObserverMode},
+  {"ModeWantsSpectatorGUI", CBasePlayer_ModeWantsSpectatorGUI},
+  {"FindNextObserverTarget", CBasePlayer_FindNextObserverTarget},
+  {"GetNextObserverSearchStartPoint", CBasePlayer_GetNextObserverSearchStartPoint},
+  {"IsValidObserverTarget", CBasePlayer_IsValidObserverTarget},
+  {"CheckObserverSettings", CBasePlayer_CheckObserverSettings},
+  {"JumptoPosition", CBasePlayer_JumptoPosition},
+  {"ForceObserverMode", CBasePlayer_ForceObserverMode},
+  {"ValidateCurrentObserverTarget", CBasePlayer_ValidateCurrentObserverTarget},
+  {"StartReplayMode", CBasePlayer_StartReplayMode},
+  {"StopReplayMode", CBasePlayer_StopReplayMode},
+  {"GetDelayTicks", CBasePlayer_GetDelayTicks},
+  {"GetReplayEntity", CBasePlayer_GetReplayEntity},
+  {"CreateCorpse", CBasePlayer_CreateCorpse},
+  {"EntSelectSpawnPoint", CBasePlayer_EntSelectSpawnPoint},
+  {"GetVehicleAnalogControlBias", CBasePlayer_GetVehicleAnalogControlBias},
+  {"SetVehicleAnalogControlBias", CBasePlayer_SetVehicleAnalogControlBias},
+  {"OnVehicleStart", CBasePlayer_OnVehicleStart},
+  {"GetVehicleEntity", CBasePlayer_GetVehicleEntity},
+  {"BumpWeapon", CBasePlayer_BumpWeapon},
+  {"RemovePlayerItem", CBasePlayer_RemovePlayerItem},
+  {"HasNamedPlayerItem", CBasePlayer_HasNamedPlayerItem},
+  {"HasWeapons", CBasePlayer_HasWeapons},
+  {"GiveNamedItem", CBasePlayer_GiveNamedItem},
+  {"EnableControl", CBasePlayer_EnableControl},
+  {"CheckTrainUpdate", CBasePlayer_CheckTrainUpdate},
+  {"EquipSuit", CBasePlayer_EquipSuit},
+  {"RemoveSuit", CBasePlayer_RemoveSuit},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CBasePlayer object
+*/
+LUALIB_API int luaopen_CBasePlayer (lua_State *L) {
+  luaL_getmetatable(L, "CBasePlayer");
+  if (lua_isnoneornil(L, -1)) {
+    lua_pop(L, 1);
+    luaL_newmetatable(L, "CBasePlayer");
+  }
+  luaL_register(L, NULL, CBasePlayermeta);
+  return 1;
+}
+
diff --git a/src/game/server/lrecipientfilter.cpp b/src/game/server/lrecipientfilter.cpp
new file mode 100644
index 0000000..bdcb99f
--- /dev/null
+++ b/src/game/server/lrecipientfilter.cpp
@@ -0,0 +1,292 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+#define lrecipientfilter_cpp
+
+#include "cbase.h"
+#include "recipientfilter.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lrecipientfilter.h"
+#include "lbaseplayer_shared.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static lua_CRecipientFilter *s_pFilter = new CRecipientFilter();
+static lua_CPASFilter *s_pPASFilter = new CPASFilter();
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CRecipientFilter &lua_torecipientfilter (lua_State *L, int idx) {
+  lua_CRecipientFilter **ppFilter = (lua_CRecipientFilter **)lua_touserdata(L, idx);
+  return **ppFilter;
+}
+
+
+LUA_API lua_CPASFilter &lua_topasfilter (lua_State *L, int idx) {
+  lua_CPASFilter **ppFilter = (lua_CPASFilter **)lua_touserdata(L, idx);
+  return **ppFilter;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushrecipientfilter (lua_State *L, lua_CRecipientFilter &filter) {
+  lua_CRecipientFilter **ppFilter = (lua_CRecipientFilter **)lua_newuserdata(L, sizeof(lua_CRecipientFilter));
+  s_pFilter->Reset();
+  s_pFilter->CopyFrom(filter);
+  *ppFilter = s_pFilter;
+  luaL_getmetatable(L, "CRecipientFilter");
+  lua_setmetatable(L, -2);
+}
+
+
+LUA_API void lua_pushpasfilter (lua_State *L, lua_CPASFilter &filter) {
+  lua_CPASFilter **ppFilter = (lua_CPASFilter **)lua_newuserdata(L, sizeof(lua_CPASFilter));
+  s_pPASFilter->Reset();
+  s_pPASFilter->CopyFrom(filter);
+  *ppFilter = s_pPASFilter;
+  luaL_getmetatable(L, "CPASFilter");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CRecipientFilter &luaL_checkrecipientfilter (lua_State *L, int narg) {
+  lua_CRecipientFilter *d = (lua_CRecipientFilter *)lua_touserdata(L, narg);
+  if (!d)
+    luaL_typerror(L, narg, "CRecipientFilter");
+  return **(lua_CRecipientFilter **)d;
+}
+
+
+LUALIB_API lua_CPASFilter &luaL_checkpasfilter (lua_State *L, int narg) {
+  lua_CPASFilter **d = (lua_CPASFilter **)luaL_checkudata(L, narg, "CPASFilter");
+  return **d;
+}
+
+
+static int CRecipientFilter_AddAllPlayers (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).AddAllPlayers();
+  return 0;
+}
+
+static int CRecipientFilter_AddRecipient (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).AddRecipient(luaL_checkplayer(L, 2));
+  return 0;
+}
+
+static int CRecipientFilter_AddRecipientsByPAS (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).AddRecipientsByPAS(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CRecipientFilter_AddRecipientsByPVS (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).AddRecipientsByPVS(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CRecipientFilter_CopyFrom (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).CopyFrom(luaL_checkrecipientfilter(L, 2));
+  return 0;
+}
+
+static int CRecipientFilter_GetRecipientCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkrecipientfilter(L, 1).GetRecipientCount());
+  return 1;
+}
+
+static int CRecipientFilter_GetRecipientIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkrecipientfilter(L, 1).GetRecipientIndex(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CRecipientFilter_IgnorePredictionCull (lua_State *L) {
+  lua_pushboolean(L, luaL_checkrecipientfilter(L, 1).IgnorePredictionCull());
+  return 1;
+}
+
+static int CRecipientFilter_IsInitMessage (lua_State *L) {
+  lua_pushboolean(L, luaL_checkrecipientfilter(L, 1).IsInitMessage());
+  return 1;
+}
+
+static int CRecipientFilter_IsReliable (lua_State *L) {
+  lua_pushboolean(L, luaL_checkrecipientfilter(L, 1).IsReliable());
+  return 1;
+}
+
+static int CRecipientFilter_IsUsingPredictionRules (lua_State *L) {
+  lua_pushboolean(L, luaL_checkrecipientfilter(L, 1).IsUsingPredictionRules());
+  return 1;
+}
+
+static int CRecipientFilter_MakeInitMessage (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).MakeInitMessage();
+  return 0;
+}
+
+static int CRecipientFilter_MakeReliable (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).MakeReliable();
+  return 0;
+}
+
+static int CRecipientFilter_RemoveAllRecipients (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).RemoveAllRecipients();
+  return 0;
+}
+
+static int CRecipientFilter_RemoveRecipient (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).RemoveRecipient(luaL_checkplayer(L, 2));
+  return 0;
+}
+
+static int CRecipientFilter_RemoveRecipientByPlayerIndex (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).RemoveRecipientByPlayerIndex(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CRecipientFilter_RemoveRecipientsByPVS (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).RemoveRecipientsByPVS(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CRecipientFilter_Reset (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).Reset();
+  return 0;
+}
+
+static int CRecipientFilter_SetIgnorePredictionCull (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).SetIgnorePredictionCull(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CRecipientFilter_UsePredictionRules (lua_State *L) {
+  luaL_checkrecipientfilter(L, 1).UsePredictionRules();
+  return 0;
+}
+
+static int CRecipientFilter___tostring (lua_State *L) {
+  lua_pushfstring(L, "CRecipientFilter: %p", luaL_checkudata(L, 1, "CRecipientFilter"));
+  return 1;
+}
+
+
+static const luaL_Reg CRecipientFiltermeta[] = {
+  {"AddAllPlayers", CRecipientFilter_AddAllPlayers},
+  {"AddRecipient", CRecipientFilter_AddRecipient},
+  {"AddRecipientsByPAS", CRecipientFilter_AddRecipientsByPAS},
+  {"AddRecipientsByPVS", CRecipientFilter_AddRecipientsByPVS},
+  {"CopyFrom", CRecipientFilter_CopyFrom},
+  {"GetRecipientCount", CRecipientFilter_GetRecipientCount},
+  {"GetRecipientIndex", CRecipientFilter_GetRecipientIndex},
+  {"IgnorePredictionCull", CRecipientFilter_IgnorePredictionCull},
+  {"IsInitMessage", CRecipientFilter_IsInitMessage},
+  {"IsReliable", CRecipientFilter_IsReliable},
+  {"IsUsingPredictionRules", CRecipientFilter_IsUsingPredictionRules},
+  {"MakeInitMessage", CRecipientFilter_MakeInitMessage},
+  {"MakeReliable", CRecipientFilter_MakeReliable},
+  {"RemoveAllRecipients", CRecipientFilter_RemoveAllRecipients},
+  {"RemoveRecipient", CRecipientFilter_RemoveRecipient},
+  {"RemoveRecipientByPlayerIndex", CRecipientFilter_RemoveRecipientByPlayerIndex},
+  {"RemoveRecipientsByPVS", CRecipientFilter_RemoveRecipientsByPVS},
+  {"Reset", CRecipientFilter_Reset},
+  {"SetIgnorePredictionCull", CRecipientFilter_SetIgnorePredictionCull},
+  {"UsePredictionRules", CRecipientFilter_UsePredictionRules},
+  {"__tostring", CRecipientFilter___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_CRecipientFilter (lua_State *L) {
+  CRecipientFilter filter;
+  lua_pushrecipientfilter(L, filter);
+  return 1;
+}
+
+
+static const luaL_Reg CRecipientFilter_funcs[] = {
+  {"CRecipientFilter", luasrc_CRecipientFilter},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CRecipientFilter object
+*/
+LUALIB_API int luaopen_CRecipientFilter (lua_State *L) {
+  luaL_newmetatable(L, LUA_RECIPIENTFILTERLIBNAME);
+  luaL_register(L, NULL, CRecipientFiltermeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "recipientfilter");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "recipientfilter" */
+  luaL_register(L, "_G", CRecipientFilter_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
+
+static int CPASFilter___index (lua_State *L) {
+  lua_getmetatable(L, 1);
+  lua_pushvalue(L, 2);
+  lua_gettable(L, -2);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 2);
+    luaL_getmetatable(L, "CRecipientFilter");
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+  }
+  return 1;
+}
+
+static int CPASFilter___tostring (lua_State *L) {
+  lua_pushfstring(L, "CPASFilter: %p", luaL_checkudata(L, 1, "CPASFilter"));
+  return 1;
+}
+
+
+static const luaL_Reg CPASFiltermeta[] = {
+  {"__index", CPASFilter___index},
+  {"__tostring", CPASFilter___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_CPASFilter (lua_State *L) {
+  CPASFilter filter(luaL_checkvector(L, 1));
+  lua_pushpasfilter(L, filter);
+  return 1;
+}
+
+
+static const luaL_Reg CPASFilter_funcs[] = {
+  {"CPASFilter", luasrc_CPASFilter},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CPASFilter object
+*/
+LUALIB_API int luaopen_CPASFilter (lua_State *L) {
+  luaL_newmetatable(L, LUA_PASFILTERLIBNAME);
+  luaL_register(L, NULL, CPASFiltermeta);
+  lua_pushstring(L, "recipientfilter");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "recipientfilter" */
+  luaL_register(L, "_G", CPASFilter_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
\ No newline at end of file
diff --git a/src/game/server/lrecipientfilter.h b/src/game/server/lrecipientfilter.h
new file mode 100644
index 0000000..1fd05b4
--- /dev/null
+++ b/src/game/server/lrecipientfilter.h
@@ -0,0 +1,43 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LRECIPIENTFILTER_H
+#define LRECIPIENTFILTER_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for CRecipientFilter functions */
+typedef CRecipientFilter lua_CRecipientFilter;
+
+
+/* type for CPASFilter functions */
+typedef CPASFilter lua_CPASFilter;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CRecipientFilter     &(lua_torecipientfilter) (lua_State *L, int idx);
+LUA_API lua_CPASFilter     &(lua_topasfilter) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushrecipientfilter) (lua_State *L, lua_CRecipientFilter &filter);
+LUA_API void  (lua_pushpasfilter) (lua_State *L, lua_CPASFilter &filter);
+
+
+
+LUALIB_API lua_CRecipientFilter &(luaL_checkrecipientfilter) (lua_State *L, int narg);
+LUALIB_API lua_CPASFilter &(luaL_checkpasfilter) (lua_State *L, int narg);
+
+
+#endif // LRECIPIENTFILTER_H
diff --git a/src/game/server/lutil.cpp b/src/game/server/lutil.cpp
new file mode 100644
index 0000000..9dd9fa5
--- /dev/null
+++ b/src/game/server/lutil.cpp
@@ -0,0 +1,521 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Utility code.
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define lutil_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "lbaseentity_shared.h"
+#include "lbaseplayer_shared.h"
+#include "lgametrace.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int luasrc_CanCreateEntityClass (lua_State *L) {
+  lua_pushboolean(L, CanCreateEntityClass(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int luasrc_ENTINDEX (lua_State *L) {
+  lua_pushinteger(L, ENTINDEX(luaL_checkentity(L, 1)));
+  return 1;
+}
+
+static int luasrc_INDEXENT (lua_State *L) {
+  CBaseEntity *pEntity = CBaseEntity::Instance(INDEXENT(luaL_checkinteger(L, 1)));
+  lua_pushentity(L, pEntity);
+  return 1;
+}
+
+static int luasrc_FNullEnt (lua_State *L) {
+  lua_pushboolean(L, FNullEnt(luaL_checkentity(L, 1)->edict()));
+  return 1;
+}
+
+static int luasrc_FStrEq (lua_State *L) {
+  lua_pushboolean(L, FStrEq(luaL_checkstring(L, 1), luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int luasrc_UTIL_SetSize (lua_State *L) {
+  UTIL_SetSize(luaL_checkentity(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int luasrc_UTIL_ClearTrace (lua_State *L) {
+  UTIL_ClearTrace(luaL_checktrace(L, 1));
+  return 0;
+}
+
+static int luasrc_UTIL_PrecacheDecal (lua_State *L) {
+  lua_pushinteger(L, UTIL_PrecacheDecal(luaL_checkstring(L, 1), luaL_optboolean(L, 2, 0)));
+  return 1;
+}
+
+static int luasrc_UTIL_GetSimulationInterval (lua_State *L) {
+  lua_pushnumber(L, UTIL_GetSimulationInterval());
+  return 1;
+}
+
+static int luasrc_UTIL_PlayerByIndex (lua_State *L) {
+  lua_pushplayer(L, UTIL_PlayerByIndex(luaL_checkinteger(L, 1)));
+  return 1;
+}
+
+static int luasrc_UTIL_GetLocalPlayer (lua_State *L) {
+  lua_pushplayer(L, UTIL_GetLocalPlayer());
+  return 1;
+}
+
+static int luasrc_UTIL_GetListenServerHost (lua_State *L) {
+  lua_pushplayer(L, UTIL_GetListenServerHost());
+  return 1;
+}
+
+static int luasrc_UTIL_PlayerByUserId (lua_State *L) {
+  lua_pushplayer(L, UTIL_PlayerByUserId(luaL_checkinteger(L, 1)));
+  return 1;
+}
+
+static int luasrc_UTIL_PlayerByName (lua_State *L) {
+  lua_pushplayer(L, UTIL_PlayerByName(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int luasrc_UTIL_IsCommandIssuedByServerAdmin (lua_State *L) {
+  lua_pushboolean(L, UTIL_IsCommandIssuedByServerAdmin());
+  return 1;
+}
+
+static int luasrc_UTIL_EntityByIndex (lua_State *L) {
+  lua_pushentity(L, UTIL_EntityByIndex(luaL_checkinteger(L, 1)));
+  return 1;
+}
+
+static int luasrc_UTIL_GetPlayerConnectionInfo (lua_State *L) {
+  int ping, packetloss;
+  UTIL_GetPlayerConnectionInfo(luaL_checkinteger(L, 1), ping, packetloss);
+  lua_pushinteger(L, ping);
+  lua_pushinteger(L, packetloss);
+  return 2;
+}
+
+static int luasrc_UTIL_ClientPVSIsExpanded (lua_State *L) {
+  lua_pushboolean(L, UTIL_ClientPVSIsExpanded());
+  return 1;
+}
+
+static int luasrc_UTIL_FindClientInPVS (lua_State *L) {
+  lua_pushentity(L, UTIL_FindClientInPVS(luaL_checkvector(L, 1), luaL_checkvector(L, 2)));
+  return 1;
+}
+
+#define MAX_ENTITYARRAY 1024
+
+static int luasrc_UTIL_EntitiesInBox (lua_State *L) {
+  CBaseEntity *pList[MAX_ENTITYARRAY];
+
+  int count = UTIL_EntitiesInBox(pList, luaL_checkinteger(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkinteger(L, 4));
+  lua_pushinteger(L, count);
+  lua_newtable(L);
+  for( int i = 0 ; i < count ; i++ )
+  {
+	  lua_pushinteger(L, i);
+	  lua_pushentity(L, pList[ i ]);
+	  lua_settable(L, -3);
+  }
+  return 2;
+}
+
+static int luasrc_UTIL_EntitiesInSphere (lua_State *L) {
+  CBaseEntity *pList[MAX_ENTITYARRAY];
+
+  int count = UTIL_EntitiesInSphere(pList, luaL_checkinteger(L, 1), luaL_checkvector(L, 2), luaL_checknumber(L, 3), luaL_checkinteger(L, 4));
+  lua_pushinteger(L, count);
+  lua_newtable(L);
+  for( int i = 0 ; i < count ; i++ )
+  {
+	  lua_pushinteger(L, i);
+	  lua_pushentity(L, pList[ i ]);
+	  lua_settable(L, -3);
+  }
+  return 2;
+}
+
+static int luasrc_UTIL_Remove (lua_State *L) {
+  UTIL_Remove(luaL_checkentity(L, 1));
+  return 0;
+}
+
+static int luasrc_UTIL_DisableRemoveImmediate (lua_State *L) {
+  UTIL_DisableRemoveImmediate();
+  return 0;
+}
+
+static int luasrc_UTIL_EnableRemoveImmediate (lua_State *L) {
+  UTIL_EnableRemoveImmediate();
+  return 0;
+}
+
+static int luasrc_UTIL_RemoveImmediate (lua_State *L) {
+  UTIL_RemoveImmediate(luaL_checkentity(L, 1));
+  return 0;
+}
+
+static int luasrc_UTIL_DropToFloor (lua_State *L) {
+  lua_pushinteger(L, UTIL_DropToFloor(luaL_checkentity(L, 1), luaL_checkinteger(L, 2), luaL_optentity(L, 3, NULL)));
+  return 1;
+}
+
+static int luasrc_UTIL_SetOrigin (lua_State *L) {
+  UTIL_SetOrigin(luaL_checkentity(L, 1), luaL_checkvector(L, 2), luaL_optboolean(L, 3, 0));
+  return 0;
+}
+
+static int luasrc_UTIL_EmitAmbientSound (lua_State *L) {
+  float duration;
+  UTIL_EmitAmbientSound(luaL_checkinteger(L, 1), luaL_checkvector(L, 2), luaL_checkstring(L, 3), luaL_checknumber(L, 4), (soundlevel_t)luaL_checkinteger(L, 5), luaL_checkinteger(L, 6), luaL_checkinteger(L, 7), luaL_optnumber(L, 8, 0.0f), &duration);
+  lua_pushnumber(L, duration);
+  return 1;
+}
+
+static int luasrc_UTIL_ScreenShake (lua_State *L) {
+  UTIL_ScreenShake(luaL_checkvector(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checknumber(L, 4), luaL_checknumber(L, 5), (ShakeCommand_t)luaL_checkinteger(L, 6), luaL_optboolean(L, 7, 0));
+  return 0;
+}
+
+static int luasrc_UTIL_ScreenShakeObject (lua_State *L) {
+  UTIL_ScreenShakeObject(luaL_checkentity(L, 1), luaL_checkvector(L, 2), luaL_checknumber(L, 3), luaL_checknumber(L, 4), luaL_checknumber(L, 5), luaL_checknumber(L, 6), (ShakeCommand_t)luaL_checkinteger(L, 7), luaL_optboolean(L, 8, 0));
+  return 0;
+}
+
+static int luasrc_UTIL_ViewPunch (lua_State *L) {
+  UTIL_ViewPunch(luaL_checkvector(L, 1), luaL_checkangle(L, 2), luaL_checknumber(L, 3), luaL_checkboolean(L, 4));
+  return 0;
+}
+
+static int luasrc_UTIL_ShowMessage (lua_State *L) {
+  UTIL_ShowMessage(luaL_checkstring(L, 1), luaL_checkplayer(L, 2));
+  return 0;
+}
+
+static int luasrc_UTIL_ShowMessageAll (lua_State *L) {
+  UTIL_ShowMessageAll(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_UTIL_MuzzleFlash (lua_State *L) {
+  UTIL_MuzzleFlash(luaL_checkvector(L, 1), luaL_checkangle(L, 2), luaL_checkinteger(L, 3), luaL_checkinteger(L, 4));
+  return 0;
+}
+
+static int luasrc_UTIL_PointOnLineNearestPoint (lua_State *L) {
+  lua_pushvector(L, UTIL_PointOnLineNearestPoint(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_optboolean(L, 4, 0)));
+  return 1;
+}
+
+static int luasrc_UTIL_EntityInSolid (lua_State *L) {
+  lua_pushinteger(L, UTIL_EntityInSolid(luaL_checkentity(L, 1)));
+  return 1;
+}
+
+static int luasrc_UTIL_BloodStream (lua_State *L) {
+  UTIL_BloodStream(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkinteger(L, 3), luaL_checkinteger(L, 4));
+  return 0;
+}
+
+static int luasrc_UTIL_BloodSpray (lua_State *L) {
+  UTIL_BloodSpray(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkinteger(L, 3), luaL_checkinteger(L, 4), luaL_checkinteger(L, 4));
+  return 0;
+}
+
+static int luasrc_UTIL_RandomBloodVector (lua_State *L) {
+  lua_pushvector(L, UTIL_RandomBloodVector());
+  return 1;
+}
+
+static int luasrc_UTIL_ImpactTrace (lua_State *L) {
+  UTIL_ImpactTrace(&luaL_checktrace(L, 1), luaL_checkinteger(L, 2), const_cast<char *>(luaL_optstring(L, 3, 0)));
+  return 0;
+}
+
+static int luasrc_UTIL_PlayerDecalTrace (lua_State *L) {
+  UTIL_PlayerDecalTrace(&luaL_checktrace(L, 1), luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int luasrc_UTIL_Smoke (lua_State *L) {
+  UTIL_Smoke(luaL_checkvector(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3));
+  return 0;
+}
+
+static int luasrc_UTIL_AxisStringToPointDir (lua_State *L) {
+  Vector start, dir;
+  UTIL_AxisStringToPointDir(start, dir, luaL_checkstring(L, 1));
+  lua_pushvector(L, start);
+  lua_pushvector(L, dir);
+  return 2;
+}
+
+static int luasrc_UTIL_AxisStringToPointPoint (lua_State *L) {
+  Vector start, end;
+  UTIL_AxisStringToPointPoint(start, end, luaL_checkstring(L, 1));
+  lua_pushvector(L, start);
+  lua_pushvector(L, end);
+  return 2;
+}
+
+static int luasrc_UTIL_AxisStringToUnitDir (lua_State *L) {
+  Vector dir;
+  UTIL_AxisStringToUnitDir(dir, luaL_checkstring(L, 1));
+  lua_pushvector(L, dir);
+  return 1;
+}
+
+static int luasrc_UTIL_ClipPunchAngleOffset (lua_State *L) {
+  UTIL_ClipPunchAngleOffset(luaL_checkangle(L, 1), luaL_checkplayer(L, 2)->m_Local.m_vecPunchAngle, luaL_checkangle(L, 3));
+  return 0;
+}
+
+static int luasrc_UTIL_PredictedPosition (lua_State *L) {
+  Vector vecPredictedPosition;
+  UTIL_PredictedPosition(luaL_checkentity(L, 1), luaL_checknumber(L, 2), &vecPredictedPosition);
+  lua_pushvector(L, vecPredictedPosition);
+  return 1;
+}
+
+static int luasrc_UTIL_Beam (lua_State *L) {
+  UTIL_Beam(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkinteger(L, 3), luaL_checkinteger(L, 4), luaL_checkinteger(L, 5), luaL_checkinteger(L, 6), luaL_checknumber(L, 7), luaL_checknumber(L, 8), luaL_checknumber(L, 9), luaL_checkinteger(L, 10), luaL_checknumber(L, 11), luaL_checkinteger(L, 12), luaL_checkinteger(L, 13), luaL_checkinteger(L, 14), luaL_checkinteger(L, 14), luaL_checknumber(L, 15));
+  return 0;
+}
+
+static int luasrc_UTIL_IsValidEntity (lua_State *L) {
+  lua_pushboolean(L, UTIL_IsValidEntity(luaL_checkentity(L, 1)));
+  return 1;
+}
+
+static int luasrc_UTIL_TeamsMatch (lua_State *L) {
+  lua_pushboolean(L, UTIL_TeamsMatch(luaL_checkstring(L, 1), luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int luasrc_UTIL_SnapDirectionToAxis (lua_State *L) {
+  UTIL_SnapDirectionToAxis(luaL_checkvector(L, 1), luaL_optnumber(L, 2, 0.002f));
+  return 0;
+}
+
+static int luasrc_UTIL_PointAtEntity (lua_State *L) {
+  lua_pushboolean(L, UTIL_PointAtEntity(luaL_checkentity(L, 1), luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int luasrc_UTIL_TransferPoseParameters (lua_State *L) {
+  lua_pushboolean(L, UTIL_TransferPoseParameters(luaL_checkentity(L, 1), luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int luasrc_UTIL_WaterLevel (lua_State *L) {
+  lua_pushnumber(L, UTIL_WaterLevel(luaL_checkvector(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3)));
+  return 1;
+}
+
+static int luasrc_UTIL_FindWaterSurface (lua_State *L) {
+  lua_pushnumber(L, UTIL_FindWaterSurface(luaL_checkvector(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3)));
+  return 1;
+}
+
+static int luasrc_UTIL_Bubbles (lua_State *L) {
+  UTIL_Bubbles(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkinteger(L, 3));
+  return 0;
+}
+
+static int luasrc_UTIL_BubbleTrail (lua_State *L) {
+  UTIL_BubbleTrail(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkinteger(L, 3));
+  return 0;
+}
+
+static int luasrc_UTIL_PrecacheOther (lua_State *L) {
+  UTIL_PrecacheOther(luaL_checkstring(L, 1), luaL_optstring(L, 2, 0));
+  return 0;
+}
+
+static int luasrc_UTIL_ClientPrintAll (lua_State *L) {
+  UTIL_ClientPrintAll(luaL_checkinteger(L, 1), luaL_checkstring(L, 2), luaL_optstring(L, 3, 0), luaL_optstring(L, 4, 0), luaL_optstring(L, 5, 0), luaL_optstring(L, 6, 0));
+  return 0;
+}
+
+static int luasrc_UTIL_ValidateSoundName (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  UTIL_ValidateSoundName((string_t &)name, luaL_checkstring(L, 2));
+  lua_pushstring(L, name);
+  return 1;
+}
+
+static int luasrc_ClientPrint (lua_State *L) {
+  ClientPrint(luaL_checkplayer(L, 1), luaL_checkinteger(L, 2), luaL_checkstring(L, 3), luaL_optstring(L, 4, 0), luaL_optstring(L, 5, 0), luaL_optstring(L, 6, 0), luaL_optstring(L, 7, 0));
+  return 0;
+}
+
+static int luasrc_UTIL_SayText (lua_State *L) {
+  UTIL_SayText(luaL_checkstring(L, 1), luaL_checkplayer(L, 2));
+  return 0;
+}
+
+static int luasrc_UTIL_SayTextAll (lua_State *L) {
+  UTIL_SayTextAll(luaL_checkstring(L, 1), luaL_optplayer(L, 2, 0), luaL_optboolean(L, 3, 0));
+  return 0;
+}
+
+static int luasrc_UTIL_GetCommandClientIndex (lua_State *L) {
+  lua_pushinteger(L, UTIL_GetCommandClientIndex());
+  return 1;
+}
+
+static int luasrc_UTIL_GetCommandClient (lua_State *L) {
+  lua_pushplayer(L, UTIL_GetCommandClient());
+  return 1;
+}
+
+
+static const luaL_Reg util_funcs[] = {
+  {"CanCreateEntityClass",  luasrc_CanCreateEntityClass},
+  {"ENTINDEX",  luasrc_ENTINDEX},
+  {"INDEXENT",  luasrc_INDEXENT},
+  {"FNullEnt",  luasrc_FNullEnt},
+  {"FStrEq",  luasrc_FStrEq},
+  // {"UTIL_SetSize",  luasrc_UTIL_SetSize},
+  {"SetSize",  luasrc_UTIL_SetSize},
+  // {"UTIL_ClearTrace",  luasrc_UTIL_ClearTrace},
+  {"ClearTrace",  luasrc_UTIL_ClearTrace},
+  // {"UTIL_PrecacheDecal",  luasrc_UTIL_PrecacheDecal},
+  {"PrecacheDecal",  luasrc_UTIL_PrecacheDecal},
+  // {"UTIL_GetSimulationInterval",  luasrc_UTIL_GetSimulationInterval},
+  {"GetSimulationInterval",  luasrc_UTIL_GetSimulationInterval},
+  // {"UTIL_PlayerByIndex",  luasrc_UTIL_PlayerByIndex},
+  {"PlayerByIndex",  luasrc_UTIL_PlayerByIndex},
+  // {"UTIL_GetLocalPlayer",  luasrc_UTIL_GetLocalPlayer},
+  {"GetLocalPlayer",  luasrc_UTIL_GetLocalPlayer},
+  // {"UTIL_GetListenServerHost",  luasrc_UTIL_GetListenServerHost},
+  {"GetListenServerHost",  luasrc_UTIL_GetListenServerHost},
+  // {"UTIL_PlayerByUserId",  luasrc_UTIL_PlayerByUserId},
+  {"PlayerByUserId",  luasrc_UTIL_PlayerByUserId},
+  // {"UTIL_PlayerByName",  luasrc_UTIL_PlayerByName},
+  {"PlayerByName",  luasrc_UTIL_PlayerByName},
+  // {"UTIL_IsCommandIssuedByServerAdmin",  luasrc_UTIL_IsCommandIssuedByServerAdmin},
+  {"IsCommandIssuedByServerAdmin",  luasrc_UTIL_IsCommandIssuedByServerAdmin},
+  // {"UTIL_EntityByIndex",  luasrc_UTIL_EntityByIndex},
+  {"EntityByIndex",  luasrc_UTIL_EntityByIndex},
+  // {"UTIL_GetPlayerConnectionInfo",  luasrc_UTIL_GetPlayerConnectionInfo},
+  {"GetPlayerConnectionInfo",  luasrc_UTIL_GetPlayerConnectionInfo},
+  // {"UTIL_ClientPVSIsExpanded",  luasrc_UTIL_ClientPVSIsExpanded},
+  {"ClientPVSIsExpanded",  luasrc_UTIL_ClientPVSIsExpanded},
+  // {"UTIL_FindClientInPVS",  luasrc_UTIL_FindClientInPVS},
+  {"FindClientInPVS",  luasrc_UTIL_FindClientInPVS},
+  // {"UTIL_EntitiesInBox",  luasrc_UTIL_EntitiesInBox},
+  {"EntitiesInBox",  luasrc_UTIL_EntitiesInBox},
+  // {"UTIL_EntitiesInSphere",  luasrc_UTIL_EntitiesInSphere},
+  {"EntitiesInSphere",  luasrc_UTIL_EntitiesInSphere},
+  // {"UTIL_Remove",  luasrc_UTIL_Remove},
+  {"Remove",  luasrc_UTIL_Remove},
+  // {"UTIL_DisableRemoveImmediate",  luasrc_UTIL_DisableRemoveImmediate},
+  {"DisableRemoveImmediate",  luasrc_UTIL_DisableRemoveImmediate},
+  // {"UTIL_EnableRemoveImmediate",  luasrc_UTIL_EnableRemoveImmediate},
+  {"EnableRemoveImmediate",  luasrc_UTIL_EnableRemoveImmediate},
+  // {"UTIL_RemoveImmediate",  luasrc_UTIL_RemoveImmediate},
+  {"RemoveImmediate",  luasrc_UTIL_RemoveImmediate},
+  // {"UTIL_DropToFloor",  luasrc_UTIL_DropToFloor},
+  {"DropToFloor",  luasrc_UTIL_DropToFloor},
+  // {"UTIL_SetOrigin",  luasrc_UTIL_SetOrigin},
+  {"SetOrigin",  luasrc_UTIL_SetOrigin},
+  // {"UTIL_EmitAmbientSound",  luasrc_UTIL_EmitAmbientSound},
+  {"EmitAmbientSound",  luasrc_UTIL_EmitAmbientSound},
+  // {"UTIL_ScreenShake",  luasrc_UTIL_ScreenShake},
+  {"ScreenShake",  luasrc_UTIL_ScreenShake},
+  // {"UTIL_ScreenShakeObject",  luasrc_UTIL_ScreenShakeObject},
+  {"ScreenShakeObject",  luasrc_UTIL_ScreenShakeObject},
+  // {"UTIL_ViewPunch",  luasrc_UTIL_ViewPunch},
+  {"ViewPunch",  luasrc_UTIL_ViewPunch},
+  // {"UTIL_ShowMessage",  luasrc_UTIL_ShowMessage},
+  {"ShowMessage",  luasrc_UTIL_ShowMessage},
+  // {"UTIL_ShowMessageAll",  luasrc_UTIL_ShowMessageAll},
+  {"ShowMessageAll",  luasrc_UTIL_ShowMessageAll},
+  // {"UTIL_MuzzleFlash",  luasrc_UTIL_MuzzleFlash},
+  {"MuzzleFlash",  luasrc_UTIL_MuzzleFlash},
+  // {"UTIL_PointOnLineNearestPoint",  luasrc_UTIL_PointOnLineNearestPoint},
+  {"PointOnLineNearestPoint",  luasrc_UTIL_PointOnLineNearestPoint},
+  // {"UTIL_EntityInSolid",  luasrc_UTIL_EntityInSolid},
+  {"EntityInSolid",  luasrc_UTIL_EntityInSolid},
+  // {"UTIL_BloodStream",  luasrc_UTIL_BloodStream},
+  {"BloodStream",  luasrc_UTIL_BloodStream},
+  // {"UTIL_BloodSpray",  luasrc_UTIL_BloodSpray},
+  {"BloodSpray",  luasrc_UTIL_BloodSpray},
+  // {"UTIL_RandomBloodVector",  luasrc_UTIL_RandomBloodVector},
+  {"RandomBloodVector",  luasrc_UTIL_RandomBloodVector},
+  // {"UTIL_ImpactTrace",  luasrc_UTIL_ImpactTrace},
+  {"ImpactTrace",  luasrc_UTIL_ImpactTrace},
+  // {"UTIL_PlayerDecalTrace",  luasrc_UTIL_PlayerDecalTrace},
+  {"PlayerDecalTrace",  luasrc_UTIL_PlayerDecalTrace},
+  // {"UTIL_Smoke",  luasrc_UTIL_Smoke},
+  {"Smoke",  luasrc_UTIL_Smoke},
+  // {"UTIL_AxisStringToPointDir",  luasrc_UTIL_AxisStringToPointDir},
+  {"AxisStringToPointDir",  luasrc_UTIL_AxisStringToPointDir},
+  // {"UTIL_AxisStringToPointPoint",  luasrc_UTIL_AxisStringToPointPoint},
+  {"AxisStringToPointPoint",  luasrc_UTIL_AxisStringToPointPoint},
+  // {"UTIL_AxisStringToUnitDir",  luasrc_UTIL_AxisStringToUnitDir},
+  {"AxisStringToUnitDir",  luasrc_UTIL_AxisStringToUnitDir},
+  // {"UTIL_ClipPunchAngleOffset",  luasrc_UTIL_ClipPunchAngleOffset},
+  {"ClipPunchAngleOffset",  luasrc_UTIL_ClipPunchAngleOffset},
+  // {"UTIL_PredictedPosition",  luasrc_UTIL_PredictedPosition},
+  {"PredictedPosition",  luasrc_UTIL_PredictedPosition},
+  // {"UTIL_Beam",  luasrc_UTIL_Beam},
+  {"Beam",  luasrc_UTIL_Beam},
+  // {"UTIL_IsValidEntity",  luasrc_UTIL_IsValidEntity},
+  {"IsValidEntity",  luasrc_UTIL_IsValidEntity},
+  // {"UTIL_TeamsMatch",  luasrc_UTIL_TeamsMatch},
+  {"TeamsMatch",  luasrc_UTIL_TeamsMatch},
+  // {"UTIL_SnapDirectionToAxis",  luasrc_UTIL_SnapDirectionToAxis},
+  {"SnapDirectionToAxis",  luasrc_UTIL_SnapDirectionToAxis},
+  // {"UTIL_PointAtEntity",  luasrc_UTIL_PointAtEntity},
+  {"PointAtEntity",  luasrc_UTIL_PointAtEntity},
+  // {"UTIL_TransferPoseParameters",  luasrc_UTIL_TransferPoseParameters},
+  {"TransferPoseParameters",  luasrc_UTIL_TransferPoseParameters},
+  // {"UTIL_WaterLevel",  luasrc_UTIL_WaterLevel},
+  {"WaterLevel",  luasrc_UTIL_WaterLevel},
+  // {"UTIL_FindWaterSurface",  luasrc_UTIL_FindWaterSurface},
+  {"FindWaterSurface",  luasrc_UTIL_FindWaterSurface},
+  // {"UTIL_Bubbles",  luasrc_UTIL_Bubbles},
+  {"Bubbles",  luasrc_UTIL_Bubbles},
+  // {"UTIL_BubbleTrail",  luasrc_UTIL_BubbleTrail},
+  {"BubbleTrail",  luasrc_UTIL_BubbleTrail},
+  // {"UTIL_PrecacheOther",  luasrc_UTIL_PrecacheOther},
+  {"PrecacheOther",  luasrc_UTIL_PrecacheOther},
+  // {"UTIL_ClientPrintAll",  luasrc_UTIL_ClientPrintAll},
+  {"ClientPrintAll",  luasrc_UTIL_ClientPrintAll},
+  // {"UTIL_ValidateSoundName",  luasrc_UTIL_ValidateSoundName},
+  {"ValidateSoundName",  luasrc_UTIL_ValidateSoundName},
+  {"ClientPrint",  luasrc_ClientPrint},
+  // {"UTIL_SayText",  luasrc_UTIL_SayText},
+  {"SayText",  luasrc_UTIL_SayText},
+  // {"UTIL_SayTextAll",  luasrc_UTIL_SayTextAll},
+  {"SayTextAll",  luasrc_UTIL_SayTextAll},
+  // {"UTIL_GetCommandClientIndex",  luasrc_UTIL_GetCommandClientIndex},
+  {"GetCommandClientIndex",  luasrc_UTIL_GetCommandClientIndex},
+  // {"UTIL_GetCommandClient",  luasrc_UTIL_GetCommandClient},
+  {"GetCommandClient",  luasrc_UTIL_GetCommandClient},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_UTIL (lua_State *L) {
+  // luaL_register(L, "_G", util_funcs);
+  luaL_register(L, "UTIL", util_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
diff --git a/src/game/server/lutil.h b/src/game/server/lutil.h
new file mode 100644
index 0000000..bcb3d10
--- /dev/null
+++ b/src/game/server/lutil.h
@@ -0,0 +1,16 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Misc utility code.
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LUTIL_H
+#define LUTIL_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+LUALIB_API int luaopen_UTIL(lua_State *L);
+
+#endif // UTIL_H
diff --git a/src/game/server/message_entity.cpp b/src/game/server/message_entity.cpp
index 63369ef..be6ca27 100644
--- a/src/game/server/message_entity.cpp
+++ b/src/game/server/message_entity.cpp
@@ -119,7 +119,11 @@ void CMessageEntity::Think( void )
 	SetNextThink( gpGlobals->curtime + 0.1f );
 
 	// check for player distance
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 
 	if ( !pPlayer || ( pPlayer->GetFlags() & FL_NOTARGET ) )
 		return;
diff --git a/src/game/server/monstermaker.cpp b/src/game/server/monstermaker.cpp
index dc8b440..3e6b7e4 100644
--- a/src/game/server/monstermaker.cpp
+++ b/src/game/server/monstermaker.cpp
@@ -632,7 +632,11 @@ CNPCSpawnDestination *CTemplateNPCMaker::FindSpawnDestination()
 {
 	CNPCSpawnDestination *pDestinations[ MAX_DESTINATION_ENTS ];
 	CBaseEntity *pEnt = NULL;
+#ifdef HL2SB
+	CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 	int	count = 0;
 
 	if( !pPlayer )
diff --git a/src/game/server/npc_talker.cpp b/src/game/server/npc_talker.cpp
index 2788d8c..f04f495 100644
--- a/src/game/server/npc_talker.cpp
+++ b/src/game/server/npc_talker.cpp
@@ -228,10 +228,19 @@ void CNPCSimpleTalker::RunTask( const Task_t *pTask )
 	case TASK_TALKER_CLIENT_STARE:
 	case TASK_TALKER_LOOK_AT_CLIENT:
 
+#ifdef HL2SB
+		if ( pTask->iTask == TASK_TALKER_CLIENT_STARE )
+		{
+			// Get edict for one player
+			CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer( this );
+			if ( !pPlayer )
+				pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 		if ( pTask->iTask == TASK_TALKER_CLIENT_STARE && AI_IsSinglePlayer() )
 		{
 			// Get edict for one player
 			CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 			Assert( pPlayer );
 
 			// fail out if the player looks away or moves away.
@@ -822,9 +831,15 @@ int CNPCSimpleTalker::SelectNonCombatSpeechSchedule()
 	}
 	
 	// failed to speak, so look at the player if he's around
+#ifdef HL2SB
+	if ( GetExpresser()->CanSpeak() && HasCondition ( COND_SEE_PLAYER ) && random->RandomInt( 0, 6 ) == 0 )
+	{
+		CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer( this );
+#else
 	if ( AI_IsSinglePlayer() && GetExpresser()->CanSpeak() && HasCondition ( COND_SEE_PLAYER ) && random->RandomInt( 0, 6 ) == 0 )
 	{
 		CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 		Assert( pPlayer );
 
 		if ( pPlayer )
diff --git a/src/game/server/physconstraint.cpp b/src/game/server/physconstraint.cpp
index e7bfb50..ec60ce2 100644
--- a/src/game/server/physconstraint.cpp
+++ b/src/game/server/physconstraint.cpp
@@ -630,6 +630,7 @@ void CPhysConstraint::GetConstraintObjects( hl_constraint_info_t &info )
 	// Missing one object, assume the world instead
 	if ( info.pObjects[0] == NULL && info.pObjects[1] )
 	{
+#if !defined ( HL2SB )
 		if ( Q_strlen(STRING(m_nameAttach1)) )
 		{
 			Warning("Bogus constraint %s (attaches ENTITY NOT FOUND:%s to %s)\n", GetDebugName(), STRING(m_nameAttach1), STRING(m_nameAttach2));
@@ -638,11 +639,13 @@ void CPhysConstraint::GetConstraintObjects( hl_constraint_info_t &info )
 			return;
 #endif	// HL2_EPISODIC
 		}
+#endif
 		info.pObjects[0] = g_PhysWorldObject;
 		info.massScale[0] = info.massScale[1] = 1.0f; // no mass scale on world constraint
 	}
 	else if ( info.pObjects[0] && !info.pObjects[1] )
 	{
+#if !defined ( HL2SB )
 		if ( Q_strlen(STRING(m_nameAttach2)) )
 		{
 			Warning("Bogus constraint %s (attaches %s to ENTITY NOT FOUND:%s)\n", GetDebugName(), STRING(m_nameAttach1), STRING(m_nameAttach2));
@@ -651,6 +654,7 @@ void CPhysConstraint::GetConstraintObjects( hl_constraint_info_t &info )
 			return;
 #endif	// HL2_EPISODIC
 		}
+#endif
 		info.pObjects[1] = info.pObjects[0];
 		info.pObjects[0] = g_PhysWorldObject;		// Try to make the world object consistently object0 for ease of implementation
 		info.massScale[0] = info.massScale[1] = 1.0f; // no mass scale on world constraint
diff --git a/src/game/server/physgun.cpp b/src/game/server/physgun.cpp
index 7d01336..63ee886 100644
--- a/src/game/server/physgun.cpp
+++ b/src/game/server/physgun.cpp
@@ -9,7 +9,7 @@
 #include "beam_shared.h"
 #include "player.h"
 #include "gamerules.h"
-#include "basecombatweapon.h"
+#include "weapon_hl2mpbasehlmpcombatweapon.h"
 #include "baseviewmodel.h"
 #include "vphysics/constraints.h"
 #include "physics.h"
@@ -33,6 +33,8 @@ ConVar phys_gunglueradius("phys_gunglueradius", "128" );
 static int g_physgunBeam;
 #define PHYSGUN_BEAM_SPRITE		"sprites/physbeam.vmt"
 
+#define	PHYSGUN_SKIN	1
+
 #define MAX_PELLETS	16
 
 class CWeaponGravityGun;
@@ -459,12 +461,12 @@ struct pelletlist_t
 	EHANDLE						parent;
 };
 
-class CWeaponGravityGun : public CBaseCombatWeapon
+class CWeaponGravityGun : public CBaseHL2MPCombatWeapon
 {
 	DECLARE_DATADESC();
 
 public:
-	DECLARE_CLASS( CWeaponGravityGun, CBaseCombatWeapon );
+	DECLARE_CLASS( CWeaponGravityGun, CBaseHL2MPCombatWeapon );
 
 	CWeaponGravityGun();
 	void Spawn( void );
@@ -478,7 +480,7 @@ public:
 	virtual bool Holster( CBaseCombatWeapon *pSwitchingTo )
 	{
 		EffectDestroy();
-		return BaseClass::Holster();
+		return BaseClass::Holster( pSwitchingTo );
 	}
 
 	bool Reload( void );
@@ -571,6 +573,8 @@ private:
 	int			m_pelletAttract;
 	float		m_glueTime;
 	CNetworkVar( bool, m_glueTouching );
+
+	DECLARE_ACTTABLE();
 };
 
 IMPLEMENT_SERVERCLASS_ST( CWeaponGravityGun, DT_WeaponGravityGun )
@@ -584,6 +588,25 @@ END_SEND_TABLE()
 LINK_ENTITY_TO_CLASS( weapon_physgun, CWeaponGravityGun );
 PRECACHE_WEAPON_REGISTER(weapon_physgun);
 
+acttable_t	CWeaponGravityGun::m_acttable[] = 
+{
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PHYSGUN,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PHYSGUN,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PHYSGUN,					false },
+};
+
+IMPLEMENT_ACTTABLE(CWeaponGravityGun);
+
 //---------------------------------------------------------
 // Save/Restore
 //---------------------------------------------------------
@@ -642,6 +665,9 @@ void CWeaponGravityGun::Spawn( )
 	BaseClass::Spawn();
 //	SetModel( GetWorldModel() );
 
+	// The physgun uses a different skin
+	m_nSkin = PHYSGUN_SKIN;
+
 	FallInit();
 }
 
@@ -1221,7 +1247,7 @@ void CWeaponGravityGun::AttachObject( CBaseEntity *pObject, const Vector& start,
 
 		m_gravCallback.AttachEntity( pObject, pPhysics, end );
 		float mass = pPhysics->GetMass();
-		Msg( "Object mass: %.2f lbs (%.2f kg)\n", kg2lbs(mass), mass );
+//		Msg( "Object mass: %.2f lbs (%.2f kg)\n", kg2lbs(mass), mass );
 		float vel = phys_gunvel.GetFloat();
 		if ( mass > phys_gunmass.GetFloat() )
 		{
@@ -1421,103 +1447,3 @@ bool CWeaponGravityGun::Reload( void )
 
 	return false;
 }
-
-#define NUM_COLLISION_TESTS 2500
-void CC_CollisionTest( const CCommand &args )
-{
-	if ( !physenv )
-		return;
-
-	Msg( "Testing collision system\n" );
-	int i;
-	CBaseEntity *pSpot = gEntList.FindEntityByClassname( NULL, "info_player_start");
-	Vector start = pSpot->GetAbsOrigin();
-	static Vector *targets = NULL;
-	static bool first = true;
-	static float test[2] = {1,1};
-	if ( first )
-	{
-		targets = new Vector[NUM_COLLISION_TESTS];
-		float radius = 0;
-		float theta = 0;
-		float phi = 0;
-		for ( i = 0; i < NUM_COLLISION_TESTS; i++ )
-		{
-			radius += NUM_COLLISION_TESTS * 123.123;
-			radius = fabs(fmod(radius, 128));
-			theta += NUM_COLLISION_TESTS * 76.76;
-			theta = fabs(fmod(theta, DEG2RAD(360)));
-			phi += NUM_COLLISION_TESTS * 1997.99;
-			phi = fabs(fmod(phi, DEG2RAD(180)));
-			
-			float st, ct, sp, cp;
-			SinCos( theta, &st, &ct );
-			SinCos( phi, &sp, &cp );
-
-			targets[i].x = radius * ct * sp;
-			targets[i].y = radius * st * sp;
-			targets[i].z = radius * cp;
-			
-			// make the trace 1024 units long
-			Vector dir = targets[i] - start;
-			VectorNormalize(dir);
-			targets[i] = start + dir * 1024;
-		}
-		first = false;
-	}
-
-	//Vector results[NUM_COLLISION_TESTS];
-
-	int testType = 0;
-	if ( args.ArgC() >= 2 )
-	{
-		testType = atoi( args[1] );
-	}
-	float duration = 0;
-	Vector size[2];
-	size[0].Init(0,0,0);
-	size[1].Init(16,16,16);
-	unsigned int dots = 0;
-
-	for ( int j = 0; j < 2; j++ )
-	{
-		float startTime = engine->Time();
-		if ( testType == 1 )
-		{
-			const CPhysCollide *pCollide = g_PhysWorldObject->GetCollide();
-			trace_t tr;
-
-			for ( i = 0; i < NUM_COLLISION_TESTS; i++ )
-			{
-				physcollision->TraceBox( start, targets[i], -size[j], size[j], pCollide, vec3_origin, vec3_angle, &tr );
-				dots += physcollision->ReadStat(0);
-				//results[i] = tr.endpos;
-			}
-		}
-		else
-		{
-			testType = 0;
-			CBaseEntity *pWorld = GetContainingEntity( INDEXENT(0) );
-			trace_t tr;
-
-			for ( i = 0; i < NUM_COLLISION_TESTS; i++ )
-			{
-				UTIL_TraceModel( start, targets[i], -size[j], size[j], pWorld, COLLISION_GROUP_NONE, &tr );
-				//results[i] = tr.endpos;
-			}
-		}
-
-		duration += engine->Time() - startTime;
-	}
-	test[testType] = duration;
-	Msg("%d collisions in %.2f ms (%u dots)\n", NUM_COLLISION_TESTS, duration*1000, dots );
-	Msg("Current speed ratio: %.2fX BSP:JGJK\n", test[1] / test[0] );
-#if 0
-	int red = 255, green = 0, blue = 0;
-	for ( i = 0; i < NUM_COLLISION_TESTS; i++ )
-	{
-		NDebugOverlay::Line( start, results[i], red, green, blue, false, 2 );
-	}
-#endif
-}
-static ConCommand collision_test("collision_test", CC_CollisionTest, "Tests collision system", FCVAR_CHEAT );
diff --git a/src/game/server/physics_npc_solver.cpp b/src/game/server/physics_npc_solver.cpp
index 16e15e9..0110baf 100644
--- a/src/game/server/physics_npc_solver.cpp
+++ b/src/game/server/physics_npc_solver.cpp
@@ -297,7 +297,11 @@ IMotionEvent::simresult_e CPhysicsNPCSolver::Simulate( IPhysicsMotionController
 
 		if ( pObject->GetGameFlags() & FVPHYSICS_PLAYER_HELD )
 		{
+#ifdef HL2SB
+			CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 			CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 			if ( pPlayer )
 			{
 				pPlayer->ForceDropOfCarriedPhysObjects( m_hEntity );
diff --git a/src/game/server/physics_prop_ragdoll.cpp b/src/game/server/physics_prop_ragdoll.cpp
index 0a0b5df..357b236 100644
--- a/src/game/server/physics_prop_ragdoll.cpp
+++ b/src/game/server/physics_prop_ragdoll.cpp
@@ -1130,7 +1130,11 @@ void CRagdollProp::FadeOutThink(void)
 		// Necessary to cause it to do the appropriate death cleanup
 		// Yeah, the player may have nothing to do with it, but
 		// passing NULL to TakeDamage causes bad things to happen
+#ifdef HL2SB
+		CBasePlayer *pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 		CTakeDamageInfo info( pPlayer, pPlayer, 10000.0, DMG_GENERIC );
 		TakeDamage( info );
 		UTIL_Remove( this );
diff --git a/src/game/server/player.cpp b/src/game/server/player.cpp
index 6855fd4..763c4c9 100644
--- a/src/game/server/player.cpp
+++ b/src/game/server/player.cpp
@@ -72,6 +72,15 @@
 #include "weapon_physcannon.h"
 #endif
 
+#ifdef LUA_SDK
+#include "luamanager.h"
+#include "lbaseentity_shared.h"
+#include "lbaseplayer_shared.h"
+#include "lgametrace.h"
+#include "ltakedamageinfo.h"
+#include "mathlib/lvector.h"
+#endif
+
 ConVar autoaim_max_dist( "autoaim_max_dist", "2160" ); // 2160 = 180 feet
 ConVar autoaim_max_deflect( "autoaim_max_deflect", "0.99" );
 
@@ -385,6 +394,14 @@ BEGIN_DATADESC( CBasePlayer )
 	DEFINE_FIELD( m_bPlayerUnderwater, FIELD_BOOLEAN ),
 	DEFINE_FIELD( m_hViewEntity, FIELD_EHANDLE ),
 
+#if defined( ARGG )
+	// adnan
+	// set the use angles
+	// set when the player presses use
+	DEFINE_FIELD( m_vecUseAngles, FIELD_VECTOR ),
+	// end adnan
+#endif
+
 	DEFINE_FIELD( m_hConstraintEntity, FIELD_EHANDLE ),
 	DEFINE_FIELD( m_vecConstraintCenter, FIELD_VECTOR ),
 	DEFINE_FIELD( m_flConstraintRadius, FIELD_FLOAT ),
@@ -854,9 +871,27 @@ void CBasePlayer::DrawDebugGeometryOverlays(void)
 //=========================================================
 void CBasePlayer::TraceAttack( const CTakeDamageInfo &inputInfo, const Vector &vecDir, trace_t *ptr )
 {
+#if defined ( LUA_SDK )
+	CTakeDamageInfo linputInfo = inputInfo;
+	Vector lvecDir = vecDir;
+
+	BEGIN_LUA_CALL_HOOK( "PlayerTraceAttack" );
+		lua_pushplayer( L, this );
+		lua_pushdamageinfo( L, linputInfo );
+		lua_pushvector( L, lvecDir );
+		lua_pushtrace( L, *ptr );
+	END_LUA_CALL_HOOK( 4, 1 );
+
+	RETURN_LUA_NONE();
+#endif
+
 	if ( m_takedamage )
 	{
+#if defined ( LUA_SDK )
+		CTakeDamageInfo info = linputInfo;
+#else
 		CTakeDamageInfo info = inputInfo;
+#endif
 
 		if ( info.GetAttacker() )
 		{
@@ -2719,6 +2754,16 @@ bool CBasePlayer::IsUseableEntity( CBaseEntity *pEntity, unsigned int requiredCa
 //-----------------------------------------------------------------------------
 bool CBasePlayer::CanPickupObject( CBaseEntity *pObject, float massLimit, float sizeLimit )
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "PlayerCanPickupObject" );
+		lua_pushentity( L, pObject );
+		lua_pushnumber( L, massLimit );
+		lua_pushnumber( L, sizeLimit );
+	END_LUA_CALL_HOOK( 3, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 	// UNDONE: Make this virtual and move to HL2 player
 #ifdef HL2_DLL
 	//Must be valid
@@ -4734,6 +4779,12 @@ ReturnSpot:
 //-----------------------------------------------------------------------------
 void CBasePlayer::InitialSpawn( void )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "PlayerInitialSpawn" );
+		lua_pushplayer( L, this );
+	END_LUA_CALL_HOOK( 1, 0 );
+#endif
+
 	m_iConnected = PlayerConnected;
 	gamestats->Event_PlayerConnected( this );
 }
@@ -5275,6 +5326,17 @@ void CBasePlayer::VelocityPunch( const Vector &vecForce )
 //-----------------------------------------------------------------------------
 bool CBasePlayer::CanEnterVehicle( IServerVehicle *pVehicle, int nRole )
 {
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_HOOK( "CanEnterVehicle" );
+		lua_pushplayer( L, this );
+		// FIXME: implement lua_pushvehicle()!
+		lua_pushentity( L, pVehicle->GetVehicleEnt());
+		lua_pushinteger( L, nRole );
+	END_LUA_CALL_HOOK( 3, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 	// Must not have a passenger there already
 	if ( pVehicle->GetPassenger( nRole ) )
 		return false;
@@ -5906,7 +5968,7 @@ static void CreateJeep( CBasePlayer *pPlayer )
 	Vector vecForward;
 	AngleVectors( pPlayer->EyeAngles(), &vecForward );
 //Tony; in sp sdk, we have prop_vehicle_hl2buggy; because episode 2 modified the jeep code to turn it into the jalopy instead of the regular buggy
-#if defined ( SP_SDK )
+#if defined ( SP_SDK ) || defined ( HL2SB )
 	CBaseEntity *pJeep = (CBaseEntity *)CreateEntityByName( "prop_vehicle_hl2buggy" );
 #else
 	CBaseEntity *pJeep = (CBaseEntity *)CreateEntityByName( "prop_vehicle_jeep" );
@@ -7409,7 +7471,11 @@ void CStripWeapons::StripWeapons(inputdata_t &data, bool stripSuit)
 	}
 	else if ( !g_pGameRules->IsDeathmatch() )
 	{
+#ifdef HL2SB
+		pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 		pPlayer = UTIL_GetLocalPlayer();
+#endif
 	}
 
 	if ( pPlayer )
@@ -7505,7 +7571,11 @@ void CRevertSaved::Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE
 	SetNextThink( gpGlobals->curtime + LoadTime() );
 	SetThink( &CRevertSaved::LoadThink );
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = pActivator->IsPlayer() ? (CBasePlayer *)pActivator : UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 
 	if ( pPlayer )
 	{
@@ -7531,7 +7601,11 @@ void CRevertSaved::InputReload( inputdata_t &inputdata )
 	SetThink( &CRevertSaved::LoadThink );
 #endif
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = inputdata.pActivator->IsPlayer() ? (CBasePlayer *)inputdata.pActivator : UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 
 	if ( pPlayer )
 	{
@@ -7643,7 +7717,11 @@ void CMovementSpeedMod::InputSpeedMod(inputdata_t &data)
 	}
 	else if ( !g_pGameRules->IsDeathmatch() )
 	{
+#ifdef HL2SB
+		pPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 		pPlayer = UTIL_GetLocalPlayer();
+#endif
 	}
 
 	if ( pPlayer )
@@ -7759,6 +7837,14 @@ void SendProxy_CropFlagsToPlayerFlagBitsLength( const SendProp *pProp, const voi
 		SendPropVector		( SENDINFO( m_vecBaseVelocity ), 20, 0, -1000, 1000 ),
 #endif
 
+#ifdef ARGG
+		// adnan
+		// send the use angles
+		// set when the player presses use
+		SendPropVector		( SENDINFO( m_vecUseAngles), 0, SPROP_NOSCALE ),
+		// end adnan
+#endif
+
 		SendPropEHandle		( SENDINFO( m_hConstraintEntity)),
 		SendPropVector		( SENDINFO( m_vecConstraintCenter), 0, SPROP_NOSCALE ),
 		SendPropFloat		( SENDINFO( m_flConstraintRadius ), 0, SPROP_NOSCALE ),
diff --git a/src/game/server/player.h b/src/game/server/player.h
index 05db514..b57a622 100644
--- a/src/game/server/player.h
+++ b/src/game/server/player.h
@@ -1036,6 +1036,20 @@ private:
 
 	EHANDLE					m_hViewEntity;
 
+#ifdef ARGG
+public:
+	// adnan
+	// send the use angles for the current player... set when they press use
+	// UPDATE: this could be improved somehow by only storing these on the server side
+	//  - set a flag on the client and send that, stating that the viewangles shouldnt change
+	//  - ... maybe not
+	CNetworkQAngle( m_vecUseAngles );
+	// end adnan
+
+private:
+
+#endif
+
 	// Movement constraints
 	CNetworkHandle( CBaseEntity, m_hConstraintEntity );
 	CNetworkVector( m_vecConstraintCenter );
@@ -1112,6 +1126,9 @@ public:
 private:
 	bool m_autoKickDisabled;
 
+#if defined( LUA_SDK )
+public:
+#endif
 	struct StepSoundCache_t
 	{
 		StepSoundCache_t() : m_usSoundNameIndex( 0 ) {}
@@ -1121,6 +1138,9 @@ private:
 	// One for left and one for right side of step
 	StepSoundCache_t		m_StepSoundCache[ 2 ];
 
+#if defined( LUA_SDK )
+private:
+#endif
 	CUtlLinkedList< CPlayerSimInfo >  m_vecPlayerSimInfo;
 	CUtlLinkedList< CPlayerCmdInfo >  m_vecPlayerCmdInfo;
 private:
@@ -1245,6 +1265,10 @@ inline bool CBasePlayer::TouchedPhysics( void )
 	return m_touchedPhysObject; 
 }
 
+#ifdef HL2SB
+extern CBaseEntity *FindPlayerStart(const char *pszClassName);
+#endif
+
 //-----------------------------------------------------------------------------
 // Converts an entity to a player
 //-----------------------------------------------------------------------------
diff --git a/src/game/server/player_pickup.cpp b/src/game/server/player_pickup.cpp
index 24d50e0..e6c958f 100644
--- a/src/game/server/player_pickup.cpp
+++ b/src/game/server/player_pickup.cpp
@@ -24,7 +24,11 @@ void Pickup_ForcePlayerToDropThisObject( CBaseEntity *pTarget )
 
 	if ( pPhysics->GetGameFlags() & FVPHYSICS_PLAYER_HELD )
 	{
+#ifdef HL2SB
+		CBasePlayer *pPlayer = UTIL_GetNearestPlayer( pTarget->GetAbsOrigin() );
+#else
 		CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
+#endif
 		pPlayer->ForceDropOfCarriedPhysObjects( pTarget );
 	}
 }
diff --git a/src/game/server/sceneentity.cpp b/src/game/server/sceneentity.cpp
index 0caa256..d9a2332 100644
--- a/src/game/server/sceneentity.cpp
+++ b/src/game/server/sceneentity.cpp
@@ -1416,6 +1416,11 @@ void CSceneEntity::DispatchEndInterrupt( CChoreoScene *scene, CChoreoEvent *even
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchStartExpression( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->AddSceneEvent( scene, event );
 }
 
@@ -1426,6 +1431,11 @@ void CSceneEntity::DispatchStartExpression( CChoreoScene *scene, CBaseFlex *acto
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchEndExpression( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->RemoveSceneEvent( scene, event, false );
 }
 
@@ -1436,6 +1446,11 @@ void CSceneEntity::DispatchEndExpression( CChoreoScene *scene, CBaseFlex *actor,
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchStartFlexAnimation( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->AddSceneEvent( scene, event );
 }
 
@@ -1446,6 +1461,11 @@ void CSceneEntity::DispatchStartFlexAnimation( CChoreoScene *scene, CBaseFlex *a
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchEndFlexAnimation( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->RemoveSceneEvent( scene, event, false );
 }
 
@@ -1456,6 +1476,11 @@ void CSceneEntity::DispatchEndFlexAnimation( CChoreoScene *scene, CBaseFlex *act
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchStartGesture( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	// Ingore null gestures
 	if ( !Q_stricmp( event->GetName(), "NULL" ) )
 		return;
@@ -1471,6 +1496,11 @@ void CSceneEntity::DispatchStartGesture( CChoreoScene *scene, CBaseFlex *actor,
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchEndGesture( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	// Ingore null gestures
 	if ( !Q_stricmp( event->GetName(), "NULL" ) )
 		return;
@@ -1485,6 +1515,11 @@ void CSceneEntity::DispatchEndGesture( CChoreoScene *scene, CBaseFlex *actor, CC
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchStartGeneric( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	CBaseEntity *pTarget = FindNamedEntity( event->GetParameters2( ) );
 	actor->AddSceneEvent( scene, event, pTarget );
 }
@@ -1497,6 +1532,11 @@ void CSceneEntity::DispatchStartGeneric( CChoreoScene *scene, CBaseFlex *actor,
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchEndGeneric( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->RemoveSceneEvent( scene, event, m_bRestoring );
 }
 
@@ -1507,12 +1547,22 @@ void CSceneEntity::DispatchEndGeneric( CChoreoScene *scene, CBaseFlex *actor, CC
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchStartLookAt( CChoreoScene *scene, CBaseFlex *actor, CBaseEntity *actor2, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->AddSceneEvent( scene, event, actor2 );
 }
 
 
 void CSceneEntity::DispatchEndLookAt( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->RemoveSceneEvent( scene, event, m_bRestoring );
 }
 
@@ -1526,12 +1576,22 @@ void CSceneEntity::DispatchEndLookAt( CChoreoScene *scene, CBaseFlex *actor, CCh
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchStartMoveTo( CChoreoScene *scene, CBaseFlex *actor, CBaseEntity *actor2, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->AddSceneEvent( scene, event, actor2 );
 }
 
 
 void CSceneEntity::DispatchEndMoveTo( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->RemoveSceneEvent( scene, event, m_bRestoring );
 }
 
@@ -1654,6 +1714,9 @@ void CSceneEntity::DispatchStartSpeak( CChoreoScene *scene, CBaseFlex *actor, CC
 	if ( actor )
 	{
 		CPASAttenuationFilter filter( actor );
+#ifdef HL2SB
+		filter.AddAllPlayers();
+#endif
 
 		if ( m_pRecipientFilter )
 		{
@@ -1849,6 +1912,11 @@ void CSceneEntity::DispatchStartSpeak( CChoreoScene *scene, CBaseFlex *actor, CC
 
 void CSceneEntity::DispatchEndSpeak( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->RemoveSceneEvent( scene, event, m_bRestoring );
 }
 
@@ -1860,6 +1928,11 @@ void CSceneEntity::DispatchEndSpeak( CChoreoScene *scene, CBaseFlex *actor, CCho
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchStartFace( CChoreoScene *scene, CBaseFlex *actor, CBaseEntity *actor2, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->AddSceneEvent( scene, event, actor2 );
 }
 
@@ -1872,6 +1945,11 @@ void CSceneEntity::DispatchStartFace( CChoreoScene *scene, CBaseFlex *actor, CBa
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchEndFace( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->RemoveSceneEvent( scene, event, m_bRestoring );
 }
 
@@ -1883,6 +1961,11 @@ void CSceneEntity::DispatchEndFace( CChoreoScene *scene, CBaseFlex *actor, CChor
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchStartSequence( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->AddSceneEvent( scene, event );
 }
 
@@ -1894,6 +1977,11 @@ void CSceneEntity::DispatchStartSequence( CChoreoScene *scene, CBaseFlex *actor,
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchEndSequence( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->RemoveSceneEvent( scene, event, m_bRestoring );
 }
 
@@ -1905,6 +1993,11 @@ void CSceneEntity::DispatchEndSequence( CChoreoScene *scene, CBaseFlex *actor, C
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchStartPermitResponses( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->SetPermitResponse( gpGlobals->curtime + event->GetDuration() );
 }
 
@@ -1916,6 +2009,11 @@ void CSceneEntity::DispatchStartPermitResponses( CChoreoScene *scene, CBaseFlex
 //-----------------------------------------------------------------------------
 void CSceneEntity::DispatchEndPermitResponses( CChoreoScene *scene, CBaseFlex *actor, CChoreoEvent *event )
 {
+#ifdef HL2SB
+	if ( !actor )
+		return;
+#endif
+
 	actor->SetPermitResponse( 0 );
 }
 
@@ -2489,6 +2587,10 @@ void CSceneEntity::StartPlayback( void )
 			return;
 		}
 
+#ifdef HL2SB
+		PrecacheScene( m_pScene );
+#endif
+
 		OnLoaded();
 
 		if ( ShouldNetwork() )
@@ -2932,7 +3034,11 @@ void CSceneEntity::StartEvent( float currenttime, CChoreoScene *scene, CChoreoEv
 				event->SetEndTime( event->GetStartTime() + 1.0 );
 			}
 
+#ifdef HL2SB
+			if ( pActor )
+#else
 			if ( pActor && !IsMultiplayer() )
+#endif
 			{
 				CBaseEntity *pActor2 = NULL;
 				if ( event->GetParameters3( ) && strlen( event->GetParameters3( ) ) > 0 )
@@ -2957,7 +3063,11 @@ void CSceneEntity::StartEvent( float currenttime, CChoreoScene *scene, CChoreoEv
 		break;
 	case CChoreoEvent::FACE:
 		{
+#ifdef HL2SB
+			if ( pActor )
+#else
 			if ( pActor && !IsMultiplayer() )
+#endif
 			{
 				CBaseEntity *pActor2 = FindNamedEntity( event->GetParameters( ), pActor );
 				if ( pActor2 )
@@ -3327,6 +3437,52 @@ bool CSceneEntity::ShouldNetwork() const
 	return false;
 }
 
+#ifdef HL2SB
+//Andrew; See https://developer.valvesoftware.com/wiki/Scenes.image
+CChoreoScene *CSceneEntity::LoadScene( const char *filename, IChoreoEventCallback *pCallback )
+{
+	char loadfile[MAX_PATH];
+	Q_strncpy( loadfile, filename, sizeof( loadfile ) );
+	Q_SetExtension( loadfile, ".vcd", sizeof( loadfile ) );
+	Q_FixSlashes( loadfile );
+ 
+	void *pBuffer = 0;
+	CChoreoScene *pScene;
+ 
+	int fileSize = filesystem->ReadFileEx( loadfile, "GAME", &pBuffer, true );
+	if (fileSize)
+	{
+		g_TokenProcessor.SetBuffer((char*)pBuffer);
+		pScene = ChoreoLoadScene( loadfile, NULL, &g_TokenProcessor, LocalScene_Printf );
+	}
+	else
+	{
+		// binary compiled vcd
+		pScene = new CChoreoScene( NULL );
+		if ( !CopySceneFileIntoMemory( loadfile, &pBuffer, &fileSize ) )
+		{
+			MissingSceneWarning( loadfile );
+			return NULL;
+		}
+		CUtlBuffer buf( pBuffer, fileSize, CUtlBuffer::READ_ONLY );
+		if ( !pScene->RestoreFromBinaryBuffer( buf, loadfile, &g_ChoreoStringPool ) )
+		{
+			Warning( "CSceneEntity::LoadScene: Unable to load scene '%s'\n", loadfile );
+			delete pScene;
+			pScene = NULL;
+		}
+	}
+ 
+	if(pScene)
+	{
+		pScene->SetPrintFunc( LocalScene_Printf );
+		pScene->SetEventCallbackInterface( pCallback );
+	}
+ 
+	FreeSceneFileMemory( pBuffer );
+	return pScene;
+}
+#else
 CChoreoScene *CSceneEntity::LoadScene( const char *filename, IChoreoEventCallback *pCallback )
 {
 	DevMsg( 2, "Blocking load of scene from '%s'\n", filename );
@@ -3362,6 +3518,7 @@ CChoreoScene *CSceneEntity::LoadScene( const char *filename, IChoreoEventCallbac
 	FreeSceneFileMemory( pBuffer );
 	return pScene;
 }
+#endif
 
 CChoreoScene *BlockingLoadScene( const char *filename )
 {
@@ -3732,7 +3889,18 @@ CBaseEntity *CSceneEntity::FindNamedEntity( const char *name, CBaseEntity *pActo
 
 	if ( !stricmp( name, "Player" ) || !stricmp( name, "!player" ))
 	{
+#ifndef HL2SB
 		entity = ( gpGlobals->maxClients == 1 ) ? ( CBaseEntity * )UTIL_GetLocalPlayer() : NULL;
+#else
+		if (pActor == NULL)
+		{
+			entity = ( gpGlobals->maxClients == 1 ) ? ( CBaseEntity * )UTIL_GetLocalPlayer() : NULL;
+		}
+		else
+		{
+			entity = ( CBaseEntity * )UTIL_GetNearestPlayer( pActor->GetAbsOrigin() );
+		}
+#endif
 	}
 	else if ( !stricmp( name, "!target1" ) )
 	{
@@ -3859,7 +4027,11 @@ CBaseEntity *CSceneEntity::FindNamedEntityClosest( const char *name, CBaseEntity
 	} 
 	else if ( !stricmp( name, "Player" ) || !stricmp( name, "!player" ))
 	{
+#ifndef HL2SB
 		entity = ( gpGlobals->maxClients == 1 ) ? ( CBaseEntity * )UTIL_GetLocalPlayer() : NULL;
+#else
+		entity = ( CBaseEntity * )UTIL_GetNearestPlayer( pActor->GetAbsOrigin() );
+#endif
 		return entity;
 	}
 	else if ( !stricmp( name, "!target1" ) )
diff --git a/src/game/server/server_hl2mp-2005.vcproj b/src/game/server/server_hl2mp-2005.vcproj
index f6a2ae9..7cad012 100644
--- a/src/game/server/server_hl2mp-2005.vcproj
+++ b/src/game/server/server_hl2mp-2005.vcproj
@@ -2,8 +2,9 @@
 <VisualStudioProject
 	ProjectType="Visual C++"
 	Version="8.00"
-	Name="Server HL2MP"
+	Name="Server HL2SB"
 	ProjectGUID="{4254C2D9-2C38-4911-BD4A-EB034CBD48D1}"
+	RootNamespace="Server HL2SB"
 	>
 	<Platforms>
 		<Platform
@@ -15,8 +16,8 @@
 	<Configurations>
 		<Configuration
 			Name="Debug|Win32"
-			OutputDirectory=".\Debug_hl2mp"
-			IntermediateDirectory=".\Debug_hl2mp"
+			OutputDirectory=".\Debug_hl2sb"
+			IntermediateDirectory=".\Debug_hl2sb"
 			ConfigurationType="2"
 			CharacterSet="2"
 			>
@@ -27,9 +28,9 @@
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
-				Description="Copying to D:\SteamLibrary\steamapps\SourceMods\mymod\bin\"
-				CommandLine="if exist &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\server.dll&quot; attrib -r &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\server.dll&quot;&#x0D;&#x0A;if exist &quot;$(TargetDir)&quot;server.dll copy &quot;$(TargetDir)&quot;server.dll &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\server.dll&quot;&#x0D;&#x0A;"
-				Outputs="D:\SteamLibrary\steamapps\SourceMods\mymod\bin\server.dll"
+				Description=""
+				CommandLine=""
+				Outputs=""
 			/>
 			<Tool
 				Name="VCXMLDataGeneratorTool"
@@ -44,8 +45,8 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="/MP"
 				Optimization="0"
-				AdditionalIncludeDirectories="..\..\common;..\..\public;..\..\public\tier0;..\..\public\tier1;.\;..\..\game\shared;..\..\utils\common;..\..\game\shared\hl2;.\hl2;.\hl2mp;..\..\game\shared\hl2mp;..\..\game\shared\Multiplayer"
-				PreprocessorDefinitions="WIN32;_WIN32;_DEBUG;DEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;GAME_DLL;VECTOR;PROTECTED_THINGS_ENABLE;fopen=dont_use_fopen;sprintf=use_Q_snprintf_instead_of_sprintf;strncpy=use_Q_strncpy_instead;_snprintf=use_Q_snprintf_instead;HL2MP;MP_SDK;HL2_DLL;VERSION_SAFE_STEAM_API_INTERFACES"
+				AdditionalIncludeDirectories="..\..\lua-5.1.5\src;..\..\lua-5.1.5\etc;..\..\open-steamworks\Open Steamworks;..\..\common;..\..\public;..\..\public\tier0;..\..\public\tier1;.\;..\..\game\shared;..\..\utils\common;..\..\game\shared\hl2;..\..\game\shared\episodic;.\hl2;.\hl2mp;.\episodic;..\..\game\shared\hl2mp;..\..\game\shared\Multiplayer"
+				PreprocessorDefinitions="WIN32;_WIN32;_DEBUG;DEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;GAME_DLL;VECTOR;PROTECTED_THINGS_ENABLE;fopen=dont_use_fopen;sprintf=use_Q_snprintf_instead_of_sprintf;strncpy=use_Q_strncpy_instead;_snprintf=use_Q_snprintf_instead;HL2MP;HL2SB;MP_SDK;LUA_SDK;ARGG;HL2_DLL;HL2_EPISODIC;VERSION_SAFE_STEAM_API_INTERFACES"
 				StringPooling="true"
 				MinimalRebuild="true"
 				ExceptionHandling="0"
@@ -84,12 +85,12 @@
 			<Tool
 				Name="VCLinkerTool"
 				UseUnicodeResponseFiles="false"
-				AdditionalDependencies=" winmm.lib"
+				AdditionalDependencies=" winmm.lib user32.lib lua51.lib"
 				ShowProgress="0"
 				OutputFile="$(OutDir)/Server.dll"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="..\..\lib\common;..\..\lib\public"
+				AdditionalLibraryDirectories="..\..\lua-5.1.5\src;..\..\lib\common;..\..\lib\public"
 				GenerateManifest="false"
 				IgnoreDefaultLibraryNames="libc;libcd;libcmt"
 				GenerateDebugInformation="true"
@@ -128,14 +129,15 @@
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
-				CommandLine=""
+				Description="Copying to c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\"
+				CommandLine="if exist &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\server.dll&quot; attrib -r &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\server.dll&quot;&#x0D;&#x0A;if exist &quot;$(TargetDir)&quot;server.dll copy &quot;$(TargetDir)&quot;server.dll &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\server.dll&quot;&#x0D;&#x0A;"
 				ExcludedFromBuild="false"
 			/>
 		</Configuration>
 		<Configuration
 			Name="Release|Win32"
-			OutputDirectory=".\Release_hl2mp"
-			IntermediateDirectory=".\Release_hl2mp"
+			OutputDirectory=".\Release_hl2sb"
+			IntermediateDirectory=".\Release_hl2sb"
 			ConfigurationType="2"
 			CharacterSet="2"
 			>
@@ -146,9 +148,9 @@
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
-				Description="Copying to D:\SteamLibrary\steamapps\SourceMods\mymod\bin\"
-				CommandLine="if exist &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\server.dll&quot; attrib -r &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\server.dll&quot;&#x0D;&#x0A;if exist &quot;$(TargetDir)&quot;server.dll copy &quot;$(TargetDir)&quot;server.dll &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\server.dll&quot;&#x0D;&#x0A;if exist &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\server.pdb&quot; attrib -r &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\server.pdb&quot;&#x0D;&#x0A;if exist &quot;$(TargetDir)&quot;server.pdb copy &quot;$(TargetDir)&quot;server.pdb &quot;D:\SteamLibrary\steamapps\SourceMods\mymod\bin&quot;&#x0D;&#x0A;"
-				Outputs="D:\SteamLibrary\steamapps\SourceMods\mymod\bin\server.dll;D:\SteamLibrary\steamapps\SourceMods\mymod\bin\server.pdb"
+				Description=""
+				CommandLine=""
+				Outputs=""
 			/>
 			<Tool
 				Name="VCXMLDataGeneratorTool"
@@ -166,8 +168,8 @@
 				InlineFunctionExpansion="2"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="..\..\common;..\..\public;..\..\public\tier0;..\..\public\tier1;.\;..\..\game\shared;..\..\utils\common;..\..\game\shared\hl2;.\hl2;.\hl2mp;..\..\game\shared\hl2mp;..\..\game\shared\Multiplayer"
-				PreprocessorDefinitions="WIN32;_WIN32;NDEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;GAME_DLL;VECTOR;PROTECTED_THINGS_ENABLE;fopen=dont_use_fopen;sprintf=use_Q_snprintf_instead_of_sprintf;strncpy=use_Q_strncpy_instead;_snprintf=use_Q_snprintf_instead;HL2MP;MP_SDK;HL2_DLL;VERSION_SAFE_STEAM_API_INTERFACES"
+				AdditionalIncludeDirectories="..\..\lua-5.1.5\src;..\..\lua-5.1.5\etc;..\..\open-steamworks\Open Steamworks;..\..\common;..\..\public;..\..\public\tier0;..\..\public\tier1;.\;..\..\game\shared;..\..\utils\common;..\..\game\shared\hl2;..\..\game\shared\episodic;.\hl2;.\episodic;.\hl2mp;..\..\game\shared\hl2mp;..\..\game\shared\Multiplayer"
+				PreprocessorDefinitions="WIN32;_WIN32;NDEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;GAME_DLL;VECTOR;PROTECTED_THINGS_ENABLE;fopen=dont_use_fopen;sprintf=use_Q_snprintf_instead_of_sprintf;strncpy=use_Q_strncpy_instead;_snprintf=use_Q_snprintf_instead;HL2MP;HL2SB;MP_SDK;LUA_SDK;ARGG;HL2_DLL;HL2_EPISODIC;VERSION_SAFE_STEAM_API_INTERFACES"
 				StringPooling="true"
 				ExceptionHandling="0"
 				RuntimeLibrary="0"
@@ -205,12 +207,12 @@
 			<Tool
 				Name="VCLinkerTool"
 				UseUnicodeResponseFiles="false"
-				AdditionalDependencies=" winmm.lib"
+				AdditionalDependencies=" winmm.lib user32.lib lua51.lib"
 				ShowProgress="0"
 				OutputFile="$(OutDir)/Server.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="..\..\lib\common;..\..\lib\public"
+				AdditionalLibraryDirectories="..\..\lua-5.1.5\src;..\..\lib\common;..\..\lib\public"
 				GenerateManifest="false"
 				IgnoreDefaultLibraryNames="libc;libcd;libcmtd"
 				GenerateDebugInformation="true"
@@ -251,7 +253,8 @@
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
-				CommandLine=""
+				Description="Copying to c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\"
+				CommandLine="if exist &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\server.dll&quot; attrib -r &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\server.dll&quot;&#x0D;&#x0A;if exist &quot;$(TargetDir)&quot;server.dll copy &quot;$(TargetDir)&quot;server.dll &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\server.dll&quot;&#x0D;&#x0A;if exist &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\server.pdb&quot; attrib -r &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin\server.pdb&quot;&#x0D;&#x0A;if exist &quot;$(TargetDir)&quot;server.pdb copy &quot;$(TargetDir)&quot;server.pdb &quot;c:\program files (x86)\steam\steamapps\SourceMods\hl2sb\bin&quot;&#x0D;&#x0A;"
 				ExcludedFromBuild="false"
 			/>
 		</Configuration>
@@ -474,6 +477,14 @@
 				RelativePath=".\ai_event.cpp"
 				>
 			</File>
+			<File
+				RelativePath=".\ai_eventresponse.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\ai_eventresponse.h"
+				>
+			</File>
 			<File
 				RelativePath=".\ai_goalentity.cpp"
 				>
@@ -946,6 +957,22 @@
 				RelativePath=".\BasePropDoor.h"
 				>
 			</File>
+			<File
+				RelativePath="..\shared\basescripted.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\basescripted.h"
+				>
+			</File>
+			<File
+				RelativePath=".\basescriptedtrigger.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\basescriptedtrigger.h"
+				>
+			</File>
 			<File
 				RelativePath=".\basetoggle.h"
 				>
@@ -1986,6 +2013,94 @@
 				RelativePath="..\..\public\keyframe\keyframe.h"
 				>
 			</File>
+			<File
+				RelativePath=".\lbaseanimating.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\lbaseanimating.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lbasecombatweapon_shared.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lbasecombatweapon_shared.h"
+				>
+			</File>
+			<File
+				RelativePath=".\lbaseentity.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\lbaseentity.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lbaseentity_shared.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lbaseentity_shared.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lbaseplayer_shared.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lbaseplayer_shared.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lbspflags.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lColor.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier1\lconvar.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier0\ldbg.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\leffect_dispatch_data.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\leiface.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\lentitylist.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lfilesystem.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lgametrace.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lglobalvars_base.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier1\liconvar.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\licvar.cpp"
+				>
+			</File>
 			<File
 				RelativePath=".\lightglow.cpp"
 				>
@@ -1998,6 +2113,58 @@
 				RelativePath=".\lights.h"
 				>
 			</File>
+			<File
+				RelativePath="..\..\public\materialsystem\limaterial.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\limovehelper.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lin_buttons.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\linetchannelinfo.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lipredictionsystem.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\SoundEmitterSystem\lisoundemittersystembase.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\steam\listeamfriends.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\steam\listeamfriends.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\engine\livdebugoverlay.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier1\LKeyValues.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\mathlib\lmathlib.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lnetworkstringtabledefs.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lnetworkstringtabledefs.h"
+				>
+			</File>
 			<File
 				RelativePath=".\locksounds.h"
 				>
@@ -2022,6 +2189,94 @@
 				RelativePath=".\logicrelay.cpp"
 				>
 			</File>
+			<File
+				RelativePath="..\..\public\vphysics\lperformance.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vphysics\lperformance.h"
+				>
+			</File>
+			<File
+				RelativePath=".\lplayer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\vstdlib\lrandom.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\lrecipientfilter.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\lrecipientfilter.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lshareddefs.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lsrcinit.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\steam\lsteam_api.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\steam\lsteam_api.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\ltakedamageinfo.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\luacachefile.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\luacachefile.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\luamanager.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\luamanager.h"
+				>
+			</File>
+			<File
+				RelativePath=".\lutil.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\lutil.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lutil_shared.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\mathlib\lvector.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\mathlib\lvmatrix.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\mathlib\lvmatrix.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lvphysics_interface.cpp"
+				>
+			</File>
 			<File
 				RelativePath="..\..\public\map_utils.cpp"
 				>
@@ -2110,6 +2365,22 @@
 				RelativePath=".\monstermaker.h"
 				>
 			</File>
+			<File
+				RelativePath="..\shared\mountaddons.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\mountaddons.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\mountsteamcontent.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\mountsteamcontent.h"
+				>
+			</File>
 			<File
 				RelativePath=".\movehelper_server.cpp"
 				>
@@ -3090,6 +3361,10 @@
 				RelativePath=".\textstatsmgr.cpp"
 				>
 			</File>
+			<File
+				RelativePath=".\ticketfix.cpp"
+				>
+			</File>
 			<File
 				RelativePath=".\timedeventmgr.cpp"
 				>
@@ -3142,6 +3417,10 @@
 				RelativePath=".\vehicle_baseserver.cpp"
 				>
 			</File>
+			<File
+				RelativePath=".\vehicle_choreo_generic.cpp"
+				>
+			</File>
 			<File
 				RelativePath=".\vehicle_sounds.h"
 				>
@@ -3222,6 +3501,10 @@
 				RelativePath=".\world.h"
 				>
 			</File>
+			<File
+				RelativePath="..\..\public\zip_utils_src.cpp"
+				>
+			</File>
 			<Filter
 				Name="Precompiled Header"
 				>
@@ -3521,6 +3804,30 @@
 					RelativePath=".\hl2\ai_behavior_holster.h"
 					>
 				</File>
+				<File
+					RelativePath=".\hl2\ai_behavior_operator.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\hl2\ai_behavior_operator.h"
+					>
+				</File>
+				<File
+					RelativePath=".\ai_behavior_passenger.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\ai_behavior_passenger.h"
+					>
+				</File>
+				<File
+					RelativePath=".\episodic\ai_behavior_passenger_companion.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\episodic\ai_behavior_passenger_companion.h"
+					>
+				</File>
 				<File
 					RelativePath=".\hl2\ai_behavior_police.cpp"
 					>
@@ -3697,6 +4004,14 @@
 					RelativePath=".\hl2\grenade_frag.h"
 					>
 				</File>
+				<File
+					RelativePath=".\hl2\grenade_spit.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\hl2\grenade_spit.h"
+					>
+				</File>
 				<File
 					RelativePath=".\hl2\hl2_ai_network.cpp"
 					>
@@ -3761,6 +4076,14 @@
 					RelativePath=".\hl2\hl_playermove.cpp"
 					>
 				</File>
+				<File
+					RelativePath=".\hl2\info_darknessmode_lightsource.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\hl2\info_darknessmode_lightsource.h"
+					>
+				</File>
 				<File
 					RelativePath=".\hl2\info_teleporter_countdown.cpp"
 					>
@@ -3802,11 +4125,11 @@
 					>
 				</File>
 				<File
-					RelativePath=".\hl2\npc_alyx.cpp"
+					RelativePath=".\hl2\npc_alyx_episodic.cpp"
 					>
 				</File>
 				<File
-					RelativePath=".\hl2\npc_alyx.h"
+					RelativePath=".\hl2\npc_alyx_episodic.h"
 					>
 				</File>
 				<File
@@ -3949,6 +4272,14 @@
 					RelativePath=".\hl2\npc_headcrab.h"
 					>
 				</File>
+				<File
+					RelativePath=".\episodic\npc_hunter.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\episodic\npc_hunter.h"
+					>
+				</File>
 				<File
 					RelativePath=".\hl2\npc_ichthyosaur.cpp"
 					>
@@ -4057,6 +4388,10 @@
 					RelativePath=".\hl2\npc_zombie.cpp"
 					>
 				</File>
+				<File
+					RelativePath=".\hl2\npc_zombine.cpp"
+					>
+				</File>
 				<File
 					RelativePath=".\hl2\point_apc_controller.cpp"
 					>
@@ -4113,6 +4448,26 @@
 					RelativePath=".\hl2\vehicle_crane.h"
 					>
 				</File>
+				<File
+					RelativePath=".\episodic\vehicle_hl2buggy.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\episodic\vehicle_hl2buggy.h"
+					>
+				</File>
+				<File
+					RelativePath=".\hl2\vehicle_jeep.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\episodic\vehicle_jeep_episodic.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\episodic\vehicle_jeep_episodic.h"
+					>
+				</File>
 				<File
 					RelativePath=".\hl2\vehicle_prisoner_pod.cpp"
 					>
@@ -4121,6 +4476,10 @@
 					RelativePath=".\hl2\vehicle_viewcontroller.cpp"
 					>
 				</File>
+				<File
+					RelativePath=".\hl2\weapon_alyxgun.cpp"
+					>
+				</File>
 				<File
 					RelativePath=".\hl2\weapon_alyxgun.h"
 					>
@@ -4141,6 +4500,14 @@
 					RelativePath=".\weapon_cubemap.cpp"
 					>
 				</File>
+				<File
+					RelativePath=".\episodic\weapon_striderbuster.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\episodic\weapon_striderbuster.h"
+					>
+				</File>
 				<Filter
 					Name="unused"
 					>
@@ -4253,6 +4620,22 @@
 					RelativePath="..\shared\hl2mp\hl2mp_weapon_parse.h"
 					>
 				</File>
+				<File
+					RelativePath=".\hl2\lhl2_player.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\hl2\lhl2_player.h"
+					>
+				</File>
+				<File
+					RelativePath="..\shared\hl2mp\lhl2mp_player_shared.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\shared\hl2mp\lhl2mp_player_shared.h"
+					>
+				</File>
 				<Filter
 					Name="Weapons"
 					>
@@ -4320,6 +4703,14 @@
 						RelativePath="..\shared\hl2mp\weapon_hl2mpbase_machinegun.h"
 						>
 					</File>
+					<File
+						RelativePath="..\shared\hl2mp\weapon_hl2mpbase_scriptedweapon.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\shared\hl2mp\weapon_hl2mpbase_scriptedweapon.h"
+						>
+					</File>
 					<File
 						RelativePath="..\shared\hl2mp\weapon_hl2mpbasebasebludgeon.cpp"
 						>
@@ -4340,6 +4731,10 @@
 						RelativePath="..\shared\hl2mp\weapon_physcannon.h"
 						>
 					</File>
+					<File
+						RelativePath="..\shared\hl2mp\weapon_physgun.cpp"
+						>
+					</File>
 					<File
 						RelativePath="..\shared\hl2mp\weapon_pistol.cpp"
 						>
@@ -4378,11 +4773,11 @@
 				Name="PluginInterface"
 				>
 				<File
-					RelativePath=".\playerinfomanager.h"
+					RelativePath=".\playerinfomanager.cpp"
 					>
 				</File>
 				<File
-					RelativePath=".\playerinfomanager.cpp"
+					RelativePath=".\playerinfomanager.h"
 					>
 				</File>
 			</Filter>
@@ -4410,6 +4805,10 @@
 				RelativePath="..\..\lib\public\dmxloader.lib"
 				>
 			</File>
+			<File
+				RelativePath="..\..\lua-5.1.5\src\lua51.lib"
+				>
+			</File>
 			<File
 				RelativePath="..\..\lib\public\mathlib.lib"
 				>
@@ -4886,10 +5285,90 @@
 				RelativePath="..\..\public\tier0\l2cache.h"
 				>
 			</File>
+			<File
+				RelativePath="..\..\public\lcmodel.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lColor.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier0\ldbg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\leffect_dispatch_data.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lfilesystem.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lgametrace.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lglobalvars_base.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\licvar.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\materialsystem\limaterial.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\limovehelper.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\linetchannelinfo.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\SoundEmitterSystem\lisoundemittersystembase.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\engine\livdebugoverlay.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\tier1\LKeyValues.h"
+				>
+			</File>
 			<File
 				RelativePath=".\logicrelay.h"
 				>
 			</File>
+			<File
+				RelativePath="..\shared\lshareddefs.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\ltakedamageinfo.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\luasrclib.h"
+				>
+			</File>
+			<File
+				RelativePath="..\shared\lutil_shared.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\mathlib\lvector.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\public\lvphysics_interface.h"
+				>
+			</File>
 			<File
 				RelativePath="..\..\public\map_utils.h"
 				>
diff --git a/src/game/server/test_stressentities.cpp b/src/game/server/test_stressentities.cpp
index 3b24deb..992a345 100644
--- a/src/game/server/test_stressentities.cpp
+++ b/src/game/server/test_stressentities.cpp
@@ -26,7 +26,11 @@ CBaseEntity* MoveToRandomSpot( CBaseEntity *pEnt )
 {
 	if ( pEnt )
 	{
+#ifdef HL2SB
+		CBasePlayer *pLocalPlayer = UTIL_GetNearestPlayer( pEnt->GetAbsOrigin() );
+#else
 		CBasePlayer *pLocalPlayer = UTIL_GetLocalPlayer();
+#endif
 		if ( pLocalPlayer )
 		{			
 			Vector vForward;
diff --git a/src/game/server/ticketfix.cpp b/src/game/server/ticketfix.cpp
new file mode 100644
index 0000000..fb2fd2c
--- /dev/null
+++ b/src/game/server/ticketfix.cpp
@@ -0,0 +1,79 @@
+//========== Copyleft  2011, Team Sandbox, Some rights reserved. ===========//
+//
+// Purpose:
+//
+//===========================================================================//
+
+#include "cbase.h"
+#include "ticketfix.h"
+
+#if defined(_WIN32)
+#pragma warning(disable : 4005)
+#include <windows.h>
+#endif 
+
+bool GetEngineBinaryInfo(void** pEngineBase, unsigned int& cubEngineSize)
+{
+#if defined(_WIN32)
+	HMODULE hEngine = GetModuleHandleA("engine.dll");
+	ASSERT(hEngine != NULL);
+
+	IMAGE_DOS_HEADER* pDOSHeader = reinterpret_cast<IMAGE_DOS_HEADER*>(hEngine);
+	if( pDOSHeader == NULL )
+		return false;
+
+	ASSERT(pDOSHeader->e_magic == IMAGE_DOS_SIGNATURE);
+
+	IMAGE_NT_HEADERS* pNTHeaders = reinterpret_cast<IMAGE_NT_HEADERS*>(pDOSHeader->e_lfanew + (LONG)pDOSHeader);
+	if( pNTHeaders == NULL )
+		return false;
+
+	ASSERT( pNTHeaders->Signature == IMAGE_NT_SIGNATURE );
+
+	if( pEngineBase )
+		*pEngineBase = reinterpret_cast<void*>(hEngine);
+
+	cubEngineSize = pNTHeaders->OptionalHeader.SizeOfImage;
+
+	return true;
+#else
+	// TODO: Implement me when necessary.
+	return false;
+#endif
+}
+
+bool PatchTicketValidation()
+{
+	const unsigned char *pEngineBase = NULL;
+	unsigned int cubEngineSize = 0;
+
+	if( !GetEngineBinaryInfo((void**)&pEngineBase, cubEngineSize) )
+		return false;
+
+	// 8B442404BA010000003991C8000000751566895068C7407000000000C740
+
+	const unsigned char cubPattern[31] = 
+		"\x8B\x44\x24\x04\xBA\x01\x00\x00\x00\x39\x91\xC8\x00\x00\x00\x75\x15\x66\x89\x50\x68\xC7\x40\x70\x00\x00\x00\x00\xC7\x40";
+
+	for(unsigned int n = 0; n < cubEngineSize; n++)
+	{
+		if( memcmp((void*)(pEngineBase + n), cubPattern, 30) == 0 )
+		{
+#if defined(_DEBUG)
+			DevMsg("Patching corrupted ticket validation: 0x%p\n", pEngineBase + n);
+#endif
+
+			DWORD dwOldProtect;
+			VirtualProtect((LPVOID)(pEngineBase + n + 15), 2, PAGE_EXECUTE_READWRITE, &dwOldProtect);
+
+			memcpy((void*)(pEngineBase + n + 15), "\x90\x90", 2);
+
+			VirtualProtect((LPVOID)(pEngineBase + n + 15), 2, dwOldProtect, &dwOldProtect);
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
diff --git a/src/game/server/ticketfix.h b/src/game/server/ticketfix.h
new file mode 100644
index 0000000..e8db8da
--- /dev/null
+++ b/src/game/server/ticketfix.h
@@ -0,0 +1,15 @@
+//========== Copyleft  2011, Team Sandbox, Some rights reserved. ===========//
+//
+// Purpose:
+//
+//===========================================================================//
+
+#ifndef TICKETFIX_H
+#define TICKETFIX_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+bool PatchTicketValidation();
+
+#endif // TICKETFIX_H
diff --git a/src/game/server/triggers.cpp b/src/game/server/triggers.cpp
index 196aa67..537ed9d 100644
--- a/src/game/server/triggers.cpp
+++ b/src/game/server/triggers.cpp
@@ -38,6 +38,10 @@
 #include "hl2_player.h"
 #endif
 
+#ifdef LUA_SDK
+#include "luamanager.h"
+#endif
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -1323,6 +1327,17 @@ bool CChangeLevel::KeyValue( const char *szKeyName, const char *szValue )
 			Assert(0);
 		}
 		Q_strncpy(m_szMapName, szValue, sizeof(m_szMapName));
+#ifdef LUA_SDK
+		if (m_nTableReference == LUA_NOREF)
+		{
+			lua_newtable(L);
+			m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+		}
+		lua_getref(L, m_nTableReference);
+		lua_pushstring(L, m_szMapName);
+		lua_setfield(L, -2, "m_szMapName");
+		lua_pop(L, 1);
+#endif
 	}
 	else if (FStrEq(szKeyName, "landmark"))
 	{
@@ -1333,6 +1348,17 @@ bool CChangeLevel::KeyValue( const char *szKeyName, const char *szValue )
 		}
 		
 		Q_strncpy(m_szLandmarkName, szValue, sizeof( m_szLandmarkName ));
+#ifdef LUA_SDK
+		if (m_nTableReference == LUA_NOREF)
+		{
+			lua_newtable(L);
+			m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+		}
+		lua_getref(L, m_nTableReference);
+		lua_pushstring(L, m_szLandmarkName);
+		lua_setfield(L, -2, "m_szLandmarkName");
+		lua_pop(L, 1);
+#endif
 	}
 	else
 		return BaseClass::KeyValue( szKeyName, szValue );
@@ -1439,6 +1465,14 @@ void CChangeLevel::InputChangeLevel( inputdata_t &inputdata )
 		if ( pPlayer && ( !pPlayer->IsAlive() || pPlayer->GetBonusChallenge() > 0 ) )
 			return;
 	}
+#ifdef HL2SB
+	else
+	{
+		CBasePlayer *pPlayer = inputdata.pActivator->IsPlayer() ? (CBasePlayer *)inputdata.pActivator : NULL;
+		if ( pPlayer && ( !pPlayer->IsAlive() || pPlayer->GetBonusChallenge() > 0 ) )
+			return;
+	}
+#endif
 
 	ChangeLevelNow( inputdata.pActivator );
 }
@@ -1526,9 +1560,11 @@ void CChangeLevel::ChangeLevelNow( CBaseEntity *pActivator )
 
 	Assert(!FStrEq(m_szMapName, ""));
 
+// #ifndef HL2SB
 	// Don't work in deathmatch
 	if ( g_pGameRules->IsDeathmatch() )
 		return;
+// #endif
 
 	// Some people are firing these multiple times in a frame, disable
 	if ( m_bTouched )
@@ -1536,7 +1572,13 @@ void CChangeLevel::ChangeLevelNow( CBaseEntity *pActivator )
 
 	m_bTouched = true;
 
+#ifdef HL2SB
+	CBasePlayer *pPlayer = (pActivator && pActivator->IsPlayer()) ? ToBasePlayer( pActivator ) : UTIL_GetLocalPlayer();
+	if( !pPlayer )
+		return;
+#else
 	CBaseEntity *pPlayer = (pActivator && pActivator->IsPlayer()) ? pActivator : UTIL_GetLocalPlayer();
+#endif
 
 	int transitionState = InTransitionVolume(pPlayer, m_szLandmarkName);
 	if ( transitionState == TRANSITION_VOLUME_SCREENED_OUT )
@@ -2852,6 +2894,10 @@ void CTriggerCamera::Spawn( void )
 	SetRenderColorA( 0 );								// The engine won't draw this model if this is set to 0 and blending is on
 	m_nRenderMode = kRenderTransTexture;
 
+#ifdef HL2SB
+	m_nOldTakeDamage = -1;
+#endif
+
 	m_state = USE_OFF;
 	
 	m_initialSpeed = m_flSpeed;
@@ -2933,7 +2979,11 @@ void CTriggerCamera::Enable( void )
 
 	if ( !m_hPlayer || !m_hPlayer->IsPlayer() )
 	{
+#ifdef HL2SB
+		m_hPlayer = UTIL_GetNearestPlayer( GetAbsOrigin() );
+#else
 		m_hPlayer = UTIL_GetLocalPlayer();
+#endif
 	}
 
 	if ( !m_hPlayer )
@@ -3127,7 +3177,12 @@ void CTriggerCamera::Disable( void )
 	}
 
 	//return the player to previous takedamage state
+#ifndef HL2SB
 	m_hPlayer->m_takedamage = m_nOldTakeDamage;
+#else
+	if ( m_nOldTakeDamage != -1 )
+		m_hPlayer->m_takedamage = m_nOldTakeDamage;
+#endif
 
 	m_state = USE_OFF;
 	m_flReturnTime = gpGlobals->curtime;
diff --git a/src/game/server/util.cpp b/src/game/server/util.cpp
index 9f23962..d3b2569 100644
--- a/src/game/server/util.cpp
+++ b/src/game/server/util.cpp
@@ -72,6 +72,9 @@ public:
 	CEntityFactoryDictionary();
 
 	virtual void InstallFactory( IEntityFactory *pFactory, const char *pClassName );
+#ifdef LUA_SDK
+	virtual void RemoveFactory( IEntityFactory *pFactory, const char *pClassName );
+#endif
 	virtual IServerNetworkable *Create( const char *pClassName );
 	virtual void Destroy( const char *pClassName, IServerNetworkable *pNetworkable );
 	virtual const char *GetCannonicalName( const char *pClassName );
@@ -141,11 +144,24 @@ IEntityFactory *CEntityFactoryDictionary::FindFactory( const char *pClassName )
 //-----------------------------------------------------------------------------
 void CEntityFactoryDictionary::InstallFactory( IEntityFactory *pFactory, const char *pClassName )
 {
+#ifndef HL2SB
 	Assert( FindFactory( pClassName ) == NULL );
+#endif
 	m_Factories.Insert( pClassName, pFactory );
 }
 
 
+#ifdef LUA_SDK
+//-----------------------------------------------------------------------------
+// Remove an existing factory
+//-----------------------------------------------------------------------------
+void CEntityFactoryDictionary::RemoveFactory( IEntityFactory *pFactory, const char *pClassName )
+{
+	m_Factories.Remove( pClassName );
+}
+#endif
+
+
 //-----------------------------------------------------------------------------
 // Instantiate something using a factory
 //-----------------------------------------------------------------------------
@@ -609,8 +625,27 @@ CBasePlayer* UTIL_PlayerByUserId( int userID )
 // 
 CBasePlayer *UTIL_GetLocalPlayer( void )
 {
+#ifdef HL2SB
+	// HACKHACK: We change the behavior of UTIL_GetLocalPlayer() here to be
+	// compatible with multiplayer games for the sake of not crashing.
+	CBasePlayer *pHostPlayer = UTIL_GetListenServerHost();
+	if ( pHostPlayer != NULL )
+		return pHostPlayer;
+#endif
+
 	if ( gpGlobals->maxClients > 1 )
 	{
+#ifdef HL2SB
+		for( int iClient = 1; iClient <= gpGlobals->maxClients; ++iClient )
+		{
+			CBasePlayer *pEnt = UTIL_PlayerByIndex( iClient );
+			if(!pEnt || !pEnt->IsPlayer())
+				continue;
+
+			// Return the first player we can get a hold of.
+			return pEnt;
+		}
+#else
 		if ( developer.GetBool() )
 		{
 			Assert( !"UTIL_GetLocalPlayer" );
@@ -621,11 +656,66 @@ CBasePlayer *UTIL_GetLocalPlayer( void )
 		}
 
 		return NULL;
+#endif
 	}
 
 	return UTIL_PlayerByIndex( 1 );
 }
 
+#ifdef HL2SB
+CBasePlayer *UTIL_GetNearestPlayer( const Vector& pos )
+{
+	CBasePlayer *pPlayer = NULL;
+	float	flNearestDistSqr = FLT_MAX;
+	float	flDistSqr;
+	for( int iClient = 1; iClient <= gpGlobals->maxClients; ++iClient )
+	{
+		CBasePlayer *pEnt = UTIL_PlayerByIndex( iClient );
+		if(!pEnt || !pEnt->IsPlayer())
+			continue;
+
+		// Distance is the deciding factor
+		flDistSqr = ( pos - pEnt->GetAbsOrigin() ).LengthSqr();
+
+		// Closer, take it
+		if ( flDistSqr < flNearestDistSqr )
+		{
+			flNearestDistSqr = flDistSqr;
+			pPlayer = pEnt;
+		}
+	}
+	
+	return pPlayer;
+}
+
+CBasePlayer *UTIL_GetNearestVisiblePlayer( CBaseEntity *pEntity, int mask )
+{
+	const Vector& pos = pEntity->GetAbsOrigin();
+
+	CBasePlayer *pPlayer = NULL;
+	float	flNearestDistSqr = FLT_MAX;
+	float	flDistSqr;
+	for( int iClient = 1; iClient <= gpGlobals->maxClients; ++iClient )
+	{
+		CBasePlayer *pEnt = UTIL_PlayerByIndex( iClient );
+		if(!pEnt || !pEnt->IsPlayer())
+			continue;
+
+		// Distance is the deciding factor
+		flDistSqr = ( pos - pEnt->GetAbsOrigin() ).LengthSqr();
+
+		// Closer, take it
+		if ( flDistSqr < flNearestDistSqr && pEntity->FVisible( pEnt, mask ) )
+		{
+			flNearestDistSqr = flDistSqr;
+			pPlayer = pEnt;
+		}
+	}
+
+	return pPlayer;
+}
+#endif
+
 //
 // Get the local player on a listen server - this is for multiplayer use only
 // 
diff --git a/src/game/server/util.h b/src/game/server/util.h
index 63c62f5..800ab93 100644
--- a/src/game/server/util.h
+++ b/src/game/server/util.h
@@ -83,6 +83,9 @@ abstract_class IEntityFactoryDictionary
 {
 public:
 	virtual void InstallFactory( IEntityFactory *pFactory, const char *pClassName ) = 0;
+#ifdef LUA_SDK
+	virtual void RemoveFactory( IEntityFactory *pFactory, const char *pClassName ) = 0;
+#endif
 	virtual IServerNetworkable *Create( const char *pClassName ) = 0;
 	virtual void Destroy( const char *pClassName, IServerNetworkable *pNetworkable ) = 0;
 	virtual IEntityFactory *FindFactory( const char *pClassName ) = 0;
@@ -111,7 +114,17 @@ public:
 	CEntityFactory( const char *pClassName )
 	{
 		EntityFactoryDictionary()->InstallFactory( this, pClassName );
+#ifdef LUA_SDK
+		strcpy( classname, pClassName );
+#endif
+	}
+
+#ifdef LUA_SDK
+	~CEntityFactory()
+	{
+		EntityFactoryDictionary()->RemoveFactory( this, classname );
 	}
+#endif
 
 	IServerNetworkable *Create( const char *pClassName )
 	{
@@ -131,6 +144,11 @@ public:
 	{
 		return sizeof(T);
 	}
+
+#ifdef LUA_SDK
+private:
+	char classname[255];
+#endif
 };
 
 #define LINK_ENTITY_TO_CLASS(mapClassName,DLLClassName) \
@@ -213,6 +231,11 @@ CBasePlayer	*UTIL_PlayerByIndex( int playerIndex );
 // not useable in multiplayer - see UTIL_GetListenServerHost()
 CBasePlayer* UTIL_GetLocalPlayer( void );
 
+#ifdef HL2SB
+CBasePlayer *UTIL_GetNearestPlayer( const Vector& pos );
+CBasePlayer *UTIL_GetNearestVisiblePlayer( CBaseEntity *pEntity, int mask = MASK_BLOCKLOS );
+#endif
+
 // get the local player on a listen server
 CBasePlayer *UTIL_GetListenServerHost( void );
 
diff --git a/src/game/server/vehicle_choreo_generic.cpp b/src/game/server/vehicle_choreo_generic.cpp
index bba7b94..cf16daf 100644
--- a/src/game/server/vehicle_choreo_generic.cpp
+++ b/src/game/server/vehicle_choreo_generic.cpp
@@ -722,7 +722,11 @@ void CPropVehicleChoreoGeneric::InputEnterVehicle( inputdata_t &inputdata )
 	if ( pPlayer == NULL )
 	{
 		// Activator was not a player, just grab the single-player player.
+#ifdef HL2SB
+		pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		pPlayer = AI_GetSinglePlayer();
+#endif
 		if ( pPlayer == NULL )
 			return;
 	}
@@ -752,7 +756,11 @@ void CPropVehicleChoreoGeneric::InputEnterVehicleImmediate( inputdata_t &inputda
 	if ( pPlayer == NULL )
 	{
 		// Activator was not a player, just grab the singleplayer player.
+#ifdef HL2SB
+		pPlayer = AI_GetNearestPlayer( GetAbsOrigin() );
+#else
 		pPlayer = AI_GetSinglePlayer();
+#endif
 		if ( pPlayer == NULL )
 			return;
 	}
diff --git a/src/game/server/world.cpp b/src/game/server/world.cpp
index 4e113cb..a070e51 100644
--- a/src/game/server/world.cpp
+++ b/src/game/server/world.cpp
@@ -31,6 +31,9 @@
 #include "engine/IStaticPropMgr.h"
 #include "particle_parse.h"
 #include "globalstate.h"
+#ifdef LUA_SDK
+#include "luamanager.h"
+#endif
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
@@ -507,7 +510,21 @@ void CWorld::DecalTrace( trace_t *pTrace, char const *decalName)
 
 void CWorld::RegisterSharedActivities( void )
 {
+#ifdef LUA_SDK
+	// Andrew; There's a big issue with including the Activity enumeration
+	// library, and that issue is that it's massive. While we clean up _G by
+	// placing it in it's own library and increase lookup times across nearly
+	// all of our resources, it may be best that we make it a standard practice
+	// for developers to look up the enumerations that they need on an
+	// as-needed basis, and store them as locals in their relative files, or
+	// simply use the raw value of that enumeration in scripts, which is the
+	// most performance efficient option.
+	// BEGIN_LUA_SET_ENUM_LIB( "Activity" );
+#endif
 	ActivityList_RegisterSharedActivities();
+#ifdef LUA_SDK
+	// END_LUA_SET_ENUM_LIB();
+#endif
 }
 
 void CWorld::RegisterSharedEvents( void )
diff --git a/src/game/shared/activitylist.cpp b/src/game/shared/activitylist.cpp
index d663608..083dabf 100644
--- a/src/game/shared/activitylist.cpp
+++ b/src/game/shared/activitylist.cpp
@@ -15,6 +15,10 @@
 #include <KeyValues.h>
 #include "utldict.h"
 
+#ifdef LUA_SDK
+#include "luamanager.h"
+#endif
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
diff --git a/src/game/shared/activitylist.h b/src/game/shared/activitylist.h
index 6b86684..ac03e19 100644
--- a/src/game/shared/activitylist.h
+++ b/src/game/shared/activitylist.h
@@ -88,7 +88,12 @@ extern int ActivityList_HighestIndex();
 
 // This macro guarantees that the names of each activity and the constant used to
 // reference it in the code are identical.
+// #ifndef LUA_SDK
 #define REGISTER_SHARED_ACTIVITY( _n ) ActivityList_RegisterSharedActivity(#_n, _n);
+// #else
+// Andrew; we register the enumerations here in Lua for use in scripts.
+// #define REGISTER_SHARED_ACTIVITY( _n ) ActivityList_RegisterSharedActivity(#_n, _n); lua_pushstring(L, #_n); lua_pushinteger(L, _n); lua_settable(L, -3);
+// #endif
 #define REGISTER_PRIVATE_ACTIVITY( _n ) _n = ActivityList_RegisterPrivateActivity( #_n );
 
 // Implemented in shared code
diff --git a/src/game/shared/basecombatweapon_shared.cpp b/src/game/shared/basecombatweapon_shared.cpp
index e2b72cb..d5afb5e 100644
--- a/src/game/shared/basecombatweapon_shared.cpp
+++ b/src/game/shared/basecombatweapon_shared.cpp
@@ -205,6 +205,10 @@ void CBaseCombatWeapon::Precache( void )
 
 	// Add this weapon to the weapon registry, and get our index into it
 	// Get weapon data from script file
+#if defined( LUA_SDK )
+	if ( !IsScripted() )
+	{
+#endif
 	if ( ReadWeaponDataFromFileForSlot( filesystem, GetClassname(), &m_hWeaponFileInfo, GetEncryptionKey() ) )
 	{
 		// Get the ammo indexes for the ammo's specified in the data file
@@ -256,6 +260,9 @@ void CBaseCombatWeapon::Precache( void )
 		Warning( "Error reading weapon data file for: %s\n", GetClassname() );
 	//	Remove( );	//don't remove, this gets released soon!
 	}
+#if defined( LUA_SDK )
+	}
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -951,9 +958,8 @@ void CBaseCombatWeapon::Equip( CBaseCombatCharacter *pOwner )
 void CBaseCombatWeapon::SetActivity( Activity act, float duration ) 
 { 
 	//Adrian: Oh man...
-#if !defined( CLIENT_DLL ) && (defined( HL2MP ) || defined( PORTAL ) || defined( SDK_DLL ) )
-	SetModel( GetWorldModel() );
-#endif
+	if ( GetOwner()->IsPlayer() )
+		SetModel( GetWorldModel() );
 	
 	int sequence = SelectWeightedSequence( act ); 
 	
@@ -962,9 +968,8 @@ void CBaseCombatWeapon::SetActivity( Activity act, float duration )
 		sequence = SelectWeightedSequence( ACT_VM_IDLE );
 
 	//Adrian: Oh man again...
-#if !defined( CLIENT_DLL ) && (defined( HL2MP ) || defined( PORTAL ) || defined( SDK_DLL ) )
-	SetModel( GetViewModel() );
-#endif
+	if ( GetOwner()->IsPlayer() )
+		SetModel( GetWorldModel() );
 
 	if ( sequence != ACTIVITY_NOT_AVAILABLE )
 	{
diff --git a/src/game/shared/basecombatweapon_shared.h b/src/game/shared/basecombatweapon_shared.h
index b13ee03..5755ffa 100644
--- a/src/game/shared/basecombatweapon_shared.h
+++ b/src/game/shared/basecombatweapon_shared.h
@@ -140,6 +140,10 @@ public:
 	// A derived weapon class should return true here so that weapon sounds, etc, can
 	//  apply the proper filter
 	virtual bool			IsPredicted( void ) const { return false; }
+#if defined( LUA_SDK )
+	virtual bool			IsScripted( void ) const { return false; }
+	virtual bool			IsWeapon( void ) const { return true; }
+#endif
 
 	virtual void			Spawn( void );
 	virtual void			Precache( void );
@@ -293,7 +297,11 @@ public:
 public:
 
 	// Weapon info accessors for data in the weapon's data file
+#ifndef LUA_SDK
 	const FileWeaponInfo_t	&GetWpnData( void ) const;
+#else
+	virtual const FileWeaponInfo_t	&GetWpnData( void ) const;
+#endif
 	virtual const char		*GetViewModel( int viewmodelindex = 0 ) const;
 	virtual const char		*GetWorldModel( void ) const;
 	virtual const char		*GetAnimPrefix( void ) const;
@@ -430,6 +438,12 @@ public:
 	virtual bool			ShouldDraw( void );
 	virtual bool			ShouldDrawPickup( void );
 	virtual void			HandleInput( void ) { return; };
+#ifdef ARGG
+	// adnan
+	// does this weapon need to override the setting of view angles?
+	virtual bool			OverrideViewAngles( void ) { return false; };
+	// end adnan
+#endif
 	virtual void			OverrideMouseInput( float *x, float *y ) { return; };
 	virtual int				KeyInput( int down, ButtonCode_t keynum, const char *pszCurrentBinding ) { return 1; }
 	virtual bool			AddLookShift( void ) { return true; };
diff --git a/src/game/shared/baseentity_shared.cpp b/src/game/shared/baseentity_shared.cpp
index dba15ba..7b33f02 100644
--- a/src/game/shared/baseentity_shared.cpp
+++ b/src/game/shared/baseentity_shared.cpp
@@ -1547,7 +1547,7 @@ void CBaseEntity::FireBullets( const FireBulletsInfo_t &info )
 	
 	bool bDoServerEffects = true;
 
-#if defined( HL2MP ) && defined( GAME_DLL )
+#if !defined( HL2SB ) && defined( HL2MP ) && defined( GAME_DLL )
 	bDoServerEffects = false;
 #endif
 
diff --git a/src/game/shared/basegrenade_shared.h b/src/game/shared/basegrenade_shared.h
index 04c6139..92ad630 100644
--- a/src/game/shared/basegrenade_shared.h
+++ b/src/game/shared/basegrenade_shared.h
@@ -28,9 +28,10 @@
 
 class CTakeDamageInfo;
 
+//Andrew; See http://www.mail-archive.com/hlcoders@list.valvesoftware.com/msg28578.html
 //Tony; Compromise! in episodic single player, inherit CBaseCombatCharacter for the barnacle interaction, otherwise this will never get called.
 class CBaseGrenade : 
-	#if defined( HL2_EPISODIC )
+	#if defined( HL2_EPISODIC ) || defined ( HL2MP )	//Tony; HL2MP needs this too for tripmine grenades.
 		public CBaseCombatCharacter
 	#else
 		public CBaseAnimating
diff --git a/src/game/shared/baseplayer_shared.cpp b/src/game/shared/baseplayer_shared.cpp
index 872c45b..984775f 100644
--- a/src/game/shared/baseplayer_shared.cpp
+++ b/src/game/shared/baseplayer_shared.cpp
@@ -40,6 +40,14 @@
 #include "decals.h"
 #include "obstacle_pushaway.h"
 
+#if defined( LUA_SDK )
+
+	#include "luamanager.h"
+	#include "lbaseplayer_shared.h"
+	#include "mathlib/lvector.h"
+
+#endif
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -1177,6 +1185,12 @@ CBaseEntity *CBasePlayer::FindUseEntity()
 //-----------------------------------------------------------------------------
 void CBasePlayer::PlayerUse ( void )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "PlayerUse" );
+		lua_pushplayer( L, this );
+	END_LUA_CALL_HOOK( 1, 0 );
+#endif
+
 #ifdef GAME_DLL
 	// Was use pressed or released?
 	if ( ! ((m_nButtons | m_afButtonPressed | m_afButtonReleased) & IN_USE) )
@@ -1522,6 +1536,24 @@ void CBasePlayer::CalcPlayerView( Vector& eyeOrigin, QAngle& eyeAngles, float& f
 
 	// calc current FOV
 	fov = GetFOV();
+
+#if defined( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "CalcPlayerView" );
+		lua_pushplayer( L, this );
+		lua_pushvector( L, eyeOrigin );
+		lua_pushangle( L, eyeAngles );
+		lua_pushnumber( L, fov );
+	END_LUA_CALL_HOOK( 4, 3 );
+
+	if ( lua_isuserdata( L, -3 ) && luaL_checkudata( L, -3, "Vector" ) )
+		VectorCopy( luaL_checkvector( L, -3 ), eyeOrigin );
+	if ( lua_isuserdata( L, -2 ) && luaL_checkudata( L, -2, "QAngle" ) )
+		VectorCopy( luaL_checkangle( L, -2 ), eyeAngles );
+	if ( lua_isnumber( L, -1 ) )
+		fov = luaL_checknumber( L, -1 );
+
+	lua_pop( L, 3 );
+#endif
 }
 
 //-----------------------------------------------------------------------------
diff --git a/src/game/shared/basescripted.cpp b/src/game/shared/basescripted.cpp
new file mode 100644
index 0000000..32db2ea
--- /dev/null
+++ b/src/game/shared/basescripted.cpp
@@ -0,0 +1,304 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//===========================================================================//
+
+#include "cbase.h"
+#include "basescripted.h"
+#include "luamanager.h"
+#ifdef CLIENT_DLL
+#include "lc_baseanimating.h"
+#else
+#include "lbaseanimating.h"
+#endif
+#include "lbaseentity_shared.h"
+#include "lvphysics_interface.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+IMPLEMENT_NETWORKCLASS_ALIASED( BaseScripted, DT_BaseScripted )
+
+BEGIN_NETWORK_TABLE( CBaseScripted, DT_BaseScripted )
+#ifdef CLIENT_DLL
+	RecvPropString( RECVINFO( m_iScriptedClassname ) ),
+#else
+	SendPropString( SENDINFO( m_iScriptedClassname ) ),
+#endif
+END_NETWORK_TABLE()
+
+BEGIN_PREDICTION_DATA(	CBaseScripted )
+END_PREDICTION_DATA()
+
+#ifdef CLIENT_DLL
+static C_BaseEntity *CCBaseScriptedFactory( void )
+{
+	return static_cast< C_BaseEntity * >( new CBaseScripted );
+};
+#endif
+
+#ifndef CLIENT_DLL
+static CUtlDict< CEntityFactory<CBaseScripted>*, unsigned short > m_EntityFactoryDatabase;
+#endif
+
+void RegisterScriptedEntity( const char *className )
+{
+#ifdef CLIENT_DLL
+	if ( GetClassMap().FindFactory( className ) )
+	{
+		return;
+	}
+
+	GetClassMap().Add( className, "CBaseScripted", sizeof( CBaseScripted ),
+		&CCBaseScriptedFactory, true );
+#else
+	if ( EntityFactoryDictionary()->FindFactory( className ) )
+	{
+		return;
+	}
+
+	unsigned short lookup = m_EntityFactoryDatabase.Find( className );
+	if ( lookup != m_EntityFactoryDatabase.InvalidIndex() )
+	{
+		return;
+	}
+
+	CEntityFactory<CBaseScripted> *pFactory = new CEntityFactory<CBaseScripted>( className );
+
+	lookup = m_EntityFactoryDatabase.Insert( className, pFactory );
+	Assert( lookup != m_EntityFactoryDatabase.InvalidIndex() );
+#endif
+}
+
+void ResetEntityFactoryDatabase( void )
+{
+#ifdef CLIENT_DLL
+#ifdef LUA_SDK
+	GetClassMap().RemoveAllScripted();
+#endif
+#else
+	for ( int i=m_EntityFactoryDatabase.First(); i != m_EntityFactoryDatabase.InvalidIndex(); i=m_EntityFactoryDatabase.Next( i ) )
+	{
+		delete m_EntityFactoryDatabase[ i ];
+	}
+	m_EntityFactoryDatabase.RemoveAll();
+#endif
+}
+
+CBaseScripted::CBaseScripted( void )
+{
+#ifdef LUA_SDK
+	// UNDONE: We're done in CBaseEntity
+	m_nTableReference = LUA_NOREF;
+#endif
+}
+
+CBaseScripted::~CBaseScripted( void )
+{
+	// Andrew; This is actually done in CBaseEntity. I'm doing it here because
+	// this is the class that initialized the reference.
+#ifdef LUA_SDK
+	lua_unref( L, m_nTableReference );
+#endif
+}
+
+void CBaseScripted::LoadScriptedEntity( void )
+{
+	lua_getglobal( L, "entity" );
+	if ( lua_istable( L, -1 ) )
+	{
+		lua_getfield( L, -1, "get" );
+		if ( lua_isfunction( L, -1 ) )
+		{
+			lua_remove( L, -2 );
+			lua_pushstring( L, GetClassname() );
+			luasrc_pcall( L, 1, 1, 0 );
+		}
+		else
+		{
+			lua_pop( L, 2 );
+		}
+	}
+	else
+	{
+		lua_pop( L, 1 );
+	}
+}
+
+void CBaseScripted::InitScriptedEntity( void )
+{
+#if defined ( LUA_SDK )
+#if 0
+#ifndef CLIENT_DLL
+	// Let the instance reinitialize itself for the client.
+	if ( m_nTableReference != LUA_NOREF )
+		return;
+#endif
+#endif
+
+	SetThink( &CBaseScripted::Think );
+#ifdef CLIENT_DLL
+	SetNextClientThink( gpGlobals->curtime );
+#endif
+	SetNextThink( gpGlobals->curtime );
+
+	SetTouch( &CBaseScripted::Touch );
+
+	char className[ 255 ];
+#if defined ( CLIENT_DLL )
+	if ( strlen( GetScriptedClassname() ) > 0 )
+		Q_strncpy( className, GetScriptedClassname(), sizeof( className ) );
+	else
+		Q_strncpy( className, GetClassname(), sizeof( className ) );
+#else
+	Q_strncpy( m_iScriptedClassname.GetForModify(), GetClassname(), sizeof( className ) );
+ 	Q_strncpy( className, GetClassname(), sizeof( className ) );
+#endif
+ 	Q_strlower( className );
+	SetClassname( className );
+
+	if ( m_nTableReference == LUA_NOREF )
+	{
+		LoadScriptedEntity();
+		m_nTableReference = luaL_ref( L, LUA_REGISTRYINDEX );
+	}
+	else
+	{
+		lua_getglobal( L, "table" );
+		if ( lua_istable( L, -1 ) )
+		{
+			lua_getfield( L, -1, "merge" );
+			if ( lua_isfunction( L, -1 ) )
+			{
+				lua_remove( L, -2 );
+				lua_getref( L, m_nTableReference );
+				LoadScriptedEntity();
+				luasrc_pcall( L, 2, 0, 0 );
+			}
+			else
+			{
+				lua_pop( L, 2 );
+			}
+		}
+		else
+		{
+			lua_pop( L, 1 );
+		}
+	}
+
+	BEGIN_LUA_CALL_ENTITY_METHOD( "Initialize" );
+	END_LUA_CALL_ENTITY_METHOD( 0, 0 );
+#endif
+}
+
+#ifdef CLIENT_DLL
+int CBaseScripted::DrawModel( int flags )
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_ENTITY_METHOD( "DrawModel" );
+		lua_pushinteger( L, flags );
+	END_LUA_CALL_ENTITY_METHOD( 1, 1 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
+	return BaseClass::DrawModel( flags );
+}
+
+void CBaseScripted::OnDataChanged( DataUpdateType_t updateType )
+{
+	BaseClass::OnDataChanged( updateType );
+
+	if ( updateType == DATA_UPDATE_CREATED )
+	{
+		if ( m_iScriptedClassname.Get() )
+		{
+			SetClassname( m_iScriptedClassname.Get() );
+			InitScriptedEntity();
+		}
+	}
+}
+
+const char *CBaseScripted::GetScriptedClassname( void )
+{
+	if ( m_iScriptedClassname.Get() )
+		return m_iScriptedClassname.Get();
+	return BaseClass::GetClassname();
+}
+#endif
+
+void CBaseScripted::Spawn( void )
+{
+	BaseClass::Spawn();
+
+#ifndef CLIENT_DLL
+	InitScriptedEntity();
+#endif
+}
+
+void CBaseScripted::Precache( void )
+{
+	BaseClass::Precache();
+
+	// InitScriptedEntity();
+}
+
+#ifdef CLIENT_DLL
+void CBaseScripted::ClientThink()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_ENTITY_METHOD( "ClientThink" );
+	END_LUA_CALL_ENTITY_METHOD( 0, 0 );
+#endif
+}
+#endif
+
+void CBaseScripted::Think()
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_ENTITY_METHOD( "Think" );
+	END_LUA_CALL_ENTITY_METHOD( 0, 0 );
+#endif
+}
+
+void CBaseScripted::StartTouch( CBaseEntity *pOther )
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_ENTITY_METHOD( "StartTouch" );
+		lua_pushentity( L, pOther );
+	END_LUA_CALL_ENTITY_METHOD( 1, 0 );
+#endif
+}
+
+void CBaseScripted::Touch( CBaseEntity *pOther )
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_ENTITY_METHOD( "Touch" );
+		lua_pushentity( L, pOther );
+	END_LUA_CALL_ENTITY_METHOD( 1, 0 );
+#endif
+}
+
+void CBaseScripted::EndTouch( CBaseEntity *pOther )
+{
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_ENTITY_METHOD( "EndTouch" );
+		lua_pushentity( L, pOther );
+	END_LUA_CALL_ENTITY_METHOD( 1, 0 );
+#endif
+}
+
+void CBaseScripted::VPhysicsUpdate( IPhysicsObject *pPhysics )
+{
+	BaseClass::VPhysicsUpdate( pPhysics );
+
+#ifdef LUA_SDK
+	BEGIN_LUA_CALL_ENTITY_METHOD( "VPhysicsUpdate" );
+		lua_pushphysicsobject( L, pPhysics );
+	END_LUA_CALL_ENTITY_METHOD( 1, 0 );
+#endif
+}
+
diff --git a/src/game/shared/basescripted.h b/src/game/shared/basescripted.h
new file mode 100644
index 0000000..5c28fde
--- /dev/null
+++ b/src/game/shared/basescripted.h
@@ -0,0 +1,74 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+
+#ifndef BASESCRIPTED_H
+#define BASESCRIPTED_H
+
+#include "predictable_entity.h"
+#include "baseentity_shared.h"
+
+#if defined( CLIENT_DLL )
+#define CBaseScripted C_BaseScripted
+
+#endif 
+
+class CBaseScripted : /* public CBaseEntity */ public CBaseAnimating
+{
+public:
+	// DECLARE_CLASS( CBaseScripted, CBaseEntity );
+	DECLARE_CLASS( CBaseScripted, CBaseAnimating );
+	DECLARE_PREDICTABLE();
+	DECLARE_NETWORKCLASS();
+
+	CBaseScripted();
+	~CBaseScripted();
+
+	bool	IsScripted( void ) const { return true; }
+	
+	// CBaseEntity overrides.
+public:
+	void	Think();	
+
+	void	Spawn( void );
+	void	Precache( void );
+	void	LoadScriptedEntity( void );
+	void	InitScriptedEntity( void );
+
+	void	StartTouch( CBaseEntity *pOther );
+	void	Touch( CBaseEntity *pOther ); 
+	void	EndTouch( CBaseEntity *pOther );
+
+#ifdef CLIENT_DLL
+	// model specific
+	virtual int DrawModel( int flags );
+#endif
+
+	virtual void VPhysicsUpdate( IPhysicsObject *pPhysics );
+
+#ifdef CLIENT_DLL
+// IClientThinkable.
+public:
+	// Called whenever you registered for a think message (with SetNextClientThink).
+	virtual void	ClientThink();
+
+	virtual void	OnDataChanged( DataUpdateType_t updateType );
+	virtual const char *GetScriptedClassname( void );
+#endif
+
+private:
+	CBaseScripted( const CBaseScripted & ); // not defined, not accessible
+
+	CNetworkString( m_iScriptedClassname, 255 );
+};
+
+void RegisterScriptedEntity( const char *szClassname );
+void ResetEntityFactoryDatabase( void );
+
+#endif
+
+
diff --git a/src/game/shared/baseviewmodel_shared.cpp b/src/game/shared/baseviewmodel_shared.cpp
index 0d7e8b6..edf80df 100644
--- a/src/game/shared/baseviewmodel_shared.cpp
+++ b/src/game/shared/baseviewmodel_shared.cpp
@@ -392,12 +392,19 @@ void CBaseViewModel::CalcViewModelView( CBasePlayer *owner, const Vector& eyePos
 	}
 	// Add model-specific bob even if no weapon associated (for head bob for off hand models)
 	AddViewModelBob( owner, vmorigin, vmangles );
+#if !defined( HL2SB )
 	// Add lag
 	CalcViewModelLag( vmorigin, vmangles, vmangoriginal );
+#endif
 
 #if defined( CLIENT_DLL )
 	if ( !prediction->InPrediction() )
 	{
+#if defined( HL2SB )
+		//Andrew; See https://developer.valvesoftware.com/wiki/Viewmodel_Prediction_Fix
+		// Add lag
+		CalcViewModelLag( vmorigin, vmangles, vmangoriginal );
+#endif
 		// Let the viewmodel shake at about 10% of the amplitude of the player's view
 		vieweffects->ApplyShake( vmorigin, vmangles, 0.1 );	
 	}
diff --git a/src/game/shared/gamerules.cpp b/src/game/shared/gamerules.cpp
index 015c635..6350993 100644
--- a/src/game/shared/gamerules.cpp
+++ b/src/game/shared/gamerules.cpp
@@ -760,6 +760,10 @@ float CGameRules::GetAmmoDamage( CBaseEntity *pAttacker, CBaseEntity *pVictim, i
 	float flDamage = 0;
 	CAmmoDef *pAmmoDef = GetAmmoDef();
 
+#ifdef HL2SB
+	if ( pAttacker )
+	{
+#endif
 	if ( pAttacker->IsPlayer() )
 	{
 		flDamage = pAmmoDef->PlrDamage( nAmmoType );
@@ -768,6 +772,9 @@ float CGameRules::GetAmmoDamage( CBaseEntity *pAttacker, CBaseEntity *pVictim, i
 	{
 		flDamage = pAmmoDef->NPCDamage( nAmmoType );
 	}
+#ifdef HL2SB
+	}
+#endif
 
 	return flDamage;
 }
diff --git a/src/game/shared/gamerules.h b/src/game/shared/gamerules.h
index 2e122c9..bd00f4f 100644
--- a/src/game/shared/gamerules.h
+++ b/src/game/shared/gamerules.h
@@ -196,7 +196,15 @@ public:
 	// Called each frame. This just forwards the call to Think().
 	virtual void FrameUpdatePostEntityThink();
 
+#endif
+#ifdef LUA_SDK
+	virtual void Think( void ) = 0;// GR_Think - runs every server frame, should handle any timer tasks, periodic events, etc.
+#else
+#ifndef CLIENT_DLL
 	virtual void Think( void ) = 0;// GR_Think - runs every server frame, should handle any timer tasks, periodic events, etc.
+#endif
+#endif
+#ifndef CLIENT_DLL
 	virtual bool IsAllowedToSpawn( CBaseEntity *pEntity ) = 0;  // Can this item spawn (eg NPCs don't spawn in deathmatch).
 
 	// Called at the end of GameFrame (i.e. after all game logic has run this frame)
diff --git a/src/game/shared/hl2/hl2_gamerules.cpp b/src/game/shared/hl2/hl2_gamerules.cpp
index 3897e72..cf13702 100644
--- a/src/game/shared/hl2/hl2_gamerules.cpp
+++ b/src/game/shared/hl2/hl2_gamerules.cpp
@@ -1323,6 +1323,26 @@ ConVar  alyx_darkness_force( "alyx_darkness_force", "0", FCVAR_CHEAT | FCVAR_REP
 	{
 	}
 
+#endif
+#ifdef LUA_SDK
+	void CHalfLife2::Think( void )
+	{
+#ifndef CLIENT_DLL
+		BaseClass::Think();
+
+		if( physcannon_mega_enabled.GetBool() == true )
+		{
+			m_bMegaPhysgun = true;
+		}
+		else
+		{
+			// FIXME: Is there a better place for this?
+			m_bMegaPhysgun = ( GlobalEntity_GetState("super_phys_gun") == GLOBAL_ON );
+		}
+#endif
+	}
+#else
+#ifndef CLIENT_DLL
 	void CHalfLife2::Think( void )
 	{
 		BaseClass::Think();
@@ -1337,6 +1357,9 @@ ConVar  alyx_darkness_force( "alyx_darkness_force", "0", FCVAR_CHEAT | FCVAR_REP
 			m_bMegaPhysgun = ( GlobalEntity_GetState("super_phys_gun") == GLOBAL_ON );
 		}
 	}
+#endif
+#endif
+#ifndef CLIENT_DLL
 
 	//-----------------------------------------------------------------------------
 	// Purpose: Returns how much damage the given ammo type should do to the victim
diff --git a/src/game/shared/hl2/hl2_gamerules.h b/src/game/shared/hl2/hl2_gamerules.h
index b3d3ef2..a609a03 100644
--- a/src/game/shared/hl2/hl2_gamerules.h
+++ b/src/game/shared/hl2/hl2_gamerules.h
@@ -62,7 +62,15 @@ private:
 	CHalfLife2();
 	virtual ~CHalfLife2() {}
 
+#endif
+#ifdef LUA_SDK
+	virtual void			Think( void );
+#else
+#ifndef CLIENT_DLL
 	virtual void			Think( void );
+#endif
+#endif
+#ifndef CLIENT_DLL
 
 	virtual bool			ClientCommand( CBaseEntity *pEdict, const CCommand &args );
 	virtual void			PlayerSpawn( CBasePlayer *pPlayer );
diff --git a/src/game/shared/hl2/hl_gamemovement.cpp b/src/game/shared/hl2/hl_gamemovement.cpp
index b97f5ff..bb14f5f 100644
--- a/src/game/shared/hl2/hl_gamemovement.cpp
+++ b/src/game/shared/hl2/hl_gamemovement.cpp
@@ -287,7 +287,11 @@ bool CHL2GameMovement::ContinueForcedMove()
 //-----------------------------------------------------------------------------
 bool CHL2GameMovement::OnLadder( trace_t &trace )
 {
+#ifndef HL2SB
 	return ( GetLadder() != NULL ) ? true : false;
+#else
+	return ( GetLadder() != NULL ) ? true : BaseClass::OnLadder( trace );
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -528,9 +532,14 @@ void CHL2GameMovement::FullLadderMove()
 {
 #if !defined( CLIENT_DLL )
 	CFuncLadder *ladder = GetLadder();
+#if !defined( HL2SB )
 	Assert( ladder );
+#endif
 	if ( !ladder )
 	{
+#if defined( HL2SB )
+		BaseClass::FullLadderMove();
+#endif
 		return;
 	}
 
@@ -891,7 +900,11 @@ bool CHL2GameMovement::LadderMove( void )
 	if ( player->GetMoveType() == MOVETYPE_NOCLIP )
 	{
 		SetLadder( NULL );
+#if !defined (HL2SB)
 		return false;
+#else
+		return BaseClass::LadderMove();
+#endif
 	}
 
 	// If being forced to mount/dismount continue to act like we are on the ladder
@@ -958,7 +971,11 @@ bool CHL2GameMovement::LadderMove( void )
 			}
 		}
 
+#if !defined (HL2SB)
 		return false;
+#else
+		return BaseClass::LadderMove();
+#endif
 	}
 
 	if ( !ladder && 
@@ -972,7 +989,11 @@ bool CHL2GameMovement::LadderMove( void )
 	ladder = GetLadder();
 	if ( !ladder )
 	{
+#if !defined (HL2SB)
 		return false;
+#else
+		return BaseClass::LadderMove();
+#endif
 	}
 
 	// Don't play the deny sound
@@ -1036,7 +1057,11 @@ bool CHL2GameMovement::LadderMove( void )
 		{
 			mv->m_vecVelocity.z = mv->m_vecVelocity.z + 50;
 		}
+#if !defined (HL2SB)
 		return false;
+#else
+		return BaseClass::LadderMove();
+#endif
 	}
 
 	if ( forwardSpeed != 0 || rightSpeed != 0 )
@@ -1068,7 +1093,11 @@ bool CHL2GameMovement::LadderMove( void )
 			player->SetMoveType( MOVETYPE_WALK );
 			// Remove from ladder
 			SetLadder( NULL );
+#if !defined (HL2SB)
 			return false;
+#else
+			return BaseClass::LadderMove();
+#endif
 		}
 
 		bool ishorizontal = fabs( topPosition.z - bottomPosition.z ) < 64.0f ? true : false;
diff --git a/src/game/shared/hl2/survival_gamerules.cpp b/src/game/shared/hl2/survival_gamerules.cpp
index 56f34ff..73b4ade 100644
--- a/src/game/shared/hl2/survival_gamerules.cpp
+++ b/src/game/shared/hl2/survival_gamerules.cpp
@@ -78,7 +78,15 @@ public:
 	CHalfLife2Survival();
 	virtual ~CHalfLife2Survival() {}
 
+#endif
+#ifdef LUA_SDK
 	virtual void Think( void );
+#else
+#ifndef CLIENT_DLL
+	virtual void Think( void );
+#endif
+#endif
+#ifndef CLIENT_DLL
 	virtual void PlayerSpawn( CBasePlayer *pPlayer );
 	virtual bool IsAllowedToSpawn( CBaseEntity *pEntity );
 	virtual void CreateStandardEntities();
@@ -143,10 +151,23 @@ CHalfLife2Survival::CHalfLife2Survival()
 	m_bActive = false;
 }
 
+#endif
+#ifdef LUA_SDK
 void CHalfLife2Survival::Think( void )
 {
+#ifndef CLIENT_DLL
 
+#endif
 }
+#else
+#ifndef CLIENT_DLL
+void CHalfLife2Survival::Think( void )
+{
+
+}
+#endif
+#endif
+#ifndef CLIENT_DLL
 
 bool CHalfLife2Survival::IsAllowedToSpawn( CBaseEntity *pEntity )
 {
diff --git a/src/game/shared/hl2mp/hl2mp_gamerules.cpp b/src/game/shared/hl2mp/hl2mp_gamerules.cpp
index 0ab1209..ea2db27 100644
--- a/src/game/shared/hl2mp/hl2mp_gamerules.cpp
+++ b/src/game/shared/hl2mp/hl2mp_gamerules.cpp
@@ -11,6 +11,20 @@
 #include <KeyValues.h>
 #include "ammodef.h"
 
+#ifdef HL2SB
+	#include "hl2_shareddefs.h"
+#endif
+
+#ifdef LUA_SDK
+	#include "takedamageinfo.h"
+	#include "luamanager.h"
+	#include "lbasecombatweapon_shared.h"
+	#include "lbaseentity_shared.h"
+	#include "lbaseplayer_shared.h"
+	#include "ltakedamageinfo.h"
+	#include "mathlib/lvector.h"
+#endif
+
 #ifdef CLIENT_DLL
 	#include "c_hl2mp_player.h"
 #else
@@ -30,10 +44,13 @@
 	#include "weapon_hl2mpbasehlmpcombatweapon.h"
 	#include "team.h"
 	#include "voice_gamemgr.h"
+#ifdef HL2SB
+	#include "globalstate.h"
+#endif
 	#include "hl2mp_gameinterface.h"
 	#include "hl2mp_cvars.h"
 
-#ifdef DEBUG	
+#if defined( DEBUG ) || defined( LUA_SDK )	
 	#include "hl2mp_bot_temp.h"
 #endif
 
@@ -67,6 +84,17 @@ extern CBaseEntity	 *g_pLastRebelSpawn;
 
 #endif
 
+#ifdef HL2SB
+#ifdef CLIENT_DLL
+#else
+
+#ifdef HL2_EPISODIC
+extern ConVar  alyx_darkness_force;
+#endif // HL2_EPISODIC
+
+#endif // CLIENT_DLL
+#endif // HL2SB
+
 
 REGISTER_GAMERULES_CLASS( CHL2MPRules );
 
@@ -172,6 +200,11 @@ static const char *s_PreserveEnts[] =
 	END_SEND_TABLE()
 #endif
 
+#ifdef HL2SB
+extern ConVar	sk_plr_health_drop_time;
+extern ConVar	sk_plr_grenade_drop_time;
+#endif
+
 #ifndef CLIENT_DLL
 
 	class CVoiceGameMgrHelper : public IVoiceGameMgrHelper
@@ -179,6 +212,20 @@ static const char *s_PreserveEnts[] =
 	public:
 		virtual bool		CanPlayerHearPlayer( CBasePlayer *pListener, CBasePlayer *pTalker, bool &bProximity )
 		{
+#if defined ( LUA_SDK )
+			BEGIN_LUA_CALL_HOOK( "CanPlayerHearPlayer" );
+				lua_pushplayer( L, pListener );
+				lua_pushplayer( L, pTalker );
+				lua_pushboolean( L, bProximity );
+			END_LUA_CALL_HOOK( 3, 2 );
+
+			if ( lua_isboolean( L, -2 ) )
+				bProximity = (bool)lua_toboolean( L, -2 );
+			lua_remove( L, -2 );
+
+			RETURN_LUA_BOOLEAN();
+#endif
+
 			return ( pListener->GetTeamNumber() == pTalker->GetTeamNumber() );
 		}
 	};
@@ -243,6 +290,10 @@ CHL2MPRules::~CHL2MPRules( void )
 
 void CHL2MPRules::CreateStandardEntities( void )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "CreateStandardEntities" );
+	END_LUA_CALL_HOOK( 0, 0 );
+#endif
 
 #ifndef CLIENT_DLL
 	// Create the entity that will send our data to the client.
@@ -266,6 +317,14 @@ void CHL2MPRules::CreateStandardEntities( void )
 //=========================================================
 float CHL2MPRules::FlWeaponRespawnTime( CBaseCombatWeapon *pWeapon )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "FlWeaponRespawnTime" );
+		lua_pushweapon( L, pWeapon );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_NUMBER();
+#endif
+
 #ifndef CLIENT_DLL
 	if ( weaponstay.GetInt() > 0 )
 	{
@@ -285,6 +344,13 @@ float CHL2MPRules::FlWeaponRespawnTime( CBaseCombatWeapon *pWeapon )
 
 bool CHL2MPRules::IsIntermission( void )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "IsIntermission" );
+	END_LUA_CALL_HOOK( 0, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 #ifndef CLIENT_DLL
 	return m_flIntermissionEndTime > gpGlobals->curtime;
 #endif
@@ -294,6 +360,15 @@ bool CHL2MPRules::IsIntermission( void )
 
 void CHL2MPRules::PlayerKilled( CBasePlayer *pVictim, const CTakeDamageInfo &info )
 {
+#if defined ( LUA_SDK )
+	CTakeDamageInfo linfo = info;
+
+	BEGIN_LUA_CALL_HOOK( "PlayerKilled" );
+		lua_pushplayer( L, pVictim );
+		lua_pushdamageinfo( L, linfo );
+	END_LUA_CALL_HOOK( 2, 0 );
+#endif
+
 #ifndef CLIENT_DLL
 	if ( IsIntermission() )
 		return;
@@ -302,8 +377,141 @@ void CHL2MPRules::PlayerKilled( CBasePlayer *pVictim, const CTakeDamageInfo &inf
 }
 
 
+#ifndef CLIENT_DLL
+#if defined ( LUA_SDK )
+bool CHL2MPRules::FPlayerCanTakeDamage( CBasePlayer *pPlayer, CBaseEntity *pAttacker )
+{
+	BEGIN_LUA_CALL_HOOK( "FPlayerCanTakeDamage" );
+		lua_pushplayer( L, pPlayer );
+		lua_pushentity( L, pAttacker );
+	END_LUA_CALL_HOOK( 2, 1 );
+
+	RETURN_LUA_BOOLEAN();
+
+	return BaseClass::FPlayerCanTakeDamage( pPlayer, pAttacker );
+}
+
+bool CHL2MPRules::AllowDamage( CBaseEntity *pVictim, const CTakeDamageInfo &info )
+{
+	CTakeDamageInfo lInfo = info;
+
+	BEGIN_LUA_CALL_HOOK( "AllowDamage" );
+		lua_pushentity( L, pVictim );
+		lua_pushdamageinfo( L, lInfo );
+	END_LUA_CALL_HOOK( 2, 1 );
+
+	RETURN_LUA_BOOLEAN();
+
+	return BaseClass::AllowDamage( pVictim, lInfo );
+}
+#ifdef HL2SB
+//-----------------------------------------------------------------------------
+// Purpose: Whether or not the NPC should drop a health vial
+// Output : Returns true on success, false on failure.
+//-----------------------------------------------------------------------------
+bool CHL2MPRules::NPC_ShouldDropHealth( CBasePlayer *pRecipient )
+{
+	// Can only do this every so often
+	if ( m_flLastHealthDropTime > gpGlobals->curtime )
+		return false;
+
+	//Try to throw dynamic health
+	float healthPerc = ( (float) pRecipient->m_iHealth / (float) pRecipient->m_iMaxHealth );
+
+	if ( random->RandomFloat( 0.0f, 1.0f ) > healthPerc*1.5f )
+		return true;
+
+	return false;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Whether or not the NPC should drop a health vial
+// Output : Returns true on success, false on failure.
+//-----------------------------------------------------------------------------
+bool CHL2MPRules::NPC_ShouldDropGrenade( CBasePlayer *pRecipient )
+{
+	// Can only do this every so often
+	if ( m_flLastGrenadeDropTime > gpGlobals->curtime )
+		return false;
+	
+	int grenadeIndex = GetAmmoDef()->Index( "grenade" );
+	int numGrenades = pRecipient->GetAmmoCount( grenadeIndex );
+
+	// If we're not maxed out on grenades and we've randomly okay'd it
+	if ( ( numGrenades < GetAmmoDef()->MaxCarry( grenadeIndex ) ) && ( random->RandomInt( 0, 2 ) == 0 ) )
+		return true;
+
+	return false;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Update the drop counter for health
+//-----------------------------------------------------------------------------
+void CHL2MPRules::NPC_DroppedHealth( void )
+{
+	m_flLastHealthDropTime = gpGlobals->curtime + sk_plr_health_drop_time.GetFloat();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Update the drop counter for grenades
+//-----------------------------------------------------------------------------
+void CHL2MPRules::NPC_DroppedGrenade( void )
+{
+	m_flLastGrenadeDropTime = gpGlobals->curtime + sk_plr_grenade_drop_time.GetFloat();
+}
+
+#endif
+
+void CHL2MPRules::PlayerThink( CBasePlayer *pPlayer )
+{
+	BEGIN_LUA_CALL_HOOK( "PlayerThink" );
+		lua_pushplayer( L, pPlayer );
+	END_LUA_CALL_HOOK( 1, 0 );
+
+	BaseClass::PlayerThink( pPlayer );
+}
+
+void CHL2MPRules::PlayerSpawn( CBasePlayer *pPlayer )
+{
+	BEGIN_LUA_CALL_HOOK( "PlayerSpawn" );
+		lua_pushplayer( L, pPlayer );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_NONE();
+
+	BaseClass::PlayerSpawn( pPlayer );
+}
+
+bool CHL2MPRules::FPlayerCanRespawn( CBasePlayer *pPlayer )
+{
+	BEGIN_LUA_CALL_HOOK( "FPlayerCanRespawn" );
+		lua_pushplayer( L, pPlayer );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_BOOLEAN();
+
+	return BaseClass::FPlayerCanRespawn( pPlayer );
+}
+
+float CHL2MPRules::FlPlayerSpawnTime( CBasePlayer *pPlayer )
+{
+	BEGIN_LUA_CALL_HOOK( "FlPlayerSpawnTime" );
+		lua_pushplayer( L, pPlayer );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_NUMBER();
+
+	return BaseClass::FlPlayerSpawnTime( pPlayer );
+}
+#endif
+#endif
+
 void CHL2MPRules::Think( void )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "Think" );
+	END_LUA_CALL_HOOK( 0, 0 );
+#endif
 
 #ifndef CLIENT_DLL
 	
@@ -386,6 +594,11 @@ void CHL2MPRules::Think( void )
 
 void CHL2MPRules::GoToIntermission( void )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "GoToIntermission" );
+	END_LUA_CALL_HOOK( 0, 0 );
+#endif
+
 #ifndef CLIENT_DLL
 	if ( g_fGameOver )
 		return;
@@ -410,6 +623,13 @@ void CHL2MPRules::GoToIntermission( void )
 
 bool CHL2MPRules::CheckGameOver()
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "CheckGameOver" );
+	END_LUA_CALL_HOOK( 0, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 #ifndef CLIENT_DLL
 	if ( g_fGameOver )   // someone else quit the game already
 	{
@@ -437,6 +657,14 @@ bool CHL2MPRules::CheckGameOver()
 //=========================================================
 float CHL2MPRules::FlWeaponTryRespawn( CBaseCombatWeapon *pWeapon )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "FlWeaponTryRespawn" );
+		lua_pushweapon( L, pWeapon );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_NUMBER();
+#endif
+
 #ifndef CLIENT_DLL
 	if ( pWeapon && (pWeapon->GetWeaponFlags() & ITEM_FLAG_LIMITINWORLD) )
 	{
@@ -456,6 +684,14 @@ float CHL2MPRules::FlWeaponTryRespawn( CBaseCombatWeapon *pWeapon )
 //=========================================================
 Vector CHL2MPRules::VecWeaponRespawnSpot( CBaseCombatWeapon *pWeapon )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "VecWeaponRespawnSpot" );
+		lua_pushweapon( L, pWeapon );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_VECTOR();
+#endif
+
 #ifndef CLIENT_DLL
 	CWeaponHL2MPBase *pHL2Weapon = dynamic_cast< CWeaponHL2MPBase*>( pWeapon );
 
@@ -565,6 +801,14 @@ void CHL2MPRules::ManageObjectRelocation( void )
 //=========================================================
 void CHL2MPRules::AddLevelDesignerPlacedObject( CBaseEntity *pEntity )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "AddLevelDesignerPlacedObject" );
+		lua_pushentity( L, pEntity );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_NONE();
+#endif
+
 	if ( m_hRespawnableItemsAndWeapons.Find( pEntity ) == -1 )
 	{
 		m_hRespawnableItemsAndWeapons.AddToTail( pEntity );
@@ -576,6 +820,14 @@ void CHL2MPRules::AddLevelDesignerPlacedObject( CBaseEntity *pEntity )
 //=========================================================
 void CHL2MPRules::RemoveLevelDesignerPlacedObject( CBaseEntity *pEntity )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "RemoveLevelDesignerPlacedObject" );
+		lua_pushentity( L, pEntity );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_NONE();
+#endif
+
 	if ( m_hRespawnableItemsAndWeapons.Find( pEntity ) != -1 )
 	{
 		m_hRespawnableItemsAndWeapons.FindAndRemove( pEntity );
@@ -588,6 +840,14 @@ void CHL2MPRules::RemoveLevelDesignerPlacedObject( CBaseEntity *pEntity )
 //=========================================================
 Vector CHL2MPRules::VecItemRespawnSpot( CItem *pItem )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "VecItemRespawnSpot" );
+		lua_pushentity( L, pItem );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_VECTOR();
+#endif
+
 	return pItem->GetOriginalSpawnOrigin();
 }
 
@@ -596,6 +856,14 @@ Vector CHL2MPRules::VecItemRespawnSpot( CItem *pItem )
 //=========================================================
 QAngle CHL2MPRules::VecItemRespawnAngles( CItem *pItem )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "VecItemRespawnAngles" );
+		lua_pushentity( L, pItem );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_ANGLE();
+#endif
+
 	return pItem->GetOriginalSpawnAngles();
 }
 
@@ -604,21 +872,64 @@ QAngle CHL2MPRules::VecItemRespawnAngles( CItem *pItem )
 //=========================================================
 float CHL2MPRules::FlItemRespawnTime( CItem *pItem )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "FlItemRespawnTime" );
+		lua_pushentity( L, pItem );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_NUMBER();
+#endif
+
 	return sv_hl2mp_item_respawn_time.GetFloat();
 }
 
 
+#if defined ( LUA_SDK )
+//=========================================================
+//=========================================================
+void CHL2MPRules::PlayerGotItem( CBasePlayer *pPlayer, CItem *pItem )
+{
+	BEGIN_LUA_CALL_HOOK( "PlayerGotItem" );
+		lua_pushentity( L, pPlayer );
+		lua_pushentity( L, pItem );
+	END_LUA_CALL_HOOK( 2, 0 );
+}
+
+//=========================================================
+//=========================================================
+int CHL2MPRules::ItemShouldRespawn( CItem *pItem )
+{
+	BEGIN_LUA_CALL_HOOK( "ItemShouldRespawn" );
+		lua_pushentity( L, pItem );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_INTEGER();
+
+	return BaseClass::ItemShouldRespawn( pItem );
+}
+#endif
+
+
 //=========================================================
 // CanHaveWeapon - returns false if the player is not allowed
 // to pick up this weapon
 //=========================================================
 bool CHL2MPRules::CanHavePlayerItem( CBasePlayer *pPlayer, CBaseCombatWeapon *pItem )
 {
+#if !defined ( LUA_SDK )
 	if ( weaponstay.GetInt() > 0 )
 	{
 		if ( pPlayer->Weapon_OwnsThisType( pItem->GetClassname(), pItem->GetSubType() ) )
 			 return false;
 	}
+#else
+	BEGIN_LUA_CALL_HOOK( "CanHavePlayerItem" );
+		lua_pushplayer( L, pPlayer );
+		lua_pushweapon( L, pItem );
+	END_LUA_CALL_HOOK( 2, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
 
 	return BaseClass::CanHavePlayerItem( pPlayer, pItem );
 }
@@ -631,6 +942,14 @@ bool CHL2MPRules::CanHavePlayerItem( CBasePlayer *pPlayer, CBaseCombatWeapon *pI
 //=========================================================
 int CHL2MPRules::WeaponShouldRespawn( CBaseCombatWeapon *pWeapon )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "WeaponShouldRespawn" );
+		lua_pushweapon( L, pWeapon );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
 #ifndef CLIENT_DLL
 	if ( pWeapon->HasSpawnFlags( SF_NORESPAWN ) )
 	{
@@ -647,6 +966,12 @@ int CHL2MPRules::WeaponShouldRespawn( CBaseCombatWeapon *pWeapon )
 void CHL2MPRules::ClientDisconnected( edict_t *pClient )
 {
 #ifndef CLIENT_DLL
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "ClientDisconnected" );
+		lua_pushplayer( L, (CBasePlayer *)CBaseEntity::Instance( pClient ) );
+	END_LUA_CALL_HOOK( 1, 0 );
+#endif
+
 	// Msg( "CLIENT DISCONNECTED, REMOVING FROM TEAM.\n" );
 
 	CBasePlayer *pPlayer = (CBasePlayer *)CBaseEntity::Instance( pClient );
@@ -665,29 +990,83 @@ void CHL2MPRules::ClientDisconnected( edict_t *pClient )
 }
 
 
+#ifndef CLIENT_DLL
+#if defined ( LUA_SDK )
+float CHL2MPRules::FlPlayerFallDamage( CBasePlayer *pPlayer )
+{
+	BEGIN_LUA_CALL_HOOK( "FlPlayerFallDamage" );
+		lua_pushplayer( L, pPlayer );
+	END_LUA_CALL_HOOK( 1, 1 );
+
+	RETURN_LUA_NUMBER();
+
+	return BaseClass::FlPlayerFallDamage( pPlayer );
+} 
+#endif
+#endif
+
 //=========================================================
 // Deathnotice. 
 //=========================================================
 void CHL2MPRules::DeathNotice( CBasePlayer *pVictim, const CTakeDamageInfo &info )
 {
+#if defined ( LUA_SDK )
+	CTakeDamageInfo lInfo = info;
+
+	BEGIN_LUA_CALL_HOOK( "DeathNotice" );
+		lua_pushplayer( L, pVictim );
+		lua_pushdamageinfo( L, lInfo );
+	END_LUA_CALL_HOOK( 2, 0 );
+#endif
+
 #ifndef CLIENT_DLL
 	// Work out what killed the player, and send a message to all clients about it
 	const char *killer_weapon_name = "world";		// by default, the player is killed by the world
 	int killer_ID = 0;
+#if defined ( LUA_SDK )
+	const char *killer_class_name = "class C_World";		// by default, the player is killed by the world
+	const char *weapon_class_name = NULL;
+#endif
 
 	// Find the killer & the scorer
+#if defined ( LUA_SDK )
+	CBaseEntity *pInflictor = lInfo.GetInflictor();
+	CBaseEntity *pKiller = lInfo.GetAttacker();
+#else
 	CBaseEntity *pInflictor = info.GetInflictor();
 	CBaseEntity *pKiller = info.GetAttacker();
+#endif
 	CBasePlayer *pScorer = GetDeathScorer( pKiller, pInflictor );
 
 	// Custom kill type?
+#if defined ( LUA_SDK )
+	if ( lInfo.GetDamageCustom() )
+	{
+		killer_weapon_name = GetDamageCustomString( lInfo );
+		killer_class_name = pKiller->GetClassname();
+		weapon_class_name = pInflictor->GetClassname();
+#else
 	if ( info.GetDamageCustom() )
 	{
 		killer_weapon_name = GetDamageCustomString( info );
+#endif
 		if ( pScorer )
 		{
 			killer_ID = pScorer->GetUserID();
 		}
+
+#ifdef LUA_SDK
+		if ( !Q_strcmp( killer_class_name, weapon_class_name ) )
+		{
+			// If the inflictor is the killer,  then it must be their current weapon doing the damage
+			CAI_BaseNPC *pNPC = pKiller->MyNPCPointer();
+			if ( pNPC && pNPC->GetActiveWeapon() )
+			{
+				killer_weapon_name = pNPC->GetActiveWeapon()->GetClassname();
+				weapon_class_name = pNPC->GetActiveWeapon()->GetClassname();
+			}
+		}
+#endif
 	}
 	else
 	{
@@ -715,6 +1094,21 @@ void CHL2MPRules::DeathNotice( CBasePlayer *pVictim, const CTakeDamageInfo &info
 		else
 		{
 			killer_weapon_name = pInflictor->GetClassname();
+#ifdef LUA_SDK
+			killer_class_name = pKiller->GetClassname();
+			weapon_class_name = pInflictor->GetClassname();
+
+			if ( !Q_strcmp( killer_class_name, weapon_class_name ) )
+			{
+				// If the inflictor is the killer,  then it must be their current weapon doing the damage
+				CAI_BaseNPC *pNPC = pKiller->MyNPCPointer();
+				if ( pNPC && pNPC->GetActiveWeapon() )
+				{
+					killer_weapon_name = pNPC->GetActiveWeapon()->GetClassname();
+					weapon_class_name = pNPC->GetActiveWeapon()->GetClassname();
+				}
+			}
+#endif
 		}
 
 		// strip the NPC_* or weapon_* from the inflictor's classname
@@ -756,7 +1150,13 @@ void CHL2MPRules::DeathNotice( CBasePlayer *pVictim, const CTakeDamageInfo &info
 	{
 		event->SetInt("userid", pVictim->GetUserID() );
 		event->SetInt("attacker", killer_ID );
+#ifdef LUA_SDK
+		event->SetString("attackername", killer_class_name );
+#endif
 		event->SetString("weapon", killer_weapon_name );
+#ifdef LUA_SDK
+		event->SetString("weaponname", weapon_class_name );
+#endif
 		event->SetInt( "priority", 7 );
 		gameeventmanager->FireEvent( event );
 	}
@@ -766,6 +1166,12 @@ void CHL2MPRules::DeathNotice( CBasePlayer *pVictim, const CTakeDamageInfo &info
 
 void CHL2MPRules::ClientSettingsChanged( CBasePlayer *pPlayer )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "ClientSettingsChanged" );
+		lua_pushplayer( L, pPlayer );
+	END_LUA_CALL_HOOK( 1, 0 );
+#endif
+
 #ifndef CLIENT_DLL
 	
 	CHL2MP_Player *pHL2Player = ToHL2MPPlayer( pPlayer );
@@ -776,6 +1182,26 @@ void CHL2MPRules::ClientSettingsChanged( CBasePlayer *pPlayer )
 	const char *pCurrentModel = modelinfo->GetModelName( pPlayer->GetModel() );
 	const char *szModelName = engine->GetClientConVarValue( engine->IndexOfEdict( pPlayer->edict() ), "cl_playermodel" );
 
+#ifdef HL2SB
+	//Andrew; Map our requested player model to the new model/player path.
+	char file[_MAX_PATH];
+	Q_strncpy( file, szModelName, sizeof(file) );
+	if ( Q_strnicmp( file, "models/player/", 14 ) )
+	{
+		char *substring = strstr( file, "models/" );
+		if ( substring )
+		{
+			// replace with new directory
+			const char *dirname = substring + strlen("models/");
+			*substring = 0;
+			char destpath[_MAX_PATH];
+			// player
+			Q_snprintf( destpath, sizeof(destpath), "models/player/%s", dirname);
+			szModelName = destpath;
+		}
+	}
+#endif
+
 	//If we're different.
 	if ( stricmp( szModelName, pCurrentModel ) )
 	{
@@ -807,7 +1233,11 @@ void CHL2MPRules::ClientSettingsChanged( CBasePlayer *pPlayer )
 		}
 		else
 		{
+#ifdef HL2SB
+			if ( Q_stristr( szModelName, "models/player/human") )
+#else
 			if ( Q_stristr( szModelName, "models/human") )
+#endif
 			{
 				pHL2Player->ChangeTeam( TEAM_REBELS );
 			}
@@ -829,6 +1259,15 @@ void CHL2MPRules::ClientSettingsChanged( CBasePlayer *pPlayer )
 
 int CHL2MPRules::PlayerRelationship( CBaseEntity *pPlayer, CBaseEntity *pTarget )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "PlayerRelationship" );
+		lua_pushentity( L, pPlayer );
+		lua_pushentity( L, pTarget );
+	END_LUA_CALL_HOOK( 2, 1 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
 #ifndef CLIENT_DLL
 	// half life multiplay has a simple concept of Player Relationships.
 	// you are either on another player's team, or you are not.
@@ -844,20 +1283,80 @@ int CHL2MPRules::PlayerRelationship( CBaseEntity *pPlayer, CBaseEntity *pTarget
 	return GR_NOTTEAMMATE;
 }
 
+#ifndef CLIENT_DLL
+#if defined ( LUA_SDK )
+bool CHL2MPRules::PlayerCanHearChat( CBasePlayer *pListener, CBasePlayer *pSpeaker )
+{
+	BEGIN_LUA_CALL_HOOK( "PlayerCanHearChat" );
+		lua_pushplayer( L, pListener );
+		lua_pushplayer( L, pSpeaker );
+	END_LUA_CALL_HOOK( 2, 1 );
+
+	RETURN_LUA_BOOLEAN();
+
+	return BaseClass::PlayerCanHearChat( pListener, pSpeaker );
+}
+
+bool CHL2MPRules::ClientConnected( edict_t *pEntity, const char *pszName, const char *pszAddress, char *reject, int maxrejectlen )
+{
+	BEGIN_LUA_CALL_HOOK( "ClientConnected" );
+		lua_pushplayer( L, (CBasePlayer *)CBaseEntity::Instance( pEntity ) );
+		lua_pushstring( L, pszName );
+		lua_pushstring( L, pszAddress );
+		lua_pushstring( L, reject );
+		lua_pushinteger( L, maxrejectlen );
+	END_LUA_CALL_HOOK( 5, 1 );
+
+	RETURN_LUA_BOOLEAN();
+
+	return BaseClass::ClientConnected( pEntity, pszName, pszAddress, reject, maxrejectlen );
+}
+
+void CHL2MPRules::InitHUD( CBasePlayer *pPlayer )
+{
+	BEGIN_LUA_CALL_HOOK( "InitHUD" );
+		lua_pushplayer( L, pPlayer );
+	END_LUA_CALL_HOOK( 1, 0 );
+
+	BaseClass::InitHUD( pPlayer );
+}
+
+
+#endif
+#endif
+
 const char *CHL2MPRules::GetGameDescription( void )
 { 
+#if !defined ( LUA_SDK )
 	if ( IsTeamplay() )
 		return "Team Deathmatch"; 
+#else
+	BEGIN_LUA_CALL_HOOK( "GetGameDescription" );
+	END_LUA_CALL_HOOK( 0, 1 );
+
+	RETURN_LUA_STRING();
+#endif
 
+#if !defined( HL2SB )
 	return "Deathmatch"; 
+#else
+	return "Half-Life 2 Sandbox";
+#endif
 } 
 
 
 float CHL2MPRules::GetMapRemainingTime()
 {
+#if !defined ( LUA_SDK )
 	// if timelimit is disabled, return 0
 	if ( mp_timelimit.GetInt() <= 0 )
 		return 0;
+#else
+	BEGIN_LUA_CALL_HOOK( "GetMapRemainingTime" );
+	END_LUA_CALL_HOOK( 0, 1 );
+
+	RETURN_LUA_NUMBER();
+#endif
 
 	// timelimit is in minutes
 
@@ -871,11 +1370,25 @@ float CHL2MPRules::GetMapRemainingTime()
 //-----------------------------------------------------------------------------
 void CHL2MPRules::Precache( void )
 {
+#if !defined ( LUA_SDK )
 	CBaseEntity::PrecacheScriptSound( "AlyxEmp.Charge" );
+#else
+	BEGIN_LUA_CALL_HOOK( "Precache" );
+	END_LUA_CALL_HOOK( 0, 0 );
+#endif
 }
 
 bool CHL2MPRules::ShouldCollide( int collisionGroup0, int collisionGroup1 )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "ShouldCollide" );
+		lua_pushinteger( L, collisionGroup0 );
+		lua_pushinteger( L, collisionGroup1 );
+	END_LUA_CALL_HOOK( 2, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
 	if ( collisionGroup0 > collisionGroup1 )
 	{
 		// swap so that lowest is always first
@@ -892,6 +1405,25 @@ bool CHL2MPRules::ShouldCollide( int collisionGroup0, int collisionGroup1 )
 
 }
 
+#if !defined( CLIENT_DLL ) && defined( HL2SB )
+//-----------------------------------------------------------------------------
+// Returns whether or not Alyx cares about light levels in order to see.
+//-----------------------------------------------------------------------------
+bool CHL2MPRules::IsAlyxInDarknessMode()
+{
+#ifdef HL2_EPISODIC
+	if ( alyx_darkness_force.GetBool() )
+		return true;
+
+	return ( GlobalEntity_GetState( "ep_alyx_darknessmode" ) == GLOBAL_ON );
+#else
+	return false;
+#endif // HL2_EPISODIC
+}
+
+
+#endif
+
 bool CHL2MPRules::ClientCommand( CBaseEntity *pEdict, const CCommand &args )
 {
 #ifndef CLIENT_DLL
@@ -928,6 +1460,7 @@ CAmmoDef *GetAmmoDef()
 	{
 		bInitted = true;
 
+#ifndef HL2SB
 		def.AddAmmoType("AR2",				DMG_BULLET,					TRACER_LINE_AND_WHIZ,	0,			0,			60,			BULLET_IMPULSE(200, 1225),	0 );
 		def.AddAmmoType("AR2AltFire",		DMG_DISSOLVE,				TRACER_NONE,			0,			0,			3,			0,							0 );
 		def.AddAmmoType("Pistol",			DMG_BULLET,					TRACER_LINE_AND_WHIZ,	0,			0,			150,		BULLET_IMPULSE(200, 1225),	0 );
@@ -938,7 +1471,82 @@ CAmmoDef *GetAmmoDef()
 		def.AddAmmoType("RPG_Round",		DMG_BURN,					TRACER_NONE,			0,			0,			3,			0,							0 );
 		def.AddAmmoType("SMG1_Grenade",		DMG_BURN,					TRACER_NONE,			0,			0,			3,			0,							0 );
 		def.AddAmmoType("Grenade",			DMG_BURN,					TRACER_NONE,			0,			0,			5,			0,							0 );
-		def.AddAmmoType("slam",				DMG_BURN,					TRACER_NONE,			0,			0,			5,			0,							0 );
+#else
+		def.AddAmmoType("AR2",				DMG_BULLET,					TRACER_LINE_AND_WHIZ,	"sk_plr_dmg_ar2",			"sk_npc_dmg_ar2",			"sk_max_ar2",			BULLET_IMPULSE(200, 1225), 0 );
+		def.AddAmmoType("AlyxGun",			DMG_BULLET,					TRACER_LINE,			"sk_plr_dmg_alyxgun",		"sk_npc_dmg_alyxgun",		"sk_max_alyxgun",		BULLET_IMPULSE(200, 1225), 0 );
+		def.AddAmmoType("Pistol",			DMG_BULLET,					TRACER_LINE_AND_WHIZ,	"sk_plr_dmg_pistol",		"sk_npc_dmg_pistol",		"sk_max_pistol",		BULLET_IMPULSE(200, 1225), 0 );
+		def.AddAmmoType("SMG1",				DMG_BULLET,					TRACER_LINE_AND_WHIZ,	"sk_plr_dmg_smg1",			"sk_npc_dmg_smg1",			"sk_max_smg1",			BULLET_IMPULSE(200, 1225), 0 );
+		def.AddAmmoType("357",				DMG_BULLET,					TRACER_LINE_AND_WHIZ,	"sk_plr_dmg_357",			"sk_npc_dmg_357",			"sk_max_357",			BULLET_IMPULSE(800, 5000), 0 );
+		def.AddAmmoType("XBowBolt",			DMG_BULLET,					TRACER_LINE,			"sk_plr_dmg_crossbow",		"sk_npc_dmg_crossbow",		"sk_max_crossbow",		BULLET_IMPULSE(800, 8000), 0 );
+
+		def.AddAmmoType("Buckshot",			DMG_BULLET | DMG_BUCKSHOT,	TRACER_LINE,			"sk_plr_dmg_buckshot",		"sk_npc_dmg_buckshot",		"sk_max_buckshot",		BULLET_IMPULSE(400, 1200), 0 );
+		def.AddAmmoType("RPG_Round",		DMG_BURN,					TRACER_NONE,			"sk_plr_dmg_rpg_round",		"sk_npc_dmg_rpg_round",		"sk_max_rpg_round",		0, 0 );
+		def.AddAmmoType("SMG1_Grenade",		DMG_BURN,					TRACER_NONE,			"sk_plr_dmg_smg1_grenade",	"sk_npc_dmg_smg1_grenade",	"sk_max_smg1_grenade",	0, 0 );
+		def.AddAmmoType("SniperRound",		DMG_BULLET | DMG_SNIPER,	TRACER_NONE,			"sk_plr_dmg_sniper_round",	"sk_npc_dmg_sniper_round",	"sk_max_sniper_round",	BULLET_IMPULSE(650, 6000), 0 );
+		def.AddAmmoType("SniperPenetratedRound", DMG_BULLET | DMG_SNIPER, TRACER_NONE,			"sk_dmg_sniper_penetrate_plr", "sk_dmg_sniper_penetrate_npc", "sk_max_sniper_round", BULLET_IMPULSE(150, 6000), 0 );
+		def.AddAmmoType("Grenade",			DMG_BURN,					TRACER_NONE,			"sk_plr_dmg_grenade",		"sk_npc_dmg_grenade",		"sk_max_grenade",		0, 0);
+		def.AddAmmoType("Slam",				DMG_BURN,					TRACER_NONE,			0,	0,	5, 0, 0 );
+		def.AddAmmoType("Thumper",			DMG_SONIC,					TRACER_NONE,			10, 10, 2, 0, 0 );
+		def.AddAmmoType("Gravity",			DMG_CLUB,					TRACER_NONE,			0,	0, 8, 0, 0 );
+//		def.AddAmmoType("Extinguisher",		DMG_BURN,					TRACER_NONE,			0,	0, 100, 0, 0 );
+		def.AddAmmoType("Battery",			DMG_CLUB,					TRACER_NONE,			NULL, NULL, NULL, 0, 0 );
+		def.AddAmmoType("GaussEnergy",		DMG_SHOCK,					TRACER_NONE,			"sk_jeep_gauss_damage",		"sk_jeep_gauss_damage", "sk_max_gauss_round", BULLET_IMPULSE(650, 8000), 0 ); // hit like a 10kg weight at 400 in/s
+		def.AddAmmoType("CombineCannon",	DMG_BULLET,					TRACER_LINE,			"sk_npc_dmg_gunship_to_plr", "sk_npc_dmg_gunship", NULL, 1.5 * 750 * 12, 0 ); // hit like a 1.5kg weight at 750 ft/s
+		def.AddAmmoType("AirboatGun",		DMG_AIRBOAT,				TRACER_LINE,			"sk_plr_dmg_airboat",		"sk_npc_dmg_airboat",		NULL,					BULLET_IMPULSE(10, 600), 0 );
+
+		//=====================================================================
+		// STRIDER MINIGUN DAMAGE - Pull up a chair and I'll tell you a tale.
+		//
+		// When we shipped Half-Life 2 in 2004, we were unaware of a bug in
+		// CAmmoDef::NPCDamage() which was returning the MaxCarry field of
+		// an ammotype as the amount of damage that should be done to a NPC
+		// by that type of ammo. Thankfully, the bug only affected Ammo Types 
+		// that DO NOT use ConVars to specify their parameters. As you can see,
+		// all of the important ammotypes use ConVars, so the effect of the bug
+		// was limited. The Strider Minigun was affected, though.
+		//
+		// According to my perforce Archeology, we intended to ship the Strider
+		// Minigun ammo type to do 15 points of damage per shot, and we did. 
+		// To achieve this we, unaware of the bug, set the Strider Minigun ammo 
+		// type to have a maxcarry of 15, since our observation was that the 
+		// number that was there before (8) was indeed the amount of damage being
+		// done to NPC's at the time. So we changed the field that was incorrectly
+		// being used as the NPC Damage field.
+		//
+		// The bug was fixed during Episode 1's development. The result of the 
+		// bug fix was that the Strider was reduced to doing 5 points of damage
+		// to NPC's, since 5 is the value that was being assigned as NPC damage
+		// even though the code was returning 15 up to that point.
+		//
+		// Now as we go to ship Orange Box, we discover that the Striders in 
+		// Half-Life 2 are hugely ineffective against citizens, causing big
+		// problems in maps 12 and 13. 
+		//
+		// In order to restore balance to HL2 without upsetting the delicate 
+		// balance of ep2_outland_12, I have chosen to build Episodic binaries
+		// with 5 as the Strider->NPC damage, since that's the value that has
+		// been in place for all of Episode 2's development. Half-Life 2 will
+		// build with 15 as the Strider->NPC damage, which is how HL2 shipped
+		// originally, only this time the 15 is located in the correct field
+		// now that the AmmoDef code is behaving correctly.
+		//
+		//=====================================================================
+#ifdef HL2_EPISODIC
+		def.AddAmmoType("StriderMinigun",	DMG_BULLET,					TRACER_LINE,			5, 5, 15, 1.0 * 750 * 12, AMMO_FORCE_DROP_IF_CARRIED ); // hit like a 1.0kg weight at 750 ft/s
+#else
+		def.AddAmmoType("StriderMinigun",	DMG_BULLET,					TRACER_LINE,			5, 15,15, 1.0 * 750 * 12, AMMO_FORCE_DROP_IF_CARRIED ); // hit like a 1.0kg weight at 750 ft/s
+#endif//HL2_EPISODIC
+
+		def.AddAmmoType("StriderMinigunDirect",	DMG_BULLET,				TRACER_LINE,			2, 2, 15, 1.0 * 750 * 12, AMMO_FORCE_DROP_IF_CARRIED ); // hit like a 1.0kg weight at 750 ft/s
+		def.AddAmmoType("HelicopterGun",	DMG_BULLET,					TRACER_LINE_AND_WHIZ,	"sk_npc_dmg_helicopter_to_plr", "sk_npc_dmg_helicopter",	"sk_max_smg1",	BULLET_IMPULSE(400, 1225), AMMO_FORCE_DROP_IF_CARRIED | AMMO_INTERPRET_PLRDAMAGE_AS_DAMAGE_TO_PLAYER );
+		def.AddAmmoType("AR2AltFire",		DMG_DISSOLVE,				TRACER_NONE,			0, 0, "sk_max_ar2_altfire", 0, 0 );
+		def.AddAmmoType("Grenade",			DMG_BURN,					TRACER_NONE,			"sk_plr_dmg_grenade",		"sk_npc_dmg_grenade",		"sk_max_grenade",		0, 0);
+#ifdef HL2_EPISODIC
+		def.AddAmmoType("Hopwire",			DMG_BLAST,					TRACER_NONE,			"sk_plr_dmg_grenade",		"sk_npc_dmg_grenade",		"sk_max_hopwire",		0, 0);
+		def.AddAmmoType("CombineHeavyCannon",	DMG_BULLET,				TRACER_LINE,			40,	40, NULL, 10 * 750 * 12, AMMO_FORCE_DROP_IF_CARRIED ); // hit like a 10 kg weight at 750 ft/s
+		def.AddAmmoType("ammo_proto1",			DMG_BULLET,				TRACER_LINE,			0, 0, 10, 0, 0 );
+#endif // HL2_EPISODIC
+#endif // HL2SB
 	}
 
 	return &def;
@@ -954,7 +1562,7 @@ CAmmoDef *GetAmmoDef()
 
 #else
 
-#ifdef DEBUG
+#if defined( DEBUG ) || defined( LUA_SDK )
 
 	// Handler for the "bot" command.
 	void Bot_f()
@@ -976,12 +1584,25 @@ CAmmoDef *GetAmmoDef()
 	}
 
 
+#ifndef LUA_SDK
 	ConCommand cc_Bot( "bot", Bot_f, "Add a bot.", FCVAR_CHEAT );
+#else
+	ConCommand cc_Bot( "bot", Bot_f, "Add a bot." );
+#endif
 
 #endif
 
 	bool CHL2MPRules::FShouldSwitchWeapon( CBasePlayer *pPlayer, CBaseCombatWeapon *pWeapon )
 	{		
+#if defined ( LUA_SDK )
+		BEGIN_LUA_CALL_HOOK( "FShouldSwitchWeapon" );
+			lua_pushplayer( L, pPlayer );
+			lua_pushweapon( L, pWeapon );
+		END_LUA_CALL_HOOK( 2, 1 );
+
+		RETURN_LUA_BOOLEAN();
+#endif
+
 		if ( pPlayer->GetActiveWeapon() && pPlayer->IsNetClient() )
 		{
 			// Player has an active item, so let's check cl_autowepswitch.
@@ -1002,6 +1623,11 @@ CAmmoDef *GetAmmoDef()
 //Tony; Re-working restart game so that it cleans up safely, and then respawns everyone.
 void CHL2MPRules::RestartGame()
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "RestartGame" );
+	END_LUA_CALL_HOOK( 0, 0 );
+#endif
+
 	// bounds check
 	if ( mp_timelimit.GetInt() < 0 )
 	{
@@ -1186,10 +1812,22 @@ void CHL2MPRules::CleanUpMap()
 	// DO NOT CALL SPAWN ON info_node ENTITIES!
 
 	MapEntity_ParseAllEntities( engine->GetMapEntitiesString(), &filter, true );
+
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "CleanUpMap" );
+	END_LUA_CALL_HOOK( 0, 0 );
+#endif
 }
 
 void CHL2MPRules::CheckChatForReadySignal( CHL2MP_Player *pPlayer, const char *chatmsg )
 {
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "CheckChatForReadySignal" );
+		lua_pushplayer( L, pPlayer );
+		lua_pushstring( L, chatmsg );
+	END_LUA_CALL_HOOK( 2, 0 );
+#endif
+
 	if( m_bAwaitingReadyRestart && FStrEq( chatmsg, mp_ready_signal.GetString() ) )
 	{
 		if( !pPlayer->IsReady() )
@@ -1309,4 +1947,935 @@ const char *CHL2MPRules::GetChatFormat( bool bTeamOnly, CBasePlayer *pPlayer )
 	return pszFormat;
 }
 
+#ifdef HL2SB
+//------------------------------------------------------------------------------
+// Purpose : Initialize all default class relationships
+// Input   :
+// Output  :
+//------------------------------------------------------------------------------
+void CHL2MPRules::InitDefaultAIRelationships( void )
+{
+	int i, j;
+
+	//  Allocate memory for default relationships
+	CBaseCombatCharacter::AllocateDefaultRelationships();
+
+	// --------------------------------------------------------------
+	// First initialize table so we can report missing relationships
+	// --------------------------------------------------------------
+	for (i=0;i<NUM_AI_CLASSES;i++)
+	{
+		for (j=0;j<NUM_AI_CLASSES;j++)
+		{
+			// By default all relationships are neutral of priority zero
+			CBaseCombatCharacter::SetDefaultRelationship( (Class_T)i, (Class_T)j, D_NU, 0 );
+		}
+	}
+
+	// ------------------------------------------------------------
+	//	> CLASS_ANTLION
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_COMBINE_HUNTER,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_MANHACK,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_SCANNER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_STALKER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_PROTOSNIPER,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_ANTLION,			D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_BARNACLE
+	//
+	//  In this case, the relationship D_HT indicates which characters
+	//  the barnacle will try to eat.
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_BARNACLE,			D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_BULLSQUID,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_MANHACK,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_STALKER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_EARTH_FAUNA,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_BULLSEYE
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_PLAYER,			D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_ANTLION,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_BULLSQUID,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_CITIZEN_REBEL,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_COMBINE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_CONSCRIPT,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_HEADCRAB,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_HOUNDEYE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_VORTIGAUNT,		D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_ZOMBIE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_PLAYER_ALLY,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_HACKED_ROLLERMINE,D_NU, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_BULLSQUID
+	// ------------------------------------------------------------
+	/*
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_BARNACLE,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_BULLSEYE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_BULLSQUID,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_COMBINE_HUNTER,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_HEADCRAB,			D_HT, 1);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_HOUNDEYE,			D_HT, 1);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_MANHACK,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_STALKER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+	*/
+	// ------------------------------------------------------------
+	//	> CLASS_CITIZEN_PASSIVE
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_PLAYER,			D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_BARNACLE,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_BULLSQUID,		D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_CITIZEN_REBEL,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_COMBINE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_COMBINE_HUNTER,	D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_CONSCRIPT,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_HEADCRAB,			D_FR, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_HOUNDEYE,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_MANHACK,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_MISSILE,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_VORTIGAUNT,		D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_ZOMBIE,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_PLAYER_ALLY,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_HACKED_ROLLERMINE,D_NU, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_CITIZEN_REBEL
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_PLAYER,			D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_BARNACLE,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_BULLSQUID,		D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_CITIZEN_REBEL,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_COMBINE_HUNTER,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_CONSCRIPT,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_MANHACK,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_MISSILE,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_SCANNER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_STALKER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_VORTIGAUNT,		D_LI, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_PLAYER_ALLY,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_HACKED_ROLLERMINE,D_NU, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_COMBINE
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_BARNACLE,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_COMBINE,			D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_COMBINE_GUNSHIP,	D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_COMBINE_HUNTER,	D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_COMBINE_GUNSHIP
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_COMBINE,			D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_COMBINE_GUNSHIP,	D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_COMBINE_HUNTER,	D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_HEADCRAB,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_MISSILE,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_COMBINE_HUNTER
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,	CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_COMBINE,			D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_COMBINE_GUNSHIP,	D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_COMBINE_HUNTER,	D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,	CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_CONSCRIPT
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_PLAYER,			D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_BARNACLE,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_CITIZEN_REBEL,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_COMBINE_HUNTER,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_CONSCRIPT,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_MANHACK,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_SCANNER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_STALKER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_VORTIGAUNT,		D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_PLAYER_ALLY,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_HACKED_ROLLERMINE,D_NU, 0);
+	
+	// ------------------------------------------------------------
+	//	> CLASS_FLARE
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_PLAYER,			D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_ANTLION,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_BULLSQUID,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_CITIZEN_REBEL,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_COMBINE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_CONSCRIPT,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_HEADCRAB,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_HOUNDEYE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_VORTIGAUNT,		D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_ZOMBIE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_PLAYER_ALLY,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_HACKED_ROLLERMINE,D_NU, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_HEADCRAB
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_BULLSQUID,		D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_HEADCRAB,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_HOUNDEYE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_ZOMBIE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_HACKED_ROLLERMINE,D_FR, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_HOUNDEYE
+	// ------------------------------------------------------------
+	/*
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_BULLSQUID,		D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_COMBINE_HUNTER,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_HEADCRAB,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_HOUNDEYE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_ZOMBIE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+	*/
+
+	// ------------------------------------------------------------
+	//	> CLASS_MANHACK
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_COMBINE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_HEADCRAB,			D_HT,-1);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_HOUNDEYE,			D_HT,-1);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_METROPOLICE
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_COMBINE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_MILITARY
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_COMBINE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_MISSILE
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_COMBINE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_NONE
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_PLAYER,			D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_ANTLION,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_BULLSEYE,			D_NU, 0);	
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_BULLSQUID,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_CITIZEN_REBEL,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_COMBINE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_CONSCRIPT,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_HEADCRAB,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_HOUNDEYE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_VORTIGAUNT,		D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_ZOMBIE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_PLAYER_ALLY,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_HACKED_ROLLERMINE,D_NU, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_PLAYER
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_PLAYER,			D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_BARNACLE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_BULLSEYE,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_CITIZEN_PASSIVE,	D_LI, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_CITIZEN_REBEL,	D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_COMBINE_GUNSHIP,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_COMBINE_HUNTER,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_CONSCRIPT,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_MANHACK,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_SCANNER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_STALKER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_VORTIGAUNT,		D_LI, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_PROTOSNIPER,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_PLAYER_ALLY,		D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_PLAYER_ALLY_VITAL,D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_HACKED_ROLLERMINE,D_LI, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_PLAYER_ALLY
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_PLAYER,			D_LI, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_BARNACLE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_CITIZEN_REBEL,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_COMBINE_HUNTER,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_CONSCRIPT,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_HEADCRAB,			D_FR, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_MANHACK,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_SCANNER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_STALKER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_VORTIGAUNT,		D_LI, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_ZOMBIE,			D_FR, 1);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_PROTOSNIPER,		D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_PLAYER_ALLY,		D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_PLAYER_ALLY_VITAL,D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_HACKED_ROLLERMINE,D_LI, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_PLAYER_ALLY_VITAL
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_PLAYER,			D_LI, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_BARNACLE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_CITIZEN_REBEL,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_COMBINE_HUNTER,	D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_CONSCRIPT,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_MANHACK,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_SCANNER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_STALKER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_VORTIGAUNT,		D_LI, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_PROTOSNIPER,		D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_PLAYER_ALLY,		D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_PLAYER_ALLY_VITAL,D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_HACKED_ROLLERMINE,D_LI, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_SCANNER
+	// ------------------------------------------------------------	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_BULLSQUID,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_COMBINE,			D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_COMBINE_GUNSHIP,	D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_COMBINE_HUNTER,	D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_HEADCRAB,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_HOUNDEYE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_MANHACK,			D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_METROPOLICE,		D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_MILITARY,			D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_SCANNER,			D_LI, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_STALKER,			D_LI, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_ZOMBIE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_PROTOSNIPER,		D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_STALKER
+	// ------------------------------------------------------------	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_COMBINE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_HEADCRAB,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_HOUNDEYE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_ZOMBIE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_VORTIGAUNT
+	// ------------------------------------------------------------	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_PLAYER,			D_LI, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_BARNACLE,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_CITIZEN_PASSIVE,	D_LI, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_CITIZEN_REBEL,	D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_COMBINE_HUNTER,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_CONSCRIPT,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_MANHACK,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_SCANNER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_STALKER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_VORTIGAUNT,		D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_PLAYER_ALLY,		D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_PLAYER_ALLY_VITAL,D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_HACKED_ROLLERMINE,D_LI, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_ZOMBIE
+	// ------------------------------------------------------------	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_BULLSQUID,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_COMBINE_HUNTER,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_HEADCRAB,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_HOUNDEYE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_MANHACK,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_MILITARY,			D_FR, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_ZOMBIE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_PROTOSNIPER
+	// ------------------------------------------------------------	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_PLAYER,			D_HT, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_BULLSQUID,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_COMBINE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_HOUNDEYE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_METROPOLICE,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_MILITARY,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_MISSILE,			D_NU, 5);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_STALKER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_VORTIGAUNT,		D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_EARTH_FAUNA
+	//
+	// Hates pretty much everything equally except other earth fauna.
+	// This will make the critter choose the nearest thing as its enemy.
+	// ------------------------------------------------------------	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_NONE,				D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_PLAYER,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_CITIZEN_REBEL,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_COMBINE_GUNSHIP,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_COMBINE_HUNTER,	D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_CONSCRIPT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_FLARE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_MANHACK,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_MISSILE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_SCANNER,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_STALKER,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_VORTIGAUNT,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_ZOMBIE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_PROTOSNIPER,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_EARTH_FAUNA,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_PLAYER_ALLY,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_HACKED_ROLLERMINE,D_NU, 0);
+
+	// ------------------------------------------------------------
+	//	> CLASS_HACKED_ROLLERMINE
+	// ------------------------------------------------------------
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_NONE,				D_NU, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_PLAYER,			D_LI, 0);			
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_ANTLION,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_BARNACLE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_BULLSEYE,			D_NU, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_BULLSQUID,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_CITIZEN_REBEL,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_COMBINE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_COMBINE_HUNTER,	D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_CONSCRIPT,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_FLARE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_HEADCRAB,			D_HT, 0);
+	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_HOUNDEYE,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_MANHACK,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_METROPOLICE,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_MILITARY,			D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_MISSILE,			D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_SCANNER,			D_NU, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_STALKER,			D_HT, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_VORTIGAUNT,		D_LI, 0);		
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_ZOMBIE,			D_HT, 1);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_PROTOSNIPER,		D_NU, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_EARTH_FAUNA,		D_HT, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_PLAYER_ALLY,		D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_PLAYER_ALLY_VITAL,D_LI, 0);
+	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_HACKED_ROLLERMINE,D_LI, 0);
+}
+#endif
 #endif
\ No newline at end of file
diff --git a/src/game/shared/hl2mp/hl2mp_gamerules.h b/src/game/shared/hl2mp/hl2mp_gamerules.h
index 8f20522..d030f1e 100644
--- a/src/game/shared/hl2mp/hl2mp_gamerules.h
+++ b/src/game/shared/hl2mp/hl2mp_gamerules.h
@@ -84,6 +84,14 @@ class CHL2MPRules : public CTeamplayRules
 public:
 	DECLARE_CLASS( CHL2MPRules, CTeamplayRules );
 
+#ifdef HL2SB
+private:
+	// Rules change for the mega physgun
+	CNetworkVar( bool, m_bMegaPhysgun );
+
+public:
+#endif
+
 #ifdef CLIENT_DLL
 
 	DECLARE_CLIENTCLASS_NOBASE(); // This makes datatables able to access our private vars.
@@ -108,6 +116,13 @@ public:
 	virtual void CreateStandardEntities( void );
 	virtual void ClientSettingsChanged( CBasePlayer *pPlayer );
 	virtual int PlayerRelationship( CBaseEntity *pPlayer, CBaseEntity *pTarget );
+#ifdef LUA_SDK
+#ifndef CLIENT_DLL
+	virtual bool PlayerCanHearChat( CBasePlayer *pListener, CBasePlayer *pSpeaker );
+	virtual bool ClientConnected( edict_t *pEntity, const char *pszName, const char *pszAddress, char *reject, int maxrejectlen );
+	virtual void InitHUD( CBasePlayer *pl );
+#endif
+#endif
 	virtual void GoToIntermission( void );
 	virtual void DeathNotice( CBasePlayer *pVictim, const CTakeDamageInfo &info );
 	virtual const char *GetGameDescription( void );
@@ -125,6 +140,10 @@ public:
 	virtual Vector VecItemRespawnSpot( CItem *pItem );
 	virtual QAngle VecItemRespawnAngles( CItem *pItem );
 	virtual float	FlItemRespawnTime( CItem *pItem );
+#ifdef LUA_SDK
+	virtual void PlayerGotItem( CBasePlayer *pPlayer, CItem *pItem );
+	virtual int ItemShouldRespawn( CItem *pItem );
+#endif
 	virtual bool	CanHavePlayerItem( CBasePlayer *pPlayer, CBaseCombatWeapon *pItem );
 	virtual bool FShouldSwitchWeapon( CBasePlayer *pPlayer, CBaseCombatWeapon *pWeapon );
 
@@ -134,9 +153,18 @@ public:
 	void    CheckChatForReadySignal( CHL2MP_Player *pPlayer, const char *chatmsg );
 	const char *GetChatFormat( bool bTeamOnly, CBasePlayer *pPlayer );
 
+#ifdef HL2SB
+	virtual void InitDefaultAIRelationships( void );
+#endif
 #endif
 	virtual void ClientDisconnected( edict_t *pClient );
 
+#ifdef LUA_SDK
+#ifndef CLIENT_DLL
+	virtual float FlPlayerFallDamage( CBasePlayer *pPlayer );
+#endif
+#endif
+
 	bool CheckGameOver( void );
 	bool IsIntermission( void );
 
@@ -144,10 +172,39 @@ public:
 
 	
 	bool	IsTeamplay( void ) { return m_bTeamPlayEnabled;	}
+#ifdef LUA_SDK
+#ifndef CLIENT_DLL
+	bool	FPlayerCanTakeDamage( CBasePlayer *pPlayer, CBaseEntity *pAttacker );
+	bool	AllowDamage( CBaseEntity *pVictim, const CTakeDamageInfo &info );
+
+	void	PlayerSpawn( CBasePlayer *pPlayer );
+	void	PlayerThink( CBasePlayer *pPlayer );
+	bool	FPlayerCanRespawn( CBasePlayer *pPlayer );
+	float	FlPlayerSpawnTime( CBasePlayer *pPlayer );
+#endif
+#endif
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	bool	NPC_ShouldDropGrenade( CBasePlayer *pRecipient );
+	bool	NPC_ShouldDropHealth( CBasePlayer *pRecipient );
+	void	NPC_DroppedHealth( void );
+	void	NPC_DroppedGrenade( void );
+	bool	MegaPhyscannonActive( void ) { return m_bMegaPhysgun;	}
+	
+	virtual bool IsAlyxInDarknessMode();
+#endif
+#endif
 	void	CheckAllPlayersReady( void );
 	
 private:
 	
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	float	m_flLastHealthDropTime;
+	float	m_flLastGrenadeDropTime;
+#endif
+#endif
+
 	CNetworkVar( bool, m_bTeamPlayEnabled );
 	CNetworkVar( float, m_flGameStartTime );
 	CUtlVector<EHANDLE> m_hRespawnableItemsAndWeapons;
diff --git a/src/game/shared/hl2mp/hl2mp_player_shared.cpp b/src/game/shared/hl2mp/hl2mp_player_shared.cpp
index cbed160..d13e3d4 100644
--- a/src/game/shared/hl2mp/hl2mp_player_shared.cpp
+++ b/src/game/shared/hl2mp/hl2mp_player_shared.cpp
@@ -20,6 +20,11 @@
 #include "engine/IEngineSound.h"
 #include "SoundEmitterSystem/isoundemittersystembase.h"
 
+#include "luamanager.h"
+#include "lhl2mp_player_shared.h"
+#include "mathlib/lvector.h"
+#include "lvphysics_interface.h"
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -75,6 +80,18 @@ Vector CHL2MP_Player::GetAttackSpread( CBaseCombatWeapon *pWeapon, CBaseEntity *
 //-----------------------------------------------------------------------------
 void CHL2MP_Player::PlayStepSound( Vector &vecOrigin, surfacedata_t *psurface, float fvol, bool force )
 {
+#if defined( LUA_SDK )
+	BEGIN_LUA_CALL_HOOK( "PlayerPlayStepSound" );
+		lua_pushhl2mpplayer( L, this );
+		lua_pushvector( L, vecOrigin );
+		lua_pushsurfacedata( L, psurface );
+		lua_pushnumber( L, fvol );
+		lua_pushboolean( L, force );
+	END_LUA_CALL_HOOK( 5, 1 );
+
+	RETURN_LUA_NONE();
+#endif
+
 	if ( gpGlobals->maxClients > 1 && !sv_footsteps.GetFloat() )
 		return;
 
diff --git a/src/game/shared/hl2mp/hl2mp_playeranimstate.cpp b/src/game/shared/hl2mp/hl2mp_playeranimstate.cpp
index 51ce02d..f8956e7 100644
--- a/src/game/shared/hl2mp/hl2mp_playeranimstate.cpp
+++ b/src/game/shared/hl2mp/hl2mp_playeranimstate.cpp
@@ -161,14 +161,49 @@ void CHL2MPPlayerAnimState::Update( float eyeYaw, float eyePitch )
 		ComputePoseParam_AimYaw( pStudioHdr );
 	}
 
+#ifndef HL2SB
 #ifdef CLIENT_DLL 
 	if ( C_BasePlayer::ShouldDrawLocalPlayer() )
 	{
 		m_pHL2MPPlayer->SetPlaybackRate( 1.0f );
 	}
 #endif
+#else
+	ComputePlaybackRate();
+#endif
 }
 
+#ifdef HL2SB
+
+void CHL2MPPlayerAnimState::ComputePlaybackRate()
+{
+	// Determine ideal playback rate
+	Vector vel;
+	GetOuterAbsVelocity( vel );
+
+	float speed = vel.Length2D();
+
+	bool isMoving = ( speed > 0.5f ) ? true : false;
+
+	float maxspeed = m_pHL2MPPlayer->GetSequenceGroundSpeed( m_pHL2MPPlayer->GetSequence() );
+	
+	if ( isMoving && ( maxspeed > 0.0f ) )
+	{
+		float flFactor = 1.0f;
+
+		// Note this gets set back to 1.0 if sequence changes due to ResetSequenceInfo below
+		m_pHL2MPPlayer->SetPlaybackRate( ( speed * flFactor ) / maxspeed );
+
+		// BUG BUG:
+		// This stuff really should be m_flPlaybackRate = speed / m_flGroundSpeed
+	}
+	else
+	{
+		m_pHL2MPPlayer->SetPlaybackRate( 1.0f );
+	}
+}
+
+#endif
 //-----------------------------------------------------------------------------
 // Purpose: 
 // Input  : event - 
@@ -543,8 +578,12 @@ void CHL2MPPlayerAnimState::ComputePoseParam_MoveYaw( CStudioHdr *pStudioHdr )
 	// view direction relative to movement
 	float flYaw;	 
 
+#ifndef HL2SB
 	QAngle	angles = GetBasePlayer()->GetLocalAngles();
 	float ang = angles[ YAW ];
+#else
+	float ang = m_flEyeYaw;
+#endif
 	if ( ang > 180.0f )
 	{
 		ang -= 360.0f;
diff --git a/src/game/shared/hl2mp/hl2mp_playeranimstate.h b/src/game/shared/hl2mp/hl2mp_playeranimstate.h
index 49a3f6a..02c7065 100644
--- a/src/game/shared/hl2mp/hl2mp_playeranimstate.h
+++ b/src/game/shared/hl2mp/hl2mp_playeranimstate.h
@@ -14,6 +14,10 @@
 #include "convar.h"
 #include "multiplayer_animstate.h"
 
+#if defined( HL2SB )
+#include "base_playeranimstate.h"
+#endif
+
 #if defined( CLIENT_DLL )
 class C_HL2MP_Player;
 #define CHL2MP_Player C_HL2MP_Player
@@ -49,6 +53,13 @@ public:
 	bool	HandleSwimming( Activity &idealActivity );
 
 	virtual float GetCurrentMaxGroundSpeed();
+#ifdef HL2SB
+protected:
+	
+	CModAnimConfig		m_AnimConfig;
+
+#endif
+
 private:
 	//Tony; temp till 9way!
 	bool						SetupPoseParameters( CStudioHdr *pStudioHdr );
@@ -56,6 +67,10 @@ private:
 	virtual void				ComputePoseParam_MoveYaw( CStudioHdr *pStudioHdr );
 	virtual void				ComputePoseParam_AimPitch( CStudioHdr *pStudioHdr );
 	virtual void				ComputePoseParam_AimYaw( CStudioHdr *pStudioHdr );
+
+#ifdef HL2SB
+	void						ComputePlaybackRate();
+#endif
 	
 	CHL2MP_Player   *m_pHL2MPPlayer;
 	bool		m_bInAirWalk;
diff --git a/src/game/shared/hl2mp/lhl2mp_player_shared.cpp b/src/game/shared/hl2mp/lhl2mp_player_shared.cpp
new file mode 100644
index 0000000..d19fff5
--- /dev/null
+++ b/src/game/shared/hl2mp/lhl2mp_player_shared.cpp
@@ -0,0 +1,255 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+#define lhl2mp_player_shared_cpp
+
+#include "cbase.h"
+
+#include "hl2mp_player_shared.h"
+
+#include "luamanager.h"
+#include "lhl2mp_player_shared.h"
+#include "lbaseentity_shared.h"
+#ifdef CLIENT_DLL
+#include "lc_baseanimating.h"
+#else
+#include "lbaseanimating.h"
+#endif
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CHL2MP_Player *lua_tohl2mpplayer (lua_State *L, int idx) {
+  CBaseHandle *hPlayer = dynamic_cast<CBaseHandle *>((CBaseHandle *)lua_touserdata(L, idx));
+  if (hPlayer == NULL)
+    return NULL;
+  return dynamic_cast<lua_CHL2MP_Player *>(hPlayer->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushhl2mpplayer (lua_State *L, CHL2MP_Player *pPlayer) {
+  CBaseHandle *hPlayer = (CBaseHandle *)lua_newuserdata(L, sizeof(CBaseHandle));
+  hPlayer->Set(pPlayer);
+  luaL_getmetatable(L, "CHL2MP_Player");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CHL2MP_Player *luaL_checkhl2mpplayer (lua_State *L, int narg) {
+  lua_CHL2MP_Player *d = lua_tohl2mpplayer(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "CHL2MP_Player expected, got NULL entity");
+  return d;
+}
+
+
+LUALIB_API lua_CHL2MP_Player *luaL_opthl2mpplayer (lua_State *L, int narg,
+                                                                 CHL2MP_Player *def) {
+  return luaL_opt(L, luaL_checkhl2mpplayer, narg, def);
+}
+
+
+static int CHL2MP_Player_BecomeRagdollOnClient (lua_State *L) {
+#ifdef CLIENT_DLL
+  lua_pushanimating(L, luaL_checkhl2mpplayer(L, 1)->BecomeRagdollOnClient());
+#else
+  lua_pushboolean(L, luaL_checkhl2mpplayer(L, 1)->BecomeRagdollOnClient(luaL_checkvector(L, 2)));
+#endif
+  return 1;
+}
+
+static int CHL2MP_Player_CalculateIKLocks (lua_State *L) {
+  luaL_checkhl2mpplayer(L, 1)->CalculateIKLocks(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CHL2MP_Player_CalcView (lua_State *L) {
+  Vector eyeOrigin;
+  QAngle eyeAngles;
+  float zNear, zFar, fov;
+  luaL_checkhl2mpplayer(L, 1)->CalcView(eyeOrigin, eyeAngles, zNear, zFar, fov);
+  lua_pushvector(L, eyeOrigin);
+  lua_pushangle(L, eyeAngles);
+  lua_pushnumber(L, zNear);
+  lua_pushnumber(L, zFar);
+  lua_pushnumber(L, fov);
+  return 5;
+}
+
+static int CHL2MP_Player_CanSprint (lua_State *L) {
+  lua_pushboolean(L, luaL_checkhl2mpplayer(L, 1)->CanSprint());
+  return 1;
+}
+
+static int CHL2MP_Player_DoAnimationEvent (lua_State *L) {
+  luaL_checkhl2mpplayer(L, 1)->DoAnimationEvent((PlayerAnimEvent_t)luaL_checkint(L, 2), luaL_optinteger(L, 3, 0));
+  return 0;
+}
+
+static int CHL2MP_Player___index (lua_State *L) {
+  CHL2MP_Player *pPlayer = lua_tohl2mpplayer(L, 1);
+  if (pPlayer == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  const char *field = luaL_checkstring(L, 2);
+#ifdef CLIENT_DLL
+  if (Q_strcmp(field, "m_fNextThinkPushAway") == 0)
+    lua_pushnumber(L, pPlayer->m_fNextThinkPushAway);
+  else {
+#endif
+    if (pPlayer->m_nTableReference != LUA_NOREF) {
+      lua_getref(L, pPlayer->m_nTableReference);
+      lua_getfield(L, -1, field);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        lua_getmetatable(L, 1);
+        lua_getfield(L, -1, field);
+        if (lua_isnil(L, -1)) {
+          lua_pop(L, 2);
+          luaL_getmetatable(L, "CBasePlayer");
+          lua_getfield(L, -1, field);
+          if (lua_isnil(L, -1)) {
+            lua_pop(L, 2);
+            luaL_getmetatable(L, "CBaseAnimating");
+            lua_getfield(L, -1, field);
+            if (lua_isnil(L, -1)) {
+              lua_pop(L, 2);
+              luaL_getmetatable(L, "CBaseEntity");
+              lua_getfield(L, -1, field);
+            }
+          }
+        }
+      }
+    }
+    else {
+      lua_getmetatable(L, 1);
+      lua_getfield(L, -1, field);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "CBasePlayer");
+        lua_getfield(L, -1, field);
+        if (lua_isnil(L, -1)) {
+          lua_pop(L, 2);
+          luaL_getmetatable(L, "CBaseAnimating");
+          lua_getfield(L, -1, field);
+          if (lua_isnil(L, -1)) {
+            lua_pop(L, 2);
+            luaL_getmetatable(L, "CBaseEntity");
+            lua_getfield(L, -1, field);
+          }
+        }
+      }
+    }
+#ifdef CLIENT_DLL
+  }
+#endif
+  return 1;
+}
+
+static int CHL2MP_Player___newindex (lua_State *L) {
+  CHL2MP_Player *pPlayer = lua_tohl2mpplayer(L, 1);
+  if (pPlayer == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  const char *field = luaL_checkstring(L, 2);
+#ifdef CLIENT_DLL
+  if (Q_strcmp(field, "m_fNextThinkPushAway") == 0)
+    pPlayer->m_fNextThinkPushAway = luaL_checknumber(L, 3);
+  else {
+#endif
+    if (pPlayer->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      pPlayer->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, pPlayer->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, field);
+	lua_pop(L, 1);
+#ifdef CLIENT_DLL
+  }
+#endif
+  return 0;
+}
+
+static int CHL2MP_Player___eq (lua_State *L) {
+  lua_pushboolean(L, lua_tohl2mpplayer(L, 1) == lua_tohl2mpplayer(L, 2));
+  return 1;
+}
+
+static int CHL2MP_Player___tostring (lua_State *L) {
+  CHL2MP_Player *pPlayer = lua_tohl2mpplayer(L, 1);
+  if (pPlayer == NULL)
+    lua_pushstring(L, "NULL");
+  else
+    lua_pushfstring(L, "CHL2MP_Player: %d \"%s\"", pPlayer->GetUserID(), pPlayer->GetPlayerName());
+  return 1;
+}
+
+
+static const luaL_Reg CHL2MP_Playermeta[] = {
+  {"BecomeRagdollOnClient", CHL2MP_Player_BecomeRagdollOnClient},
+  {"CalculateIKLocks", CHL2MP_Player_CalculateIKLocks},
+  {"CalcView", CHL2MP_Player_CalcView},
+  {"CanSprint", CHL2MP_Player_CanSprint},
+  {"DoAnimationEvent", CHL2MP_Player_DoAnimationEvent},
+  {"__index", CHL2MP_Player___index},
+  {"__newindex", CHL2MP_Player___newindex},
+  {"__eq", CHL2MP_Player___eq},
+  {"__tostring", CHL2MP_Player___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_ToHL2MPPlayer (lua_State *L) {
+  lua_pushhl2mpplayer(L, ToHL2MPPlayer(lua_toentity(L, 1)));
+  return 1;
+}
+
+
+static const luaL_Reg CHL2MP_Player_funcs[] = {
+  {"ToHL2MPPlayer", luasrc_ToHL2MPPlayer},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CHL2MP_Player object
+*/
+LUALIB_API int luaopen_CHL2MP_Player_shared (lua_State *L) {
+  luaL_newmetatable(L, "CHL2MP_Player");
+  luaL_register(L, NULL, CHL2MP_Playermeta);
+  lua_pushstring(L, "entity");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "entity" */
+  luaL_register(L, "_G", CHL2MP_Player_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
diff --git a/src/game/shared/hl2mp/lhl2mp_player_shared.h b/src/game/shared/hl2mp/lhl2mp_player_shared.h
new file mode 100644
index 0000000..3155c33
--- /dev/null
+++ b/src/game/shared/hl2mp/lhl2mp_player_shared.h
@@ -0,0 +1,42 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+#ifndef LHL2MP_PLAYER_SHARED_H
+#define LHL2MP_PLAYER_SHARED_H
+#pragma once
+
+#ifdef CLIENT_DLL
+	#include "c_hl2mp_player.h"
+#else
+	#include "hl2mp_player.h"
+#endif
+
+/* type for CHL2MP_Player functions */
+typedef CHL2MP_Player lua_CHL2MP_Player;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CHL2MP_Player     *(lua_tohl2mpplayer) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushhl2mpplayer) (lua_State *L, lua_CHL2MP_Player *pPlayer);
+
+
+
+LUALIB_API lua_CHL2MP_Player *(luaL_checkhl2mpplayer) (lua_State *L, int narg);
+LUALIB_API lua_CHL2MP_Player *(luaL_opthl2mpplayer) (lua_State *L, int narg,
+                                                                   lua_CHL2MP_Player *def);
+
+
+#endif //LHL2MP_PLAYER_SHARED_h
diff --git a/src/game/shared/hl2mp/weapon_ar2.cpp b/src/game/shared/hl2mp/weapon_ar2.cpp
index a8e8d1d..5e6f044 100644
--- a/src/game/shared/hl2mp/weapon_ar2.cpp
+++ b/src/game/shared/hl2mp/weapon_ar2.cpp
@@ -20,6 +20,14 @@
 #include "weapon_ar2.h"
 #include "effect_dispatch_data.h"
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+#include "npc_combine.h"
+#include "rumble_shared.h"
+#include "gamestats.h"
+#endif
+#endif
+
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
@@ -61,6 +69,57 @@ acttable_t	CWeaponAR2::m_acttable[] =
 	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_AR2,		false },
 
 	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_AR2,					false },
+
+#ifdef HL2SB
+	{ ACT_RANGE_ATTACK1,			ACT_RANGE_ATTACK_AR2,			true },
+	{ ACT_RELOAD,					ACT_RELOAD_SMG1,				true },		// FIXME: hook to AR2 unique
+	{ ACT_IDLE,						ACT_IDLE_SMG1,					true },		// FIXME: hook to AR2 unique
+	{ ACT_IDLE_ANGRY,				ACT_IDLE_ANGRY_SMG1,			true },		// FIXME: hook to AR2 unique
+
+	{ ACT_WALK,						ACT_WALK_RIFLE,					true },
+
+// Readiness activities (not aiming)
+	{ ACT_IDLE_RELAXED,				ACT_IDLE_SMG1_RELAXED,			false },//never aims
+	{ ACT_IDLE_STIMULATED,			ACT_IDLE_SMG1_STIMULATED,		false },
+	{ ACT_IDLE_AGITATED,			ACT_IDLE_ANGRY_SMG1,			false },//always aims
+
+	{ ACT_WALK_RELAXED,				ACT_WALK_RIFLE_RELAXED,			false },//never aims
+	{ ACT_WALK_STIMULATED,			ACT_WALK_RIFLE_STIMULATED,		false },
+	{ ACT_WALK_AGITATED,			ACT_WALK_AIM_RIFLE,				false },//always aims
+
+	{ ACT_RUN_RELAXED,				ACT_RUN_RIFLE_RELAXED,			false },//never aims
+	{ ACT_RUN_STIMULATED,			ACT_RUN_RIFLE_STIMULATED,		false },
+	{ ACT_RUN_AGITATED,				ACT_RUN_AIM_RIFLE,				false },//always aims
+
+// Readiness activities (aiming)
+	{ ACT_IDLE_AIM_RELAXED,			ACT_IDLE_SMG1_RELAXED,			false },//never aims	
+	{ ACT_IDLE_AIM_STIMULATED,		ACT_IDLE_AIM_RIFLE_STIMULATED,	false },
+	{ ACT_IDLE_AIM_AGITATED,		ACT_IDLE_ANGRY_SMG1,			false },//always aims
+
+	{ ACT_WALK_AIM_RELAXED,			ACT_WALK_RIFLE_RELAXED,			false },//never aims
+	{ ACT_WALK_AIM_STIMULATED,		ACT_WALK_AIM_RIFLE_STIMULATED,	false },
+	{ ACT_WALK_AIM_AGITATED,		ACT_WALK_AIM_RIFLE,				false },//always aims
+
+	{ ACT_RUN_AIM_RELAXED,			ACT_RUN_RIFLE_RELAXED,			false },//never aims
+	{ ACT_RUN_AIM_STIMULATED,		ACT_RUN_AIM_RIFLE_STIMULATED,	false },
+	{ ACT_RUN_AIM_AGITATED,			ACT_RUN_AIM_RIFLE,				false },//always aims
+//End readiness activities
+
+	{ ACT_WALK_AIM,					ACT_WALK_AIM_RIFLE,				true },
+	{ ACT_WALK_CROUCH,				ACT_WALK_CROUCH_RIFLE,			true },
+	{ ACT_WALK_CROUCH_AIM,			ACT_WALK_CROUCH_AIM_RIFLE,		true },
+	{ ACT_RUN,						ACT_RUN_RIFLE,					true },
+	{ ACT_RUN_AIM,					ACT_RUN_AIM_RIFLE,				true },
+	{ ACT_RUN_CROUCH,				ACT_RUN_CROUCH_RIFLE,			true },
+	{ ACT_RUN_CROUCH_AIM,			ACT_RUN_CROUCH_AIM_RIFLE,		true },
+	{ ACT_GESTURE_RANGE_ATTACK1,	ACT_GESTURE_RANGE_ATTACK_AR2,	false },
+	{ ACT_COVER_LOW,				ACT_COVER_SMG1_LOW,				false },		// FIXME: hook to AR2 unique
+	{ ACT_RANGE_AIM_LOW,			ACT_RANGE_AIM_AR2_LOW,			false },
+	{ ACT_RANGE_ATTACK1_LOW,		ACT_RANGE_ATTACK_SMG1_LOW,		true },		// FIXME: hook to AR2 unique
+	{ ACT_RELOAD_LOW,				ACT_RELOAD_SMG1_LOW,			false },
+	{ ACT_GESTURE_RELOAD,			ACT_GESTURE_RELOAD_SMG1,		true },
+//	{ ACT_RANGE_ATTACK2, ACT_RANGE_ATTACK_AR2_GRENADE, true },
+#endif
 };
 
 IMPLEMENT_ACTTABLE(CWeaponAR2);
@@ -75,6 +134,10 @@ CWeaponAR2::CWeaponAR2( )
 
 	m_nShotsFired	= 0;
 	m_nVentPose		= -1;
+
+#ifdef HL2SB
+	m_bAltFiresUnderwater = false;
+#endif
 }
 
 void CWeaponAR2::Precache( void )
@@ -175,9 +238,20 @@ void CWeaponAR2::DelayedAttack( void )
 
 	// Register a muzzleflash for the AI
 	pOwner->DoMuzzleFlash();
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	pOwner->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
+#endif
+#endif
 	
 	WeaponSound( WPN_DOUBLE );
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	pOwner->RumbleEffect(RUMBLE_SHOTGUN_DOUBLE, 0, RUMBLE_FLAG_RESTART );
+#endif
+#endif
+
 	// Fire the bullets
 	Vector vecSrc	 = pOwner->Weapon_ShootPosition( );
 	Vector vecAiming = pOwner->GetAutoaimVector( AUTOAIM_2DEGREES );
@@ -241,8 +315,24 @@ void CWeaponAR2::SecondaryAttack( void )
 	m_bShotDelayed = true;
 	m_flNextPrimaryAttack = m_flNextSecondaryAttack = m_flDelayedFire = gpGlobals->curtime + 0.5f;
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+	if( pPlayer )
+	{
+		pPlayer->RumbleEffect(RUMBLE_AR2_ALT_FIRE, 0, RUMBLE_FLAG_RESTART );
+	}
+#endif
+#endif
+
 	SendWeaponAnim( ACT_VM_FIDGET );
 	WeaponSound( SPECIAL1 );
+
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	gamestats->Event_WeaponFired( pPlayer, false, GetClassname() );
+#endif
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -277,6 +367,158 @@ bool CWeaponAR2::Reload( void )
 	return BaseClass::Reload();
 }
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : *pOperator - 
+//-----------------------------------------------------------------------------
+void CWeaponAR2::FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles )
+{
+	Vector vecShootOrigin, vecShootDir;
+
+	CAI_BaseNPC *npc = pOperator->MyNPCPointer();
+	ASSERT( npc != NULL );
+
+	if ( bUseWeaponAngles )
+	{
+		QAngle	angShootDir;
+		GetAttachment( LookupAttachment( "muzzle" ), vecShootOrigin, angShootDir );
+		AngleVectors( angShootDir, &vecShootDir );
+	}
+	else 
+	{
+		vecShootOrigin = pOperator->Weapon_ShootPosition();
+		vecShootDir = npc->GetActualShootTrajectory( vecShootOrigin );
+	}
+
+	WeaponSoundRealtime( SINGLE_NPC );
+
+	CSoundEnt::InsertSound( SOUND_COMBAT|SOUND_CONTEXT_GUNFIRE, pOperator->GetAbsOrigin(), SOUNDENT_VOLUME_MACHINEGUN, 0.2, pOperator, SOUNDENT_CHANNEL_WEAPON, pOperator->GetEnemy() );
+
+	pOperator->FireBullets( 1, vecShootOrigin, vecShootDir, VECTOR_CONE_PRECALCULATED, MAX_TRACE_LENGTH, m_iPrimaryAmmoType, 2 );
+
+	// NOTENOTE: This is overriden on the client-side
+	// pOperator->DoMuzzleFlash();
+
+	m_iClip1 = m_iClip1 - 1;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CWeaponAR2::FireNPCSecondaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles )
+{
+	WeaponSound( WPN_DOUBLE );
+
+	if ( !GetOwner() )
+		return;
+		
+	CAI_BaseNPC *pNPC = GetOwner()->MyNPCPointer();
+	if ( !pNPC )
+		return;
+	
+	// Fire!
+	Vector vecSrc;
+	Vector vecAiming;
+
+	if ( bUseWeaponAngles )
+	{
+		QAngle	angShootDir;
+		GetAttachment( LookupAttachment( "muzzle" ), vecSrc, angShootDir );
+		AngleVectors( angShootDir, &vecAiming );
+	}
+	else 
+	{
+		vecSrc = pNPC->Weapon_ShootPosition( );
+		
+		Vector vecTarget;
+
+		CNPC_Combine *pSoldier = dynamic_cast<CNPC_Combine *>( pNPC );
+		if ( pSoldier )
+		{
+			// In the distant misty past, elite soldiers tried to use bank shots.
+			// Therefore, we must ask them specifically what direction they are shooting.
+			vecTarget = pSoldier->GetAltFireTarget();
+		}
+		else
+		{
+			// All other users of the AR2 alt-fire shoot directly at their enemy.
+			if ( !pNPC->GetEnemy() )
+				return;
+				
+			vecTarget = pNPC->GetEnemy()->BodyTarget( vecSrc );
+		}
+
+		vecAiming = vecTarget - vecSrc;
+		VectorNormalize( vecAiming );
+	}
+
+	Vector impactPoint = vecSrc + ( vecAiming * MAX_TRACE_LENGTH );
+
+	float flAmmoRatio = 1.0f;
+	float flDuration = RemapValClamped( flAmmoRatio, 0.0f, 1.0f, 0.5f, sk_weapon_ar2_alt_fire_duration.GetFloat() );
+	float flRadius = RemapValClamped( flAmmoRatio, 0.0f, 1.0f, 4.0f, sk_weapon_ar2_alt_fire_radius.GetFloat() );
+
+	// Fire the bullets
+	Vector vecVelocity = vecAiming * 1000.0f;
+
+	// Fire the combine ball
+	CreateCombineBall(	vecSrc, 
+		vecVelocity, 
+		flRadius, 
+		sk_weapon_ar2_alt_fire_mass.GetFloat(),
+		flDuration,
+		pNPC );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CWeaponAR2::Operator_ForceNPCFire( CBaseCombatCharacter *pOperator, bool bSecondary )
+{
+	if ( bSecondary )
+	{
+		FireNPCSecondaryAttack( pOperator, true );
+	}
+	else
+	{
+		// Ensure we have enough rounds in the clip
+		m_iClip1++;
+
+		FireNPCPrimaryAttack( pOperator, true );
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : *pEvent - 
+//			*pOperator - 
+//-----------------------------------------------------------------------------
+void CWeaponAR2::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator )
+{
+	switch( pEvent->event )
+	{ 
+		case EVENT_WEAPON_AR2:
+			{
+				FireNPCPrimaryAttack( pOperator, false );
+			}
+			break;
+
+		case EVENT_WEAPON_AR2_ALTFIRE:
+			{
+				FireNPCSecondaryAttack( pOperator, false );
+			}
+			break;
+
+		default:
+			CBaseCombatWeapon::Operator_HandleAnimEvent( pEvent, pOperator );
+			break;
+	}
+}
+#endif
+#endif
+
 //-----------------------------------------------------------------------------
 // Purpose: 
 //-----------------------------------------------------------------------------
@@ -292,7 +534,24 @@ void CWeaponAR2::AddViewKick( void )
 	if (!pPlayer)
 		return;
 
+#ifndef HL2SB
 	DoMachineGunKick( pPlayer, EASY_DAMPEN, MAX_VERTICAL_KICK, m_fFireDuration, SLIDE_LIMIT );
+#else
+	float flDuration = m_fFireDuration;
+
+#ifndef CLIENT_DLL
+	if( g_pGameRules->GetAutoAimMode() == AUTOAIM_ON_CONSOLE )
+	{
+		// On the 360 (or in any configuration using the 360 aiming scheme), don't let the
+		// AR2 progressive into the late, highly inaccurate stages of its kick. Just
+		// spoof the time to make it look (to the kicking code) like we haven't been
+		// firing for very long.
+		flDuration = min( flDuration, 0.75f );
+	}
+#endif
+
+	DoMachineGunKick( pPlayer, EASY_DAMPEN, MAX_VERTICAL_KICK, flDuration, SLIDE_LIMIT );
+#endif
 }
 
 //-----------------------------------------------------------------------------
diff --git a/src/game/shared/hl2mp/weapon_ar2.h b/src/game/shared/hl2mp/weapon_ar2.h
index bc6751c..e8dc6f9 100644
--- a/src/game/shared/hl2mp/weapon_ar2.h
+++ b/src/game/shared/hl2mp/weapon_ar2.h
@@ -41,6 +41,15 @@ public:
 
 	void	AddViewKick( void );
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	void	FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles );
+	void	FireNPCSecondaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles );
+	void	Operator_ForceNPCFire( CBaseCombatCharacter  *pOperator, bool bSecondary );
+	void	Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator );
+#endif
+#endif
+
 	int		GetMinBurst( void ) { return 2; }
 	int		GetMaxBurst( void ) { return 5; }
 	float	GetFireRate( void ) { return 0.1f; }
@@ -48,6 +57,12 @@ public:
 	bool	CanHolster( void );
 	bool	Reload( void );
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	int		CapabilitiesGet( void ) { return bits_CAP_WEAPON_RANGE_ATTACK1; }
+#endif
+#endif
+
 	Activity	GetPrimaryAttackActivity( void );
 	
 	void	DoImpactEffect( trace_t &tr, int nDamageType );
diff --git a/src/game/shared/hl2mp/weapon_crowbar.cpp b/src/game/shared/hl2mp/weapon_crowbar.cpp
index 155d9d7..7028bd1 100644
--- a/src/game/shared/hl2mp/weapon_crowbar.cpp
+++ b/src/game/shared/hl2mp/weapon_crowbar.cpp
@@ -30,6 +30,11 @@
 #define	CROWBAR_REFIRE	0.4f
 
 
+#ifdef HL2SB
+ConVar    sk_plr_dmg_crowbar		( "sk_plr_dmg_crowbar","0",FCVAR_REPLICATED );
+ConVar    sk_npc_dmg_crowbar		( "sk_npc_dmg_crowbar","0",FCVAR_REPLICATED );
+#endif
+
 //-----------------------------------------------------------------------------
 // CWeaponCrowbar
 //-----------------------------------------------------------------------------
diff --git a/src/game/shared/hl2mp/weapon_hl2mpbase.h b/src/game/shared/hl2mp/weapon_hl2mpbase.h
index 1f09733..19f9c5e 100644
--- a/src/game/shared/hl2mp/weapon_hl2mpbase.h
+++ b/src/game/shared/hl2mp/weapon_hl2mpbase.h
@@ -13,6 +13,12 @@
 #include "hl2mp_player_shared.h"
 #include "basecombatweapon_shared.h"
 #include "hl2mp_weapon_parse.h"
+#if defined( HL2SB )
+//Andrew; see https://developer.valvesoftware.com/wiki/Fixing_AI_in_multiplayer#Weapons
+#ifndef CLIENT_DLL
+	#include "AI_BaseNPC.h"
+#endif
+#endif
 
 #if defined( CLIENT_DLL )
 	#define CWeaponHL2MPBase C_WeaponHL2MPBase
diff --git a/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.h b/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.h
index 74645ad..b490a96 100644
--- a/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.h
+++ b/src/game/shared/hl2mp/weapon_hl2mpbase_machinegun.h
@@ -4,7 +4,11 @@
 //
 //=============================================================================//
 
+#if !defined( HL2SB )
 #include "weapon_hl2mpbase.h"
+#else
+#include "weapon_hl2mpbasehlmpcombatweapon.h"
+#endif
 
 #ifndef BASEHLCOMBATWEAPON_H
 #define BASEHLCOMBATWEAPON_H
@@ -19,7 +23,11 @@
 //=========================================================
 // Machine gun base class
 //=========================================================
+#if !defined( HL2SB )
 class CHL2MPMachineGun : public CWeaponHL2MPBase
+#else
+class CHL2MPMachineGun : public CBaseHL2MPCombatWeapon
+#endif
 {
 public:
 	DECLARE_CLASS( CHL2MPMachineGun, CWeaponHL2MPBase );
diff --git a/src/game/shared/hl2mp/weapon_hl2mpbase_scriptedweapon.cpp b/src/game/shared/hl2mp/weapon_hl2mpbase_scriptedweapon.cpp
new file mode 100644
index 0000000..ef1260e
--- /dev/null
+++ b/src/game/shared/hl2mp/weapon_hl2mpbase_scriptedweapon.cpp
@@ -0,0 +1,1022 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+//=============================================================================//
+
+#include "cbase.h"
+
+#if defined( CLIENT_DLL )
+	#include "c_hl2mp_player.h"
+#else
+	#include "hl2mp_player.h"
+#endif
+
+#include "weapon_hl2mpbase_scriptedweapon.h"
+#include "in_buttons.h"
+#include "ammodef.h"
+#include "luamanager.h"
+#include "lbasecombatweapon_shared.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+IMPLEMENT_NETWORKCLASS_ALIASED( HL2MPScriptedWeapon, DT_HL2MPScriptedWeapon )
+
+BEGIN_NETWORK_TABLE( CHL2MPScriptedWeapon, DT_HL2MPScriptedWeapon )
+#ifdef CLIENT_DLL
+	RecvPropString( RECVINFO( m_iScriptedClassname ) ),
+#else
+	SendPropString( SENDINFO( m_iScriptedClassname ) ),
+#endif
+END_NETWORK_TABLE()
+
+BEGIN_PREDICTION_DATA( CHL2MPScriptedWeapon )
+END_PREDICTION_DATA()
+
+//=========================================================
+//	>> CHLSelectFireScriptedWeapon
+//=========================================================
+BEGIN_DATADESC( CHL2MPScriptedWeapon )
+END_DATADESC()
+
+
+
+// LINK_ENTITY_TO_CLASS( weapon_hl2mpbase_scriptedweapon, CHL2MPScriptedWeapon );
+// PRECACHE_WEAPON_REGISTER( weapon_hl2mpbase_scriptedweapon );
+
+// These functions replace the macros above for runtime registration of
+// scripted weapons.
+#ifdef CLIENT_DLL
+static C_BaseEntity *CCHL2MPScriptedWeaponFactory( void )
+{
+	return static_cast< C_BaseEntity * >( new CHL2MPScriptedWeapon );
+};
+#endif
+
+#ifndef CLIENT_DLL
+static CUtlDict< CEntityFactory<CHL2MPScriptedWeapon>*, unsigned short > m_WeaponFactoryDatabase;
+#endif
+
+void RegisterScriptedWeapon( const char *className )
+{
+#ifdef CLIENT_DLL
+	if ( GetClassMap().FindFactory( className ) )
+	{
+		return;
+	}
+
+	GetClassMap().Add( className, "CHL2MPScriptedWeapon", sizeof( CHL2MPScriptedWeapon ),
+		&CCHL2MPScriptedWeaponFactory, true );
+#else
+	if ( EntityFactoryDictionary()->FindFactory( className ) )
+	{
+		return;
+	}
+
+	unsigned short lookup = m_WeaponFactoryDatabase.Find( className );
+	if ( lookup != m_WeaponFactoryDatabase.InvalidIndex() )
+	{
+		return;
+	}
+
+	// Andrew; This fixes months worth of pain and anguish.
+	CEntityFactory<CHL2MPScriptedWeapon> *pFactory = new CEntityFactory<CHL2MPScriptedWeapon>( className );
+
+	lookup = m_WeaponFactoryDatabase.Insert( className, pFactory );
+	Assert( lookup != m_WeaponFactoryDatabase.InvalidIndex() );
+#endif
+	// BUGBUG: When attempting to precache weapons registered during runtime,
+	// they don't appear as valid registered entities.
+	// static CPrecacheRegister precache_weapon_(&CPrecacheRegister::PrecacheFn_Other, className);
+}
+
+void ResetWeaponFactoryDatabase( void )
+{
+#ifdef CLIENT_DLL
+#ifdef LUA_SDK
+	GetClassMap().RemoveAllScripted();
+#endif
+#else
+	for ( int i=m_WeaponFactoryDatabase.First(); i != m_WeaponFactoryDatabase.InvalidIndex(); i=m_WeaponFactoryDatabase.Next( i ) )
+	{
+		delete m_WeaponFactoryDatabase[ i ];
+	}
+	m_WeaponFactoryDatabase.RemoveAll();
+#endif
+}
+
+
+// acttable_t CHL2MPScriptedWeapon::m_acttable[] = 
+// {
+// 	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PISTOL,					false },
+// 	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PISTOL,			false },
+// 
+// 	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PISTOL,					false },
+// 	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PISTOL,			false },
+// 
+// 	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,	false },
+// 	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,	false },
+// 
+// 	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
+// 	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
+// 
+// 	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PISTOL,					false },
+// };
+
+// IMPLEMENT_ACTTABLE( CHL2MPScriptedWeapon );
+
+// These functions serve as skeletons for the our weapons' actions to be
+// implemented in Lua.
+acttable_t *CHL2MPScriptedWeapon::ActivityList( void ) {
+#ifdef LUA_SDK
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "m_acttable" );
+	lua_remove( L, -2 );
+	if ( lua_istable( L, -1 ) )
+	{
+		for( int i = 0 ; i < LUA_MAX_WEAPON_ACTIVITIES ; i++ )
+		{
+			lua_pushinteger( L, i );
+			lua_gettable( L, -2 );
+			if ( lua_istable( L, -1 ) )
+			{
+				m_acttable[i].baseAct = ACT_INVALID;
+				lua_pushinteger( L, 1 );
+				lua_gettable( L, -2 );
+				if ( lua_isnumber( L, -1 ) )
+					m_acttable[i].baseAct = lua_tointeger( L, -1 );
+				lua_pop( L, 1 );
+
+				m_acttable[i].weaponAct = ACT_INVALID;
+				lua_pushinteger( L, 2 );
+				lua_gettable( L, -2 );
+				if ( lua_isnumber( L, -1 ) )
+					m_acttable[i].weaponAct = lua_tointeger( L, -1 );
+				lua_pop( L, 1 );
+
+				m_acttable[i].required = false;
+				lua_pushinteger( L, 3 );
+				lua_gettable( L, -2 );
+				if ( lua_isboolean( L, -1 ) )
+					m_acttable[i].required = (bool)lua_toboolean( L, -1 );
+				lua_pop( L, 1 );
+			}
+			lua_pop( L, 1 );
+		}
+	}
+	lua_pop( L, 1 );
+#endif
+	return m_acttable;
+}
+int CHL2MPScriptedWeapon::ActivityListCount( void ) { return LUA_MAX_WEAPON_ACTIVITIES; }
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+CHL2MPScriptedWeapon::CHL2MPScriptedWeapon( void )
+{
+	m_pLuaWeaponInfo = dynamic_cast< CHL2MPSWeaponInfo* >( CreateWeaponInfo() );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+CHL2MPScriptedWeapon::~CHL2MPScriptedWeapon( void )
+{
+	delete m_pLuaWeaponInfo;
+	// Andrew; This is actually done in CBaseEntity. I'm doing it here because
+	// this is the class that initialized the reference.
+#ifdef LUA_SDK
+	lua_unref( L, m_nTableReference );
+#endif
+}
+
+extern const char *pWeaponSoundCategories[ NUM_SHOOT_SOUND_TYPES ];
+
+#ifdef CLIENT_DLL
+extern ConVar hud_fastswitch;
+#endif
+
+void CHL2MPScriptedWeapon::InitScriptedWeapon( void )
+{
+#if defined ( LUA_SDK )
+#ifndef CLIENT_DLL
+	// Let the instance reinitialize itself for the client.
+	if ( m_nTableReference != LUA_NOREF )
+		return;
+#endif
+
+	char className[ MAX_WEAPON_STRING ];
+#if defined ( CLIENT_DLL )
+	if ( strlen( GetScriptedClassname() ) > 0 )
+		Q_strncpy( className, GetScriptedClassname(), sizeof( className ) );
+	else
+		Q_strncpy( className, GetClassname(), sizeof( className ) );
+#else
+	Q_strncpy( m_iScriptedClassname.GetForModify(), GetClassname(), sizeof( className ) );
+ 	Q_strncpy( className, GetClassname(), sizeof( className ) );
+#endif
+ 	Q_strlower( className );
+	// Andrew; This redundancy is pretty annoying.
+	// Classname
+	Q_strncpy( m_pLuaWeaponInfo->szClassName, className, MAX_WEAPON_STRING );
+	SetClassname( className );
+
+	lua_getglobal( L, "weapon" );
+	if ( lua_istable( L, -1 ) )
+	{
+		lua_getfield( L, -1, "get" );
+		if ( lua_isfunction( L, -1 ) )
+		{
+			lua_remove( L, -2 );
+			lua_pushstring( L, className );
+			luasrc_pcall( L, 1, 1, 0 );
+		}
+		else
+		{
+			lua_pop( L, 2 );
+		}
+	}
+	else
+	{
+		lua_pop( L, 1 );
+	}
+
+	m_nTableReference = luaL_ref( L, LUA_REGISTRYINDEX );
+#ifndef CLIENT_DLL
+	m_pLuaWeaponInfo->bParsedScript = true;
+#endif
+
+	// Printable name
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "printname" );
+	lua_remove( L, -2 );
+	if ( lua_isstring( L, -1 ) )
+	{
+		Q_strncpy( m_pLuaWeaponInfo->szPrintName, lua_tostring( L, -1 ), MAX_WEAPON_STRING );
+	}
+	else
+	{
+		Q_strncpy( m_pLuaWeaponInfo->szPrintName, WEAPON_PRINTNAME_MISSING, MAX_WEAPON_STRING );
+	}
+	lua_pop( L, 1 );
+	// View model & world model
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "viewmodel" );
+	lua_remove( L, -2 );
+	if ( lua_isstring( L, -1 ) )
+	{
+		Q_strncpy( m_pLuaWeaponInfo->szViewModel, lua_tostring( L, -1 ), MAX_WEAPON_STRING );
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "playermodel" );
+	lua_remove( L, -2 );
+	if ( lua_isstring( L, -1 ) )
+	{
+		Q_strncpy( m_pLuaWeaponInfo->szWorldModel, lua_tostring( L, -1 ), MAX_WEAPON_STRING );
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "anim_prefix" );
+	lua_remove( L, -2 );
+	if ( lua_isstring( L, -1 ) )
+	{
+		Q_strncpy( m_pLuaWeaponInfo->szAnimationPrefix, lua_tostring( L, -1 ), MAX_WEAPON_PREFIX );
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "bucket" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->iSlot = lua_tonumber( L, -1 );
+	}
+	else
+	{
+		m_pLuaWeaponInfo->iSlot = 0;
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "bucket_position" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->iPosition = lua_tonumber( L, -1 );
+	}
+	else
+	{
+		m_pLuaWeaponInfo->iPosition = 0;
+	}
+	lua_pop( L, 1 );
+
+	// Use the console (X360) buckets if hud_fastswitch is set to 2.
+#ifdef CLIENT_DLL
+	if ( hud_fastswitch.GetInt() == 2 )
+#else
+	if ( IsX360() )
+#endif
+	{
+		lua_getref( L, m_nTableReference );
+		lua_getfield( L, -1, "bucket_360" );
+		lua_remove( L, -2 );
+		if ( lua_isnumber( L, -1 ) )
+		{
+			m_pLuaWeaponInfo->iSlot = lua_tonumber( L, -1 );
+		}
+		lua_pop( L, 1 );
+		lua_getref( L, m_nTableReference );
+		lua_getfield( L, -1, "bucket_position_360" );
+		lua_remove( L, -2 );
+		if ( lua_isnumber( L, -1 ) )
+		{
+			m_pLuaWeaponInfo->iPosition = lua_tonumber( L, -1 );
+		}
+		lua_pop( L, 1 );
+	}
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "clip_size" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->iMaxClip1 = lua_tonumber( L, -1 );					// Max primary clips gun can hold (assume they don't use clips by default)
+	}
+	else
+	{
+		m_pLuaWeaponInfo->iMaxClip1 = WEAPON_NOCLIP;
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "clip2_size" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->iMaxClip2 = lua_tonumber( L, -1 );					// Max secondary clips gun can hold (assume they don't use clips by default)
+	}
+	else
+	{
+		m_pLuaWeaponInfo->iMaxClip2 = WEAPON_NOCLIP;
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "default_clip" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->iDefaultClip1 = lua_tonumber( L, -1 );		// amount of primary ammo placed in the primary clip when it's picked up
+	}
+	else
+	{
+		m_pLuaWeaponInfo->iDefaultClip1 = m_pLuaWeaponInfo->iMaxClip1;
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "default_clip2" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->iDefaultClip2 = lua_tonumber( L, -1 );		// amount of secondary ammo placed in the secondary clip when it's picked up
+	}
+	else
+	{
+		m_pLuaWeaponInfo->iDefaultClip2 = m_pLuaWeaponInfo->iMaxClip2;
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "weight" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->iWeight = lua_tonumber( L, -1 );
+	}
+	else
+	{
+		m_pLuaWeaponInfo->iWeight = 0;
+	}
+	lua_pop( L, 1 );
+
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "rumble" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->iWeight = lua_tonumber( L, -1 );
+	}
+	else
+	{
+		m_pLuaWeaponInfo->iWeight = -1;
+	}
+	lua_pop( L, 1 );
+	
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "showusagehint" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->bShowUsageHint = (int)lua_tointeger( L, -1 ) != 0 ? true : false;
+	}
+	else
+	{
+		m_pLuaWeaponInfo->bShowUsageHint = false;
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "autoswitchto" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->bAutoSwitchTo = (int)lua_tointeger( L, -1 ) != 0 ? true : false;
+	}
+	else
+	{
+		m_pLuaWeaponInfo->bAutoSwitchTo = true;
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "autoswitchfrom" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->bAutoSwitchFrom = (int)lua_tointeger( L, -1 ) != 0 ? true : false;
+	}
+	else
+	{
+		m_pLuaWeaponInfo->bAutoSwitchFrom = true;
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "BuiltRightHanded" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->m_bBuiltRightHanded = (int)lua_tointeger( L, -1 ) != 0 ? true : false;
+	}
+	else
+	{
+		m_pLuaWeaponInfo->m_bBuiltRightHanded = true;
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "AllowFlipping" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->m_bAllowFlipping = (int)lua_tointeger( L, -1 ) != 0 ? true : false;
+	}
+	else
+	{
+		m_pLuaWeaponInfo->m_bAllowFlipping = true;
+	}
+	lua_pop( L, 1 );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "MeleeWeapon" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->m_bMeleeWeapon = (int)lua_tointeger( L, -1 ) != 0 ? true : false;
+	}
+	else
+	{
+		m_pLuaWeaponInfo->m_bMeleeWeapon = false;
+	}
+	lua_pop( L, 1 );
+
+	// Primary ammo used
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "primary_ammo" );
+	lua_remove( L, -2 );
+	if ( lua_isstring( L, -1 ) )
+	{
+		const char *pAmmo = lua_tostring( L, -1 );
+		if ( strcmp("None", pAmmo) == 0 )
+			Q_strncpy( m_pLuaWeaponInfo->szAmmo1, "", sizeof( m_pLuaWeaponInfo->szAmmo1 ) );
+		else
+			Q_strncpy( m_pLuaWeaponInfo->szAmmo1, pAmmo, sizeof( m_pLuaWeaponInfo->szAmmo1 )  );
+		m_pLuaWeaponInfo->iAmmoType = GetAmmoDef()->Index( m_pLuaWeaponInfo->szAmmo1 );
+	}
+	lua_pop( L, 1 );
+	
+	// Secondary ammo used
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "secondary_ammo" );
+	lua_remove( L, -2 );
+	if ( lua_isstring( L, -1 ) )
+	{
+		const char *pAmmo = lua_tostring( L, -1 );
+		if ( strcmp("None", pAmmo) == 0)
+			Q_strncpy( m_pLuaWeaponInfo->szAmmo2, "", sizeof( m_pLuaWeaponInfo->szAmmo2 ) );
+		else
+			Q_strncpy( m_pLuaWeaponInfo->szAmmo2, pAmmo, sizeof( m_pLuaWeaponInfo->szAmmo2 )  );
+		m_pLuaWeaponInfo->iAmmo2Type = GetAmmoDef()->Index( m_pLuaWeaponInfo->szAmmo2 );
+	}
+	lua_pop( L, 1 );
+
+	// Now read the weapon sounds
+	memset( m_pLuaWeaponInfo->aShootSounds, 0, sizeof( m_pLuaWeaponInfo->aShootSounds ) );
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "SoundData" );
+	lua_remove( L, -2 );
+	if ( lua_istable( L, -1 ) )
+	{
+		for ( int i = EMPTY; i < NUM_SHOOT_SOUND_TYPES; i++ )
+		{
+			lua_getfield( L, -1, pWeaponSoundCategories[i] );
+			if ( lua_isstring( L, -1 ) )
+			{
+				const char *soundname = lua_tostring( L, -1 );
+				if ( soundname && soundname[0] )
+				{
+					Q_strncpy( m_pLuaWeaponInfo->aShootSounds[i], soundname, MAX_WEAPON_STRING );
+				}
+			}
+			lua_pop( L, 1 );
+		}
+	}
+	lua_pop( L, 1 );
+
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "damage" );
+	lua_remove( L, -2 );
+	if ( lua_isnumber( L, -1 ) )
+	{
+		m_pLuaWeaponInfo->m_iPlayerDamage = (int)lua_tointeger( L, -1 );
+	}
+	lua_pop( L, 1 );
+
+	BEGIN_LUA_CALL_WEAPON_METHOD( "Initialize" );
+	END_LUA_CALL_WEAPON_METHOD( 0, 0 );
+#endif
+}
+
+#ifdef CLIENT_DLL
+void CHL2MPScriptedWeapon::OnDataChanged( DataUpdateType_t updateType )
+{
+	BaseClass::OnDataChanged( updateType );
+
+	if ( updateType == DATA_UPDATE_CREATED )
+	{
+		if ( m_iScriptedClassname.Get() && !m_pLuaWeaponInfo->bParsedScript )
+		{
+			m_pLuaWeaponInfo->bParsedScript = true;
+			SetClassname( m_iScriptedClassname.Get() );
+			InitScriptedWeapon();
+
+#ifdef LUA_SDK
+			BEGIN_LUA_CALL_WEAPON_METHOD( "Precache" );
+			END_LUA_CALL_WEAPON_METHOD( 0, 0 );
+#endif
+		}
+	}
+}
+
+const char *CHL2MPScriptedWeapon::GetScriptedClassname( void )
+{
+	if ( m_iScriptedClassname.Get() )
+		return m_iScriptedClassname.Get();
+	return BaseClass::GetClassname();
+}
+#endif
+
+void CHL2MPScriptedWeapon::Precache( void )
+{
+	BaseClass::Precache();
+
+	InitScriptedWeapon();
+
+	// Get the ammo indexes for the ammo's specified in the data file
+	if ( GetWpnData().szAmmo1[0] )
+	{
+		m_iPrimaryAmmoType = GetAmmoDef()->Index( GetWpnData().szAmmo1 );
+		if (m_iPrimaryAmmoType == -1)
+		{
+			Msg("ERROR: Weapon (%s) using undefined primary ammo type (%s)\n",GetClassname(), GetWpnData().szAmmo1);
+		}
+	}
+	if ( GetWpnData().szAmmo2[0] )
+	{
+		m_iSecondaryAmmoType = GetAmmoDef()->Index( GetWpnData().szAmmo2 );
+		if (m_iSecondaryAmmoType == -1)
+		{
+			Msg("ERROR: Weapon (%s) using undefined secondary ammo type (%s)\n",GetClassname(),GetWpnData().szAmmo2);
+		}
+
+	}
+
+	// Precache models (preload to avoid hitch)
+	m_iViewModelIndex = 0;
+	m_iWorldModelIndex = 0;
+	if ( GetViewModel() && GetViewModel()[0] )
+	{
+		m_iViewModelIndex = CBaseEntity::PrecacheModel( GetViewModel() );
+	}
+	if ( GetWorldModel() && GetWorldModel()[0] )
+	{
+		m_iWorldModelIndex = CBaseEntity::PrecacheModel( GetWorldModel() );
+	}
+
+	// Precache sounds, too
+	for ( int i = 0; i < NUM_SHOOT_SOUND_TYPES; ++i )
+	{
+		const char *shootsound = GetShootSound( i );
+		if ( shootsound && shootsound[0] )
+		{
+			CBaseEntity::PrecacheScriptSound( shootsound );
+		}
+	}
+
+#if defined ( LUA_SDK ) && !defined( CLIENT_DLL )
+	BEGIN_LUA_CALL_WEAPON_METHOD( "Precache" );
+	END_LUA_CALL_WEAPON_METHOD( 0, 0 );
+#endif
+}
+
+
+//-----------------------------------------------------------------------------
+// Purpose: Get my data in the file weapon info array
+//-----------------------------------------------------------------------------
+const FileWeaponInfo_t &CHL2MPScriptedWeapon::GetWpnData( void ) const
+{
+	return *m_pLuaWeaponInfo;
+}
+
+const char *CHL2MPScriptedWeapon::GetViewModel( int ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "viewmodel" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_STRING();
+#endif
+
+	return BaseClass::GetViewModel();
+}
+
+const char *CHL2MPScriptedWeapon::GetWorldModel( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "playermodel" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_STRING();
+#endif
+
+	return BaseClass::GetWorldModel();
+}
+
+const char *CHL2MPScriptedWeapon::GetAnimPrefix( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "anim_prefix" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_STRING();
+#endif
+
+	return BaseClass::GetAnimPrefix();
+}
+
+const char *CHL2MPScriptedWeapon::GetPrintName( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "printname" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_STRING();
+#endif
+
+	return BaseClass::GetPrintName();
+}
+
+int CHL2MPScriptedWeapon::GetMaxClip1( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "clip_size" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
+	return BaseClass::GetMaxClip1();
+}
+
+int CHL2MPScriptedWeapon::GetMaxClip2( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "clip2_size" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
+	return BaseClass::GetMaxClip2();
+}
+
+int CHL2MPScriptedWeapon::GetDefaultClip1( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "default_clip" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
+	return BaseClass::GetDefaultClip1();
+}
+
+int CHL2MPScriptedWeapon::GetDefaultClip2( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "default_clip2" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
+	return BaseClass::GetDefaultClip2();
+}
+
+
+bool CHL2MPScriptedWeapon::IsMeleeWeapon() const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "MeleeWeapon" );
+	lua_remove( L, -2 );
+
+	if ( lua_gettop( L ) == 1 )
+	{
+		if ( lua_isnumber( L, -1 ) )
+		{
+			int res = ( (int)lua_tointeger( L, -1 ) != 0 ) ? true : false;
+			lua_pop(L, 1);
+			return res;
+		}
+		else
+			lua_pop(L, 1);
+	}
+#endif
+
+	return BaseClass::IsMeleeWeapon();
+}
+
+int CHL2MPScriptedWeapon::GetWeight( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "weight" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
+	return BaseClass::GetWeight();
+}
+
+bool CHL2MPScriptedWeapon::AllowsAutoSwitchTo( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "autoswitchto" );
+	lua_remove( L, -2 );
+
+	if ( lua_gettop( L ) == 1 )
+	{
+		if ( lua_isnumber( L, -1 ) )
+		{
+			int res = ( (int)lua_tointeger( L, -1 ) != 0 ) ? true : false;
+			lua_pop(L, 1);
+			return res;
+		}
+		else
+			lua_pop(L, 1);
+	}
+#endif
+
+	return BaseClass::AllowsAutoSwitchTo();
+}
+
+bool CHL2MPScriptedWeapon::AllowsAutoSwitchFrom( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "autoswitchfrom" );
+	lua_remove( L, -2 );
+
+	if ( lua_gettop( L ) == 1 )
+	{
+		if ( lua_isnumber( L, -1 ) )
+		{
+			int res = ( (int)lua_tointeger( L, -1 ) != 0 ) ? true : false;
+			lua_pop(L, 1);
+			return res;
+		}
+		else
+			lua_pop(L, 1);
+	}
+#endif
+
+	return BaseClass::AllowsAutoSwitchFrom();
+}
+
+int CHL2MPScriptedWeapon::GetWeaponFlags( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "item_flags" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
+	return BaseClass::GetWeaponFlags();
+}
+
+int CHL2MPScriptedWeapon::GetSlot( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "bucket" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
+	return BaseClass::GetSlot();
+}
+
+int CHL2MPScriptedWeapon::GetPosition( void ) const
+{
+#if defined ( LUA_SDK )
+	lua_getref( L, m_nTableReference );
+	lua_getfield( L, -1, "bucket_position" );
+	lua_remove( L, -2 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
+	return BaseClass::GetPosition();
+}
+
+const Vector &CHL2MPScriptedWeapon::GetBulletSpread( void )
+{
+	static Vector cone = VECTOR_CONE_3DEGREES;
+	return cone;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//
+//
+//-----------------------------------------------------------------------------
+void CHL2MPScriptedWeapon::PrimaryAttack( void )
+{
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_WEAPON_METHOD( "PrimaryAttack" );
+	END_LUA_CALL_WEAPON_METHOD( 0, 0 );
+#endif
+}
+
+void CHL2MPScriptedWeapon::SecondaryAttack( void )
+{
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_WEAPON_METHOD( "SecondaryAttack" );
+	END_LUA_CALL_WEAPON_METHOD( 0, 0 );
+#endif
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : &info - 
+//-----------------------------------------------------------------------------
+void CHL2MPScriptedWeapon::FireBullets( const FireBulletsInfo_t &info )
+{
+	if(CBasePlayer *pPlayer = ToBasePlayer ( GetOwner() ) )
+	{
+		pPlayer->FireBullets(info);
+	}
+}
+
+bool CHL2MPScriptedWeapon::Reload( void )
+{
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_WEAPON_METHOD( "Reload" );
+	END_LUA_CALL_WEAPON_METHOD( 0, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+	return BaseClass::Reload();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Output : Returns true on success, false on failure.
+//-----------------------------------------------------------------------------
+bool CHL2MPScriptedWeapon::Deploy( void )
+{
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_WEAPON_METHOD( "Deploy" );
+	END_LUA_CALL_WEAPON_METHOD( 0, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
+	return BaseClass::Deploy();
+}
+
+Activity CHL2MPScriptedWeapon::GetDrawActivity( void )
+{
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_WEAPON_METHOD( "GetDrawActivity" );
+	END_LUA_CALL_WEAPON_METHOD( 0, 1 );
+
+	// Kind of lame, but we're required to explicitly cast
+	RETURN_LUA_ACTIVITY();
+#endif
+
+	return BaseClass::GetDrawActivity();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Output : Returns true on success, false on failure.
+//-----------------------------------------------------------------------------
+bool CHL2MPScriptedWeapon::Holster( CBaseCombatWeapon *pSwitchingTo )
+{
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_WEAPON_METHOD( "Holster" );
+		lua_pushweapon( L, pSwitchingTo );
+	END_LUA_CALL_WEAPON_METHOD( 1, 1 );
+
+	RETURN_LUA_BOOLEAN();
+#endif
+
+	return BaseClass::Holster( pSwitchingTo );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CHL2MPScriptedWeapon::ItemPostFrame( void )
+{
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_WEAPON_METHOD( "ItemPostFrame" );
+	END_LUA_CALL_WEAPON_METHOD( 0, 1 );
+
+	RETURN_LUA_NONE();
+#endif
+
+	BaseClass::ItemPostFrame();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Called each frame by the player PostThink, if the player's not ready to attack yet
+//-----------------------------------------------------------------------------
+void CHL2MPScriptedWeapon::ItemBusyFrame( void )
+{
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_WEAPON_METHOD( "ItemBusyFrame" );
+	END_LUA_CALL_WEAPON_METHOD( 0, 1 );
+
+	RETURN_LUA_NONE();
+#endif
+
+	BaseClass::ItemBusyFrame();
+}
+
+#ifndef CLIENT_DLL
+int CHL2MPScriptedWeapon::CapabilitiesGet( void )
+{
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_WEAPON_METHOD( "CapabilitiesGet" );
+	END_LUA_CALL_WEAPON_METHOD( 0, 1 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
+	return BaseClass::CapabilitiesGet();
+}
+#else
+int CHL2MPScriptedWeapon::DrawModel( int flags )
+{
+#if defined ( LUA_SDK )
+	BEGIN_LUA_CALL_WEAPON_METHOD( "DrawModel" );
+		lua_pushinteger( L, flags );
+	END_LUA_CALL_WEAPON_METHOD( 1, 1 );
+
+	RETURN_LUA_INTEGER();
+#endif
+
+	return BaseClass::DrawModel( flags );
+}
+#endif
+
+
diff --git a/src/game/shared/hl2mp/weapon_hl2mpbase_scriptedweapon.h b/src/game/shared/hl2mp/weapon_hl2mpbase_scriptedweapon.h
new file mode 100644
index 0000000..91757b9
--- /dev/null
+++ b/src/game/shared/hl2mp/weapon_hl2mpbase_scriptedweapon.h
@@ -0,0 +1,113 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+//=============================================================================//
+
+#include "weapon_hl2mpbasehlmpcombatweapon.h"
+#include "luamanager.h"
+
+#ifndef BASEHLCOMBATWEAPON_H
+#define BASEHLCOMBATWEAPON_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+#if defined( CLIENT_DLL )
+	#define CHL2MPScriptedWeapon C_HL2MPScriptedWeapon
+#endif
+
+//=========================================================
+// Scripted weapon base class
+//=========================================================
+class CHL2MPScriptedWeapon : public CBaseHL2MPCombatWeapon
+{
+public:
+	DECLARE_CLASS( CHL2MPScriptedWeapon, CWeaponHL2MPBase );
+	DECLARE_DATADESC();
+
+	CHL2MPScriptedWeapon();
+	~CHL2MPScriptedWeapon();
+
+	bool			IsScripted( void ) const { return true; }
+	
+	DECLARE_NETWORKCLASS(); 
+	DECLARE_PREDICTABLE();
+	// DECLARE_ACTTABLE();
+
+	acttable_t m_acttable[LUA_MAX_WEAPON_ACTIVITIES];
+	acttable_t *ActivityList( void );
+	int ActivityListCount( void );
+
+	void			Precache( void );
+	void			InitScriptedWeapon( void );
+
+	void	PrimaryAttack( void );
+	void	SecondaryAttack( void );
+
+	// Firing animations
+	virtual Activity		GetDrawActivity( void );
+
+	// Default calls through to m_hOwner, but plasma weapons can override and shoot projectiles here.
+	virtual void	ItemPostFrame( void );
+	virtual void	ItemBusyFrame( void );
+	virtual void	FireBullets( const FireBulletsInfo_t &info );
+	virtual bool	Reload();
+	
+	virtual bool	Deploy( void );
+	virtual bool	Holster( CBaseCombatWeapon *pSwitchingTo );
+
+#ifdef CLIENT_DLL
+	virtual void	OnDataChanged( DataUpdateType_t updateType );
+	virtual const char *GetScriptedClassname( void );
+#endif
+
+	virtual const Vector &GetBulletSpread( void );
+
+public:
+
+	// Weapon info accessors for data in the weapon's data file
+	CHL2MPSWeaponInfo *m_pLuaWeaponInfo;
+	virtual const FileWeaponInfo_t	&GetWpnData( void ) const;
+	virtual const char		*GetViewModel( int viewmodelindex = 0 ) const;
+	virtual const char		*GetWorldModel( void ) const;
+	virtual const char		*GetAnimPrefix( void ) const;
+	virtual int				GetMaxClip1( void ) const;
+	virtual int				GetMaxClip2( void ) const;
+	virtual int				GetDefaultClip1( void ) const;
+	virtual int				GetDefaultClip2( void ) const;
+	virtual int				GetWeight( void ) const;
+	virtual bool			AllowsAutoSwitchTo( void ) const;
+	virtual bool			AllowsAutoSwitchFrom( void ) const;
+	virtual int				GetWeaponFlags( void ) const;
+	virtual int				GetSlot( void ) const;
+	virtual int				GetPosition( void ) const;
+	virtual char const		*GetPrintName( void ) const;
+	bool					IsMeleeWeapon() const;
+
+public:
+// Server Only Methods
+#if !defined( CLIENT_DLL )
+
+	virtual int				CapabilitiesGet( void );
+
+// Client only methods
+#else
+
+	// Returns the aiment render origin + angles
+	virtual int				DrawModel( int flags );
+
+#endif // End client-only methods
+
+private:
+	
+	CHL2MPScriptedWeapon( const CHL2MPScriptedWeapon & );
+
+	CNetworkString( m_iScriptedClassname, MAX_WEAPON_STRING );
+
+};
+
+void RegisterScriptedWeapon( const char *szClassname );
+void ResetWeaponFactoryDatabase( void );
+
+#endif // BASEHLCOMBATWEAPON_H
diff --git a/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp b/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp
index d1179b7..b303de1 100644
--- a/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp
+++ b/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp
@@ -21,6 +21,9 @@
 	#include "ndebugoverlay.h"
 	#include "te_effect_dispatch.h"
 	#include "ilagcompensationmanager.h"
+#if defined( HL2SB )
+	#include "basecombatcharacter.h"
+#endif
 #endif
 
 // memdbgon must be the last include file in a .cpp file!!!
@@ -69,6 +72,31 @@ void CBaseHL2MPBludgeonWeapon::Precache( void )
 	BaseClass::Precache();
 }
 
+#ifdef HL2SB
+//Andrew; see https://developer.valvesoftware.com/wiki/Talk:Fixing_AI_in_multiplayer#Metropolice_with_stunstick
+#ifndef CLIENT_DLL
+int CBaseHL2MPBludgeonWeapon::CapabilitiesGet()
+{ 
+	return bits_CAP_WEAPON_MELEE_ATTACK1; 
+}
+
+
+int CBaseHL2MPBludgeonWeapon::WeaponMeleeAttack1Condition( float flDot, float flDist )
+{
+	if (flDist > 64)
+	{
+		return COND_TOO_FAR_TO_ATTACK;
+	}
+	else if (flDot < 0.7)
+	{
+		return COND_NOT_FACING_ATTACK;
+	}
+
+	return COND_CAN_MELEE_ATTACK1;
+}
+#endif
+#endif
+
 //------------------------------------------------------------------------------
 // Purpose : Update weapon
 //------------------------------------------------------------------------------
diff --git a/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.h b/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.h
index 7d5b24b..2f81891 100644
--- a/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.h
+++ b/src/game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.h
@@ -51,6 +51,12 @@ public:
 	virtual float	GetRange( void )								{	return	32.0f;	}
 	virtual	float	GetDamageForActivity( Activity hitActivity )	{	return	1.0f;	}
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	virtual int		CapabilitiesGet( void );
+	virtual	int		WeaponMeleeAttack1Condition( float flDot, float flDist );
+#endif
+#endif
 	CBaseHL2MPBludgeonWeapon( const CBaseHL2MPBludgeonWeapon & );
 
 protected:
diff --git a/src/game/shared/hl2mp/weapon_physcannon.cpp b/src/game/shared/hl2mp/weapon_physcannon.cpp
index a75aa4f..95e011b 100644
--- a/src/game/shared/hl2mp/weapon_physcannon.cpp
+++ b/src/game/shared/hl2mp/weapon_physcannon.cpp
@@ -46,6 +46,18 @@
 #include "vphysics/friction.h"
 #include "debugoverlay_shared.h"
 
+#ifdef HL2SB
+#ifdef CLIENT_DLL
+enum PhysGunForce_t
+{
+	PHYSGUN_FORCE_DROPPED,	// Dropped by +USE
+	PHYSGUN_FORCE_THROWN,	// Thrown from +USE
+	PHYSGUN_FORCE_PUNTED,	// Punted by cannon
+	PHYSGUN_FORCE_LAUNCHED,	// Launched by cannon
+};
+#endif
+#endif
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -1147,7 +1159,11 @@ protected:
 	void	PuntVPhysics( CBaseEntity *pEntity, const Vector &forward, trace_t &tr );
 
 	// Velocity-based throw common to punt and launch code.
+#ifndef HL2SB
 	void	ApplyVelocityBasedForce( CBaseEntity *pEntity, const Vector &forward );
+#else
+	void	ApplyVelocityBasedForce( CBaseEntity *pEntity, const Vector &forward, const Vector &vecHitPos, PhysGunForce_t reason );
+#endif
 
 	// Physgun effects
 	void	DoEffectClosed( void );
@@ -1728,7 +1744,11 @@ void CWeaponPhysCannon::PuntVPhysics( CBaseEntity *pEntity, const Vector &vecFor
 		}
 		else
 		{
+#ifndef HL2SB
 			ApplyVelocityBasedForce( pEntity, vecForward );
+#else
+			ApplyVelocityBasedForce( pEntity, vecForward, tr.endpos, PHYSGUN_FORCE_PUNTED );
+#endif
 		}
 	}
 
@@ -1757,8 +1777,13 @@ void CWeaponPhysCannon::PuntVPhysics( CBaseEntity *pEntity, const Vector &vecFor
 //			ASSUMES: that pEntity is a vphysics entity.
 // Input  : - 
 //-----------------------------------------------------------------------------
+#ifndef HL2SB
 void CWeaponPhysCannon::ApplyVelocityBasedForce( CBaseEntity *pEntity, const Vector &forward )
+#else
+void CWeaponPhysCannon::ApplyVelocityBasedForce( CBaseEntity *pEntity, const Vector &forward, const Vector &vecHitPos, PhysGunForce_t reason )
+#endif
 {
+#ifndef HL2SB
 #ifndef CLIENT_DLL
 	IPhysicsObject *pPhysicsObject = pEntity->VPhysicsGetObject();
 	Assert(pPhysicsObject); // Shouldn't ever get here with a non-vphysics object.
@@ -1784,6 +1809,58 @@ void CWeaponPhysCannon::ApplyVelocityBasedForce( CBaseEntity *pEntity, const Vec
 
 #endif
 
+#else
+#ifndef CLIENT_DLL
+	// Get the launch velocity
+	Vector vVel = Pickup_PhysGunLaunchVelocity( pEntity, forward, reason );
+	
+	// Get the launch angular impulse
+	AngularImpulse aVel = Pickup_PhysGunLaunchAngularImpulse( pEntity, reason );
+		
+	// Get the physics object (MUST have one)
+	IPhysicsObject *pPhysicsObject = pEntity->VPhysicsGetObject();
+	if ( pPhysicsObject == NULL )
+	{
+		Assert( 0 );
+		return;
+	}
+
+	// Affect the object
+	CRagdollProp *pRagdoll = dynamic_cast<CRagdollProp*>( pEntity );
+	if ( pRagdoll == NULL )
+	{
+#ifdef HL2_EPISODIC
+		// The jeep being punted needs special force overrides
+		if ( reason == PHYSGUN_FORCE_PUNTED && pEntity->GetServerVehicle() )
+		{
+			// We want the point to emanate low on the vehicle to move it along the ground, not to twist it
+			Vector vecFinalPos = vecHitPos;
+			vecFinalPos.z = pEntity->GetAbsOrigin().z;
+			pPhysicsObject->ApplyForceOffset( vVel, vecFinalPos );
+		}
+		else
+		{
+			pPhysicsObject->AddVelocity( &vVel, &aVel );
+		}
+#else
+
+		pPhysicsObject->AddVelocity( &vVel, &aVel );
+
+#endif // HL2_EPISODIC
+	}
+	else
+	{
+		Vector	vTempVel;
+		AngularImpulse vTempAVel;
+
+		ragdoll_t *pRagdollPhys = pRagdoll->GetRagdoll( );
+		for ( int j = 0; j < pRagdollPhys->listCount; ++j )
+		{
+			pRagdollPhys->list[j].pObject->AddVelocity( &vVel, &aVel ); 
+		}
+	}
+#endif
+#endif
 }
 
 
@@ -2708,8 +2785,33 @@ void CWeaponPhysCannon::LaunchObject( const Vector &vecDir, float flForce )
 			m_hLastPuntedObject = pObject;
 			m_flRepuntObjectTime = gpGlobals->curtime + 0.5f;
 
+#ifndef HL2SB
 			// Launch
 			ApplyVelocityBasedForce( pObject, vecDir );
+#else
+			// Trace ahead a bit and make a chain of danger sounds ahead of the phys object
+			// to scare potential targets
+			trace_t	tr;
+			Vector	vecStart = pObject->GetAbsOrigin();
+			Vector	vecSpot;
+			int		iLength;
+			int		i;
+
+			UTIL_TraceLine( vecStart, vecStart + vecDir * flForce, MASK_SHOT, pObject, COLLISION_GROUP_NONE, &tr );
+			iLength = ( tr.startpos - tr.endpos ).Length();
+			vecSpot = vecStart + vecDir * PHYSCANNON_DANGER_SOUND_RADIUS;
+
+			for( i = PHYSCANNON_DANGER_SOUND_RADIUS ; i < iLength ; i += PHYSCANNON_DANGER_SOUND_RADIUS )
+			{
+#ifndef CLIENT_DLL
+				CSoundEnt::InsertSound( SOUND_PHYSICS_DANGER, vecSpot, PHYSCANNON_DANGER_SOUND_RADIUS, 0.5, pObject );
+#endif
+				vecSpot = vecSpot + ( vecDir * PHYSCANNON_DANGER_SOUND_RADIUS );
+			}
+					
+			// Launch
+			ApplyVelocityBasedForce( pObject, vecDir, tr.endpos, PHYSGUN_FORCE_LAUNCHED );
+#endif
 
 			// Don't allow the gun to regrab a thrown object!!
 			m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
diff --git a/src/game/shared/hl2mp/weapon_physgun.cpp b/src/game/shared/hl2mp/weapon_physgun.cpp
new file mode 100644
index 0000000..23013d9
--- /dev/null
+++ b/src/game/shared/hl2mp/weapon_physgun.cpp
@@ -0,0 +1,1456 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#include "cbase.h"
+#include "beam_shared.h"
+#ifndef CLIENT_DLL
+#include "player.h"
+#endif
+#include "gamerules.h"
+#ifdef CLIENT_DLL
+#include "ClientEffectPrecacheSystem.h"
+#endif
+#include "weapon_hl2mpbasehlmpcombatweapon.h"
+#ifndef CLIENT_DLL
+#include "baseviewmodel.h"
+#endif
+#include "vphysics/constraints.h"
+#include "physics.h"
+#include "in_buttons.h"
+#include "IEffects.h"
+#include "soundenvelope.h"
+#include "engine/IEngineSound.h"
+#ifndef CLIENT_DLL
+#include "ndebugoverlay.h"
+#endif
+#include "physics_saverestore.h"
+#ifndef CLIENT_DLL
+#include "player_pickup.h"
+#endif
+#include "soundemittersystem/isoundemittersystembase.h"
+#ifdef CLIENT_DLL
+#include "model_types.h"
+#include "view_shared.h"
+#include "view.h"
+#include "iviewrender.h"
+#include "ragdoll.h"
+#else
+#include "physics_prop_ragdoll.h"
+#endif
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int g_physgunBeam1;
+static int g_physgunBeam;
+static int g_physgunGlow;
+#define PHYSGUN_BEAM_SPRITE1	"sprites/physbeam1.vmt"
+#define PHYSGUN_BEAM_SPRITE		"sprites/physbeam.vmt"
+#define PHYSGUN_BEAM_GLOW		"sprites/physglow.vmt"
+
+#define	PHYSGUN_SKIN	1
+
+class CWeaponGravityGun;
+
+#ifdef CLIENT_DLL
+CLIENTEFFECT_REGISTER_BEGIN( PrecacheEffectGravityGun )
+CLIENTEFFECT_MATERIAL( "sprites/physbeam1" )
+CLIENTEFFECT_MATERIAL( "sprites/physbeam" )
+CLIENTEFFECT_MATERIAL( "sprites/physglow" )
+CLIENTEFFECT_REGISTER_END()
+
+
+#endif
+
+IPhysicsObject *GetPhysObjFromPhysicsBone( CBaseEntity *pEntity, short physicsbone )
+{
+	if( pEntity->IsNPC() )
+	{
+		return pEntity->VPhysicsGetObject();
+	}
+
+	CBaseAnimating *pModel = static_cast< CBaseAnimating * >( pEntity );
+	if ( pModel != NULL )
+	{
+		IPhysicsObject	*pPhysicsObject = NULL;
+		
+		//Find the real object we hit.
+		if( physicsbone >= 0 )
+		{
+#ifdef CLIENT_DLL
+			if ( pModel->m_pRagdoll )
+			{
+				CRagdoll *pCRagdoll = dynamic_cast < CRagdoll * > ( pModel->m_pRagdoll );
+#else
+				// Affect the object
+				CRagdollProp *pCRagdoll = dynamic_cast<CRagdollProp*>( pEntity );
+#endif
+				if ( pCRagdoll )
+				{
+					ragdoll_t *pRagdollT = pCRagdoll->GetRagdoll();
+
+					if ( physicsbone < pRagdollT->listCount )
+					{
+						pPhysicsObject = pRagdollT->list[physicsbone].pObject;
+					}
+					return pPhysicsObject;
+				}
+#ifdef CLIENT_DLL
+			}
+#endif
+		}
+	}
+
+	return pEntity->VPhysicsGetObject();
+}
+
+class CGravControllerPoint : public IMotionEvent
+{
+	DECLARE_SIMPLE_DATADESC();
+
+public:
+	CGravControllerPoint( void );
+	~CGravControllerPoint( void );
+	void AttachEntity( CBasePlayer *pPlayer, CBaseEntity *pEntity, IPhysicsObject *pPhys, short physicsbone, const Vector &position );
+	void DetachEntity( void );
+
+	bool UpdateObject( CBasePlayer *pPlayer, CBaseEntity *pEntity );
+
+	void SetTargetPosition( const Vector &target, const QAngle &targetOrientation )
+	{
+		m_shadow.targetPosition = target;
+		m_shadow.targetRotation = targetOrientation;
+
+		m_timeToArrive = gpGlobals->frametime;
+
+		CBaseEntity *pAttached = m_attachedEntity;
+		if ( pAttached )
+		{
+			IPhysicsObject *pObj = GetPhysObjFromPhysicsBone( pAttached, m_attachedPhysicsBone );
+			
+			if ( pObj != NULL )
+			{
+				pObj->Wake();
+			}
+			else
+			{
+				DetachEntity();
+			}
+		}
+	}
+	QAngle TransformAnglesToPlayerSpace( const QAngle &anglesIn, CBasePlayer *pPlayer );
+	QAngle TransformAnglesFromPlayerSpace( const QAngle &anglesIn, CBasePlayer *pPlayer );
+
+	IMotionEvent::simresult_e Simulate( IPhysicsMotionController *pController, IPhysicsObject *pObject, float deltaTime, Vector &linear, AngularImpulse &angular );
+	Vector			m_localPosition;
+	Vector			m_targetPosition;
+	Vector			m_worldPosition;
+	float			m_saveDamping;
+	float			m_saveMass;
+	float			m_maxAcceleration;
+	Vector			m_maxAngularAcceleration;
+	EHANDLE			m_attachedEntity;
+	short			m_attachedPhysicsBone;
+	QAngle			m_targetRotation;
+	float			m_timeToArrive;
+
+#ifdef ARGG
+	// adnan
+	// set up the modified pickup angles... allow the player to rotate the object in their grip
+	QAngle		m_vecRotatedCarryAngles;
+	bool			m_bHasRotatedCarryAngles;
+	// end adnan
+#endif
+
+	IPhysicsMotionController *m_controller;
+
+private:
+	hlshadowcontrol_params_t	m_shadow;
+};
+
+
+BEGIN_SIMPLE_DATADESC( CGravControllerPoint )
+
+	DEFINE_FIELD( m_localPosition,		FIELD_VECTOR ),
+	DEFINE_FIELD( m_targetPosition,		FIELD_POSITION_VECTOR ),
+	DEFINE_FIELD( m_worldPosition,		FIELD_POSITION_VECTOR ),
+	DEFINE_FIELD( m_saveDamping,			FIELD_FLOAT ),
+	DEFINE_FIELD( m_saveMass,			FIELD_FLOAT ),
+	DEFINE_FIELD( m_maxAcceleration,		FIELD_FLOAT ),
+	DEFINE_FIELD( m_maxAngularAcceleration,	FIELD_VECTOR ),
+	DEFINE_FIELD( m_attachedEntity,		FIELD_EHANDLE ),
+	DEFINE_FIELD( m_attachedPhysicsBone,		FIELD_SHORT ),
+	DEFINE_FIELD( m_targetRotation,		FIELD_VECTOR ),
+	DEFINE_FIELD( m_timeToArrive,			FIELD_FLOAT ),
+#ifdef ARGG
+	// adnan
+	// set up the fields for our added vars
+	DEFINE_FIELD( m_vecRotatedCarryAngles, FIELD_VECTOR ),
+	DEFINE_FIELD( m_bHasRotatedCarryAngles, FIELD_BOOLEAN ),
+	// end adnan
+#endif
+
+	// Physptrs can't be saved in embedded classes... this is to silence classcheck
+	// DEFINE_PHYSPTR( m_controller ),
+
+END_DATADESC()
+
+
+CGravControllerPoint::CGravControllerPoint( void )
+{
+	m_shadow.dampFactor = 0.8;
+	m_shadow.teleportDistance = 0;
+	// make this controller really stiff!
+	m_shadow.maxSpeed = 5000;
+	m_shadow.maxAngular = m_shadow.maxSpeed;
+	m_shadow.maxDampSpeed = m_shadow.maxSpeed*2;
+	m_shadow.maxDampAngular = m_shadow.maxAngular*2;
+	m_attachedEntity = NULL;
+	m_attachedPhysicsBone = 0;
+
+#ifdef ARGG
+	// adnan
+	// initialize our added vars
+	m_vecRotatedCarryAngles = vec3_angle;
+	m_bHasRotatedCarryAngles = false;
+	// end adnan
+#endif
+}
+
+CGravControllerPoint::~CGravControllerPoint( void )
+{
+	DetachEntity();
+}
+
+
+QAngle CGravControllerPoint::TransformAnglesToPlayerSpace( const QAngle &anglesIn, CBasePlayer *pPlayer )
+{
+	matrix3x4_t test;
+	QAngle angleTest = pPlayer->EyeAngles();
+	angleTest.x = 0;
+	AngleMatrix( angleTest, test );
+	return TransformAnglesToLocalSpace( anglesIn, test );
+}
+
+QAngle CGravControllerPoint::TransformAnglesFromPlayerSpace( const QAngle &anglesIn, CBasePlayer *pPlayer )
+{
+	matrix3x4_t test;
+	QAngle angleTest = pPlayer->EyeAngles();
+	angleTest.x = 0;
+	AngleMatrix( angleTest, test );
+	return TransformAnglesToWorldSpace( anglesIn, test );
+}
+
+
+void CGravControllerPoint::AttachEntity( CBasePlayer *pPlayer, CBaseEntity *pEntity, IPhysicsObject *pPhys, short physicsbone, const Vector &vGrabPosition )
+{
+	m_attachedEntity = pEntity;
+	m_attachedPhysicsBone = physicsbone;
+	pPhys->WorldToLocal( &m_localPosition, vGrabPosition );
+	m_worldPosition = vGrabPosition;
+	pPhys->GetDamping( NULL, &m_saveDamping );
+	m_saveMass = pPhys->GetMass();
+	float damping = 2;
+	pPhys->SetDamping( NULL, &damping );
+	pPhys->SetMass( 50000 );
+	m_controller = physenv->CreateMotionController( this );
+	m_controller->AttachObject( pPhys, true );
+	Vector position;
+	QAngle angles;
+	pPhys->GetPosition( &position, &angles );
+	SetTargetPosition( vGrabPosition, angles );
+	m_targetRotation = TransformAnglesToPlayerSpace( angles, pPlayer );
+#ifdef ARGG
+	// adnan
+	// we need to grab the preferred/non preferred carry angles here for the rotatedcarryangles
+	m_vecRotatedCarryAngles = m_targetRotation;
+	// end adnan
+#endif
+}
+
+void CGravControllerPoint::DetachEntity( void )
+{
+	CBaseEntity *pEntity = m_attachedEntity;
+	if ( pEntity )
+	{
+		IPhysicsObject *pPhys = GetPhysObjFromPhysicsBone( pEntity, m_attachedPhysicsBone );
+		if ( pPhys )
+		{
+			// on the odd chance that it's gone to sleep while under anti-gravity
+			pPhys->Wake();
+			pPhys->SetDamping( NULL, &m_saveDamping );
+			pPhys->SetMass( m_saveMass );
+		}
+	}
+	m_attachedEntity = NULL;
+	m_attachedPhysicsBone = 0;
+	if ( physenv )
+	{
+		physenv->DestroyMotionController( m_controller );
+	}
+	m_controller = NULL;
+
+	// UNDONE: Does this help the networking?
+	m_targetPosition = vec3_origin;
+	m_worldPosition = vec3_origin;
+}
+
+void AxisAngleQAngle( const Vector &axis, float angle, QAngle &outAngles )
+{
+	// map back to HL rotation axes
+	outAngles.z = axis.x * angle;
+	outAngles.x = axis.y * angle;
+	outAngles.y = axis.z * angle;
+}
+
+IMotionEvent::simresult_e CGravControllerPoint::Simulate( IPhysicsMotionController *pController, IPhysicsObject *pObject, float deltaTime, Vector &linear, AngularImpulse &angular )
+{
+	hlshadowcontrol_params_t shadowParams = m_shadow;
+#ifndef CLIENT_DLL
+	m_timeToArrive = pObject->ComputeShadowControl( shadowParams, m_timeToArrive, deltaTime );
+#else
+	m_timeToArrive = pObject->ComputeShadowControl( shadowParams, (TICK_INTERVAL*2), deltaTime );
+#endif
+	
+	linear.Init();
+	angular.Init();
+
+	return SIM_LOCAL_ACCELERATION;
+}
+
+
+#ifdef CLIENT_DLL
+#define CWeaponGravityGun C_WeaponGravityGun
+#endif
+
+class CWeaponGravityGun : public CBaseHL2MPCombatWeapon
+{
+	DECLARE_DATADESC();
+
+public:
+	DECLARE_CLASS( CWeaponGravityGun, CBaseHL2MPCombatWeapon );
+
+	DECLARE_NETWORKCLASS();
+	DECLARE_PREDICTABLE();
+
+	CWeaponGravityGun();
+
+#ifdef CLIENT_DLL
+	void GetRenderBounds( Vector& mins, Vector& maxs )
+	{
+		BaseClass::GetRenderBounds( mins, maxs );
+
+		// add to the bounds, don't clear them.
+		// ClearBounds( mins, maxs );
+		AddPointToBounds( vec3_origin, mins, maxs );
+		AddPointToBounds( m_targetPosition, mins, maxs );
+		AddPointToBounds( m_worldPosition, mins, maxs );
+		CBaseEntity *pEntity = GetBeamEntity();
+		if ( pEntity )
+		{
+			mins -= pEntity->GetRenderOrigin();
+			maxs -= pEntity->GetRenderOrigin();
+		}
+	}
+
+	void GetRenderBoundsWorldspace( Vector& mins, Vector& maxs )
+	{
+		BaseClass::GetRenderBoundsWorldspace( mins, maxs );
+
+		// add to the bounds, don't clear them.
+		// ClearBounds( mins, maxs );
+		AddPointToBounds( vec3_origin, mins, maxs );
+		AddPointToBounds( m_targetPosition, mins, maxs );
+		AddPointToBounds( m_worldPosition, mins, maxs );
+		mins -= GetRenderOrigin();
+		maxs -= GetRenderOrigin();
+	}
+
+	int KeyInput( int down, ButtonCode_t keynum, const char *pszCurrentBinding )
+	{
+		if ( gHUD.m_iKeyBits & IN_ATTACK )
+		{
+			switch ( keynum )
+			{
+			case MOUSE_WHEEL_UP:
+				m_bInWeapon1 = true;
+				// gHUD.m_iKeyBits |= IN_WEAPON1;
+				if ( gpGlobals->maxClients > 1 )
+					gHUD.m_bSkipClear = true;
+				return 0;
+
+			case MOUSE_WHEEL_DOWN:
+				m_bInWeapon2 = true;
+				// gHUD.m_iKeyBits |= IN_WEAPON2;
+				if ( gpGlobals->maxClients > 1 )
+					gHUD.m_bSkipClear = true;
+				return 0;
+			}
+		}
+
+		// Allow engine to process
+		return BaseClass::KeyInput( down, keynum, pszCurrentBinding );
+	}
+
+	void HandleInput()
+	{
+		if ( m_bInWeapon1 )
+		{
+			gHUD.m_iKeyBits |= IN_WEAPON1;
+			m_bInWeapon1 = false;
+		}
+
+		if ( m_bInWeapon2 )
+		{
+			gHUD.m_iKeyBits |= IN_WEAPON2;
+			m_bInWeapon2 = false;
+		}
+	}
+
+	int	 DrawModel( int flags );
+	void ViewModelDrawn( C_BaseViewModel *pBaseViewModel );
+	bool IsTransparent( void );
+
+	// We need to render opaque and translucent pieces
+	RenderGroup_t	GetRenderGroup( void ) {	return RENDER_GROUP_TWOPASS;	}
+#endif
+
+	void Spawn( void );
+	void OnRestore( void );
+	void Precache( void );
+
+#ifdef ARGG
+	// adnan
+	// for overriding the mouse -> view angles (but still calc view angles)
+	bool OverrideViewAngles( void );
+	// end adnan
+#endif
+
+	virtual void	UpdateOnRemove(void);
+	void PrimaryAttack( void );
+	void SecondaryAttack( void );
+	void ItemPreFrame( void );
+	void ItemPostFrame( void );
+	virtual bool Holster( CBaseCombatWeapon *pSwitchingTo )
+	{
+		EffectDestroy();
+		SoundDestroy();
+		return BaseClass::Holster( pSwitchingTo );
+	}
+
+	bool Reload( void );
+	void Drop(const Vector &vecVelocity)
+	{
+		EffectDestroy();
+		SoundDestroy();
+
+#ifndef CLIENT_DLL
+		UTIL_Remove( this );
+#endif
+	}
+
+	bool HasAnyAmmo( void );
+
+	void AttachObject( CBaseEntity *pEdict, IPhysicsObject *pPhysics, short physicsbone, const Vector& start, const Vector &end, float distance );
+	void UpdateObject( void );
+	void DetachObject( void );
+
+	void TraceLine( trace_t *ptr );
+
+	void EffectCreate( void );
+	void EffectUpdate( void );
+	void EffectDestroy( void );
+
+	void SoundCreate( void );
+	void SoundDestroy( void );
+	void SoundStop( void );
+	void SoundStart( void );
+	void SoundUpdate( void );
+
+	int ObjectCaps( void ) 
+	{ 
+		int caps = BaseClass::ObjectCaps();
+		if ( m_active )
+		{
+			caps |= FCAP_DIRECTIONAL_USE;
+		}
+		return caps;
+	}
+
+	CBaseEntity *GetBeamEntity();
+
+private:
+	CNetworkVar( int, m_active );
+	bool		m_useDown;
+	CNetworkHandle( CBaseEntity, m_hObject );
+	CNetworkVar( int, m_physicsBone );
+	float		m_distance;
+	float		m_movementLength;
+	int			m_soundState;
+	Vector		m_originalObjectPosition;
+	CNetworkVector	( m_targetPosition );
+	CNetworkVector	( m_worldPosition );
+
+#ifdef ARGG
+	// adnan
+	// this is how we tell if we're rotating what we're holding
+	CNetworkVar( bool, m_bIsCurrentlyRotating );
+	// end adnan
+#endif
+
+	CSoundPatch					*m_sndMotor;		// Whirring sound for the gun
+	CSoundPatch					*m_sndLockedOn;
+	CSoundPatch					*m_sndLightObject;
+	CSoundPatch					*m_sndHeavyObject;
+
+	CGravControllerPoint		m_gravCallback;
+
+	bool		m_bInWeapon1;
+	bool		m_bInWeapon2;
+
+	DECLARE_ACTTABLE();
+};
+
+IMPLEMENT_NETWORKCLASS_ALIASED( WeaponGravityGun, DT_WeaponGravityGun )
+
+BEGIN_NETWORK_TABLE( CWeaponGravityGun, DT_WeaponGravityGun )
+#ifdef CLIENT_DLL
+	RecvPropEHandle( RECVINFO( m_hObject ) ),
+	RecvPropInt( RECVINFO( m_physicsBone ) ),
+	RecvPropVector( RECVINFO( m_targetPosition ) ),
+	RecvPropVector( RECVINFO( m_worldPosition ) ),
+	RecvPropInt( RECVINFO(m_active) ),
+#ifdef ARGG
+	// adnan
+	// also receive if we're rotating what we're holding (by pressing use)
+	RecvPropBool( RECVINFO( m_bIsCurrentlyRotating ) ),
+	// end adnan
+#endif
+#else
+	SendPropEHandle( SENDINFO( m_hObject ) ),
+	SendPropInt( SENDINFO( m_physicsBone ) ),
+	SendPropVector(SENDINFO( m_targetPosition ), -1, SPROP_COORD),
+	SendPropVector(SENDINFO( m_worldPosition ), -1, SPROP_COORD),
+	SendPropInt( SENDINFO(m_active), 1, SPROP_UNSIGNED ),
+#ifdef ARGG
+	// adnan
+	// need to seind if we're rotating what we're holding
+	SendPropBool( SENDINFO( m_bIsCurrentlyRotating ) ),
+	// end adnan
+#endif
+#endif
+END_NETWORK_TABLE()
+
+#ifdef CLIENT_DLL
+BEGIN_PREDICTION_DATA( CWeaponGravityGun )
+END_PREDICTION_DATA()
+#endif
+
+LINK_ENTITY_TO_CLASS( weapon_physgun, CWeaponGravityGun );
+PRECACHE_WEAPON_REGISTER(weapon_physgun);
+
+acttable_t	CWeaponGravityGun::m_acttable[] = 
+{
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PHYSGUN,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PHYSGUN,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PHYSGUN,					false },
+};
+
+IMPLEMENT_ACTTABLE(CWeaponGravityGun);
+
+
+//---------------------------------------------------------
+// Save/Restore
+//---------------------------------------------------------
+BEGIN_DATADESC( CWeaponGravityGun )
+
+	DEFINE_FIELD( m_active,				FIELD_INTEGER ),
+	DEFINE_FIELD( m_useDown,				FIELD_BOOLEAN ),
+	DEFINE_FIELD( m_hObject,				FIELD_EHANDLE ),
+	DEFINE_FIELD( m_physicsBone,				FIELD_INTEGER ),
+	DEFINE_FIELD( m_distance,			FIELD_FLOAT ),
+	DEFINE_FIELD( m_movementLength,		FIELD_FLOAT ),
+	DEFINE_FIELD( m_soundState,			FIELD_INTEGER ),
+	DEFINE_FIELD( m_originalObjectPosition,	FIELD_POSITION_VECTOR ),
+#ifdef ARGG
+	// adnan
+	DEFINE_FIELD( m_bIsCurrentlyRotating, FIELD_BOOLEAN ),
+	// end adnan
+#endif
+	DEFINE_SOUNDPATCH( m_sndMotor ),
+	DEFINE_SOUNDPATCH( m_sndLockedOn ),
+	DEFINE_SOUNDPATCH( m_sndLightObject ),
+	DEFINE_SOUNDPATCH( m_sndHeavyObject ),
+	DEFINE_EMBEDDED( m_gravCallback ),
+	// Physptrs can't be saved in embedded classes..
+	DEFINE_PHYSPTR( m_gravCallback.m_controller ),
+
+END_DATADESC()
+
+
+enum physgun_soundstate { SS_SCANNING, SS_LOCKEDON };
+enum physgun_soundIndex { SI_LOCKEDON = 0, SI_SCANNING = 1, SI_LIGHTOBJECT = 2, SI_HEAVYOBJECT = 3, SI_ON, SI_OFF };
+
+
+//=========================================================
+//=========================================================
+
+CWeaponGravityGun::CWeaponGravityGun()
+{
+	m_active = false;
+	m_bFiresUnderwater = true;
+	m_bInWeapon1 = false;
+	m_bInWeapon2 = false;
+}
+
+
+//-----------------------------------------------------------------------------
+// On Remove
+//-----------------------------------------------------------------------------
+void CWeaponGravityGun::UpdateOnRemove(void)
+{
+	EffectDestroy();
+	SoundDestroy();
+	BaseClass::UpdateOnRemove();
+}
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+// adnan
+// want to add an angles modifier key
+bool CGravControllerPoint::UpdateObject( CBasePlayer *pPlayer, CBaseEntity *pEntity )
+{
+	IPhysicsObject *pPhysics = GetPhysObjFromPhysicsBone( pEntity, m_attachedPhysicsBone );
+	if ( !pEntity || !pPhysics )
+	{
+		return false;
+	}
+
+#ifdef ARGG
+	// adnan
+	// if we've been rotating it, set it to its proper new angles (change m_attachedAnglesPlayerSpace while modifier)
+	//Pickup_GetRotatedCarryAngles( pEntity, pPlayer, pPlayer->EntityToWorldTransform(), angles );
+	// added the ... && (mousedx | mousedy) so we dont have to calculate if no mouse movement
+	// UPDATE: m_vecRotatedCarryAngles has become a temp variable... can be cleaned up by using actual temp vars
+#ifdef CLIENT_DLL
+	if( m_bHasRotatedCarryAngles && (pPlayer->m_pCurrentCommand->mousedx || pPlayer->m_pCurrentCommand->mousedy) )
+#else
+	if( m_bHasRotatedCarryAngles && (pPlayer->GetCurrentCommand()->mousedx || pPlayer->GetCurrentCommand()->mousedy) )
+#endif
+	{
+		// method II: relative orientation
+		VMatrix vDeltaRotation, vCurrentRotation, vNewRotation;
+		
+		MatrixFromAngles( m_targetRotation, vCurrentRotation );
+
+#ifdef CLIENT_DLL
+		m_vecRotatedCarryAngles[YAW] = pPlayer->m_pCurrentCommand->mousedx*0.05;
+		m_vecRotatedCarryAngles[PITCH] = pPlayer->m_pCurrentCommand->mousedy*-0.05;
+#else
+		m_vecRotatedCarryAngles[YAW] = pPlayer->GetCurrentCommand()->mousedx*0.05;
+		m_vecRotatedCarryAngles[PITCH] = pPlayer->GetCurrentCommand()->mousedy*-0.05;
+#endif
+		m_vecRotatedCarryAngles[ROLL] = 0;
+		MatrixFromAngles( m_vecRotatedCarryAngles, vDeltaRotation );
+
+		MatrixMultiply(vDeltaRotation, vCurrentRotation, vNewRotation);
+		MatrixToAngles( vNewRotation, m_targetRotation );
+	}
+	// end adnan
+#endif
+
+	SetTargetPosition( m_targetPosition, m_targetRotation );
+
+	return true;
+}
+
+#ifdef ARGG
+// adnan
+// this is where we say that we dont want ot apply the current calculated view angles
+//-----------------------------------------------------------------------------
+// Purpose: Allow weapons to override mouse input to viewangles (for orbiting)
+//-----------------------------------------------------------------------------
+bool CWeaponGravityGun::OverrideViewAngles( void )
+{
+	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+	
+	if(!pPlayer)
+		return false;
+
+	if (m_bIsCurrentlyRotating) {
+		return true;
+	}
+
+	return false;
+}
+// end adnan
+#endif
+
+//=========================================================
+//=========================================================
+void CWeaponGravityGun::Spawn( )
+{
+	BaseClass::Spawn();
+//	SetModel( GetWorldModel() );
+
+	// The physgun uses a different skin
+	m_nSkin = PHYSGUN_SKIN;
+
+	FallInit();
+}
+
+void CWeaponGravityGun::OnRestore( void )
+{
+	BaseClass::OnRestore();
+
+	if ( m_gravCallback.m_controller )
+	{
+		m_gravCallback.m_controller->SetEventHandler( &m_gravCallback );
+	}
+}
+
+
+//=========================================================
+//=========================================================
+void CWeaponGravityGun::Precache( void )
+{
+	BaseClass::Precache();
+
+	g_physgunBeam1 = PrecacheModel(PHYSGUN_BEAM_SPRITE1);
+	g_physgunBeam = PrecacheModel(PHYSGUN_BEAM_SPRITE);
+	g_physgunGlow = PrecacheModel(PHYSGUN_BEAM_GLOW);
+
+	PrecacheScriptSound( "Weapon_Physgun.Scanning" );
+	PrecacheScriptSound( "Weapon_Physgun.LockedOn" );
+	PrecacheScriptSound( "Weapon_Physgun.Scanning" );
+	PrecacheScriptSound( "Weapon_Physgun.LightObject" );
+	PrecacheScriptSound( "Weapon_Physgun.HeavyObject" );
+}
+
+void CWeaponGravityGun::EffectCreate( void )
+{
+	EffectUpdate();
+	m_active = true;
+}
+
+
+// Andrew; added so we can trace both in EffectUpdate and DrawModel with the same results
+void CWeaponGravityGun::TraceLine( trace_t *ptr )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return;
+
+	Vector start, forward, right;
+	pOwner->EyeVectors( &forward, &right, NULL );
+
+	start = pOwner->Weapon_ShootPosition();
+	Vector end = start + forward * 4096;
+
+	// UTIL_TraceLine( start, end, MASK_SHOT, pOwner, COLLISION_GROUP_NONE, ptr );
+	UTIL_TraceLine( start, end, MASK_SHOT|CONTENTS_GRATE, pOwner, COLLISION_GROUP_NONE, ptr );
+}
+
+
+void CWeaponGravityGun::EffectUpdate( void )
+{
+	Vector start, forward, right;
+	trace_t tr;
+
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return;
+
+	pOwner->EyeVectors( &forward, &right, NULL );
+
+	start = pOwner->Weapon_ShootPosition();
+
+	TraceLine( &tr );
+	Vector end = tr.endpos;
+	float distance = tr.fraction * 4096;
+
+	if ( m_hObject == NULL && tr.DidHitNonWorldEntity() )
+	{
+		CBaseEntity *pEntity = tr.m_pEnt;
+		AttachObject( pEntity, GetPhysObjFromPhysicsBone( pEntity, tr.physicsbone ), tr.physicsbone, start, tr.endpos, distance );
+	}
+
+	// Add the incremental player yaw to the target transform
+	QAngle angles = m_gravCallback.TransformAnglesFromPlayerSpace( m_gravCallback.m_targetRotation, pOwner );
+
+	CBaseEntity *pObject = m_hObject;
+	if ( pObject )
+	{
+		if ( m_useDown )
+		{
+			if ( pOwner->m_afButtonPressed & IN_USE )
+			{
+				m_useDown = false;
+			}
+		}
+		else 
+		{
+			if ( pOwner->m_afButtonPressed & IN_USE )
+			{
+				m_useDown = true;
+			}
+		}
+
+		if ( m_useDown )
+		{
+#ifndef CLIENT_DLL
+			pOwner->SetPhysicsFlag( PFLAG_DIROVERRIDE, true );
+#endif
+			if ( pOwner->m_nButtons & IN_FORWARD )
+			{
+				m_distance = Approach( 1024, m_distance, gpGlobals->frametime * 100 );
+			}
+			if ( pOwner->m_nButtons & IN_BACK )
+			{
+				m_distance = Approach( 40, m_distance, gpGlobals->frametime * 100 );
+			}
+		}
+
+		if ( pOwner->m_nButtons & IN_WEAPON1 )
+		{
+			m_distance = Approach( 1024, m_distance, m_distance * 0.1 );
+#ifdef CLIENT_DLL
+			if ( gpGlobals->maxClients > 1 )
+			{
+				gHUD.m_bSkipClear = false;
+			}
+#endif
+		}
+		if ( pOwner->m_nButtons & IN_WEAPON2 )
+		{
+			m_distance = Approach( 40, m_distance, m_distance * 0.1 );
+#ifdef CLIENT_DLL
+			if ( gpGlobals->maxClients > 1 )
+			{
+				gHUD.m_bSkipClear = false;
+			}
+#endif
+		}
+
+		IPhysicsObject *pPhys = GetPhysObjFromPhysicsBone( pObject, m_physicsBone );
+		if ( pPhys )
+		{
+			if ( pPhys->IsAsleep() )
+			{
+				// on the odd chance that it's gone to sleep while under anti-gravity
+				pPhys->Wake();
+			}
+
+			Vector newPosition = start + forward * m_distance;
+			Vector offset;
+			pPhys->LocalToWorld( &offset, m_worldPosition );
+			Vector vecOrigin;
+			pPhys->GetPosition( &vecOrigin, NULL );
+			m_gravCallback.SetTargetPosition( newPosition + (vecOrigin - offset), angles );
+			Vector dir = (newPosition - pObject->GetLocalOrigin());
+			m_movementLength = dir.Length();
+		}
+	}
+	else
+	{
+		m_targetPosition = end;
+		//m_gravCallback.SetTargetPosition( end, m_gravCallback.m_targetRotation );
+	}
+}
+
+void CWeaponGravityGun::SoundCreate( void )
+{
+	m_soundState = SS_SCANNING;
+	SoundStart();
+}
+
+
+void CWeaponGravityGun::SoundDestroy( void )
+{
+	SoundStop();
+}
+
+
+void CWeaponGravityGun::SoundStop( void )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return;
+
+	switch( m_soundState )
+	{
+	case SS_SCANNING:
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndMotor );
+		m_sndMotor = NULL;
+		break;
+	case SS_LOCKEDON:
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndMotor );
+		m_sndMotor = NULL;
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndLockedOn );
+		m_sndLockedOn = NULL;
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndLightObject );
+		m_sndLightObject = NULL;
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndHeavyObject );
+		m_sndHeavyObject = NULL;
+		break;
+	}
+}
+
+
+
+//-----------------------------------------------------------------------------
+// Purpose: returns the linear fraction of value between low & high (0.0 - 1.0) * scale
+//			e.g. UTIL_LineFraction( 1.5, 1, 2, 1 ); will return 0.5 since 1.5 is
+//			halfway between 1 and 2
+// Input  : value - a value between low & high (clamped)
+//			low - the value that maps to zero
+//			high - the value that maps to "scale"
+//			scale - the output scale
+// Output : parametric fraction between low & high
+//-----------------------------------------------------------------------------
+static float UTIL_LineFraction( float value, float low, float high, float scale )
+{
+	if ( value < low )
+		value = low;
+	if ( value > high )
+		value = high;
+
+	float delta = high - low;
+	if ( delta == 0 )
+		return 0;
+	
+	return scale * (value-low) / delta;
+}
+
+void CWeaponGravityGun::SoundStart( void )
+{
+	CPASAttenuationFilter filter( this );
+
+	switch( m_soundState )
+	{
+	case SS_SCANNING:
+		{
+			m_sndMotor = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.Scanning", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndMotor, 1.0f, 100 );
+		}
+		break;
+	case SS_LOCKEDON:
+		{
+			m_sndLockedOn = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.LockedOn", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndLockedOn, 1.0f, 100 );
+			m_sndMotor = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.Scanning", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndMotor, 1.0f, 100 );
+			m_sndLightObject = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.LightObject", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndLightObject, 1.0f, 100 );
+			m_sndHeavyObject = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.HeavyObject", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndHeavyObject, 1.0f, 100 );
+		}
+		break;
+	}
+													//   volume, att, flags, pitch
+}
+
+void CWeaponGravityGun::SoundUpdate( void )
+{
+	int newState;
+	
+	if ( m_hObject )
+		newState = SS_LOCKEDON;
+	else
+		newState = SS_SCANNING;
+
+	if ( newState != m_soundState )
+	{
+		SoundStop();
+		m_soundState = newState;
+		SoundStart();
+	}
+
+	switch( m_soundState )
+	{
+	case SS_SCANNING:
+		break;
+	case SS_LOCKEDON:
+		{
+			CPASAttenuationFilter filter( this );
+
+			float height = m_hObject->GetAbsOrigin().z - m_originalObjectPosition.z;
+
+			// go from pitch 90 to 150 over a height of 500
+			int pitch = 90 + (int)UTIL_LineFraction( height, 0, 500, 60 );
+
+			assert(m_sndLockedOn!=NULL);
+			if ( m_sndLockedOn != NULL )
+			{
+				(CSoundEnvelopeController::GetController()).SoundChangePitch( m_sndLockedOn, pitch, 0.0f );
+			}
+
+			// attenutate the movement sounds over 200 units of movement
+			float distance = UTIL_LineFraction( m_movementLength, 0, 200, 1.0 );
+
+			// blend the "mass" sounds between 50 and 500 kg
+			IPhysicsObject *pPhys = GetPhysObjFromPhysicsBone( m_hObject, m_physicsBone );
+			if ( pPhys == NULL )
+			{
+				// we no longer exist!
+				break;
+			}
+			
+			float fade = UTIL_LineFraction( pPhys->GetMass(), 50, 500, 1.0 );
+
+			(CSoundEnvelopeController::GetController()).SoundChangeVolume( m_sndLightObject, fade * distance, 0.0f );
+
+			(CSoundEnvelopeController::GetController()).SoundChangeVolume( m_sndHeavyObject, (1.0 - fade) * distance, 0.0f );
+		}
+		break;
+	}
+}
+
+
+CBaseEntity *CWeaponGravityGun::GetBeamEntity()
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return NULL;
+
+	// Make sure I've got a view model
+	CBaseViewModel *vm = pOwner->GetViewModel();
+	if ( vm )
+		return vm;
+
+	return pOwner;
+}
+
+void CWeaponGravityGun::EffectDestroy( void )
+{
+#ifdef CLIENT_DLL
+	gHUD.m_bSkipClear = false;
+#endif
+	m_active = false;
+	SoundStop();
+
+	DetachObject();
+}
+
+void CWeaponGravityGun::UpdateObject( void )
+{
+	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+	Assert( pPlayer );
+
+	CBaseEntity *pObject = m_hObject;
+	if ( !pObject )
+		return;
+
+	if ( !m_gravCallback.UpdateObject( pPlayer, pObject ) )
+	{
+		DetachObject();
+		return;
+	}
+}
+
+void CWeaponGravityGun::DetachObject( void )
+{
+	if ( m_hObject )
+	{
+#ifndef CLIENT_DLL
+		CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+		Pickup_OnPhysGunDrop( m_hObject, pOwner, DROPPED_BY_CANNON );
+#endif
+
+		IPhysicsObject *pList[VPHYSICS_MAX_OBJECT_LIST_COUNT];
+		int count = m_hObject->VPhysicsGetObjectList( pList, ARRAYSIZE(pList) );
+		for ( int i = 0; i < count; i++ )
+		{
+			PhysClearGameFlags( pList[i], FVPHYSICS_PLAYER_HELD );
+		}
+		m_gravCallback.DetachEntity();
+		m_hObject = NULL;
+		m_physicsBone = 0;
+	}
+}
+
+void CWeaponGravityGun::AttachObject( CBaseEntity *pObject, IPhysicsObject *pPhysics, short physicsbone, const Vector& start, const Vector &end, float distance )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if( !pOwner )
+		return;
+	m_hObject = pObject;
+	m_physicsBone = physicsbone;
+	m_useDown = false;
+	if ( pPhysics && pObject->GetMoveType() == MOVETYPE_VPHYSICS )
+	{
+		m_distance = distance;
+
+		Vector worldPosition;
+		pPhysics->WorldToLocal( &worldPosition, end );
+		m_worldPosition = worldPosition;
+		Vector vecOrigin;
+		pPhysics->GetPosition( &vecOrigin, NULL );
+		m_gravCallback.AttachEntity( pOwner, pObject, pPhysics, physicsbone, vecOrigin );
+
+		m_originalObjectPosition = vecOrigin;
+
+		pPhysics->Wake();
+		IPhysicsObject *pList[VPHYSICS_MAX_OBJECT_LIST_COUNT];
+		int count = pObject->VPhysicsGetObjectList( pList, ARRAYSIZE(pList) );
+		for ( int i = 0; i < count; i++ )
+		{
+			PhysSetGameFlags( pList[i], FVPHYSICS_PLAYER_HELD );
+		}
+
+#ifndef CLIENT_DLL
+		Pickup_OnPhysGunPickup( pObject, pOwner );
+#endif
+	}
+	else
+	{
+		m_hObject = NULL;
+		m_physicsBone = 0;
+	}
+}
+
+//=========================================================
+//=========================================================
+void CWeaponGravityGun::PrimaryAttack( void )
+{
+	if ( !m_active )
+	{
+		SendWeaponAnim( ACT_VM_PRIMARYATTACK );
+		EffectCreate();
+		SoundCreate();
+	}
+	else
+	{
+		EffectUpdate();
+		SoundUpdate();
+	}
+}
+
+void CWeaponGravityGun::SecondaryAttack( void )
+{
+	return;
+}
+
+#ifdef CLIENT_DLL
+//-----------------------------------------------------------------------------
+// Purpose: Third-person function call to render world model
+//-----------------------------------------------------------------------------
+int CWeaponGravityGun::DrawModel( int flags )
+{
+	// Only render these on the transparent pass
+	if ( flags & STUDIO_TRANSPARENCY )
+	{
+		if ( !m_active )
+			return 0;
+
+		C_BasePlayer *pOwner = ToBasePlayer( GetOwner() );
+
+		if ( !pOwner )
+			return 0;
+
+		Vector points[3];
+		QAngle tmpAngle;
+
+		C_BaseEntity *pObject = m_hObject;
+		//if ( pObject == NULL )
+		//	return 0;
+
+		GetAttachment( 1, points[0], tmpAngle );
+
+		// a little noise 11t & 13t should be somewhat non-periodic looking
+		//points[1].z += 4*sin( gpGlobals->curtime*11 ) + 5*cos( gpGlobals->curtime*13 );
+		if ( pObject == NULL )
+		{
+			//points[2] = m_targetPosition;
+			trace_t tr;
+			TraceLine( &tr );
+			points[2] = tr.endpos;
+		}
+		else
+		{
+			pObject->EntityToWorldSpace( m_worldPosition, &points[2] );
+		}
+
+		Vector forward, right, up;
+		QAngle playerAngles = pOwner->EyeAngles();
+		AngleVectors( playerAngles, &forward, &right, &up );
+		if ( pObject == NULL )
+		{
+			Vector vecDir = points[2] - points[0];
+			VectorNormalize( vecDir );
+			points[1] = points[0] + 0.5f * (vecDir * points[2].DistTo(points[0]));
+		}
+		else
+		{
+			Vector vecSrc = pOwner->Weapon_ShootPosition( );
+			points[1] = vecSrc + 0.5f * (forward * points[2].DistTo(points[0]));
+		}
+		
+		IMaterial *pMat = materials->FindMaterial( "sprites/physbeam1", TEXTURE_GROUP_CLIENT_EFFECTS );
+		if ( pObject )
+			pMat = materials->FindMaterial( "sprites/physbeam", TEXTURE_GROUP_CLIENT_EFFECTS );
+		Vector color;
+		color.Init(1,1,1);
+
+		float scrollOffset = gpGlobals->curtime - (int)gpGlobals->curtime;
+		CMatRenderContextPtr pRenderContext( materials );
+		pRenderContext->Bind( pMat );
+		DrawBeamQuadratic( points[0], points[1], points[2], pObject ? 13/3.0f : 13/5.0f, color, scrollOffset );
+		DrawBeamQuadratic( points[0], points[1], points[2], pObject ? 13/3.0f : 13/5.0f, color, -scrollOffset );
+
+		IMaterial *pMaterial = materials->FindMaterial( "sprites/physglow", TEXTURE_GROUP_CLIENT_EFFECTS );
+
+		color32 clr={0,64,255,255};
+		if ( pObject )
+		{
+			clr.r = 186;
+			clr.g = 253;
+			clr.b = 247;
+			clr.a = 255;
+		}
+
+		float scale = random->RandomFloat( 3, 5 ) * ( pObject ? 3 : 2 );
+
+		// Draw the sprite
+		pRenderContext->Bind( pMaterial );
+		for ( int i = 0; i < 3; i++ )
+		{
+			DrawSprite( points[2], scale, scale, clr );
+		}
+		return 1;
+	}
+
+	// Only do this on the opaque pass
+	return BaseClass::DrawModel( flags );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: First-person function call after viewmodel has been drawn
+//-----------------------------------------------------------------------------
+void CWeaponGravityGun::ViewModelDrawn( C_BaseViewModel *pBaseViewModel )
+{
+	if ( !m_active )
+		return;
+
+	// Render our effects
+	C_BasePlayer *pOwner = ToBasePlayer( GetOwner() );
+
+	if ( !pOwner )
+		return;
+
+	Vector points[3];
+	QAngle tmpAngle;
+
+	C_BaseEntity *pObject = m_hObject;
+	//if ( pObject == NULL )
+	//	return;
+
+	pBaseViewModel->GetAttachment( 1, points[0], tmpAngle );
+
+	// a little noise 11t & 13t should be somewhat non-periodic looking
+	//points[1].z += 4*sin( gpGlobals->curtime*11 ) + 5*cos( gpGlobals->curtime*13 );
+	if ( pObject == NULL )
+	{
+		//points[2] = m_targetPosition;
+		trace_t tr;
+		TraceLine( &tr );
+		points[2] = tr.endpos;
+	}
+	else
+	{
+		pObject->EntityToWorldSpace(m_worldPosition, &points[2]);
+	}
+
+	Vector forward, right, up;
+	QAngle playerAngles = pOwner->EyeAngles();
+	AngleVectors( playerAngles, &forward, &right, &up );
+	Vector vecSrc = pOwner->Weapon_ShootPosition( );
+	points[1] = vecSrc + 0.5f * (forward * points[2].DistTo(points[0]));
+	
+	IMaterial *pMat = materials->FindMaterial( "sprites/physbeam1", TEXTURE_GROUP_CLIENT_EFFECTS );
+	if ( pObject )
+		pMat = materials->FindMaterial( "sprites/physbeam", TEXTURE_GROUP_CLIENT_EFFECTS );
+	Vector color;
+	color.Init(1,1,1);
+
+	// Now draw it.
+	CViewSetup beamView = *view->GetPlayerViewSetup();
+
+	Frustum dummyFrustum;
+	render->Push3DView( beamView, 0, NULL, dummyFrustum );
+
+	float scrollOffset = gpGlobals->curtime - (int)gpGlobals->curtime;
+	CMatRenderContextPtr pRenderContext( materials );
+	pRenderContext->Bind( pMat );
+#if 1
+	// HACK HACK:  Munge the depth range to prevent view model from poking into walls, etc.
+	// Force clipped down range
+	pRenderContext->DepthRange( 0.1f, 0.2f );
+#endif
+	DrawBeamQuadratic( points[0], points[1], points[2], pObject ? 13/3.0f : 13/5.0f, color, scrollOffset );
+	DrawBeamQuadratic( points[0], points[1], points[2], pObject ? 13/3.0f : 13/5.0f, color, -scrollOffset );
+
+	IMaterial *pMaterial = materials->FindMaterial( "sprites/physglow", TEXTURE_GROUP_CLIENT_EFFECTS );
+
+	color32 clr={0,64,255,255};
+	if ( pObject )
+	{
+		clr.r = 186;
+		clr.g = 253;
+		clr.b = 247;
+		clr.a = 255;
+	}
+
+	float scale = random->RandomFloat( 3, 5 ) * ( pObject ? 3 : 2 );
+
+	// Draw the sprite
+	pRenderContext->Bind( pMaterial );
+	for ( int i = 0; i < 3; i++ )
+	{
+		DrawSprite( points[2], scale, scale, clr );
+	}
+#if 1
+	pRenderContext->DepthRange( 0.0f, 1.0f );
+#endif
+
+	render->PopView( dummyFrustum );
+
+	// Pass this back up
+	BaseClass::ViewModelDrawn( pBaseViewModel );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: We are always considered transparent
+//-----------------------------------------------------------------------------
+bool CWeaponGravityGun::IsTransparent( void )
+{
+	return true;
+}
+
+#endif
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+void CWeaponGravityGun::ItemPreFrame()
+{
+	BaseClass::ItemPreFrame();
+
+#ifndef CLIENT_DLL
+	// Update the object if the weapon is switched on.
+	if( m_active )
+	{
+		UpdateObject();
+	}
+#endif
+}
+
+
+void CWeaponGravityGun::ItemPostFrame( void )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if (!pOwner)
+		return;
+
+#ifdef ARGG
+	// adnan
+	// this is where we check if we're orbiting the object
+	
+	// if we're holding something and pressing use,
+	//  then set us in the orbiting state
+	//  - this will indicate to OverrideMouseInput that we should zero the input and update our delta angles
+	//  UPDATE: not anymore.  now this just sets our state variables.
+	CBaseEntity *pObject = m_hObject;
+	if( pObject ) {
+
+		if((pOwner->m_nButtons & IN_ATTACK) && (pOwner->m_nButtons & IN_USE) ) {
+			m_gravCallback.m_bHasRotatedCarryAngles = true;
+			
+			// did we JUST hit use?
+			//  if so, grab the current angles to begin with as the rotated angles
+			if( !(pOwner->m_afButtonLast & IN_USE) ) {
+				m_gravCallback.m_vecRotatedCarryAngles = pObject->GetAbsAngles();
+			}
+
+			m_bIsCurrentlyRotating = true;
+		} else {
+			m_gravCallback.m_bHasRotatedCarryAngles = false;
+
+			m_bIsCurrentlyRotating = false;
+		}
+	} else {
+		m_bIsCurrentlyRotating = false;
+
+		m_gravCallback.m_bHasRotatedCarryAngles = false;
+	}
+	// end adnan
+#endif
+
+	if ( pOwner->m_nButtons & IN_ATTACK )
+	{
+#if defined( ARGG )
+		if( (pOwner->m_nButtons & IN_USE) ) {
+			pOwner->m_vecUseAngles = pOwner->pl.v_angle;
+		}
+#endif
+		if ( pOwner->m_afButtonPressed & IN_ATTACK2 )
+		{
+			SecondaryAttack();
+		}
+		else if ( pOwner->m_nButtons & IN_ATTACK2 )
+		{
+			if ( m_active )
+			{
+				EffectDestroy();
+				SoundDestroy();
+			}
+			WeaponIdle( );
+			return;
+		}
+		PrimaryAttack();
+	}
+	else 
+	{
+		if ( m_active )
+		{
+			EffectDestroy();
+			SoundDestroy();
+		}
+		WeaponIdle( );
+		return;
+	}
+	if ( pOwner->m_afButtonPressed & IN_RELOAD )
+	{
+		Reload();
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Output : Returns true on success, false on failure.
+//-----------------------------------------------------------------------------
+bool CWeaponGravityGun::HasAnyAmmo( void )
+{
+	//Always report that we have ammo
+	return true;
+}
+
+//=========================================================
+//=========================================================
+bool CWeaponGravityGun::Reload( void )
+{
+	return false;
+}
diff --git a/src/game/shared/hl2mp/weapon_physgun_argg.cpp b/src/game/shared/hl2mp/weapon_physgun_argg.cpp
new file mode 100644
index 0000000..3454c17
--- /dev/null
+++ b/src/game/shared/hl2mp/weapon_physgun_argg.cpp
@@ -0,0 +1,1331 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#include "cbase.h"
+#include "beam_shared.h"
+#ifndef CLIENT_DLL
+#include "player.h"
+#endif
+#include "gamerules.h"
+#ifdef CLIENT_DLL
+#include "ClientEffectPrecacheSystem.h"
+#endif
+#include "weapon_hl2mpbasehlmpcombatweapon.h"
+#ifndef CLIENT_DLL
+#include "baseviewmodel.h"
+#endif
+#include "vphysics/constraints.h"
+#include "physics.h"
+#include "in_buttons.h"
+#include "IEffects.h"
+#include "soundenvelope.h"
+#include "engine/IEngineSound.h"
+#ifndef CLIENT_DLL
+#include "ndebugoverlay.h"
+#endif
+#include "physics_saverestore.h"
+#ifndef CLIENT_DLL
+#include "player_pickup.h"
+#endif
+#include "soundemittersystem/isoundemittersystembase.h"
+#ifdef CLIENT_DLL
+#include "model_types.h"
+#include "view_shared.h"
+#include "view.h"
+#include "iviewrender.h"
+#endif
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int g_physgunBeam;
+#define PHYSGUN_BEAM_SPRITE		"sprites/physbeam.vmt"
+
+#define	PHYSGUN_SKIN	1
+
+class CWeaponGravityGun;
+
+#ifdef CLIENT_DLL
+CLIENTEFFECT_REGISTER_BEGIN( PrecacheEffectGravityGun )
+CLIENTEFFECT_MATERIAL( "sprites/physbeam" )
+CLIENTEFFECT_REGISTER_END()
+
+
+#endif
+
+class CGravControllerPoint : public IMotionEvent
+{
+	DECLARE_SIMPLE_DATADESC();
+
+public:
+	CGravControllerPoint( void );
+	~CGravControllerPoint( void );
+	void AttachEntity( CBasePlayer *pPlayer, CBaseEntity *pEntity, IPhysicsObject *pPhys, const Vector &position );
+	void DetachEntity( void );
+
+	bool UpdateObject( CBasePlayer *pPlayer, CBaseEntity *pEntity );
+
+	void SetTargetPosition( const Vector &target, const QAngle &targetOrientation )
+	{
+		m_shadow.targetPosition = target;
+		m_shadow.targetRotation = targetOrientation;
+
+		m_timeToArrive = gpGlobals->frametime;
+
+		CBaseEntity *pAttached = m_attachedEntity;
+		if ( pAttached )
+		{
+			IPhysicsObject *pObj = pAttached->VPhysicsGetObject();
+			
+			if ( pObj != NULL )
+			{
+				pObj->Wake();
+			}
+			else
+			{
+				DetachEntity();
+			}
+		}
+	}
+	QAngle TransformAnglesToPlayerSpace( const QAngle &anglesIn, CBasePlayer *pPlayer );
+	QAngle TransformAnglesFromPlayerSpace( const QAngle &anglesIn, CBasePlayer *pPlayer );
+
+	IMotionEvent::simresult_e Simulate( IPhysicsMotionController *pController, IPhysicsObject *pObject, float deltaTime, Vector &linear, AngularImpulse &angular );
+	Vector			m_localPosition;
+	Vector			m_targetPosition;
+	Vector			m_worldPosition;
+	float			m_saveDamping;
+	float			m_saveMass;
+	float			m_maxAcceleration;
+	Vector			m_maxAngularAcceleration;
+	EHANDLE			m_attachedEntity;
+	QAngle			m_targetRotation;
+	float			m_timeToArrive;
+
+#ifdef ARGG
+	// adnan
+	// set up the modified pickup angles... allow the player to rotate the object in their grip
+	QAngle		m_vecRotatedCarryAngles;
+	bool			m_bHasRotatedCarryAngles;
+	// end adnan
+#endif
+
+	IPhysicsMotionController *m_controller;
+
+private:
+	hlshadowcontrol_params_t	m_shadow;
+};
+
+
+BEGIN_SIMPLE_DATADESC( CGravControllerPoint )
+
+	DEFINE_FIELD( m_localPosition,		FIELD_VECTOR ),
+	DEFINE_FIELD( m_targetPosition,		FIELD_POSITION_VECTOR ),
+	DEFINE_FIELD( m_worldPosition,		FIELD_POSITION_VECTOR ),
+	DEFINE_FIELD( m_saveDamping,			FIELD_FLOAT ),
+	DEFINE_FIELD( m_saveMass,			FIELD_FLOAT ),
+	DEFINE_FIELD( m_maxAcceleration,		FIELD_FLOAT ),
+	DEFINE_FIELD( m_maxAngularAcceleration,	FIELD_VECTOR ),
+	DEFINE_FIELD( m_attachedEntity,		FIELD_EHANDLE ),
+	DEFINE_FIELD( m_targetRotation,		FIELD_VECTOR ),
+	DEFINE_FIELD( m_timeToArrive,			FIELD_FLOAT ),
+#ifdef ARGG
+	// adnan
+	// set up the fields for our added vars
+	DEFINE_FIELD( m_vecRotatedCarryAngles, FIELD_VECTOR ),
+	DEFINE_FIELD( m_bHasRotatedCarryAngles, FIELD_BOOLEAN ),
+	// end adnan
+#endif
+
+	// Physptrs can't be saved in embedded classes... this is to silence classcheck
+	// DEFINE_PHYSPTR( m_controller ),
+
+END_DATADESC()
+
+
+CGravControllerPoint::CGravControllerPoint( void )
+{
+	m_shadow.dampFactor = 0.8;
+	m_shadow.teleportDistance = 0;
+	// make this controller really stiff!
+	m_shadow.maxSpeed = 5000;
+	m_shadow.maxAngular = m_shadow.maxSpeed;
+	m_shadow.maxDampSpeed = m_shadow.maxSpeed*2;
+	m_shadow.maxDampAngular = m_shadow.maxAngular*2;
+	m_attachedEntity = NULL;
+
+#ifdef ARGG
+	// adnan
+	// initialize our added vars
+	m_vecRotatedCarryAngles = vec3_angle;
+	m_bHasRotatedCarryAngles = false;
+	// end adnan
+#endif
+}
+
+CGravControllerPoint::~CGravControllerPoint( void )
+{
+	DetachEntity();
+}
+
+
+QAngle CGravControllerPoint::TransformAnglesToPlayerSpace( const QAngle &anglesIn, CBasePlayer *pPlayer )
+{
+	matrix3x4_t test;
+	QAngle angleTest = pPlayer->EyeAngles();
+	angleTest.x = 0;
+	AngleMatrix( angleTest, test );
+	return TransformAnglesToLocalSpace( anglesIn, test );
+}
+
+QAngle CGravControllerPoint::TransformAnglesFromPlayerSpace( const QAngle &anglesIn, CBasePlayer *pPlayer )
+{
+	matrix3x4_t test;
+	QAngle angleTest = pPlayer->EyeAngles();
+	angleTest.x = 0;
+	AngleMatrix( angleTest, test );
+	return TransformAnglesToWorldSpace( anglesIn, test );
+}
+
+
+void CGravControllerPoint::AttachEntity( CBasePlayer *pPlayer, CBaseEntity *pEntity, IPhysicsObject *pPhys, const Vector &vGrabPosition )
+{
+	m_attachedEntity = pEntity;
+	pPhys->WorldToLocal( &m_localPosition, vGrabPosition );
+	m_worldPosition = vGrabPosition;
+	pPhys->GetDamping( NULL, &m_saveDamping );
+	m_saveMass = pPhys->GetMass();
+	float damping = 2;
+	pPhys->SetDamping( NULL, &damping );
+	pPhys->SetMass( 50000 );
+	m_controller = physenv->CreateMotionController( this );
+	m_controller->AttachObject( pPhys, true );
+	Vector position;
+	QAngle angles;
+	pPhys->GetPosition( &position, &angles );
+	SetTargetPosition( vGrabPosition, angles );
+	m_targetRotation = TransformAnglesToPlayerSpace( angles, pPlayer );
+#ifdef ARGG
+	// adnan
+	// we need to grab the preferred/non preferred carry angles here for the rotatedcarryangles
+	m_vecRotatedCarryAngles = m_targetRotation;
+	// end adnan
+#endif
+}
+
+void CGravControllerPoint::DetachEntity( void )
+{
+	CBaseEntity *pEntity = m_attachedEntity;
+	if ( pEntity )
+	{
+		IPhysicsObject *pPhys = pEntity->VPhysicsGetObject();
+		if ( pPhys )
+		{
+			// on the odd chance that it's gone to sleep while under anti-gravity
+			pPhys->Wake();
+			pPhys->SetDamping( NULL, &m_saveDamping );
+			pPhys->SetMass( m_saveMass );
+		}
+	}
+	m_attachedEntity = NULL;
+	if ( physenv )
+	{
+		physenv->DestroyMotionController( m_controller );
+	}
+	m_controller = NULL;
+
+	// UNDONE: Does this help the networking?
+	m_targetPosition = vec3_origin;
+	m_worldPosition = vec3_origin;
+}
+
+void AxisAngleQAngle( const Vector &axis, float angle, QAngle &outAngles )
+{
+	// map back to HL rotation axes
+	outAngles.z = axis.x * angle;
+	outAngles.x = axis.y * angle;
+	outAngles.y = axis.z * angle;
+}
+
+IMotionEvent::simresult_e CGravControllerPoint::Simulate( IPhysicsMotionController *pController, IPhysicsObject *pObject, float deltaTime, Vector &linear, AngularImpulse &angular )
+{
+	hlshadowcontrol_params_t shadowParams = m_shadow;
+#ifndef CLIENT_DLL
+	m_timeToArrive = pObject->ComputeShadowControl( shadowParams, m_timeToArrive, deltaTime );
+#else
+	m_timeToArrive = pObject->ComputeShadowControl( shadowParams, (TICK_INTERVAL*2), deltaTime );
+#endif
+	
+	linear.Init();
+	angular.Init();
+
+	return SIM_LOCAL_ACCELERATION;
+}
+
+
+#ifdef CLIENT_DLL
+#define CWeaponGravityGun C_WeaponGravityGun
+#endif
+
+class CWeaponGravityGun : public CBaseHL2MPCombatWeapon
+{
+	DECLARE_DATADESC();
+
+public:
+	DECLARE_CLASS( CWeaponGravityGun, CBaseHL2MPCombatWeapon );
+
+	DECLARE_NETWORKCLASS();
+	DECLARE_PREDICTABLE();
+
+	CWeaponGravityGun();
+
+#ifdef CLIENT_DLL
+	void GetRenderBounds( Vector& mins, Vector& maxs )
+	{
+		BaseClass::GetRenderBounds( mins, maxs );
+
+		// add to the bounds, don't clear them.
+		// ClearBounds( mins, maxs );
+		AddPointToBounds( vec3_origin, mins, maxs );
+		AddPointToBounds( m_targetPosition, mins, maxs );
+		AddPointToBounds( m_worldPosition, mins, maxs );
+		CBaseEntity *pEntity = GetBeamEntity();
+		if ( pEntity )
+		{
+			mins -= pEntity->GetRenderOrigin();
+			maxs -= pEntity->GetRenderOrigin();
+		}
+	}
+
+	void GetRenderBoundsWorldspace( Vector& mins, Vector& maxs )
+	{
+		BaseClass::GetRenderBoundsWorldspace( mins, maxs );
+
+		// add to the bounds, don't clear them.
+		// ClearBounds( mins, maxs );
+		AddPointToBounds( vec3_origin, mins, maxs );
+		AddPointToBounds( m_targetPosition, mins, maxs );
+		AddPointToBounds( m_worldPosition, mins, maxs );
+		mins -= GetRenderOrigin();
+		maxs -= GetRenderOrigin();
+	}
+
+	int KeyInput( int down, ButtonCode_t keynum, const char *pszCurrentBinding )
+	{
+		if ( gHUD.m_iKeyBits & IN_ATTACK )
+		{
+			switch ( keynum )
+			{
+			case MOUSE_WHEEL_UP:
+				m_bInWeapon1 = true;
+				// gHUD.m_iKeyBits |= IN_WEAPON1;
+				if ( gpGlobals->maxClients > 1 )
+					gHUD.m_bSkipClear = true;
+				return 0;
+
+			case MOUSE_WHEEL_DOWN:
+				m_bInWeapon2 = true;
+				// gHUD.m_iKeyBits |= IN_WEAPON2;
+				if ( gpGlobals->maxClients > 1 )
+					gHUD.m_bSkipClear = true;
+				return 0;
+			}
+		}
+
+		// Allow engine to process
+		return BaseClass::KeyInput( down, keynum, pszCurrentBinding );
+	}
+
+	void HandleInput()
+	{
+		if ( m_bInWeapon1 )
+		{
+			gHUD.m_iKeyBits |= IN_WEAPON1;
+			m_bInWeapon1 = false;
+		}
+
+		if ( m_bInWeapon2 )
+		{
+			gHUD.m_iKeyBits |= IN_WEAPON2;
+			m_bInWeapon2 = false;
+		}
+	}
+
+	int	 DrawModel( int flags );
+	void ViewModelDrawn( C_BaseViewModel *pBaseViewModel );
+	bool IsTransparent( void );
+
+	// We need to render opaque and translucent pieces
+	RenderGroup_t	GetRenderGroup( void ) {	return RENDER_GROUP_TWOPASS;	}
+#endif
+
+	void Spawn( void );
+	void OnRestore( void );
+	void Precache( void );
+
+#ifdef ARGG
+	// adnan
+	// for overriding the mouse -> view angles (but still calc view angles)
+	bool OverrideViewAngles( void );
+	// end adnan
+#endif
+
+	virtual void	UpdateOnRemove(void);
+	void PrimaryAttack( void );
+	void SecondaryAttack( void );
+	void ItemPreFrame( void );
+	void ItemPostFrame( void );
+	virtual bool Holster( CBaseCombatWeapon *pSwitchingTo )
+	{
+		EffectDestroy();
+		SoundDestroy();
+		return BaseClass::Holster( pSwitchingTo );
+	}
+
+	bool Reload( void );
+	void Drop(const Vector &vecVelocity)
+	{
+		EffectDestroy();
+		SoundDestroy();
+
+#ifndef CLIENT_DLL
+		UTIL_Remove( this );
+#endif
+	}
+
+	bool HasAnyAmmo( void );
+
+	void AttachObject( CBaseEntity *pEdict, const Vector& start, const Vector &end, float distance );
+	void UpdateObject( void );
+	void DetachObject( void );
+
+	void TraceLine( trace_t *ptr );
+
+	void EffectCreate( void );
+	void EffectUpdate( void );
+	void EffectDestroy( void );
+
+	void SoundCreate( void );
+	void SoundDestroy( void );
+	void SoundStop( void );
+	void SoundStart( void );
+	void SoundUpdate( void );
+
+	int ObjectCaps( void ) 
+	{ 
+		int caps = BaseClass::ObjectCaps();
+		if ( m_active )
+		{
+			caps |= FCAP_DIRECTIONAL_USE;
+		}
+		return caps;
+	}
+
+	CBaseEntity *GetBeamEntity();
+
+private:
+	CNetworkVar( int, m_active );
+	bool		m_useDown;
+	CNetworkHandle( CBaseEntity, m_hObject );
+	float		m_distance;
+	float		m_movementLength;
+	int			m_soundState;
+	Vector		m_originalObjectPosition;
+	CNetworkVector	( m_targetPosition );
+	CNetworkVector	( m_worldPosition );
+
+#ifdef ARGG
+	// adnan
+	// this is how we tell if we're rotating what we're holding
+	CNetworkVar( bool, m_bIsCurrentlyRotating );
+	// end adnan
+#endif
+
+	CSoundPatch					*m_sndMotor;		// Whirring sound for the gun
+	CSoundPatch					*m_sndLockedOn;
+	CSoundPatch					*m_sndLightObject;
+	CSoundPatch					*m_sndHeavyObject;
+
+	CGravControllerPoint		m_gravCallback;
+
+	bool		m_bInWeapon1;
+	bool		m_bInWeapon2;
+
+	DECLARE_ACTTABLE();
+};
+
+IMPLEMENT_NETWORKCLASS_ALIASED( WeaponGravityGun, DT_WeaponGravityGun )
+
+BEGIN_NETWORK_TABLE( CWeaponGravityGun, DT_WeaponGravityGun )
+#ifdef CLIENT_DLL
+	RecvPropEHandle( RECVINFO( m_hObject ) ),
+	RecvPropVector( RECVINFO( m_targetPosition ) ),
+	RecvPropVector( RECVINFO( m_worldPosition ) ),
+	RecvPropInt( RECVINFO(m_active) ),
+#ifdef ARGG
+	// adnan
+	// also receive if we're rotating what we're holding (by pressing use)
+	RecvPropBool( RECVINFO( m_bIsCurrentlyRotating ) ),
+	// end adnan
+#endif
+#else
+	SendPropEHandle( SENDINFO( m_hObject ) ),
+	SendPropVector(SENDINFO( m_targetPosition ), -1, SPROP_COORD),
+	SendPropVector(SENDINFO( m_worldPosition ), -1, SPROP_COORD),
+	SendPropInt( SENDINFO(m_active), 1, SPROP_UNSIGNED ),
+#ifdef ARGG
+	// adnan
+	// need to seind if we're rotating what we're holding
+	SendPropBool( SENDINFO( m_bIsCurrentlyRotating ) ),
+	// end adnan
+#endif
+#endif
+END_NETWORK_TABLE()
+
+#ifdef CLIENT_DLL
+BEGIN_PREDICTION_DATA( CWeaponGravityGun )
+END_PREDICTION_DATA()
+#endif
+
+LINK_ENTITY_TO_CLASS( weapon_physgun, CWeaponGravityGun );
+PRECACHE_WEAPON_REGISTER(weapon_physgun);
+
+acttable_t	CWeaponGravityGun::m_acttable[] = 
+{
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PHYSGUN,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PHYSGUN,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PHYSGUN,					false },
+};
+
+IMPLEMENT_ACTTABLE(CWeaponGravityGun);
+
+
+//---------------------------------------------------------
+// Save/Restore
+//---------------------------------------------------------
+BEGIN_DATADESC( CWeaponGravityGun )
+
+	DEFINE_FIELD( m_active,				FIELD_INTEGER ),
+	DEFINE_FIELD( m_useDown,				FIELD_BOOLEAN ),
+	DEFINE_FIELD( m_hObject,				FIELD_EHANDLE ),
+	DEFINE_FIELD( m_distance,			FIELD_FLOAT ),
+	DEFINE_FIELD( m_movementLength,		FIELD_FLOAT ),
+	DEFINE_FIELD( m_soundState,			FIELD_INTEGER ),
+	DEFINE_FIELD( m_originalObjectPosition,	FIELD_POSITION_VECTOR ),
+#ifdef ARGG
+	// adnan
+	DEFINE_FIELD( m_bIsCurrentlyRotating, FIELD_BOOLEAN ),
+	// end adnan
+#endif
+	DEFINE_SOUNDPATCH( m_sndMotor ),
+	DEFINE_SOUNDPATCH( m_sndLockedOn ),
+	DEFINE_SOUNDPATCH( m_sndLightObject ),
+	DEFINE_SOUNDPATCH( m_sndHeavyObject ),
+	DEFINE_EMBEDDED( m_gravCallback ),
+	// Physptrs can't be saved in embedded classes..
+	DEFINE_PHYSPTR( m_gravCallback.m_controller ),
+
+END_DATADESC()
+
+
+enum physgun_soundstate { SS_SCANNING, SS_LOCKEDON };
+enum physgun_soundIndex { SI_LOCKEDON = 0, SI_SCANNING = 1, SI_LIGHTOBJECT = 2, SI_HEAVYOBJECT = 3, SI_ON, SI_OFF };
+
+
+//=========================================================
+//=========================================================
+
+CWeaponGravityGun::CWeaponGravityGun()
+{
+	m_active = false;
+	m_bFiresUnderwater = true;
+	m_bInWeapon1 = false;
+	m_bInWeapon2 = false;
+}
+
+
+//-----------------------------------------------------------------------------
+// On Remove
+//-----------------------------------------------------------------------------
+void CWeaponGravityGun::UpdateOnRemove(void)
+{
+	EffectDestroy();
+	SoundDestroy();
+	BaseClass::UpdateOnRemove();
+}
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+// adnan
+// want to add an angles modifier key
+bool CGravControllerPoint::UpdateObject( CBasePlayer *pPlayer, CBaseEntity *pEntity )
+{
+	if ( !pEntity || !pEntity->VPhysicsGetObject() )
+	{
+		return false;
+	}
+
+#ifdef ARGG
+	// adnan
+	// if we've been rotating it, set it to its proper new angles (change m_attachedAnglesPlayerSpace while modifier)
+	//Pickup_GetRotatedCarryAngles( pEntity, pPlayer, pPlayer->EntityToWorldTransform(), angles );
+	// added the ... && (mousedx | mousedy) so we dont have to calculate if no mouse movement
+	// UPDATE: m_vecRotatedCarryAngles has become a temp variable... can be cleaned up by using actual temp vars
+#ifdef CLIENT_DLL
+	if( m_bHasRotatedCarryAngles && (pPlayer->m_pCurrentCommand->mousedx || pPlayer->m_pCurrentCommand->mousedy) )
+#else
+	if( m_bHasRotatedCarryAngles && (pPlayer->GetCurrentCommand()->mousedx || pPlayer->GetCurrentCommand()->mousedy) )
+#endif
+	{
+		// method II: relative orientation
+		VMatrix vDeltaRotation, vCurrentRotation, vNewRotation;
+		
+		MatrixFromAngles( m_targetRotation, vCurrentRotation );
+
+#ifdef CLIENT_DLL
+		m_vecRotatedCarryAngles[YAW] = pPlayer->m_pCurrentCommand->mousedx*0.05;
+		m_vecRotatedCarryAngles[PITCH] = pPlayer->m_pCurrentCommand->mousedy*-0.05;
+#else
+		m_vecRotatedCarryAngles[YAW] = pPlayer->GetCurrentCommand()->mousedx*0.05;
+		m_vecRotatedCarryAngles[PITCH] = pPlayer->GetCurrentCommand()->mousedy*-0.05;
+#endif
+		m_vecRotatedCarryAngles[ROLL] = 0;
+		MatrixFromAngles( m_vecRotatedCarryAngles, vDeltaRotation );
+
+		MatrixMultiply(vDeltaRotation, vCurrentRotation, vNewRotation);
+		MatrixToAngles( vNewRotation, m_targetRotation );
+	}
+	// end adnan
+#endif
+
+	SetTargetPosition( m_targetPosition, m_targetRotation );
+
+	return true;
+}
+
+#ifdef ARGG
+// adnan
+// this is where we say that we dont want ot apply the current calculated view angles
+//-----------------------------------------------------------------------------
+// Purpose: Allow weapons to override mouse input to viewangles (for orbiting)
+//-----------------------------------------------------------------------------
+bool CWeaponGravityGun::OverrideViewAngles( void )
+{
+	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+	
+	if(!pPlayer)
+		return false;
+
+	if (m_bIsCurrentlyRotating) {
+		return true;
+	}
+
+	return false;
+}
+// end adnan
+#endif
+
+//=========================================================
+//=========================================================
+void CWeaponGravityGun::Spawn( )
+{
+	BaseClass::Spawn();
+//	SetModel( GetWorldModel() );
+
+	// The physgun uses a different skin
+	m_nSkin = PHYSGUN_SKIN;
+
+	FallInit();
+}
+
+void CWeaponGravityGun::OnRestore( void )
+{
+	BaseClass::OnRestore();
+
+	if ( m_gravCallback.m_controller )
+	{
+		m_gravCallback.m_controller->SetEventHandler( &m_gravCallback );
+	}
+}
+
+
+//=========================================================
+//=========================================================
+void CWeaponGravityGun::Precache( void )
+{
+	BaseClass::Precache();
+
+	g_physgunBeam = PrecacheModel(PHYSGUN_BEAM_SPRITE);
+
+	PrecacheScriptSound( "Weapon_Physgun.Scanning" );
+	PrecacheScriptSound( "Weapon_Physgun.LockedOn" );
+	PrecacheScriptSound( "Weapon_Physgun.Scanning" );
+	PrecacheScriptSound( "Weapon_Physgun.LightObject" );
+	PrecacheScriptSound( "Weapon_Physgun.HeavyObject" );
+}
+
+void CWeaponGravityGun::EffectCreate( void )
+{
+	EffectUpdate();
+	m_active = true;
+}
+
+
+// Andrew; added so we can trace both in EffectUpdate and DrawModel with the same results
+void CWeaponGravityGun::TraceLine( trace_t *ptr )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return;
+
+	Vector start, forward, right;
+	pOwner->EyeVectors( &forward, &right, NULL );
+
+	start = pOwner->Weapon_ShootPosition();
+	Vector end = start + forward * 4096;
+
+	UTIL_TraceLine( start, end, MASK_SHOT, pOwner, COLLISION_GROUP_NONE, ptr );
+}
+
+
+void CWeaponGravityGun::EffectUpdate( void )
+{
+	Vector start, forward, right;
+	trace_t tr;
+
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return;
+
+	pOwner->EyeVectors( &forward, &right, NULL );
+
+	start = pOwner->Weapon_ShootPosition();
+
+	TraceLine( &tr );
+	Vector end = tr.endpos;
+	float distance = tr.fraction * 4096;
+
+	if ( m_hObject == NULL && tr.DidHitNonWorldEntity() )
+	{
+		CBaseEntity *pEntity = tr.m_pEnt;
+		AttachObject( pEntity, start, tr.endpos, distance );
+	}
+
+	// Add the incremental player yaw to the target transform
+	QAngle angles = m_gravCallback.TransformAnglesFromPlayerSpace( m_gravCallback.m_targetRotation, pOwner );
+
+	CBaseEntity *pObject = m_hObject;
+	if ( pObject )
+	{
+		if ( m_useDown )
+		{
+			if ( pOwner->m_afButtonPressed & IN_USE )
+			{
+				m_useDown = false;
+			}
+		}
+		else 
+		{
+			if ( pOwner->m_afButtonPressed & IN_USE )
+			{
+				m_useDown = true;
+			}
+		}
+
+		if ( m_useDown )
+		{
+#ifndef CLIENT_DLL
+			pOwner->SetPhysicsFlag( PFLAG_DIROVERRIDE, true );
+#endif
+			if ( pOwner->m_nButtons & IN_FORWARD )
+			{
+				m_distance = Approach( 1024, m_distance, gpGlobals->frametime * 100 );
+			}
+			if ( pOwner->m_nButtons & IN_BACK )
+			{
+				m_distance = Approach( 40, m_distance, gpGlobals->frametime * 100 );
+			}
+		}
+
+		if ( pOwner->m_nButtons & IN_WEAPON1 )
+		{
+			m_distance = Approach( 1024, m_distance, m_distance * 0.1 );
+#ifdef CLIENT_DLL
+			if ( gpGlobals->maxClients > 1 )
+			{
+				gHUD.m_bSkipClear = false;
+			}
+#endif
+		}
+		if ( pOwner->m_nButtons & IN_WEAPON2 )
+		{
+			m_distance = Approach( 40, m_distance, m_distance * 0.1 );
+#ifdef CLIENT_DLL
+			if ( gpGlobals->maxClients > 1 )
+			{
+				gHUD.m_bSkipClear = false;
+			}
+#endif
+		}
+
+		IPhysicsObject *pPhys = pObject->VPhysicsGetObject();
+		if ( pPhys && pPhys->IsAsleep() )
+		{
+			// on the odd chance that it's gone to sleep while under anti-gravity
+			pPhys->Wake();
+		}
+
+		Vector newPosition = start + forward * m_distance;
+		Vector offset;
+		pObject->EntityToWorldSpace( m_worldPosition, &offset );
+		m_gravCallback.SetTargetPosition( newPosition + (pObject->GetAbsOrigin() - offset), angles );
+		Vector dir = (newPosition - pObject->GetLocalOrigin());
+		m_movementLength = dir.Length();
+	}
+	else
+	{
+		m_targetPosition = end;
+		//m_gravCallback.SetTargetPosition( end, m_gravCallback.m_targetRotation );
+	}
+}
+
+void CWeaponGravityGun::SoundCreate( void )
+{
+	m_soundState = SS_SCANNING;
+	SoundStart();
+}
+
+
+void CWeaponGravityGun::SoundDestroy( void )
+{
+	SoundStop();
+}
+
+
+void CWeaponGravityGun::SoundStop( void )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return;
+
+	switch( m_soundState )
+	{
+	case SS_SCANNING:
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndMotor );
+		m_sndMotor = NULL;
+		break;
+	case SS_LOCKEDON:
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndMotor );
+		m_sndMotor = NULL;
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndLockedOn );
+		m_sndLockedOn = NULL;
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndLightObject );
+		m_sndLightObject = NULL;
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndHeavyObject );
+		m_sndHeavyObject = NULL;
+		break;
+	}
+}
+
+
+
+//-----------------------------------------------------------------------------
+// Purpose: returns the linear fraction of value between low & high (0.0 - 1.0) * scale
+//			e.g. UTIL_LineFraction( 1.5, 1, 2, 1 ); will return 0.5 since 1.5 is
+//			halfway between 1 and 2
+// Input  : value - a value between low & high (clamped)
+//			low - the value that maps to zero
+//			high - the value that maps to "scale"
+//			scale - the output scale
+// Output : parametric fraction between low & high
+//-----------------------------------------------------------------------------
+static float UTIL_LineFraction( float value, float low, float high, float scale )
+{
+	if ( value < low )
+		value = low;
+	if ( value > high )
+		value = high;
+
+	float delta = high - low;
+	if ( delta == 0 )
+		return 0;
+	
+	return scale * (value-low) / delta;
+}
+
+void CWeaponGravityGun::SoundStart( void )
+{
+	CPASAttenuationFilter filter( this );
+
+	switch( m_soundState )
+	{
+	case SS_SCANNING:
+		{
+			m_sndMotor = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.Scanning", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndMotor, 1.0f, 100 );
+		}
+		break;
+	case SS_LOCKEDON:
+		{
+			m_sndLockedOn = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.LockedOn", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndLockedOn, 1.0f, 100 );
+			m_sndMotor = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.Scanning", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndMotor, 1.0f, 100 );
+			m_sndLightObject = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.LightObject", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndLightObject, 1.0f, 100 );
+			m_sndHeavyObject = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.HeavyObject", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndHeavyObject, 1.0f, 100 );
+		}
+		break;
+	}
+													//   volume, att, flags, pitch
+}
+
+void CWeaponGravityGun::SoundUpdate( void )
+{
+	int newState;
+	
+	if ( m_hObject )
+		newState = SS_LOCKEDON;
+	else
+		newState = SS_SCANNING;
+
+	if ( newState != m_soundState )
+	{
+		SoundStop();
+		m_soundState = newState;
+		SoundStart();
+	}
+
+	switch( m_soundState )
+	{
+	case SS_SCANNING:
+		break;
+	case SS_LOCKEDON:
+		{
+			CPASAttenuationFilter filter( this );
+
+			float height = m_hObject->GetAbsOrigin().z - m_originalObjectPosition.z;
+
+			// go from pitch 90 to 150 over a height of 500
+			int pitch = 90 + (int)UTIL_LineFraction( height, 0, 500, 60 );
+
+			assert(m_sndLockedOn!=NULL);
+			if ( m_sndLockedOn != NULL )
+			{
+				(CSoundEnvelopeController::GetController()).SoundChangePitch( m_sndLockedOn, pitch, 0.0f );
+			}
+
+			// attenutate the movement sounds over 200 units of movement
+			float distance = UTIL_LineFraction( m_movementLength, 0, 200, 1.0 );
+
+			// blend the "mass" sounds between 50 and 500 kg
+			IPhysicsObject *pPhys = m_hObject->VPhysicsGetObject();
+			if ( pPhys == NULL )
+			{
+				// we no longer exist!
+				break;
+			}
+			
+			float fade = UTIL_LineFraction( pPhys->GetMass(), 50, 500, 1.0 );
+
+			(CSoundEnvelopeController::GetController()).SoundChangeVolume( m_sndLightObject, fade * distance, 0.0f );
+
+			(CSoundEnvelopeController::GetController()).SoundChangeVolume( m_sndHeavyObject, (1.0 - fade) * distance, 0.0f );
+		}
+		break;
+	}
+}
+
+
+CBaseEntity *CWeaponGravityGun::GetBeamEntity()
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return NULL;
+
+	// Make sure I've got a view model
+	CBaseViewModel *vm = pOwner->GetViewModel();
+	if ( vm )
+		return vm;
+
+	return pOwner;
+}
+
+void CWeaponGravityGun::EffectDestroy( void )
+{
+#ifdef CLIENT_DLL
+	gHUD.m_bSkipClear = false;
+#endif
+	m_active = false;
+	SoundStop();
+
+	DetachObject();
+}
+
+void CWeaponGravityGun::UpdateObject( void )
+{
+	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+	Assert( pPlayer );
+
+	CBaseEntity *pObject = m_hObject;
+	if ( !pObject )
+		return;
+
+	if ( !m_gravCallback.UpdateObject( pPlayer, pObject ) )
+	{
+		DetachObject();
+		return;
+	}
+}
+
+void CWeaponGravityGun::DetachObject( void )
+{
+	if ( m_hObject )
+	{
+#ifndef CLIENT_DLL
+		CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+		Pickup_OnPhysGunDrop( m_hObject, pOwner, DROPPED_BY_CANNON );
+#endif
+
+		IPhysicsObject *pPhysics = m_hObject->VPhysicsGetObject();
+		if ( pPhysics )
+		{
+			PhysClearGameFlags( pPhysics, FVPHYSICS_PLAYER_HELD );
+		}
+		m_gravCallback.DetachEntity();
+		m_hObject = NULL;
+	}
+}
+
+void CWeaponGravityGun::AttachObject( CBaseEntity *pObject, const Vector& start, const Vector &end, float distance )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if( !pOwner )
+		return;
+	m_hObject = pObject;
+	m_useDown = false;
+	IPhysicsObject *pPhysics = pObject ? (pObject->VPhysicsGetObject()) : NULL;
+	if ( pPhysics && pObject->GetMoveType() == MOVETYPE_VPHYSICS )
+	{
+		m_distance = distance;
+
+		Vector worldPosition;
+		pObject->WorldToEntitySpace( end, &worldPosition );
+		m_worldPosition = worldPosition;
+		m_gravCallback.AttachEntity( pOwner, pObject, pPhysics, pObject->GetAbsOrigin() );
+
+		m_originalObjectPosition = pObject->GetAbsOrigin();
+
+		pPhysics->Wake();
+		PhysSetGameFlags( pPhysics, FVPHYSICS_PLAYER_HELD );
+
+#ifndef CLIENT_DLL
+		Pickup_OnPhysGunPickup( pObject, pOwner );
+#endif
+	}
+	else
+	{
+		m_hObject = NULL;
+	}
+}
+
+//=========================================================
+//=========================================================
+void CWeaponGravityGun::PrimaryAttack( void )
+{
+	if ( !m_active )
+	{
+		SendWeaponAnim( ACT_VM_PRIMARYATTACK );
+		EffectCreate();
+		SoundCreate();
+	}
+	else
+	{
+		EffectUpdate();
+		SoundUpdate();
+	}
+}
+
+void CWeaponGravityGun::SecondaryAttack( void )
+{
+	return;
+}
+
+#ifdef CLIENT_DLL
+//-----------------------------------------------------------------------------
+// Purpose: Third-person function call to render world model
+//-----------------------------------------------------------------------------
+int CWeaponGravityGun::DrawModel( int flags )
+{
+	// Only render these on the transparent pass
+	if ( flags & STUDIO_TRANSPARENCY )
+	{
+		if ( !m_active )
+			return 0;
+
+		C_BasePlayer *pOwner = ToBasePlayer( GetOwner() );
+
+		if ( !pOwner )
+			return 0;
+
+		Vector points[3];
+		QAngle tmpAngle;
+
+		C_BaseEntity *pObject = m_hObject;
+		//if ( pObject == NULL )
+		//	return 0;
+
+		GetAttachment( 1, points[0], tmpAngle );
+
+		// a little noise 11t & 13t should be somewhat non-periodic looking
+		//points[1].z += 4*sin( gpGlobals->curtime*11 ) + 5*cos( gpGlobals->curtime*13 );
+		if ( pObject == NULL )
+		{
+			//points[2] = m_targetPosition;
+			trace_t tr;
+			TraceLine( &tr );
+			points[2] = tr.endpos;
+		}
+		else
+		{
+			pObject->EntityToWorldSpace( m_worldPosition, &points[2] );
+		}
+
+		Vector forward, right, up;
+		QAngle playerAngles = pOwner->EyeAngles();
+		AngleVectors( playerAngles, &forward, &right, &up );
+		if ( pObject == NULL )
+		{
+			Vector vecDir = points[2] - points[0];
+			VectorNormalize( vecDir );
+			points[1] = points[0] + 0.5f * (vecDir * points[2].DistTo(points[0]));
+		}
+		else
+		{
+			Vector vecSrc = pOwner->Weapon_ShootPosition( );
+			points[1] = vecSrc + 0.5f * (forward * points[2].DistTo(points[0]));
+		}
+		
+		IMaterial *pMat = materials->FindMaterial( "sprites/physbeam", TEXTURE_GROUP_CLIENT_EFFECTS );
+		Vector color;
+		color.Init(1,1,1);
+
+		float scrollOffset = gpGlobals->curtime - (int)gpGlobals->curtime;
+		CMatRenderContextPtr pRenderContext( materials );
+		pRenderContext->Bind( pMat );
+		DrawBeamQuadratic( points[0], points[1], points[2], 13, color, scrollOffset );
+		return 1;
+	}
+
+	// Only do this on the opaque pass
+	return BaseClass::DrawModel( flags );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: First-person function call after viewmodel has been drawn
+//-----------------------------------------------------------------------------
+void CWeaponGravityGun::ViewModelDrawn( C_BaseViewModel *pBaseViewModel )
+{
+	if ( !m_active )
+		return;
+
+	// Render our effects
+	C_BasePlayer *pOwner = ToBasePlayer( GetOwner() );
+
+	if ( !pOwner )
+		return;
+
+	Vector points[3];
+	QAngle tmpAngle;
+
+	C_BaseEntity *pObject = m_hObject;
+	//if ( pObject == NULL )
+	//	return;
+
+	pBaseViewModel->GetAttachment( 1, points[0], tmpAngle );
+
+	// a little noise 11t & 13t should be somewhat non-periodic looking
+	//points[1].z += 4*sin( gpGlobals->curtime*11 ) + 5*cos( gpGlobals->curtime*13 );
+	if ( pObject == NULL )
+	{
+		//points[2] = m_targetPosition;
+		trace_t tr;
+		TraceLine( &tr );
+		points[2] = tr.endpos;
+	}
+	else
+	{
+		pObject->EntityToWorldSpace(m_worldPosition, &points[2]);
+	}
+
+	Vector forward, right, up;
+	QAngle playerAngles = pOwner->EyeAngles();
+	AngleVectors( playerAngles, &forward, &right, &up );
+	Vector vecSrc = pOwner->Weapon_ShootPosition( );
+	points[1] = vecSrc + 0.5f * (forward * points[2].DistTo(points[0]));
+	
+	IMaterial *pMat = materials->FindMaterial( "sprites/physbeam", TEXTURE_GROUP_CLIENT_EFFECTS );
+	Vector color;
+	color.Init(1,1,1);
+
+	// Now draw it.
+	CViewSetup beamView = *view->GetPlayerViewSetup();
+
+	Frustum dummyFrustum;
+	render->Push3DView( beamView, 0, NULL, dummyFrustum );
+
+	float scrollOffset = gpGlobals->curtime - (int)gpGlobals->curtime;
+	CMatRenderContextPtr pRenderContext( materials );
+	pRenderContext->Bind( pMat );
+#if 1
+	// HACK HACK:  Munge the depth range to prevent view model from poking into walls, etc.
+	// Force clipped down range
+	pRenderContext->DepthRange( 0.1f, 0.2f );
+#endif
+	DrawBeamQuadratic( points[0], points[1], points[2], 13, color, scrollOffset );
+#if 1
+	pRenderContext->DepthRange( 0.0f, 1.0f );
+#endif
+
+	render->PopView( dummyFrustum );
+
+	// Pass this back up
+	BaseClass::ViewModelDrawn( pBaseViewModel );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: We are always considered transparent
+//-----------------------------------------------------------------------------
+bool CWeaponGravityGun::IsTransparent( void )
+{
+	return true;
+}
+
+#endif
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+void CWeaponGravityGun::ItemPreFrame()
+{
+	BaseClass::ItemPreFrame();
+
+#ifndef CLIENT_DLL
+	// Update the object if the weapon is switched on.
+	if( m_active )
+	{
+		UpdateObject();
+	}
+#endif
+}
+
+
+void CWeaponGravityGun::ItemPostFrame( void )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if (!pOwner)
+		return;
+
+#ifdef ARGG
+	// adnan
+	// this is where we check if we're orbiting the object
+	
+	// if we're holding something and pressing use,
+	//  then set us in the orbiting state
+	//  - this will indicate to OverrideMouseInput that we should zero the input and update our delta angles
+	//  UPDATE: not anymore.  now this just sets our state variables.
+	CBaseEntity *pObject = m_hObject;
+	if( pObject ) {
+
+		if((pOwner->m_nButtons & IN_ATTACK) && (pOwner->m_nButtons & IN_USE) ) {
+			m_gravCallback.m_bHasRotatedCarryAngles = true;
+			
+			// did we JUST hit use?
+			//  if so, grab the current angles to begin with as the rotated angles
+			if( !(pOwner->m_afButtonLast & IN_USE) ) {
+				m_gravCallback.m_vecRotatedCarryAngles = pObject->GetAbsAngles();
+			}
+
+			m_bIsCurrentlyRotating = true;
+		} else {
+			m_gravCallback.m_bHasRotatedCarryAngles = false;
+
+			m_bIsCurrentlyRotating = false;
+		}
+	} else {
+		m_bIsCurrentlyRotating = false;
+
+		m_gravCallback.m_bHasRotatedCarryAngles = false;
+	}
+	// end adnan
+#endif
+
+	if ( pOwner->m_nButtons & IN_ATTACK )
+	{
+#if defined( ARGG )
+		if( (pOwner->m_nButtons & IN_USE) ) {
+			pOwner->m_vecUseAngles = pOwner->pl.v_angle;
+		}
+#endif
+		if ( pOwner->m_afButtonPressed & IN_ATTACK2 )
+		{
+			SecondaryAttack();
+		}
+		else if ( pOwner->m_nButtons & IN_ATTACK2 )
+		{
+			if ( m_active )
+			{
+				EffectDestroy();
+				SoundDestroy();
+			}
+			WeaponIdle( );
+			return;
+		}
+		PrimaryAttack();
+	}
+	else 
+	{
+		if ( m_active )
+		{
+			EffectDestroy();
+			SoundDestroy();
+		}
+		WeaponIdle( );
+		return;
+	}
+	if ( pOwner->m_afButtonPressed & IN_RELOAD )
+	{
+		Reload();
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Output : Returns true on success, false on failure.
+//-----------------------------------------------------------------------------
+bool CWeaponGravityGun::HasAnyAmmo( void )
+{
+	//Always report that we have ammo
+	return true;
+}
+
+//=========================================================
+//=========================================================
+bool CWeaponGravityGun::Reload( void )
+{
+	return false;
+}
diff --git a/src/game/shared/hl2mp/weapon_physgun_valve.cpp b/src/game/shared/hl2mp/weapon_physgun_valve.cpp
new file mode 100644
index 0000000..c644189
--- /dev/null
+++ b/src/game/shared/hl2mp/weapon_physgun_valve.cpp
@@ -0,0 +1,1188 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+// Andrew; this is a heavily modified c_weapon_gravitygun.cpp + physgun.cpp for
+// multiplayer purposes. We're including this file separate from
+// weapon_physgun.cpp, because after revision 92, all of our changes will be
+// based off this file, which should be considered a heavily cleaned up Physics
+// Gun, which adhears as much to the original Valve codebase as possible while
+// still including massive overhauls in physics handling, render code, etc.
+
+#include "cbase.h"
+#include "beam_shared.h"
+#ifndef CLIENT_DLL
+#include "player.h"
+#endif
+#include "gamerules.h"
+#ifdef CLIENT_DLL
+#include "ClientEffectPrecacheSystem.h"
+#endif
+#include "weapon_hl2mpbasehlmpcombatweapon.h"
+#ifndef CLIENT_DLL
+#include "baseviewmodel.h"
+#endif
+#include "vphysics/constraints.h"
+#include "physics.h"
+#include "in_buttons.h"
+#include "IEffects.h"
+#include "soundenvelope.h"
+#include "engine/IEngineSound.h"
+#ifndef CLIENT_DLL
+#include "ndebugoverlay.h"
+#endif
+#include "physics_saverestore.h"
+#ifndef CLIENT_DLL
+#include "player_pickup.h"
+#endif
+#include "soundemittersystem/isoundemittersystembase.h"
+#ifdef CLIENT_DLL
+#include "model_types.h"
+#include "view_shared.h"
+#include "view.h"
+#include "iviewrender.h"
+#endif
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int g_physgunBeam;
+#define PHYSGUN_BEAM_SPRITE		"sprites/physbeam.vmt"
+
+#define	PHYSGUN_SKIN	1
+
+class CWeaponGravityGun;
+
+#ifdef CLIENT_DLL
+CLIENTEFFECT_REGISTER_BEGIN( PrecacheEffectGravityGun )
+CLIENTEFFECT_MATERIAL( "sprites/physbeam" )
+CLIENTEFFECT_REGISTER_END()
+
+
+#endif
+
+class CGravControllerPoint : public IMotionEvent
+{
+	DECLARE_SIMPLE_DATADESC();
+
+public:
+	CGravControllerPoint( void );
+	~CGravControllerPoint( void );
+	void AttachEntity( CBasePlayer *pPlayer, CBaseEntity *pEntity, IPhysicsObject *pPhys, const Vector &position );
+	void DetachEntity( void );
+
+	bool UpdateObject( CBasePlayer *pPlayer, CBaseEntity *pEntity );
+
+	void SetTargetPosition( const Vector &target, const QAngle &targetOrientation )
+	{
+		m_shadow.targetPosition = target;
+		m_shadow.targetRotation = targetOrientation;
+
+		m_timeToArrive = gpGlobals->frametime;
+
+		CBaseEntity *pAttached = m_attachedEntity;
+		if ( pAttached )
+		{
+			IPhysicsObject *pObj = pAttached->VPhysicsGetObject();
+			
+			if ( pObj != NULL )
+			{
+				pObj->Wake();
+			}
+			else
+			{
+				DetachEntity();
+			}
+		}
+	}
+
+	IMotionEvent::simresult_e Simulate( IPhysicsMotionController *pController, IPhysicsObject *pObject, float deltaTime, Vector &linear, AngularImpulse &angular );
+	Vector			m_localPosition;
+	Vector			m_targetPosition;
+	Vector			m_worldPosition;
+	float			m_saveDamping;
+	float			m_saveMass;
+	float			m_maxAcceleration;
+	Vector			m_maxAngularAcceleration;
+	EHANDLE			m_attachedEntity;
+	QAngle			m_targetRotation;
+	float			m_timeToArrive;
+
+	IPhysicsMotionController *m_controller;
+
+private:
+	hlshadowcontrol_params_t	m_shadow;
+};
+
+
+BEGIN_SIMPLE_DATADESC( CGravControllerPoint )
+
+	DEFINE_FIELD( m_localPosition,		FIELD_VECTOR ),
+	DEFINE_FIELD( m_targetPosition,		FIELD_POSITION_VECTOR ),
+	DEFINE_FIELD( m_worldPosition,		FIELD_POSITION_VECTOR ),
+	DEFINE_FIELD( m_saveDamping,			FIELD_FLOAT ),
+	DEFINE_FIELD( m_saveMass,			FIELD_FLOAT ),
+	DEFINE_FIELD( m_maxAcceleration,		FIELD_FLOAT ),
+	DEFINE_FIELD( m_maxAngularAcceleration,	FIELD_VECTOR ),
+	DEFINE_FIELD( m_attachedEntity,		FIELD_EHANDLE ),
+	DEFINE_FIELD( m_targetRotation,		FIELD_VECTOR ),
+	DEFINE_FIELD( m_timeToArrive,			FIELD_FLOAT ),
+
+	// Physptrs can't be saved in embedded classes... this is to silence classcheck
+	// DEFINE_PHYSPTR( m_controller ),
+
+END_DATADESC()
+
+
+CGravControllerPoint::CGravControllerPoint( void )
+{
+	m_shadow.dampFactor = 0.8;
+	m_shadow.teleportDistance = 0;
+	// make this controller really stiff!
+	m_shadow.maxSpeed = 5000;
+	m_shadow.maxAngular = m_shadow.maxSpeed;
+	m_shadow.maxDampSpeed = m_shadow.maxSpeed*2;
+	m_shadow.maxDampAngular = m_shadow.maxAngular*2;
+	m_attachedEntity = NULL;
+}
+
+CGravControllerPoint::~CGravControllerPoint( void )
+{
+	DetachEntity();
+}
+
+
+void CGravControllerPoint::AttachEntity( CBasePlayer *pPlayer, CBaseEntity *pEntity, IPhysicsObject *pPhys, const Vector &vGrabPosition )
+{
+	m_attachedEntity = pEntity;
+	pPhys->WorldToLocal( &m_localPosition, vGrabPosition );
+	m_worldPosition = vGrabPosition;
+	pPhys->GetDamping( NULL, &m_saveDamping );
+	m_saveMass = pPhys->GetMass();
+	float damping = 2;
+	pPhys->SetDamping( NULL, &damping );
+	pPhys->SetMass( 50000 );
+	m_controller = physenv->CreateMotionController( this );
+	m_controller->AttachObject( pPhys, true );
+	Vector position;
+	QAngle angles;
+	pPhys->GetPosition( &position, &angles );
+	SetTargetPosition( vGrabPosition, angles );
+	m_targetRotation = angles;
+}
+
+void CGravControllerPoint::DetachEntity( void )
+{
+	CBaseEntity *pEntity = m_attachedEntity;
+	if ( pEntity )
+	{
+		IPhysicsObject *pPhys = pEntity->VPhysicsGetObject();
+		if ( pPhys )
+		{
+			// on the odd chance that it's gone to sleep while under anti-gravity
+			pPhys->Wake();
+			pPhys->SetDamping( NULL, &m_saveDamping );
+			pPhys->SetMass( m_saveMass );
+		}
+	}
+	m_attachedEntity = NULL;
+	if ( physenv )
+	{
+		physenv->DestroyMotionController( m_controller );
+	}
+	m_controller = NULL;
+
+	// UNDONE: Does this help the networking?
+	m_targetPosition = vec3_origin;
+	m_worldPosition = vec3_origin;
+}
+
+void AxisAngleQAngle( const Vector &axis, float angle, QAngle &outAngles )
+{
+	// map back to HL rotation axes
+	outAngles.z = axis.x * angle;
+	outAngles.x = axis.y * angle;
+	outAngles.y = axis.z * angle;
+}
+
+IMotionEvent::simresult_e CGravControllerPoint::Simulate( IPhysicsMotionController *pController, IPhysicsObject *pObject, float deltaTime, Vector &linear, AngularImpulse &angular )
+{
+	hlshadowcontrol_params_t shadowParams = m_shadow;
+#ifndef CLIENT_DLL
+	m_timeToArrive = pObject->ComputeShadowControl( shadowParams, m_timeToArrive, deltaTime );
+#else
+	m_timeToArrive = pObject->ComputeShadowControl( shadowParams, (TICK_INTERVAL*2), deltaTime );
+#endif
+	
+	linear.Init();
+	angular.Init();
+
+	return SIM_LOCAL_ACCELERATION;
+}
+
+
+#ifdef CLIENT_DLL
+#define CWeaponGravityGun C_WeaponGravityGun
+#endif
+
+class CWeaponGravityGun : public CBaseHL2MPCombatWeapon
+{
+	DECLARE_DATADESC();
+
+public:
+	DECLARE_CLASS( CWeaponGravityGun, CBaseHL2MPCombatWeapon );
+
+	DECLARE_NETWORKCLASS();
+	DECLARE_PREDICTABLE();
+
+	CWeaponGravityGun();
+
+#ifdef CLIENT_DLL
+	void GetRenderBounds( Vector& mins, Vector& maxs )
+	{
+		BaseClass::GetRenderBounds( mins, maxs );
+
+		// add to the bounds, don't clear them.
+		// ClearBounds( mins, maxs );
+		AddPointToBounds( vec3_origin, mins, maxs );
+		AddPointToBounds( m_targetPosition, mins, maxs );
+		AddPointToBounds( m_worldPosition, mins, maxs );
+		CBaseEntity *pEntity = GetBeamEntity();
+		if ( pEntity )
+		{
+			mins -= pEntity->GetRenderOrigin();
+			maxs -= pEntity->GetRenderOrigin();
+		}
+	}
+
+	void GetRenderBoundsWorldspace( Vector& mins, Vector& maxs )
+	{
+		BaseClass::GetRenderBoundsWorldspace( mins, maxs );
+
+		// add to the bounds, don't clear them.
+		// ClearBounds( mins, maxs );
+		AddPointToBounds( vec3_origin, mins, maxs );
+		AddPointToBounds( m_targetPosition, mins, maxs );
+		AddPointToBounds( m_worldPosition, mins, maxs );
+		mins -= GetRenderOrigin();
+		maxs -= GetRenderOrigin();
+	}
+
+	int KeyInput( int down, ButtonCode_t keynum, const char *pszCurrentBinding )
+	{
+		if ( gHUD.m_iKeyBits & IN_ATTACK )
+		{
+			switch ( keynum )
+			{
+			case MOUSE_WHEEL_UP:
+				m_bInWeapon1 = true;
+				// gHUD.m_iKeyBits |= IN_WEAPON1;
+				if ( gpGlobals->maxClients > 1 )
+					gHUD.m_bSkipClear = true;
+				return 0;
+
+			case MOUSE_WHEEL_DOWN:
+				m_bInWeapon2 = true;
+				// gHUD.m_iKeyBits |= IN_WEAPON2;
+				if ( gpGlobals->maxClients > 1 )
+					gHUD.m_bSkipClear = true;
+				return 0;
+			}
+		}
+
+		// Allow engine to process
+		return BaseClass::KeyInput( down, keynum, pszCurrentBinding );
+	}
+
+	void HandleInput()
+	{
+		if ( m_bInWeapon1 )
+		{
+			gHUD.m_iKeyBits |= IN_WEAPON1;
+			m_bInWeapon1 = false;
+		}
+
+		if ( m_bInWeapon2 )
+		{
+			gHUD.m_iKeyBits |= IN_WEAPON2;
+			m_bInWeapon2 = false;
+		}
+	}
+
+	int	 DrawModel( int flags );
+	void ViewModelDrawn( C_BaseViewModel *pBaseViewModel );
+	bool IsTransparent( void );
+
+	// We need to render opaque and translucent pieces
+	RenderGroup_t	GetRenderGroup( void ) {	return RENDER_GROUP_TWOPASS;	}
+#endif
+
+	void Spawn( void );
+	void OnRestore( void );
+	void Precache( void );
+
+	virtual void	UpdateOnRemove(void);
+	void PrimaryAttack( void );
+	void SecondaryAttack( void );
+	void ItemPreFrame( void );
+	void ItemPostFrame( void );
+	virtual bool Holster( CBaseCombatWeapon *pSwitchingTo )
+	{
+		EffectDestroy();
+		SoundDestroy();
+		return BaseClass::Holster( pSwitchingTo );
+	}
+
+	bool Reload( void );
+	void Drop(const Vector &vecVelocity)
+	{
+		EffectDestroy();
+		SoundDestroy();
+
+#ifndef CLIENT_DLL
+		UTIL_Remove( this );
+#endif
+	}
+
+	bool HasAnyAmmo( void );
+
+	void AttachObject( CBaseEntity *pEdict, const Vector& start, const Vector &end, float distance );
+	void UpdateObject( void );
+	void DetachObject( void );
+
+	void TraceLine( trace_t *ptr );
+
+	void EffectCreate( void );
+	void EffectUpdate( void );
+	void EffectDestroy( void );
+
+	void SoundCreate( void );
+	void SoundDestroy( void );
+	void SoundStop( void );
+	void SoundStart( void );
+	void SoundUpdate( void );
+
+	int ObjectCaps( void ) 
+	{ 
+		int caps = BaseClass::ObjectCaps();
+		if ( m_active )
+		{
+			caps |= FCAP_DIRECTIONAL_USE;
+		}
+		return caps;
+	}
+
+	CBaseEntity *GetBeamEntity();
+
+private:
+	CNetworkVar( int, m_active );
+	bool		m_useDown;
+	CNetworkHandle( CBaseEntity, m_hObject );
+	float		m_distance;
+	float		m_movementLength;
+	float		m_lastYaw;
+	int			m_soundState;
+	Vector		m_originalObjectPosition;
+	CNetworkVector	( m_targetPosition );
+	CNetworkVector	( m_worldPosition );
+
+	CSoundPatch					*m_sndMotor;		// Whirring sound for the gun
+	CSoundPatch					*m_sndLockedOn;
+	CSoundPatch					*m_sndLightObject;
+	CSoundPatch					*m_sndHeavyObject;
+
+	CGravControllerPoint		m_gravCallback;
+
+	bool		m_bInWeapon1;
+	bool		m_bInWeapon2;
+
+	DECLARE_ACTTABLE();
+};
+
+IMPLEMENT_NETWORKCLASS_ALIASED( WeaponGravityGun, DT_WeaponGravityGun )
+
+BEGIN_NETWORK_TABLE( CWeaponGravityGun, DT_WeaponGravityGun )
+#ifdef CLIENT_DLL
+	RecvPropEHandle( RECVINFO( m_hObject ) ),
+	RecvPropVector( RECVINFO( m_targetPosition ) ),
+	RecvPropVector( RECVINFO( m_worldPosition ) ),
+	RecvPropInt( RECVINFO(m_active) ),
+#else
+	SendPropEHandle( SENDINFO( m_hObject ) ),
+	SendPropVector(SENDINFO( m_targetPosition ), -1, SPROP_COORD),
+	SendPropVector(SENDINFO( m_worldPosition ), -1, SPROP_COORD),
+	SendPropInt( SENDINFO(m_active), 1, SPROP_UNSIGNED ),
+#endif
+END_NETWORK_TABLE()
+
+#ifdef CLIENT_DLL
+BEGIN_PREDICTION_DATA( CWeaponGravityGun )
+END_PREDICTION_DATA()
+#endif
+
+LINK_ENTITY_TO_CLASS( weapon_physgun, CWeaponGravityGun );
+PRECACHE_WEAPON_REGISTER(weapon_physgun);
+
+acttable_t	CWeaponGravityGun::m_acttable[] = 
+{
+	{ ACT_MP_STAND_IDLE,				ACT_HL2MP_IDLE_PHYSGUN,					false },
+	{ ACT_MP_CROUCH_IDLE,				ACT_HL2MP_IDLE_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_RUN,						ACT_HL2MP_RUN_PHYSGUN,					false },
+	{ ACT_MP_CROUCHWALK,				ACT_HL2MP_WALK_CROUCH_PHYSGUN,			false },
+
+	{ ACT_MP_ATTACK_STAND_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+	{ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,	false },
+
+	{ ACT_MP_RELOAD_STAND,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,		false },
+
+	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PHYSGUN,					false },
+};
+
+IMPLEMENT_ACTTABLE(CWeaponGravityGun);
+
+
+//---------------------------------------------------------
+// Save/Restore
+//---------------------------------------------------------
+BEGIN_DATADESC( CWeaponGravityGun )
+
+	DEFINE_FIELD( m_active,				FIELD_INTEGER ),
+	DEFINE_FIELD( m_useDown,				FIELD_BOOLEAN ),
+	DEFINE_FIELD( m_hObject,				FIELD_EHANDLE ),
+	DEFINE_FIELD( m_distance,			FIELD_FLOAT ),
+	DEFINE_FIELD( m_movementLength,		FIELD_FLOAT ),
+	DEFINE_FIELD( m_lastYaw,				FIELD_FLOAT ),
+	DEFINE_FIELD( m_soundState,			FIELD_INTEGER ),
+	DEFINE_FIELD( m_originalObjectPosition,	FIELD_POSITION_VECTOR ),
+	DEFINE_SOUNDPATCH( m_sndMotor ),
+	DEFINE_SOUNDPATCH( m_sndLockedOn ),
+	DEFINE_SOUNDPATCH( m_sndLightObject ),
+	DEFINE_SOUNDPATCH( m_sndHeavyObject ),
+	DEFINE_EMBEDDED( m_gravCallback ),
+	// Physptrs can't be saved in embedded classes..
+	DEFINE_PHYSPTR( m_gravCallback.m_controller ),
+
+END_DATADESC()
+
+
+enum physgun_soundstate { SS_SCANNING, SS_LOCKEDON };
+enum physgun_soundIndex { SI_LOCKEDON = 0, SI_SCANNING = 1, SI_LIGHTOBJECT = 2, SI_HEAVYOBJECT = 3, SI_ON, SI_OFF };
+
+
+//=========================================================
+//=========================================================
+
+CWeaponGravityGun::CWeaponGravityGun()
+{
+	m_active = false;
+	m_bFiresUnderwater = true;
+	m_bInWeapon1 = false;
+	m_bInWeapon2 = false;
+}
+
+
+//-----------------------------------------------------------------------------
+// On Remove
+//-----------------------------------------------------------------------------
+void CWeaponGravityGun::UpdateOnRemove(void)
+{
+	EffectDestroy();
+	SoundDestroy();
+	BaseClass::UpdateOnRemove();
+}
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+// adnan
+// want to add an angles modifier key
+bool CGravControllerPoint::UpdateObject( CBasePlayer *pPlayer, CBaseEntity *pEntity )
+{
+	if ( !pEntity || pPlayer->GetGroundEntity() == pEntity || !pEntity->VPhysicsGetObject() )
+	{
+		return false;
+	}
+
+	//Adrian: Oops, our object became motion disabled, let go!
+	IPhysicsObject *pPhys = pEntity->VPhysicsGetObject();
+	if ( pPhys && pPhys->IsMoveable() == false )
+	{
+		return false;
+	}
+
+	SetTargetPosition( m_targetPosition, m_targetRotation );
+
+	return true;
+}
+
+//=========================================================
+//=========================================================
+void CWeaponGravityGun::Spawn( )
+{
+	BaseClass::Spawn();
+//	SetModel( GetWorldModel() );
+
+	// The physgun uses a different skin
+	m_nSkin = PHYSGUN_SKIN;
+
+	FallInit();
+}
+
+void CWeaponGravityGun::OnRestore( void )
+{
+	BaseClass::OnRestore();
+
+	if ( m_gravCallback.m_controller )
+	{
+		m_gravCallback.m_controller->SetEventHandler( &m_gravCallback );
+	}
+}
+
+
+//=========================================================
+//=========================================================
+void CWeaponGravityGun::Precache( void )
+{
+	BaseClass::Precache();
+
+	g_physgunBeam = PrecacheModel(PHYSGUN_BEAM_SPRITE);
+
+	PrecacheScriptSound( "Weapon_Physgun.Scanning" );
+	PrecacheScriptSound( "Weapon_Physgun.LockedOn" );
+	PrecacheScriptSound( "Weapon_Physgun.Scanning" );
+	PrecacheScriptSound( "Weapon_Physgun.LightObject" );
+	PrecacheScriptSound( "Weapon_Physgun.HeavyObject" );
+}
+
+void CWeaponGravityGun::EffectCreate( void )
+{
+	EffectUpdate();
+	m_active = true;
+}
+
+
+// Andrew; added so we can trace both in EffectUpdate and DrawModel with the same results
+void CWeaponGravityGun::TraceLine( trace_t *ptr )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return;
+
+	Vector start, forward, right;
+	pOwner->EyeVectors( &forward, &right, NULL );
+
+	start = pOwner->Weapon_ShootPosition();
+	Vector end = start + forward * 4096;
+
+	UTIL_TraceLine( start, end, MASK_SHOT, pOwner, COLLISION_GROUP_NONE, ptr );
+}
+
+
+void CWeaponGravityGun::EffectUpdate( void )
+{
+	Vector start, forward, right;
+	trace_t tr;
+
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return;
+
+	pOwner->EyeVectors( &forward, &right, NULL );
+
+	start = pOwner->Weapon_ShootPosition();
+
+	TraceLine( &tr );
+	Vector end = tr.endpos;
+	float distance = tr.fraction * 4096;
+	if ( tr.fraction != 1 )
+	{
+		// too close to the player, drop the object
+		if ( distance < 36 )
+		{
+			DetachObject();
+			return;
+		}
+	}
+
+	if ( m_hObject == NULL && tr.DidHitNonWorldEntity() )
+	{
+		CBaseEntity *pEntity = tr.m_pEnt;
+		AttachObject( pEntity, start, tr.endpos, distance );
+		m_lastYaw = pOwner->EyeAngles().y;
+	}
+
+	// Add the incremental player yaw to the target transform
+	matrix3x4_t curMatrix, incMatrix, nextMatrix;
+
+	AngleMatrix( m_gravCallback.m_targetRotation, curMatrix );
+	AngleMatrix( QAngle(0,pOwner->EyeAngles().y - m_lastYaw,0), incMatrix );
+	ConcatTransforms( incMatrix, curMatrix, nextMatrix );
+	MatrixAngles( nextMatrix, m_gravCallback.m_targetRotation );
+	m_lastYaw = pOwner->EyeAngles().y;
+
+	CBaseEntity *pObject = m_hObject;
+	if ( pObject )
+	{
+		if ( m_useDown )
+		{
+			if ( pOwner->m_afButtonPressed & IN_USE )
+			{
+				m_useDown = false;
+			}
+		}
+		else 
+		{
+			if ( pOwner->m_afButtonPressed & IN_USE )
+			{
+				m_useDown = true;
+			}
+		}
+
+		if ( m_useDown )
+		{
+#ifndef CLIENT_DLL
+			pOwner->SetPhysicsFlag( PFLAG_DIROVERRIDE, true );
+#endif
+			if ( pOwner->m_nButtons & IN_FORWARD )
+			{
+				m_distance = Approach( 1024, m_distance, gpGlobals->frametime * 100 );
+			}
+			if ( pOwner->m_nButtons & IN_BACK )
+			{
+				m_distance = Approach( 40, m_distance, gpGlobals->frametime * 100 );
+			}
+		}
+
+		if ( pOwner->m_nButtons & IN_WEAPON1 )
+		{
+			m_distance = Approach( 1024, m_distance, m_distance * 0.1 );
+#ifdef CLIENT_DLL
+			if ( gpGlobals->maxClients > 1 )
+			{
+				gHUD.m_bSkipClear = false;
+			}
+#endif
+		}
+		if ( pOwner->m_nButtons & IN_WEAPON2 )
+		{
+			m_distance = Approach( 40, m_distance, m_distance * 0.1 );
+#ifdef CLIENT_DLL
+			if ( gpGlobals->maxClients > 1 )
+			{
+				gHUD.m_bSkipClear = false;
+			}
+#endif
+		}
+
+		IPhysicsObject *pPhys = pObject->VPhysicsGetObject();
+		if ( pPhys && pPhys->IsAsleep() )
+		{
+			// on the odd chance that it's gone to sleep while under anti-gravity
+			pPhys->Wake();
+		}
+
+		Vector newPosition = start + forward * m_distance;
+		Vector offset;
+		pObject->EntityToWorldSpace( m_worldPosition, &offset );
+		m_gravCallback.SetTargetPosition( newPosition + (pObject->GetAbsOrigin() - offset), m_gravCallback.m_targetRotation );
+		Vector dir = (newPosition - pObject->GetLocalOrigin());
+		m_movementLength = dir.Length();
+	}
+	else
+	{
+		m_targetPosition = end;
+		//m_gravCallback.SetTargetPosition( end, m_gravCallback.m_targetRotation );
+	}
+}
+
+void CWeaponGravityGun::SoundCreate( void )
+{
+	m_soundState = SS_SCANNING;
+	SoundStart();
+}
+
+
+void CWeaponGravityGun::SoundDestroy( void )
+{
+	SoundStop();
+}
+
+
+void CWeaponGravityGun::SoundStop( void )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return;
+
+	switch( m_soundState )
+	{
+	case SS_SCANNING:
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndMotor );
+		m_sndMotor = NULL;
+		break;
+	case SS_LOCKEDON:
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndMotor );
+		m_sndMotor = NULL;
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndLockedOn );
+		m_sndLockedOn = NULL;
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndLightObject );
+		m_sndLightObject = NULL;
+		(CSoundEnvelopeController::GetController()).SoundDestroy( m_sndHeavyObject );
+		m_sndHeavyObject = NULL;
+		break;
+	}
+}
+
+
+
+//-----------------------------------------------------------------------------
+// Purpose: returns the linear fraction of value between low & high (0.0 - 1.0) * scale
+//			e.g. UTIL_LineFraction( 1.5, 1, 2, 1 ); will return 0.5 since 1.5 is
+//			halfway between 1 and 2
+// Input  : value - a value between low & high (clamped)
+//			low - the value that maps to zero
+//			high - the value that maps to "scale"
+//			scale - the output scale
+// Output : parametric fraction between low & high
+//-----------------------------------------------------------------------------
+static float UTIL_LineFraction( float value, float low, float high, float scale )
+{
+	if ( value < low )
+		value = low;
+	if ( value > high )
+		value = high;
+
+	float delta = high - low;
+	if ( delta == 0 )
+		return 0;
+	
+	return scale * (value-low) / delta;
+}
+
+void CWeaponGravityGun::SoundStart( void )
+{
+	CPASAttenuationFilter filter( this );
+
+	switch( m_soundState )
+	{
+	case SS_SCANNING:
+		{
+			m_sndMotor = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.Scanning", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndMotor, 1.0f, 100 );
+		}
+		break;
+	case SS_LOCKEDON:
+		{
+			m_sndLockedOn = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.LockedOn", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndLockedOn, 1.0f, 100 );
+			m_sndMotor = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.Scanning", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndMotor, 1.0f, 100 );
+			m_sndLightObject = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.LightObject", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndLightObject, 1.0f, 100 );
+			m_sndHeavyObject = (CSoundEnvelopeController::GetController()).SoundCreate( filter, entindex(), CHAN_STATIC, "Weapon_Physgun.HeavyObject", ATTN_NORM );
+			(CSoundEnvelopeController::GetController()).Play( m_sndHeavyObject, 1.0f, 100 );
+		}
+		break;
+	}
+													//   volume, att, flags, pitch
+}
+
+void CWeaponGravityGun::SoundUpdate( void )
+{
+	int newState;
+	
+	if ( m_hObject )
+		newState = SS_LOCKEDON;
+	else
+		newState = SS_SCANNING;
+
+	if ( newState != m_soundState )
+	{
+		SoundStop();
+		m_soundState = newState;
+		SoundStart();
+	}
+
+	switch( m_soundState )
+	{
+	case SS_SCANNING:
+		break;
+	case SS_LOCKEDON:
+		{
+			CPASAttenuationFilter filter( this );
+
+			float height = m_hObject->GetAbsOrigin().z - m_originalObjectPosition.z;
+
+			// go from pitch 90 to 150 over a height of 500
+			int pitch = 90 + (int)UTIL_LineFraction( height, 0, 500, 60 );
+
+			assert(m_sndLockedOn!=NULL);
+			if ( m_sndLockedOn != NULL )
+			{
+				(CSoundEnvelopeController::GetController()).SoundChangePitch( m_sndLockedOn, pitch, 0.0f );
+			}
+
+			// attenutate the movement sounds over 200 units of movement
+			float distance = UTIL_LineFraction( m_movementLength, 0, 200, 1.0 );
+
+			// blend the "mass" sounds between 50 and 500 kg
+			IPhysicsObject *pPhys = m_hObject->VPhysicsGetObject();
+			if ( pPhys == NULL )
+			{
+				// we no longer exist!
+				break;
+			}
+			
+			float fade = UTIL_LineFraction( pPhys->GetMass(), 50, 500, 1.0 );
+
+			(CSoundEnvelopeController::GetController()).SoundChangeVolume( m_sndLightObject, fade * distance, 0.0f );
+
+			(CSoundEnvelopeController::GetController()).SoundChangeVolume( m_sndHeavyObject, (1.0 - fade) * distance, 0.0f );
+		}
+		break;
+	}
+}
+
+
+CBaseEntity *CWeaponGravityGun::GetBeamEntity()
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if ( !pOwner )
+		return NULL;
+
+	// Make sure I've got a view model
+	CBaseViewModel *vm = pOwner->GetViewModel();
+	if ( vm )
+		return vm;
+
+	return pOwner;
+}
+
+void CWeaponGravityGun::EffectDestroy( void )
+{
+#ifdef CLIENT_DLL
+	gHUD.m_bSkipClear = false;
+#endif
+	m_active = false;
+	SoundStop();
+
+	DetachObject();
+}
+
+void CWeaponGravityGun::UpdateObject( void )
+{
+	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
+	Assert( pPlayer );
+
+	CBaseEntity *pObject = m_hObject;
+	if ( !pObject )
+		return;
+
+	if ( !m_gravCallback.UpdateObject( pPlayer, pObject ) )
+	{
+		DetachObject();
+		return;
+	}
+}
+
+void CWeaponGravityGun::DetachObject( void )
+{
+	if ( m_hObject )
+	{
+#ifndef CLIENT_DLL
+		CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+		Pickup_OnPhysGunDrop( m_hObject, pOwner, DROPPED_BY_CANNON );
+#endif
+
+		IPhysicsObject *pPhysics = m_hObject->VPhysicsGetObject();
+		if ( pPhysics )
+		{
+			PhysClearGameFlags( pPhysics, FVPHYSICS_PLAYER_HELD );
+		}
+		m_gravCallback.DetachEntity();
+		m_hObject = NULL;
+	}
+}
+
+void CWeaponGravityGun::AttachObject( CBaseEntity *pObject, const Vector& start, const Vector &end, float distance )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if( !pOwner )
+		return;
+	m_hObject = pObject;
+	m_useDown = false;
+	IPhysicsObject *pPhysics = pObject ? (pObject->VPhysicsGetObject()) : NULL;
+	if ( pPhysics && pObject->GetMoveType() == MOVETYPE_VPHYSICS )
+	{
+		m_distance = distance;
+
+		Vector worldPosition;
+		pObject->WorldToEntitySpace( end, &worldPosition );
+		m_worldPosition = worldPosition;
+		m_gravCallback.AttachEntity( pOwner, pObject, pPhysics, pObject->GetAbsOrigin() );
+
+		m_originalObjectPosition = pObject->GetAbsOrigin();
+
+		pPhysics->Wake();
+		PhysSetGameFlags( pPhysics, FVPHYSICS_PLAYER_HELD );
+
+#ifndef CLIENT_DLL
+		Pickup_OnPhysGunPickup( pObject, pOwner );
+#endif
+	}
+	else
+	{
+		m_hObject = NULL;
+	}
+}
+
+//=========================================================
+//=========================================================
+void CWeaponGravityGun::PrimaryAttack( void )
+{
+	if ( !m_active )
+	{
+		SendWeaponAnim( ACT_VM_PRIMARYATTACK );
+		EffectCreate();
+		SoundCreate();
+	}
+	else
+	{
+		EffectUpdate();
+		SoundUpdate();
+	}
+}
+
+void CWeaponGravityGun::SecondaryAttack( void )
+{
+	return;
+}
+
+#ifdef CLIENT_DLL
+//-----------------------------------------------------------------------------
+// Purpose: Third-person function call to render world model
+//-----------------------------------------------------------------------------
+int CWeaponGravityGun::DrawModel( int flags )
+{
+	// Only render these on the transparent pass
+	if ( flags & STUDIO_TRANSPARENCY )
+	{
+		if ( !m_active )
+			return 0;
+
+		C_BasePlayer *pOwner = ToBasePlayer( GetOwner() );
+
+		if ( !pOwner )
+			return 0;
+
+		Vector points[3];
+		QAngle tmpAngle;
+
+		C_BaseEntity *pObject = m_hObject;
+		//if ( pObject == NULL )
+		//	return 0;
+
+		GetAttachment( 1, points[0], tmpAngle );
+
+		// a little noise 11t & 13t should be somewhat non-periodic looking
+		//points[1].z += 4*sin( gpGlobals->curtime*11 ) + 5*cos( gpGlobals->curtime*13 );
+		if ( pObject == NULL )
+		{
+			//points[2] = m_targetPosition;
+			trace_t tr;
+			TraceLine( &tr );
+			points[2] = tr.endpos;
+		}
+		else
+		{
+			pObject->EntityToWorldSpace( m_worldPosition, &points[2] );
+		}
+
+		Vector forward, right, up;
+		QAngle playerAngles = pOwner->EyeAngles();
+		AngleVectors( playerAngles, &forward, &right, &up );
+		if ( pObject == NULL )
+		{
+			Vector vecDir = points[2] - points[0];
+			VectorNormalize( vecDir );
+			points[1] = points[0] + 0.5f * (vecDir * points[2].DistTo(points[0]));
+		}
+		else
+		{
+			Vector vecSrc = pOwner->Weapon_ShootPosition( );
+			points[1] = vecSrc + 0.5f * (forward * points[2].DistTo(points[0]));
+		}
+		
+		IMaterial *pMat = materials->FindMaterial( "sprites/physbeam", TEXTURE_GROUP_CLIENT_EFFECTS );
+		Vector color;
+		color.Init(1,1,1);
+
+		float scrollOffset = gpGlobals->curtime - (int)gpGlobals->curtime;
+		CMatRenderContextPtr pRenderContext( materials );
+		pRenderContext->Bind( pMat );
+		DrawBeamQuadratic( points[0], points[1], points[2], 13, color, scrollOffset );
+		return 1;
+	}
+
+	// Only do this on the opaque pass
+	return BaseClass::DrawModel( flags );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: First-person function call after viewmodel has been drawn
+//-----------------------------------------------------------------------------
+void CWeaponGravityGun::ViewModelDrawn( C_BaseViewModel *pBaseViewModel )
+{
+	if ( !m_active )
+		return;
+
+	// Render our effects
+	C_BasePlayer *pOwner = ToBasePlayer( GetOwner() );
+
+	if ( !pOwner )
+		return;
+
+	Vector points[3];
+	QAngle tmpAngle;
+
+	C_BaseEntity *pObject = m_hObject;
+	//if ( pObject == NULL )
+	//	return;
+
+	pBaseViewModel->GetAttachment( 1, points[0], tmpAngle );
+
+	// a little noise 11t & 13t should be somewhat non-periodic looking
+	//points[1].z += 4*sin( gpGlobals->curtime*11 ) + 5*cos( gpGlobals->curtime*13 );
+	if ( pObject == NULL )
+	{
+		//points[2] = m_targetPosition;
+		trace_t tr;
+		TraceLine( &tr );
+		points[2] = tr.endpos;
+	}
+	else
+	{
+		pObject->EntityToWorldSpace(m_worldPosition, &points[2]);
+	}
+
+	Vector forward, right, up;
+	QAngle playerAngles = pOwner->EyeAngles();
+	AngleVectors( playerAngles, &forward, &right, &up );
+	Vector vecSrc = pOwner->Weapon_ShootPosition( );
+	points[1] = vecSrc + 0.5f * (forward * points[2].DistTo(points[0]));
+	
+	IMaterial *pMat = materials->FindMaterial( "sprites/physbeam", TEXTURE_GROUP_CLIENT_EFFECTS );
+	Vector color;
+	color.Init(1,1,1);
+
+	// Now draw it.
+	CViewSetup beamView = *view->GetPlayerViewSetup();
+
+	Frustum dummyFrustum;
+	render->Push3DView( beamView, 0, NULL, dummyFrustum );
+
+	float scrollOffset = gpGlobals->curtime - (int)gpGlobals->curtime;
+	CMatRenderContextPtr pRenderContext( materials );
+	pRenderContext->Bind( pMat );
+#if 1
+	// HACK HACK:  Munge the depth range to prevent view model from poking into walls, etc.
+	// Force clipped down range
+	pRenderContext->DepthRange( 0.1f, 0.2f );
+#endif
+	DrawBeamQuadratic( points[0], points[1], points[2], 13, color, scrollOffset );
+#if 1
+	pRenderContext->DepthRange( 0.0f, 1.0f );
+#endif
+
+	render->PopView( dummyFrustum );
+
+	// Pass this back up
+	BaseClass::ViewModelDrawn( pBaseViewModel );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: We are always considered transparent
+//-----------------------------------------------------------------------------
+bool CWeaponGravityGun::IsTransparent( void )
+{
+	return true;
+}
+
+#endif
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+void CWeaponGravityGun::ItemPreFrame()
+{
+	BaseClass::ItemPreFrame();
+
+#ifndef CLIENT_DLL
+	// Update the object if the weapon is switched on.
+	if( m_active )
+	{
+		UpdateObject();
+	}
+#endif
+}
+
+
+void CWeaponGravityGun::ItemPostFrame( void )
+{
+	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
+	if (!pOwner)
+		return;
+
+	if ( pOwner->m_nButtons & IN_ATTACK )
+	{
+		if ( pOwner->m_afButtonPressed & IN_ATTACK2 )
+		{
+			SecondaryAttack();
+		}
+		else if ( pOwner->m_nButtons & IN_ATTACK2 )
+		{
+			if ( m_active )
+			{
+				EffectDestroy();
+				SoundDestroy();
+			}
+			WeaponIdle( );
+			return;
+		}
+		PrimaryAttack();
+	}
+	else 
+	{
+		if ( m_active )
+		{
+			EffectDestroy();
+			SoundDestroy();
+		}
+		WeaponIdle( );
+		return;
+	}
+	if ( pOwner->m_afButtonPressed & IN_RELOAD )
+	{
+		Reload();
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Output : Returns true on success, false on failure.
+//-----------------------------------------------------------------------------
+bool CWeaponGravityGun::HasAnyAmmo( void )
+{
+	//Always report that we have ammo
+	return true;
+}
+
+//=========================================================
+//=========================================================
+bool CWeaponGravityGun::Reload( void )
+{
+	return false;
+}
diff --git a/src/game/shared/hl2mp/weapon_pistol.cpp b/src/game/shared/hl2mp/weapon_pistol.cpp
index 8eb1539..0bcae36 100644
--- a/src/game/shared/hl2mp/weapon_pistol.cpp
+++ b/src/game/shared/hl2mp/weapon_pistol.cpp
@@ -7,6 +7,11 @@
 #include "cbase.h"
 #include "npcevent.h"
 #include "in_buttons.h"
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+#include "soundent.h"
+#endif
+#endif
 
 #ifdef CLIENT_DLL
 	#include "c_hl2mp_player.h"
@@ -17,6 +22,12 @@
 #include "weapon_hl2mpbasehlmpcombatweapon.h"
 #include "weapon_hl2mpbase_machinegun.h"
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+#include "gamestats.h"
+#endif
+#endif
+
 #define	PISTOL_FASTEST_REFIRE_TIME		0.1f
 #define	PISTOL_FASTEST_DRY_REFIRE_TIME	0.2f
 
@@ -26,6 +37,9 @@
 #ifdef CLIENT_DLL
 #define CWeaponPistol C_WeaponPistol
 #endif
+#ifdef HL2SB
+ConVar	pistol_use_new_accuracy( "pistol_use_new_accuracy", "1", FCVAR_REPLICATED );
+#endif
 
 //-----------------------------------------------------------------------------
 // CWeaponPistol
@@ -48,17 +62,35 @@ public:
 	void	PrimaryAttack( void );
 	void	AddViewKick( void );
 	void	DryFire( void );
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	void	Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator );
+#endif
+#endif
 
 	void	UpdatePenaltyTime( void );
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	int		CapabilitiesGet( void ) { return bits_CAP_WEAPON_RANGE_ATTACK1; }
+#endif
+#endif
 	Activity	GetPrimaryAttackActivity( void );
 
 	virtual bool Reload( void );
 
 	virtual const Vector& GetBulletSpread( void )
 	{		
+#ifdef HL2SB
+		// Handle NPCs first
+		static Vector npcCone = VECTOR_CONE_5DEGREES;
+		if ( GetOwner() && GetOwner()->IsNPC() )
+			return npcCone;
+#endif
+			
 		static Vector cone;
 
+#ifndef HL2SB
 		float ramp = RemapValClamped(	m_flAccuracyPenalty, 
 											0.0f, 
 											PISTOL_ACCURACY_MAXIMUM_PENALTY_TIME, 
@@ -67,6 +99,24 @@ public:
 
 			// We lerp from very accurate to inaccurate over time
 		VectorLerp( VECTOR_CONE_1DEGREES, VECTOR_CONE_6DEGREES, ramp, cone );
+#else
+		if ( pistol_use_new_accuracy.GetBool() )
+		{
+			float ramp = RemapValClamped(	m_flAccuracyPenalty, 
+											0.0f, 
+											PISTOL_ACCURACY_MAXIMUM_PENALTY_TIME, 
+											0.0f, 
+											1.0f ); 
+
+			// We lerp from very accurate to inaccurate over time
+			VectorLerp( VECTOR_CONE_1DEGREES, VECTOR_CONE_6DEGREES, ramp, cone );
+		}
+		else
+		{
+			// Old value
+			cone = VECTOR_CONE_4DEGREES;
+		}
+#endif
 
 		return cone;
 	}
@@ -140,6 +190,23 @@ acttable_t CWeaponPistol::m_acttable[] =
 	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_PISTOL,		false },
 
 	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PISTOL,					false },
+
+#ifdef HL2SB
+	{ ACT_IDLE,						ACT_IDLE_PISTOL,				true },
+	{ ACT_IDLE_ANGRY,				ACT_IDLE_ANGRY_PISTOL,			true },
+	{ ACT_RANGE_ATTACK1,			ACT_RANGE_ATTACK_PISTOL,		true },
+	{ ACT_RELOAD,					ACT_RELOAD_PISTOL,				true },
+	{ ACT_WALK_AIM,					ACT_WALK_AIM_PISTOL,			true },
+	{ ACT_RUN_AIM,					ACT_RUN_AIM_PISTOL,				true },
+	{ ACT_GESTURE_RANGE_ATTACK1,	ACT_GESTURE_RANGE_ATTACK_PISTOL,true },
+	{ ACT_RELOAD_LOW,				ACT_RELOAD_PISTOL_LOW,			false },
+	{ ACT_RANGE_ATTACK1_LOW,		ACT_RANGE_ATTACK_PISTOL_LOW,	false },
+	{ ACT_COVER_LOW,				ACT_COVER_PISTOL_LOW,			false },
+	{ ACT_RANGE_AIM_LOW,			ACT_RANGE_AIM_PISTOL_LOW,		false },
+	{ ACT_GESTURE_RELOAD,			ACT_GESTURE_RELOAD_PISTOL,		false },
+	{ ACT_WALK,						ACT_WALK_PISTOL,				false },
+	{ ACT_RUN,						ACT_RUN_PISTOL,					false },
+#endif
 };
 
 IMPLEMENT_ACTTABLE( CWeaponPistol );
@@ -168,6 +235,42 @@ void CWeaponPistol::Precache( void )
 	BaseClass::Precache();
 }
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+//-----------------------------------------------------------------------------
+// Purpose:
+// Input  :
+// Output :
+//-----------------------------------------------------------------------------
+void CWeaponPistol::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator )
+{
+	switch( pEvent->event )
+	{
+		case EVENT_WEAPON_PISTOL_FIRE:
+		{
+			Vector vecShootOrigin, vecShootDir;
+			vecShootOrigin = pOperator->Weapon_ShootPosition();
+
+			CAI_BaseNPC *npc = pOperator->MyNPCPointer();
+			ASSERT( npc != NULL );
+
+			vecShootDir = npc->GetActualShootTrajectory( vecShootOrigin );
+
+			CSoundEnt::InsertSound( SOUND_COMBAT|SOUND_CONTEXT_GUNFIRE, pOperator->GetAbsOrigin(), SOUNDENT_VOLUME_PISTOL, 0.2, pOperator, SOUNDENT_CHANNEL_WEAPON, pOperator->GetEnemy() );
+
+			WeaponSound( SINGLE_NPC );
+			pOperator->FireBullets( 1, vecShootOrigin, vecShootDir, VECTOR_CONE_PRECALCULATED, MAX_TRACE_LENGTH, m_iPrimaryAmmoType, 2 );
+			pOperator->DoMuzzleFlash();
+			m_iClip1 = m_iClip1 - 1;
+		}
+		break;
+		default:
+			BaseClass::Operator_HandleAnimEvent( pEvent, pOperator );
+			break;
+	}
+}
+#endif
+#endif
 
 //-----------------------------------------------------------------------------
 // Purpose:
@@ -197,6 +300,11 @@ void CWeaponPistol::PrimaryAttack( void )
 
 	m_flLastAttackTime = gpGlobals->curtime;
 	m_flSoonestPrimaryAttack = gpGlobals->curtime + PISTOL_FASTEST_REFIRE_TIME;
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	CSoundEnt::InsertSound( SOUND_COMBAT, GetAbsOrigin(), SOUNDENT_VOLUME_PISTOL, 0.2, GetOwner() );
+#endif
+#endif
 
 	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
 
@@ -213,6 +321,12 @@ void CWeaponPistol::PrimaryAttack( void )
 
 	// Add an accuracy penalty which can move past our maximum penalty time if we're really spastic
 	m_flAccuracyPenalty += PISTOL_ACCURACY_SHOT_PENALTY_TIME;
+
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	gamestats->Event_WeaponFired( pOwner, true, GetClassname() );
+#endif
+#endif
 }
 
 //-----------------------------------------------------------------------------
diff --git a/src/game/shared/hl2mp/weapon_rpg.cpp b/src/game/shared/hl2mp/weapon_rpg.cpp
index 58e82c4..dab9131 100644
--- a/src/game/shared/hl2mp/weapon_rpg.cpp
+++ b/src/game/shared/hl2mp/weapon_rpg.cpp
@@ -673,6 +673,35 @@ CMissile *CMissile::Create( const Vector &vecOrigin, const QAngle &vecAngles, ed
 }
 
 
+#ifdef HL2SB
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+CUtlVector<CMissile::CustomDetonator_t> CMissile::gm_CustomDetonators;
+
+void CMissile::AddCustomDetonator( CBaseEntity *pEntity, float radius, float height )
+{
+	int i = gm_CustomDetonators.AddToTail();
+	gm_CustomDetonators[i].hEntity = pEntity;
+	gm_CustomDetonators[i].radiusSq = Square( radius );
+	gm_CustomDetonators[i].halfHeight = height * 0.5f;
+}
+
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+void CMissile::RemoveCustomDetonator( CBaseEntity *pEntity )
+{
+	for ( int i = 0; i < gm_CustomDetonators.Count(); i++ )
+	{
+		if ( gm_CustomDetonators[i].hEntity == pEntity )
+		{
+			gm_CustomDetonators.FastRemove( i );
+			break;
+		}
+	}
+}
+#endif
+
 
 //-----------------------------------------------------------------------------
 // This entity is used to create little force boxes that the helicopter
@@ -1321,6 +1350,22 @@ acttable_t	CWeaponRPG::m_acttable[] =
 	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_RPG,		false },
 
 	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_RPG,					false },
+
+#ifdef HL2SB
+	{ ACT_RANGE_ATTACK1, ACT_RANGE_ATTACK_RPG, true },
+
+	{ ACT_IDLE_RELAXED,				ACT_IDLE_RPG_RELAXED,			true },
+	{ ACT_IDLE_STIMULATED,			ACT_IDLE_ANGRY_RPG,				true },
+	{ ACT_IDLE_AGITATED,			ACT_IDLE_ANGRY_RPG,				true },
+
+	{ ACT_IDLE,						ACT_IDLE_RPG,					true },
+	{ ACT_IDLE_ANGRY,				ACT_IDLE_ANGRY_RPG,				true },
+	{ ACT_WALK,						ACT_WALK_RPG,					true },
+	{ ACT_WALK_CROUCH,				ACT_WALK_CROUCH_RPG,			true },
+	{ ACT_RUN,						ACT_RUN_RPG,					true },
+	{ ACT_RUN_CROUCH,				ACT_RUN_CROUCH_RPG,				true },
+	{ ACT_COVER_LOW,				ACT_COVER_LOW_RPG,				true },
+#endif
 };
 
 IMPLEMENT_ACTTABLE(CWeaponRPG);
@@ -1398,6 +1443,78 @@ void CWeaponRPG::Activate( void )
 	}
 }
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : *pEvent - 
+//			*pOperator - 
+//-----------------------------------------------------------------------------
+void CWeaponRPG::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator )
+{
+	switch( pEvent->event )
+	{
+		case EVENT_WEAPON_SMG1:
+		{
+			if ( m_hMissile != NULL )
+				return;
+
+			Vector	muzzlePoint;
+			QAngle	vecAngles;
+
+			muzzlePoint = GetOwner()->Weapon_ShootPosition();
+
+			CAI_BaseNPC *npc = pOperator->MyNPCPointer();
+			ASSERT( npc != NULL );
+
+			Vector vecShootDir = npc->GetActualShootTrajectory( muzzlePoint );
+
+			// look for a better launch location
+			Vector altLaunchPoint;
+			if (GetAttachment( "missile", altLaunchPoint ))
+			{
+				// check to see if it's relativly free
+				trace_t tr;
+				AI_TraceHull( altLaunchPoint, altLaunchPoint + vecShootDir * (10.0f*12.0f), Vector( -24, -24, -24 ), Vector( 24, 24, 24 ), MASK_NPCSOLID, NULL, &tr );
+
+				if( tr.fraction == 1.0)
+				{
+					muzzlePoint = altLaunchPoint;
+				}
+			}
+
+			VectorAngles( vecShootDir, vecAngles );
+
+			m_hMissile = CMissile::Create( muzzlePoint, vecAngles, GetOwner()->edict() );		
+			CMissile *pMissile = (CMissile *)m_hMissile.Get();
+			pMissile->m_hOwner = this;
+
+			// NPCs always get a grace period
+			pMissile->SetGracePeriod( 0.5 );
+
+			pOperator->DoMuzzleFlash();
+
+			WeaponSound( SINGLE_NPC );
+
+			// Make sure our laserdot is off
+			m_bGuiding = false;
+
+			if ( m_hLaserDot )
+			{
+				m_hLaserDot->TurnOff();
+			}
+		}
+		break;
+
+		default:
+			BaseClass::Operator_HandleAnimEvent( pEvent, pOperator );
+			break;
+	}
+}
+#endif
+#endif
+
 //-----------------------------------------------------------------------------
 // Purpose: 
 //-----------------------------------------------------------------------------
@@ -1603,7 +1720,22 @@ Vector CWeaponRPG::GetLaserPosition( void )
 //-----------------------------------------------------------------------------
 void CWeaponRPG::UpdateNPCLaserPosition( const Vector &vecTarget )
 {
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	CreateLaserPointer();
+	// Turn the laserdot on
+	m_bGuiding = true;
+	m_hLaserDot->TurnOn();
+
+	Vector muzzlePoint = GetOwner()->Weapon_ShootPosition();
+	Vector vecDir = (vecTarget - muzzlePoint);
+	VectorNormalize( vecDir );
+	vecDir = muzzlePoint + ( vecDir * MAX_TRACE_LENGTH );
+	UpdateLaserPosition( muzzlePoint, vecDir );
 
+	SetNPCLaserPosition( vecTarget );
+#endif
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -1611,6 +1743,12 @@ void CWeaponRPG::UpdateNPCLaserPosition( const Vector &vecTarget )
 //-----------------------------------------------------------------------------
 void CWeaponRPG::SetNPCLaserPosition( const Vector &vecTarget ) 
 { 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	m_vecNPCLaserDot = vecTarget; 
+	//NDebugOverlay::Box( m_vecNPCLaserDot, -Vector(10,10,10), Vector(10,10,10), 255,0,0, 8, 3 );
+#endif
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -1618,7 +1756,15 @@ void CWeaponRPG::SetNPCLaserPosition( const Vector &vecTarget )
 //-----------------------------------------------------------------------------
 const Vector &CWeaponRPG::GetNPCLaserPosition( void )
 {
+#ifndef HL2SB
+	return vec3_origin;
+#else
+#ifndef CLIENT_DLL
+	return m_vecNPCLaserDot;
+#else
 	return vec3_origin;
+#endif
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -1844,6 +1990,91 @@ bool CWeaponRPG::Reload( void )
 	return true;
 }
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+bool CWeaponRPG::WeaponLOSCondition( const Vector &ownerPos, const Vector &targetPos, bool bSetConditions )
+{
+	bool bResult = BaseClass::WeaponLOSCondition( ownerPos, targetPos, bSetConditions );
+
+	if( bResult )
+	{
+		CAI_BaseNPC* npcOwner = GetOwner()->MyNPCPointer();
+
+		if( npcOwner )
+		{
+			trace_t tr;
+
+			Vector vecRelativeShootPosition;
+			VectorSubtract( npcOwner->Weapon_ShootPosition(), npcOwner->GetAbsOrigin(), vecRelativeShootPosition );
+			Vector vecMuzzle = ownerPos + vecRelativeShootPosition;
+			Vector vecShootDir = npcOwner->GetActualShootTrajectory( vecMuzzle );
+
+			// Make sure I have a good 10 feet of wide clearance in front, or I'll blow my teeth out.
+			AI_TraceHull( vecMuzzle, vecMuzzle + vecShootDir * (10.0f*12.0f), Vector( -24, -24, -24 ), Vector( 24, 24, 24 ), MASK_NPCSOLID, NULL, &tr );
+
+			if( tr.fraction != 1.0f )
+				bResult = false;
+		}
+	}
+
+	return bResult;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : flDot - 
+//			flDist - 
+// Output : int
+//-----------------------------------------------------------------------------
+int CWeaponRPG::WeaponRangeAttack1Condition( float flDot, float flDist )
+{
+	if ( m_hMissile != NULL )
+		return 0;
+
+	// Ignore vertical distance when doing our RPG distance calculations
+	CAI_BaseNPC *pNPC = GetOwner()->MyNPCPointer();
+	if ( pNPC )
+	{
+		CBaseEntity *pEnemy = pNPC->GetEnemy();
+		Vector vecToTarget = (pEnemy->GetAbsOrigin() - pNPC->GetAbsOrigin());
+		vecToTarget.z = 0;
+		flDist = vecToTarget.Length();
+	}
+
+	if ( flDist < min( m_fMinRange1, m_fMinRange2 ) )
+		return COND_TOO_CLOSE_TO_ATTACK;
+
+	if ( m_flNextPrimaryAttack > gpGlobals->curtime )
+		return 0;
+
+	// See if there's anyone in the way!
+	CAI_BaseNPC *pOwner = GetOwner()->MyNPCPointer();
+	ASSERT( pOwner != NULL );
+
+	if( pOwner )
+	{
+		// Make sure I don't shoot the world!
+		trace_t tr;
+
+		Vector vecMuzzle = pOwner->Weapon_ShootPosition();
+		Vector vecShootDir = pOwner->GetActualShootTrajectory( vecMuzzle );
+
+		// Make sure I have a good 10 feet of wide clearance in front, or I'll blow my teeth out.
+		AI_TraceHull( vecMuzzle, vecMuzzle + vecShootDir * (10.0f*12.0f), Vector( -24, -24, -24 ), Vector( 24, 24, 24 ), MASK_NPCSOLID, NULL, &tr );
+
+		if( tr.fraction != 1.0 )
+		{
+			return COND_WEAPON_SIGHT_OCCLUDED;
+		}
+	}
+
+	return COND_CAN_RANGE_ATTACK1;
+}
+#endif
+#endif
+
 #ifdef CLIENT_DLL
 
 #define	RPG_MUZZLE_ATTACHMENT		1
@@ -2209,7 +2440,11 @@ void CLaserDot::TurnOn( void )
 	m_bIsOn = true;
 	if ( m_bVisibleLaserDot )
 	{
+#ifndef HL2SB
 		//BaseClass::TurnOn();
+#else
+		RemoveEffects( EF_NODRAW );
+#endif
 	}
 }
 
@@ -2222,7 +2457,12 @@ void CLaserDot::TurnOff( void )
 	m_bIsOn = false;
 	if ( m_bVisibleLaserDot )
 	{
+#ifndef HL2SB
 		//BaseClass::TurnOff();
+#else
+		AddEffects( EF_NODRAW );
+		SetNextThink( TICK_NEVER_THINK );
+#endif
 	}
 }
 
@@ -2232,6 +2472,10 @@ void CLaserDot::TurnOff( void )
 //-----------------------------------------------------------------------------
 void CLaserDot::MakeInvisible( void )
 {
+#ifdef HL2SB
+	AddEffects( EF_NODRAW );
+	SetNextThink( TICK_NEVER_THINK );
+#endif
 }
 
 #ifdef CLIENT_DLL
diff --git a/src/game/shared/hl2mp/weapon_rpg.h b/src/game/shared/hl2mp/weapon_rpg.h
index b90621d..1c22c02 100644
--- a/src/game/shared/hl2mp/weapon_rpg.h
+++ b/src/game/shared/hl2mp/weapon_rpg.h
@@ -70,6 +70,11 @@ public:
 
 	static CMissile *Create( const Vector &vecOrigin, const QAngle &vecAngles, edict_t *pentOwner );
 
+#ifdef HL2SB
+	static void AddCustomDetonator( CBaseEntity *pEntity, float radius, float height = -1 );
+	static void RemoveCustomDetonator( CBaseEntity *pEntity );
+#endif
+
 protected:
 	virtual void DoExplosion();	
 	virtual void ComputeActualDotPosition( CLaserDot *pLaserDot, Vector *pActualDotPosition, float *pHomingSpeed );
@@ -86,6 +91,17 @@ protected:
 	float					m_flMarkDeadTime;
 	float					m_flDamage;
 
+#ifdef HL2SB
+	struct CustomDetonator_t
+	{
+		EHANDLE hEntity;
+		float radiusSq;
+		float halfHeight;
+	};
+
+	static CUtlVector<CustomDetonator_t> gm_CustomDetonators;
+#endif
+
 private:
 	float					m_flGracePeriodEndsAt;
 
@@ -199,6 +215,14 @@ public:
 	float	GetMinRestTime() { return 4.0; }
 	float	GetMaxRestTime() { return 4.0; }
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	bool	WeaponLOSCondition( const Vector &ownerPos, const Vector &targetPos, bool bSetConditions );
+	int		WeaponRangeAttack1Condition( float flDot, float flDist );
+
+	void	Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator );
+#endif
+#endif
 	void	StartGuiding( void );
 	void	StopGuiding( void );
 	void	ToggleGuiding( void );
@@ -219,6 +243,18 @@ public:
 	void	SetNPCLaserPosition( const Vector &vecTarget );
 	const Vector &GetNPCLaserPosition( void );
 	
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	int		CapabilitiesGet( void ) { return bits_CAP_WEAPON_RANGE_ATTACK1; }
+
+	virtual const Vector& GetBulletSpread( void )
+	{
+		static Vector cone = VECTOR_CONE_3DEGREES;
+		return cone;
+	}
+#endif
+#endif
+
 #ifdef CLIENT_DLL
 
 	// We need to render opaque and translucent pieces
@@ -257,6 +293,9 @@ protected:
 	CNetworkVar(	Vector,			m_vecLaserDot );
 
 #ifndef CLIENT_DLL
+#ifdef HL2SB
+	Vector				m_vecNPCLaserDot;
+#endif
 	CHandle<CLaserDot>	m_hLaserDot;
 #endif
 
diff --git a/src/game/shared/hl2mp/weapon_shotgun.cpp b/src/game/shared/hl2mp/weapon_shotgun.cpp
index 09e510f..d00d34f 100644
--- a/src/game/shared/hl2mp/weapon_shotgun.cpp
+++ b/src/game/shared/hl2mp/weapon_shotgun.cpp
@@ -16,6 +16,12 @@
 
 #include "weapon_hl2mpbasehlmpcombatweapon.h"
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+#include "gamestats.h"
+#endif
+#endif
+
 #ifdef CLIENT_DLL
 #define CWeaponShotgun C_WeaponShotgun
 #endif
@@ -36,17 +42,53 @@ private:
 	CNetworkVar( bool,	m_bDelayedFire1 );	// Fire primary when finished reloading
 	CNetworkVar( bool,	m_bDelayedFire2 );	// Fire secondary when finished reloading
 	CNetworkVar( bool,	m_bDelayedReload );	// Reload when finished pump
+#ifdef HL2SB
+	CNetworkVar( bool,	m_bInReload );
+#endif
 
 public:
+#ifdef HL2SB
+	void	Precache( void );
+
+#ifndef CLIENT_DLL
+	int CapabilitiesGet( void ) { return bits_CAP_WEAPON_RANGE_ATTACK1; }
+#endif
+#endif
+
 	virtual const Vector& GetBulletSpread( void )
 	{
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+		static Vector vitalAllyCone = VECTOR_CONE_3DEGREES;
+#endif
+#endif
 		static Vector cone = VECTOR_CONE_10DEGREES;
+
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+		if( GetOwner() && (GetOwner()->Classify() == CLASS_PLAYER_ALLY_VITAL) )
+		{
+			// Give Alyx's shotgun blasts more a more directed punch. She needs
+			// to be at least as deadly as she would be with her pistol to stay interesting (sjb)
+			return vitalAllyCone;
+		}
+#endif
+#endif
+
 		return cone;
 	}
 
 	virtual int				GetMinBurst() { return 1; }
 	virtual int				GetMaxBurst() { return 3; }
 
+#ifdef HL2SB
+	bool Holster( CBaseCombatWeapon *pSwitchingTo );
+	virtual float			GetMinRestTime();
+	virtual float			GetMaxRestTime();
+
+	virtual float			GetFireRate( void );
+#endif
+
 	bool StartReload( void );
 	bool Reload( void );
 	void FillClip( void );
@@ -59,7 +101,17 @@ public:
 	void PrimaryAttack( void );
 	void SecondaryAttack( void );
 	void DryFire( void );
+#ifndef HL2SB
 	virtual float GetFireRate( void ) { return 0.7; };
+#endif
+
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	void FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles );
+	void Operator_ForceNPCFire( CBaseCombatCharacter  *pOperator, bool bSecondary );
+	void Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator );
+#endif
+#endif
 
 	DECLARE_ACTTABLE();
 
@@ -77,11 +129,17 @@ BEGIN_NETWORK_TABLE( CWeaponShotgun, DT_WeaponShotgun )
 	RecvPropBool( RECVINFO( m_bDelayedFire1 ) ),
 	RecvPropBool( RECVINFO( m_bDelayedFire2 ) ),
 	RecvPropBool( RECVINFO( m_bDelayedReload ) ),
+#ifdef HL2SB
+	RecvPropBool( RECVINFO( m_bInReload ) ),
+#endif
 #else
 	SendPropBool( SENDINFO( m_bNeedPump ) ),
 	SendPropBool( SENDINFO( m_bDelayedFire1 ) ),
 	SendPropBool( SENDINFO( m_bDelayedFire2 ) ),
 	SendPropBool( SENDINFO( m_bDelayedReload ) ),
+#ifdef HL2SB
+	SendPropBool( SENDINFO( m_bInReload ) ),
+#endif
 #endif
 END_NETWORK_TABLE()
 
@@ -91,6 +149,9 @@ BEGIN_PREDICTION_DATA( CWeaponShotgun )
 	DEFINE_PRED_FIELD( m_bDelayedFire1, FIELD_BOOLEAN, FTYPEDESC_INSENDTABLE ),
 	DEFINE_PRED_FIELD( m_bDelayedFire2, FIELD_BOOLEAN, FTYPEDESC_INSENDTABLE ),
 	DEFINE_PRED_FIELD( m_bDelayedReload, FIELD_BOOLEAN, FTYPEDESC_INSENDTABLE ),
+#ifdef HL2SB
+	DEFINE_PRED_FIELD( m_bInReload, FIELD_BOOLEAN, FTYPEDESC_INSENDTABLE ),
+#endif
 END_PREDICTION_DATA()
 #endif
 
@@ -112,11 +173,191 @@ acttable_t	CWeaponShotgun::m_acttable[] =
 	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,		false },
 
 	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_SHOTGUN,					false },
+
+#ifdef HL2SB
+	{ ACT_IDLE,						ACT_IDLE_SMG1,					true },	// FIXME: hook to shotgun unique
+
+	{ ACT_RANGE_ATTACK1,			ACT_RANGE_ATTACK_SHOTGUN,			true },
+	{ ACT_RELOAD,					ACT_RELOAD_SHOTGUN,					false },
+	{ ACT_WALK,						ACT_WALK_RIFLE,						true },
+	{ ACT_IDLE_ANGRY,				ACT_IDLE_ANGRY_SHOTGUN,				true },
+
+// Readiness activities (not aiming)
+	{ ACT_IDLE_RELAXED,				ACT_IDLE_SHOTGUN_RELAXED,		false },//never aims
+	{ ACT_IDLE_STIMULATED,			ACT_IDLE_SHOTGUN_STIMULATED,	false },
+	{ ACT_IDLE_AGITATED,			ACT_IDLE_SHOTGUN_AGITATED,		false },//always aims
+
+	{ ACT_WALK_RELAXED,				ACT_WALK_RIFLE_RELAXED,			false },//never aims
+	{ ACT_WALK_STIMULATED,			ACT_WALK_RIFLE_STIMULATED,		false },
+	{ ACT_WALK_AGITATED,			ACT_WALK_AIM_RIFLE,				false },//always aims
+
+	{ ACT_RUN_RELAXED,				ACT_RUN_RIFLE_RELAXED,			false },//never aims
+	{ ACT_RUN_STIMULATED,			ACT_RUN_RIFLE_STIMULATED,		false },
+	{ ACT_RUN_AGITATED,				ACT_RUN_AIM_RIFLE,				false },//always aims
+
+// Readiness activities (aiming)
+	{ ACT_IDLE_AIM_RELAXED,			ACT_IDLE_SMG1_RELAXED,			false },//never aims	
+	{ ACT_IDLE_AIM_STIMULATED,		ACT_IDLE_AIM_RIFLE_STIMULATED,	false },
+	{ ACT_IDLE_AIM_AGITATED,		ACT_IDLE_ANGRY_SMG1,			false },//always aims
+
+	{ ACT_WALK_AIM_RELAXED,			ACT_WALK_RIFLE_RELAXED,			false },//never aims
+	{ ACT_WALK_AIM_STIMULATED,		ACT_WALK_AIM_RIFLE_STIMULATED,	false },
+	{ ACT_WALK_AIM_AGITATED,		ACT_WALK_AIM_RIFLE,				false },//always aims
+
+	{ ACT_RUN_AIM_RELAXED,			ACT_RUN_RIFLE_RELAXED,			false },//never aims
+	{ ACT_RUN_AIM_STIMULATED,		ACT_RUN_AIM_RIFLE_STIMULATED,	false },
+	{ ACT_RUN_AIM_AGITATED,			ACT_RUN_AIM_RIFLE,				false },//always aims
+//End readiness activities
+
+	{ ACT_WALK_AIM,					ACT_WALK_AIM_SHOTGUN,				true },
+	{ ACT_WALK_CROUCH,				ACT_WALK_CROUCH_RIFLE,				true },
+	{ ACT_WALK_CROUCH_AIM,			ACT_WALK_CROUCH_AIM_RIFLE,			true },
+	{ ACT_RUN,						ACT_RUN_RIFLE,						true },
+	{ ACT_RUN_AIM,					ACT_RUN_AIM_SHOTGUN,				true },
+	{ ACT_RUN_CROUCH,				ACT_RUN_CROUCH_RIFLE,				true },
+	{ ACT_RUN_CROUCH_AIM,			ACT_RUN_CROUCH_AIM_RIFLE,			true },
+	{ ACT_GESTURE_RANGE_ATTACK1,	ACT_GESTURE_RANGE_ATTACK_SHOTGUN,	true },
+	{ ACT_RANGE_ATTACK1_LOW,		ACT_RANGE_ATTACK_SHOTGUN_LOW,		true },
+	{ ACT_RELOAD_LOW,				ACT_RELOAD_SHOTGUN_LOW,				false },
+	{ ACT_GESTURE_RELOAD,			ACT_GESTURE_RELOAD_SHOTGUN,			false },
+#endif
 };
 
 IMPLEMENT_ACTTABLE(CWeaponShotgun);
 
 
+#ifdef HL2SB
+bool CWeaponShotgun::Holster( CBaseCombatWeapon *pSwitchingTo )
+{
+	m_bInReload = false;
+
+	return BaseClass::Holster( pSwitchingTo );
+}
+
+void CWeaponShotgun::Precache( void )
+{
+	CBaseCombatWeapon::Precache();
+}
+
+#ifndef CLIENT_DLL
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : *pOperator - 
+//-----------------------------------------------------------------------------
+void CWeaponShotgun::FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles )
+{
+	Vector vecShootOrigin, vecShootDir;
+	CAI_BaseNPC *npc = pOperator->MyNPCPointer();
+	ASSERT( npc != NULL );
+	WeaponSound( SINGLE_NPC );
+	pOperator->DoMuzzleFlash();
+	m_iClip1 = m_iClip1 - 1;
+
+	if ( bUseWeaponAngles )
+	{
+		QAngle	angShootDir;
+		GetAttachment( LookupAttachment( "muzzle" ), vecShootOrigin, angShootDir );
+		AngleVectors( angShootDir, &vecShootDir );
+	}
+	else 
+	{
+		vecShootOrigin = pOperator->Weapon_ShootPosition();
+		vecShootDir = npc->GetActualShootTrajectory( vecShootOrigin );
+	}
+
+	pOperator->FireBullets( 8, vecShootOrigin, vecShootDir, GetBulletSpread(), MAX_TRACE_LENGTH, m_iPrimaryAmmoType, 0 );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CWeaponShotgun::Operator_ForceNPCFire( CBaseCombatCharacter *pOperator, bool bSecondary )
+{
+	// Ensure we have enough rounds in the clip
+	m_iClip1++;
+
+	FireNPCPrimaryAttack( pOperator, true );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose:
+// Input  :
+// Output :
+//-----------------------------------------------------------------------------
+void CWeaponShotgun::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator )
+{
+	switch( pEvent->event )
+	{
+		case EVENT_WEAPON_SHOTGUN_FIRE:
+		{
+			FireNPCPrimaryAttack( pOperator, false );
+		}
+		break;
+
+		default:
+			CBaseCombatWeapon::Operator_HandleAnimEvent( pEvent, pOperator );
+			break;
+	}
+}
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Purpose:	When we shipped HL2, the shotgun weapon did not override the
+//			BaseCombatWeapon default rest time of 0.3 to 0.6 seconds. When
+//			NPC's fight from a stationary position, their animation events
+//			govern when they fire so the rate of fire is specified by the
+//			animation. When NPC's move-and-shoot, the rate of fire is 
+//			specifically controlled by the shot regulator, so it's imporant
+//			that GetMinRestTime and GetMaxRestTime are implemented and provide
+//			reasonable defaults for the weapon. To address difficulty concerns,
+//			we are going to fix the combine's rate of shotgun fire in episodic.
+//			This change will not affect Alyx using a shotgun in EP1. (sjb)
+//-----------------------------------------------------------------------------
+float CWeaponShotgun::GetMinRestTime()
+{
+#ifndef CLIENT_DLL
+	if( hl2_episodic.GetBool() && GetOwner() && GetOwner()->Classify() == CLASS_COMBINE )
+	{
+		return 1.2f;
+	}
+#endif
+	
+	return BaseClass::GetMinRestTime();
+}
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+float CWeaponShotgun::GetMaxRestTime()
+{
+#ifndef CLIENT_DLL
+	if( hl2_episodic.GetBool() && GetOwner() && GetOwner()->Classify() == CLASS_COMBINE )
+	{
+		return 1.5f;
+	}
+#endif
+
+	return BaseClass::GetMaxRestTime();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Time between successive shots in a burst. Also returned for EP2
+//			with an eye to not messing up Alyx in EP1.
+//-----------------------------------------------------------------------------
+float CWeaponShotgun::GetFireRate()
+{
+#ifndef CLIENT_DLL
+	if( hl2_episodic.GetBool() && GetOwner() && GetOwner()->Classify() == CLASS_COMBINE )
+	{
+		return 0.8f;
+	}
+#endif
+
+	return 0.7;
+}
+#endif
+
+//-----------------------------------------------------------------------------
 //-----------------------------------------------------------------------------
 // Purpose: Override so only reload one shell at a time
 // Input  :
@@ -322,7 +563,17 @@ void CWeaponShotgun::PrimaryAttack( void )
 	Vector	vecSrc		= pPlayer->Weapon_ShootPosition( );
 	Vector	vecAiming	= pPlayer->GetAutoaimVector( AUTOAIM_10DEGREES );	
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 1.0 );
+#endif
+#endif
+
+#ifndef HL2SB
 	FireBulletsInfo_t info( 7, vecSrc, vecAiming, GetBulletSpread(), MAX_TRACE_LENGTH, m_iPrimaryAmmoType );
+#else
+	FireBulletsInfo_t info( sk_plr_num_shotgun_pellets.GetInt(), vecSrc, vecAiming, GetBulletSpread(), MAX_TRACE_LENGTH, m_iPrimaryAmmoType );
+#endif
 	info.m_pAttacker = pPlayer;
 
 	// Fire the bullets, and force the first shot to be perfectly accuracy
@@ -332,6 +583,12 @@ void CWeaponShotgun::PrimaryAttack( void )
 	punch.Init( SharedRandomFloat( "shotgunpax", -2, -1 ), SharedRandomFloat( "shotgunpay", -2, 2 ), 0 );
 	pPlayer->ViewPunch( punch );
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	CSoundEnt::InsertSound( SOUND_COMBAT, GetAbsOrigin(), SOUNDENT_VOLUME_SHOTGUN, 0.2, GetOwner() );
+#endif
+#endif
+
 	if (!m_iClip1 && pPlayer->GetAmmoCount(m_iPrimaryAmmoType) <= 0)
 	{
 		// HEV suit - indicate out of ammo condition
@@ -339,6 +596,12 @@ void CWeaponShotgun::PrimaryAttack( void )
 	}
 
 	m_bNeedPump = true;
+
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	gamestats->Event_WeaponFired( pPlayer, true, GetClassname() );
+#endif
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -384,6 +647,14 @@ void CWeaponShotgun::SecondaryAttack( void )
 	pPlayer->FireBullets( info );
 	pPlayer->ViewPunch( QAngle(SharedRandomFloat( "shotgunsax", -5, 5 ),0,0) );
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 1.0 );
+
+	CSoundEnt::InsertSound( SOUND_COMBAT, GetAbsOrigin(), SOUNDENT_VOLUME_SHOTGUN, 0.2 );
+#endif
+#endif
+
 	if (!m_iClip1 && pPlayer->GetAmmoCount(m_iPrimaryAmmoType) <= 0)
 	{
 		// HEV suit - indicate out of ammo condition
@@ -391,6 +662,12 @@ void CWeaponShotgun::SecondaryAttack( void )
 	}
 
 	m_bNeedPump = true;
+
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	gamestats->Event_WeaponFired( pPlayer, false, GetClassname() );
+#endif
+#endif
 }
 
 //-----------------------------------------------------------------------------
diff --git a/src/game/shared/hl2mp/weapon_smg1.cpp b/src/game/shared/hl2mp/weapon_smg1.cpp
index 9eda487..b0af605 100644
--- a/src/game/shared/hl2mp/weapon_smg1.cpp
+++ b/src/game/shared/hl2mp/weapon_smg1.cpp
@@ -7,6 +7,11 @@
 #include "cbase.h"
 #include "npcevent.h"
 #include "in_buttons.h"
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+#include "soundent.h"
+#endif
+#endif
 
 #ifdef CLIENT_DLL
 	#include "c_hl2mp_player.h"
@@ -19,6 +24,13 @@
 #include "weapon_hl2mpbase.h"
 #include "weapon_hl2mpbase_machinegun.h"
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+#include "rumble_shared.h"
+#include "gamestats.h"
+#endif
+#endif
+
 #ifdef CLIENT_DLL
 #define CWeaponSMG1 C_WeaponSMG1
 #endif
@@ -28,6 +40,9 @@
 
 #define SMG1_GRENADE_DAMAGE 100.0f
 #define SMG1_GRENADE_RADIUS 250.0f
+#ifdef HL2SB
+extern ConVar    sk_plr_dmg_smg1_grenade;	
+#endif
 
 class CWeaponSMG1 : public CHL2MPMachineGun
 {
@@ -51,6 +66,12 @@ public:
 	bool	Reload( void );
 
 	float	GetFireRate( void ) { return 0.075f; }	// 13.3hz
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	int		CapabilitiesGet( void ) { return bits_CAP_WEAPON_RANGE_ATTACK1; }
+	int		WeaponRangeAttack2Condition( float flDot, float flDist );
+#endif
+#endif
 	Activity	GetPrimaryAttackActivity( void );
 
 	virtual const Vector& GetBulletSpread( void )
@@ -61,6 +82,14 @@ public:
 
 	const WeaponProficiencyInfo_t *GetProficiencyValues();
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	void FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, Vector &vecShootOrigin, Vector &vecShootDir );
+	void Operator_ForceNPCFire( CBaseCombatCharacter  *pOperator, bool bSecondary );
+	void Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator );
+#endif
+#endif
+
 	DECLARE_ACTTABLE();
 
 protected:
@@ -98,6 +127,57 @@ acttable_t	CWeaponSMG1::m_acttable[] =
 	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_SMG1,			false },
 
 	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_SMG1,					false },
+
+#ifdef HL2SB
+	{ ACT_RANGE_ATTACK1,			ACT_RANGE_ATTACK_SMG1,			true },
+	{ ACT_RELOAD,					ACT_RELOAD_SMG1,				true },
+	{ ACT_IDLE,						ACT_IDLE_SMG1,					true },
+	{ ACT_IDLE_ANGRY,				ACT_IDLE_ANGRY_SMG1,			true },
+
+	{ ACT_WALK,						ACT_WALK_RIFLE,					true },
+	{ ACT_WALK_AIM,					ACT_WALK_AIM_RIFLE,				true  },
+	
+// Readiness activities (not aiming)
+	{ ACT_IDLE_RELAXED,				ACT_IDLE_SMG1_RELAXED,			false },//never aims
+	{ ACT_IDLE_STIMULATED,			ACT_IDLE_SMG1_STIMULATED,		false },
+	{ ACT_IDLE_AGITATED,			ACT_IDLE_ANGRY_SMG1,			false },//always aims
+
+	{ ACT_WALK_RELAXED,				ACT_WALK_RIFLE_RELAXED,			false },//never aims
+	{ ACT_WALK_STIMULATED,			ACT_WALK_RIFLE_STIMULATED,		false },
+	{ ACT_WALK_AGITATED,			ACT_WALK_AIM_RIFLE,				false },//always aims
+
+	{ ACT_RUN_RELAXED,				ACT_RUN_RIFLE_RELAXED,			false },//never aims
+	{ ACT_RUN_STIMULATED,			ACT_RUN_RIFLE_STIMULATED,		false },
+	{ ACT_RUN_AGITATED,				ACT_RUN_AIM_RIFLE,				false },//always aims
+
+// Readiness activities (aiming)
+	{ ACT_IDLE_AIM_RELAXED,			ACT_IDLE_SMG1_RELAXED,			false },//never aims	
+	{ ACT_IDLE_AIM_STIMULATED,		ACT_IDLE_AIM_RIFLE_STIMULATED,	false },
+	{ ACT_IDLE_AIM_AGITATED,		ACT_IDLE_ANGRY_SMG1,			false },//always aims
+
+	{ ACT_WALK_AIM_RELAXED,			ACT_WALK_RIFLE_RELAXED,			false },//never aims
+	{ ACT_WALK_AIM_STIMULATED,		ACT_WALK_AIM_RIFLE_STIMULATED,	false },
+	{ ACT_WALK_AIM_AGITATED,		ACT_WALK_AIM_RIFLE,				false },//always aims
+
+	{ ACT_RUN_AIM_RELAXED,			ACT_RUN_RIFLE_RELAXED,			false },//never aims
+	{ ACT_RUN_AIM_STIMULATED,		ACT_RUN_AIM_RIFLE_STIMULATED,	false },
+	{ ACT_RUN_AIM_AGITATED,			ACT_RUN_AIM_RIFLE,				false },//always aims
+//End readiness activities
+
+	{ ACT_WALK_AIM,					ACT_WALK_AIM_RIFLE,				true },
+	{ ACT_WALK_CROUCH,				ACT_WALK_CROUCH_RIFLE,			true },
+	{ ACT_WALK_CROUCH_AIM,			ACT_WALK_CROUCH_AIM_RIFLE,		true },
+	{ ACT_RUN,						ACT_RUN_RIFLE,					true },
+	{ ACT_RUN_AIM,					ACT_RUN_AIM_RIFLE,				true },
+	{ ACT_RUN_CROUCH,				ACT_RUN_CROUCH_RIFLE,			true },
+	{ ACT_RUN_CROUCH_AIM,			ACT_RUN_CROUCH_AIM_RIFLE,		true },
+	{ ACT_GESTURE_RANGE_ATTACK1,	ACT_GESTURE_RANGE_ATTACK_SMG1,	true },
+	{ ACT_RANGE_ATTACK1_LOW,		ACT_RANGE_ATTACK_SMG1_LOW,		true },
+	{ ACT_COVER_LOW,				ACT_COVER_SMG1_LOW,				false },
+	{ ACT_RANGE_AIM_LOW,			ACT_RANGE_AIM_SMG1_LOW,			false },
+	{ ACT_RELOAD_LOW,				ACT_RELOAD_SMG1_LOW,			false },
+	{ ACT_GESTURE_RELOAD,			ACT_GESTURE_RELOAD_SMG1,		true },
+#endif
 };
 
 IMPLEMENT_ACTTABLE(CWeaponSMG1);
@@ -107,6 +187,10 @@ CWeaponSMG1::CWeaponSMG1( )
 {
 	m_fMinRange1		= 0;// No minimum range. 
 	m_fMaxRange1		= 1400;
+
+#ifdef HL2SB
+	m_bAltFiresUnderwater = false;
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -126,11 +210,120 @@ void CWeaponSMG1::Precache( void )
 //-----------------------------------------------------------------------------
 void CWeaponSMG1::Equip( CBaseCombatCharacter *pOwner )
 {
+#ifndef HL2SB
 	m_fMaxRange1 = 1400;
+#else
+#ifdef CLIENT_DLL
+	m_fMaxRange1 = 1400;
+#else
+	if( pOwner->Classify() == CLASS_PLAYER_ALLY )
+	{
+		m_fMaxRange1 = 3000;
+	}
+	else
+	{
+		m_fMaxRange1 = 1400;
+	}
+#endif
+#endif
 
 	BaseClass::Equip( pOwner );
 }
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CWeaponSMG1::FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, Vector &vecShootOrigin, Vector &vecShootDir )
+{
+	// FIXME: use the returned number of bullets to account for >10hz firerate
+	WeaponSoundRealtime( SINGLE_NPC );
+
+	CSoundEnt::InsertSound( SOUND_COMBAT|SOUND_CONTEXT_GUNFIRE, pOperator->GetAbsOrigin(), SOUNDENT_VOLUME_MACHINEGUN, 0.2, pOperator, SOUNDENT_CHANNEL_WEAPON, pOperator->GetEnemy() );
+	pOperator->FireBullets( 1, vecShootOrigin, vecShootDir, VECTOR_CONE_PRECALCULATED,
+		MAX_TRACE_LENGTH, m_iPrimaryAmmoType, 2, entindex(), 0 );
+
+	pOperator->DoMuzzleFlash();
+	m_iClip1 = m_iClip1 - 1;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CWeaponSMG1::Operator_ForceNPCFire( CBaseCombatCharacter *pOperator, bool bSecondary )
+{
+	// Ensure we have enough rounds in the clip
+	m_iClip1++;
+
+	Vector vecShootOrigin, vecShootDir;
+	QAngle	angShootDir;
+	GetAttachment( LookupAttachment( "muzzle" ), vecShootOrigin, angShootDir );
+	AngleVectors( angShootDir, &vecShootDir );
+	FireNPCPrimaryAttack( pOperator, vecShootOrigin, vecShootDir );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CWeaponSMG1::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator )
+{
+	switch( pEvent->event )
+	{
+	case EVENT_WEAPON_SMG1:
+		{
+			Vector vecShootOrigin, vecShootDir;
+			QAngle angDiscard;
+
+			// Support old style attachment point firing
+			if ((pEvent->options == NULL) || (pEvent->options[0] == '\0') || (!pOperator->GetAttachment(pEvent->options, vecShootOrigin, angDiscard)))
+			{
+				vecShootOrigin = pOperator->Weapon_ShootPosition();
+			}
+
+			CAI_BaseNPC *npc = pOperator->MyNPCPointer();
+			ASSERT( npc != NULL );
+			vecShootDir = npc->GetActualShootTrajectory( vecShootOrigin );
+
+			FireNPCPrimaryAttack( pOperator, vecShootOrigin, vecShootDir );
+		}
+		break;
+
+		/*//FIXME: Re-enable
+		case EVENT_WEAPON_AR2_GRENADE:
+		{
+		CAI_BaseNPC *npc = pOperator->MyNPCPointer();
+
+		Vector vecShootOrigin, vecShootDir;
+		vecShootOrigin = pOperator->Weapon_ShootPosition();
+		vecShootDir = npc->GetShootEnemyDir( vecShootOrigin );
+
+		Vector vecThrow = m_vecTossVelocity;
+
+		CGrenadeAR2 *pGrenade = (CGrenadeAR2*)Create( "grenade_ar2", vecShootOrigin, vec3_angle, npc );
+		pGrenade->SetAbsVelocity( vecThrow );
+		pGrenade->SetLocalAngularVelocity( QAngle( 0, 400, 0 ) );
+		pGrenade->SetMoveType( MOVETYPE_FLYGRAVITY ); 
+		pGrenade->m_hOwner			= npc;
+		pGrenade->m_pMyWeaponAR2	= this;
+		pGrenade->SetDamage(sk_npc_dmg_ar2_grenade.GetFloat());
+
+		// FIXME: arrgg ,this is hard coded into the weapon???
+		m_flNextGrenadeCheck = gpGlobals->curtime + 6;// wait six seconds before even looking again to see if a grenade can be thrown.
+
+		m_iClip2--;
+		}
+		break;
+		*/
+
+	default:
+		BaseClass::Operator_HandleAnimEvent( pEvent, pOperator );
+		break;
+	}
+}
+#endif
+#endif
+
 //-----------------------------------------------------------------------------
 // Purpose: 
 // Output : Activity
@@ -216,6 +409,12 @@ void CWeaponSMG1::SecondaryAttack( void )
 	// MUST call sound before removing a round from the clip of a CMachineGun
 	BaseClass::WeaponSound( WPN_DOUBLE );
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	pPlayer->RumbleEffect( RUMBLE_357, 0, RUMBLE_FLAGS_NONE );
+#endif
+#endif
+
 	Vector vecSrc = pPlayer->Weapon_ShootPosition();
 	Vector	vecThrow;
 	// Don't autoaim on grenade tosses
@@ -230,12 +429,22 @@ void CWeaponSMG1::SecondaryAttack( void )
 	pGrenade->SetLocalAngularVelocity( RandomAngle( -400, 400 ) );
 	pGrenade->SetMoveType( MOVETYPE_FLYGRAVITY, MOVECOLLIDE_FLY_BOUNCE ); 
 	pGrenade->SetThrower( GetOwner() );
+#ifndef HL2SB
 	pGrenade->SetDamage( SMG1_GRENADE_DAMAGE );
+#else
+	pGrenade->SetDamage( sk_plr_dmg_smg1_grenade.GetFloat() );
+#endif
 	pGrenade->SetDamageRadius( SMG1_GRENADE_RADIUS );
 #endif
 
 	SendWeaponAnim( ACT_VM_SECONDARYATTACK );
 
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	CSoundEnt::InsertSound( SOUND_COMBAT, GetAbsOrigin(), 1000, 0.2, GetOwner(), SOUNDENT_CHANNEL_WEAPON );
+#endif
+#endif
+
 	// player "shoot" animation
 	pPlayer->SetAnimation( PLAYER_ATTACK1 );
 	//Tony; TODO SECONDARY!
@@ -250,7 +459,128 @@ void CWeaponSMG1::SecondaryAttack( void )
 
 	// Can blow up after a short delay (so have time to release mouse button)
 	m_flNextSecondaryAttack = gpGlobals->curtime + 1.0f;
+
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+	// Register a muzzleflash for the AI.
+	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );	
+
+	gamestats->Event_WeaponFired( pPlayer, false, GetClassname() );
+#endif
+#endif
+}
+
+#ifdef HL2SB
+#ifndef CLIENT_DLL
+#define	COMBINE_MIN_GRENADE_CLEAR_DIST 256
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : flDot - 
+//			flDist - 
+// Output : int
+//-----------------------------------------------------------------------------
+int CWeaponSMG1::WeaponRangeAttack2Condition( float flDot, float flDist )
+{
+	CAI_BaseNPC *npcOwner = GetOwner()->MyNPCPointer();
+
+	return COND_NONE;
+
+/*
+	// --------------------------------------------------------
+	// Assume things haven't changed too much since last time
+	// --------------------------------------------------------
+	if (gpGlobals->curtime < m_flNextGrenadeCheck )
+		return m_lastGrenadeCondition;
+*/
+
+	// -----------------------
+	// If moving, don't check.
+	// -----------------------
+	if ( npcOwner->IsMoving())
+		return COND_NONE;
+
+	CBaseEntity *pEnemy = npcOwner->GetEnemy();
+
+	if (!pEnemy)
+		return COND_NONE;
+
+	Vector vecEnemyLKP = npcOwner->GetEnemyLKP();
+	if ( !( pEnemy->GetFlags() & FL_ONGROUND ) && pEnemy->GetWaterLevel() == 0 && vecEnemyLKP.z > (GetAbsOrigin().z + WorldAlignMaxs().z) )
+	{
+		//!!!BUGBUG - we should make this check movetype and make sure it isn't FLY? Players who jump a lot are unlikely to 
+		// be grenaded.
+		// don't throw grenades at anything that isn't on the ground!
+		return COND_NONE;
+	}
+	
+	// --------------------------------------
+	//  Get target vector
+	// --------------------------------------
+	Vector vecTarget;
+	if (random->RandomInt(0,1))
+	{
+		// magically know where they are
+		vecTarget = pEnemy->WorldSpaceCenter();
+	}
+	else
+	{
+		// toss it to where you last saw them
+		vecTarget = vecEnemyLKP;
+	}
+	// vecTarget = m_vecEnemyLKP + (pEnemy->BodyTarget( GetLocalOrigin() ) - pEnemy->GetLocalOrigin());
+	// estimate position
+	// vecTarget = vecTarget + pEnemy->m_vecVelocity * 2;
+
+
+	if ( ( vecTarget - npcOwner->GetLocalOrigin() ).Length2D() <= COMBINE_MIN_GRENADE_CLEAR_DIST )
+	{
+		// crap, I don't want to blow myself up
+		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
+		return (COND_NONE);
+	}
+
+	// ---------------------------------------------------------------------
+	// Are any friendlies near the intended grenade impact area?
+	// ---------------------------------------------------------------------
+	CBaseEntity *pTarget = NULL;
+
+	while ( ( pTarget = gEntList.FindEntityInSphere( pTarget, vecTarget, COMBINE_MIN_GRENADE_CLEAR_DIST ) ) != NULL )
+	{
+		//Check to see if the default relationship is hatred, and if so intensify that
+		if ( npcOwner->IRelationType( pTarget ) == D_LI )
+		{
+			// crap, I might blow my own guy up. Don't throw a grenade and don't check again for a while.
+			m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
+			return (COND_WEAPON_BLOCKED_BY_FRIEND);
+		}
+	}
+
+	// ---------------------------------------------------------------------
+	// Check that throw is legal and clear
+	// ---------------------------------------------------------------------
+	// FIXME: speed is based on difficulty...
+
+	Vector vecToss = VecCheckThrow( this, npcOwner->GetLocalOrigin() + Vector(0,0,60), vecTarget, 600.0, 0.5 );
+	if ( vecToss != vec3_origin )
+	{
+		m_vecTossVelocity = vecToss;
+
+		// don't check again for a while.
+		// JAY: HL1 keeps checking - test?
+		//m_flNextGrenadeCheck = gpGlobals->curtime;
+		m_flNextGrenadeCheck = gpGlobals->curtime + 0.3; // 1/3 second.
+		return COND_CAN_RANGE_ATTACK2;
+	}
+	else
+	{
+		// don't check again for a while.
+		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
+		return COND_WEAPON_SIGHT_OCCLUDED;
+	}
 }
+#endif
+#endif
 
 //-----------------------------------------------------------------------------
 const WeaponProficiencyInfo_t *CWeaponSMG1::GetProficiencyValues()
diff --git a/src/game/shared/hl2mp/weapon_stunstick.cpp b/src/game/shared/hl2mp/weapon_stunstick.cpp
index 152b3aa..b9960bc 100644
--- a/src/game/shared/hl2mp/weapon_stunstick.cpp
+++ b/src/game/shared/hl2mp/weapon_stunstick.cpp
@@ -35,6 +35,11 @@
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
+#ifdef HL2SB
+ConVar    sk_plr_dmg_stunstick	( "sk_plr_dmg_stunstick","0",FCVAR_REPLICATED );
+ConVar    sk_npc_dmg_stunstick	( "sk_npc_dmg_stunstick","0",FCVAR_REPLICATED );
+#endif
+
 extern ConVar metropolice_move_and_melee;
 
 #define	STUNSTICK_RANGE				75.0f
@@ -165,6 +170,11 @@ acttable_t	CWeaponStunStick::m_acttable[] =
 	{ ACT_MP_RELOAD_CROUCH,				ACT_HL2MP_GESTURE_RELOAD_MELEE,			false },
 
 	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_MELEE,					false },
+
+#ifdef HL2SB
+	{ ACT_MELEE_ATTACK1,	ACT_MELEE_ATTACK_SWING,	true },
+	{ ACT_IDLE_ANGRY,		ACT_IDLE_ANGRY_MELEE,	true },
+#endif
 };
 
 IMPLEMENT_ACTTABLE(CWeaponStunStick);
@@ -212,7 +222,14 @@ void CWeaponStunStick::Precache()
 //-----------------------------------------------------------------------------
 float CWeaponStunStick::GetDamageForActivity( Activity hitActivity )
 {
+#ifndef HL2SB
 	return 40.0f;
+#else
+	if ( ( GetOwner() != NULL ) && ( GetOwner()->IsPlayer() ) )
+		return sk_plr_dmg_stunstick.GetFloat();
+	
+	return sk_npc_dmg_stunstick.GetFloat();
+#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -356,7 +373,37 @@ void CWeaponStunStick::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseComba
 
 				CBasePlayer *pPlayer = ToBasePlayer( pHurt );
 
+#ifdef HL2SB
+				CNPC_MetroPolice *pCop = dynamic_cast<CNPC_MetroPolice *>(pOperator);
+#endif
 				bool bFlashed = false;
+
+#ifdef HL2SB
+				if ( pCop != NULL && pPlayer != NULL )
+				{
+					// See if we need to knock out this target
+					if ( pCop->ShouldKnockOutTarget( pHurt ) )
+					{
+						float yawKick = random->RandomFloat( -48, -24 );
+
+						//Kick the player angles
+						pPlayer->ViewPunch( QAngle( -16, yawKick, 2 ) );
+
+						color32 white = {255,255,255,255};
+						UTIL_ScreenFade( pPlayer, white, 0.2f, 1.0f, FFADE_OUT|FFADE_PURGE|FFADE_STAYOUT );
+						bFlashed = true;
+						
+						pCop->KnockOutTarget( pHurt );
+
+						break;
+					}
+					else
+					{
+						// Notify that we've stunned a target
+						pCop->StunnedTarget( pHurt );
+					}
+				}
+#endif
 				
 				// Punch angles
 				if ( pPlayer != NULL && !(pPlayer->GetFlags() & FL_GODMODE) )
@@ -907,4 +954,4 @@ void StunstickImpactCallback( const CEffectData &data )
 
 DECLARE_CLIENT_EFFECT( "StunstickImpact", StunstickImpactCallback );
 
-#endif
\ No newline at end of file
+#endif
diff --git a/src/game/shared/lbasecombatweapon_shared.cpp b/src/game/shared/lbasecombatweapon_shared.cpp
new file mode 100644
index 0000000..66e3f2f
--- /dev/null
+++ b/src/game/shared/lbasecombatweapon_shared.cpp
@@ -0,0 +1,1117 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+#define lbasecombatweapon_shared_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lbasecombatweapon_shared.h"
+#include "lbaseentity_shared.h"
+#include "lbaseplayer_shared.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CBaseCombatWeapon *lua_toweapon (lua_State *L, int idx) {
+  CBaseHandle *hWeapon = dynamic_cast<CBaseHandle *>((CBaseHandle *)lua_touserdata(L, idx));
+  if (hWeapon == NULL)
+    return NULL;
+  return dynamic_cast<lua_CBaseCombatWeapon *>(hWeapon->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushweapon (lua_State *L, lua_CBaseCombatWeapon *pWeapon) {
+  CBaseHandle *hWeapon = (CBaseHandle *)lua_newuserdata(L, sizeof(CBaseHandle));
+  hWeapon->Set((CBaseEntity *)pWeapon);
+  luaL_getmetatable(L, "CBaseCombatWeapon");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CBaseCombatWeapon *luaL_checkweapon (lua_State *L, int narg) {
+  lua_CBaseCombatWeapon *d = lua_toweapon(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "CBaseCombatWeapon expected, got NULL entity");
+  return d;
+}
+
+
+static int CBaseCombatWeapon_AbortReload (lua_State *L) {
+  luaL_checkweapon(L, 1)->AbortReload();
+  return 0;
+}
+
+static int CBaseCombatWeapon_Activate (lua_State *L) {
+  luaL_checkweapon(L, 1)->Activate();
+  return 0;
+}
+
+static int CBaseCombatWeapon_ActivityListCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->ActivityListCount());
+  return 1;
+}
+
+static int CBaseCombatWeapon_ActivityOverride (lua_State *L) {
+  bool *pRequired = (bool *)luaL_checkboolean(L, 3);
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->ActivityOverride((Activity)luaL_checkint(L, 2), pRequired));
+  return 1;
+}
+
+static int CBaseCombatWeapon_AddViewKick (lua_State *L) {
+  luaL_checkweapon(L, 1)->AddViewKick();
+  return 0;
+}
+
+static int CBaseCombatWeapon_AllowsAutoSwitchFrom (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->AllowsAutoSwitchFrom());
+  return 1;
+}
+
+static int CBaseCombatWeapon_AllowsAutoSwitchTo (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->AllowsAutoSwitchTo());
+  return 1;
+}
+
+static int CBaseCombatWeapon_CalcViewmodelBob (lua_State *L) {
+  lua_pushnumber(L, luaL_checkweapon(L, 1)->CalcViewmodelBob());
+  return 1;
+}
+
+static int CBaseCombatWeapon_CanBePickedUpByNPCs (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->CanBePickedUpByNPCs());
+  return 1;
+}
+
+static int CBaseCombatWeapon_CanBeSelected (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->CanBeSelected());
+  return 1;
+}
+
+static int CBaseCombatWeapon_CanDeploy (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->CanDeploy());
+  return 1;
+}
+
+static int CBaseCombatWeapon_CanHolster (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->CanHolster());
+  return 1;
+}
+
+static int CBaseCombatWeapon_CanLower (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->CanLower());
+  return 1;
+}
+
+static int CBaseCombatWeapon_CheckReload (lua_State *L) {
+  luaL_checkweapon(L, 1)->CheckReload();
+  return 0;
+}
+
+static int CBaseCombatWeapon_Clip1 (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->Clip1());
+  return 1;
+}
+
+static int CBaseCombatWeapon_Clip2 (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->Clip2());
+  return 1;
+}
+
+static int CBaseCombatWeapon_DefaultDeploy (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->DefaultDeploy( (char*)luaL_checkstring(L, 2), (char*)luaL_checkstring(L, 3), luaL_checkint(L, 4), (char*)luaL_checkstring(L, 5) ));
+  return 1;
+}
+
+static int CBaseCombatWeapon_DefaultReload (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->DefaultReload(luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4)));
+  return 1;
+}
+
+static int CBaseCombatWeapon_DefaultTouch (lua_State *L) {
+  luaL_checkweapon(L, 1)->DefaultTouch(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseCombatWeapon_Deploy (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->Deploy());
+  return 1;
+}
+
+static int CBaseCombatWeapon_DisplayAltFireHudHint (lua_State *L) {
+  luaL_checkweapon(L, 1)->DisplayAltFireHudHint();
+  return 0;
+}
+
+static int CBaseCombatWeapon_DisplayReloadHudHint (lua_State *L) {
+  luaL_checkweapon(L, 1)->DisplayReloadHudHint();
+  return 0;
+}
+
+static int CBaseCombatWeapon_Drop (lua_State *L) {
+  luaL_checkweapon(L, 1)->Drop(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBaseCombatWeapon_FinishReload (lua_State *L) {
+  luaL_checkweapon(L, 1)->FinishReload();
+  return 0;
+}
+
+static int CBaseCombatWeapon_GetActivity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetActivity());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetAnimPrefix (lua_State *L) {
+  lua_pushstring(L, luaL_checkweapon(L, 1)->GetAnimPrefix());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetBulletType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetBulletType());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetDamage (lua_State *L) {
+  lua_pushnumber(L, luaL_checkweapon(L, 1)->GetDamage(luaL_checknumber(L, 2), luaL_checkint(L, 3)));
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetDeathNoticeName (lua_State *L) {
+  lua_pushstring(L, luaL_checkweapon(L, 1)->GetDeathNoticeName());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetDefaultAnimSpeed (lua_State *L) {
+  lua_pushnumber(L, luaL_checkweapon(L, 1)->GetDefaultAnimSpeed());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetDefaultClip1 (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetDefaultClip1());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetDefaultClip2 (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetDefaultClip2());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetDrawActivity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetDrawActivity());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetFireRate (lua_State *L) {
+  lua_pushnumber(L, luaL_checkweapon(L, 1)->GetFireRate());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetIdealActivity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetIdealActivity());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetIdealSequence (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetIdealSequence());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetMaxAutoAimDeflection (lua_State *L) {
+  lua_pushnumber(L, luaL_checkweapon(L, 1)->GetMaxAutoAimDeflection());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetMaxBurst (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetMaxBurst());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetMaxClip1 (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetMaxClip1());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetMaxClip2 (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetMaxClip2());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetMaxRestTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkweapon(L, 1)->GetMaxRestTime());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetMinBurst (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetMinBurst());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetMinRestTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkweapon(L, 1)->GetMinRestTime());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetName (lua_State *L) {
+  lua_pushstring(L, luaL_checkweapon(L, 1)->GetName());
+  return 1;
+}
+
+// FIXME: push CBaseCombatCharacter instead
+static int CBaseCombatWeapon_GetOwner (lua_State *L) {
+  lua_pushplayer(L, (CBasePlayer *)luaL_checkweapon(L, 1)->GetOwner());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetPosition (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetPosition());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetPrimaryAmmoCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetPrimaryAmmoCount());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetPrimaryAmmoType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetPrimaryAmmoType());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetPrimaryAttackActivity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetPrimaryAttackActivity());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetPrintName (lua_State *L) {
+  lua_pushstring(L, luaL_checkweapon(L, 1)->GetPrintName());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetRandomBurst (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetRandomBurst());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetRumbleEffect (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetRumbleEffect());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetSecondaryAmmoCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetSecondaryAmmoCount());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetSecondaryAmmoType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetSecondaryAmmoType());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetSecondaryAttackActivity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetSecondaryAttackActivity());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetShootSound (lua_State *L) {
+  lua_pushstring(L, luaL_checkweapon(L, 1)->GetShootSound(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetSlot (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetSlot());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetSubType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetSubType());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetViewModel (lua_State *L) {
+  lua_pushstring(L, luaL_checkweapon(L, 1)->GetViewModel(luaL_optint(L, 2, 0)));
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetViewModelSequenceDuration (lua_State *L) {
+  lua_pushnumber(L, luaL_checkweapon(L, 1)->GetViewModelSequenceDuration());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetWeaponFlags (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetWeaponFlags());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetWeaponIdleTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkweapon(L, 1)->GetWeaponIdleTime());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetWeight (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->GetWeight());
+  return 1;
+}
+
+static int CBaseCombatWeapon_GetWorldModel (lua_State *L) {
+  lua_pushstring(L, luaL_checkweapon(L, 1)->GetWorldModel());
+  return 1;
+}
+
+extern const char *pWeaponSoundCategories[ NUM_SHOOT_SOUND_TYPES ];
+
+static int CBaseCombatWeapon_GetWpnData (lua_State *L) {
+  const FileWeaponInfo_t &weaponInfo = luaL_checkweapon(L, 1)->GetWpnData();
+  lua_newtable(L);
+  lua_pushstring(L, "aShootSounds");
+  lua_newtable(L);
+  for ( int i = EMPTY; i < NUM_SHOOT_SOUND_TYPES; i++ )
+  {
+	lua_pushstring( L, pWeaponSoundCategories[i] );
+	const char *soundname = weaponInfo.aShootSounds[i];
+	if ( soundname && soundname[0] )
+	{
+		lua_pushstring( L, soundname );
+		lua_settable( L, -3 );
+	}
+	else
+	{
+		lua_pop( L, 1 );
+	}
+  }
+  lua_settable(L, -3);
+  lua_pushstring(L, "bAutoSwitchFrom");
+  lua_pushboolean(L, weaponInfo.bAutoSwitchFrom);
+  lua_settable(L, -3);
+  lua_pushstring(L, "bAutoSwitchTo");
+  lua_pushboolean(L, weaponInfo.bAutoSwitchTo);
+  lua_settable(L, -3);
+  lua_pushstring(L, "bLoadedHudElements");
+  lua_pushboolean(L, weaponInfo.bLoadedHudElements);
+  lua_settable(L, -3);
+  lua_pushstring(L, "bParsedScript");
+  lua_pushboolean(L, weaponInfo.bParsedScript);
+  lua_settable(L, -3);
+  lua_pushstring(L, "bShowUsageHint");
+  lua_pushboolean(L, weaponInfo.bShowUsageHint);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iAmmo2Type");
+  lua_pushinteger(L, weaponInfo.iAmmo2Type);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iAmmoType");
+  lua_pushinteger(L, weaponInfo.iAmmoType);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iDefaultClip1");
+  lua_pushinteger(L, weaponInfo.iDefaultClip1);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iDefaultClip2");
+  lua_pushinteger(L, weaponInfo.iDefaultClip2);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iFlags");
+  lua_pushinteger(L, weaponInfo.iFlags);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iMaxClip1");
+  lua_pushinteger(L, weaponInfo.iMaxClip1);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iMaxClip2");
+  lua_pushinteger(L, weaponInfo.iMaxClip2);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iPosition");
+  lua_pushinteger(L, weaponInfo.iPosition);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iRumbleEffect");
+  lua_pushinteger(L, weaponInfo.iRumbleEffect);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iSlot");
+  lua_pushinteger(L, weaponInfo.iSlot);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iSpriteCount");
+  lua_pushinteger(L, weaponInfo.iSpriteCount);
+  lua_settable(L, -3);
+  lua_pushstring(L, "iWeight");
+  lua_pushinteger(L, weaponInfo.iWeight);
+  lua_settable(L, -3);
+  lua_pushstring(L, "m_bAllowFlipping");
+  lua_pushboolean(L, weaponInfo.m_bAllowFlipping);
+  lua_settable(L, -3);
+  lua_pushstring(L, "m_bBuiltRightHanded");
+  lua_pushboolean(L, weaponInfo.m_bBuiltRightHanded);
+  lua_settable(L, -3);
+  lua_pushstring(L, "m_bMeleeWeapon");
+  lua_pushboolean(L, weaponInfo.m_bMeleeWeapon);
+  lua_settable(L, -3);
+  lua_pushstring(L, "szAmmo1");
+  lua_pushstring(L, weaponInfo.szAmmo1);
+  lua_settable(L, -3);
+  lua_pushstring(L, "szAmmo2");
+  lua_pushstring(L, weaponInfo.szAmmo2);
+  lua_settable(L, -3);
+  lua_pushstring(L, "szAnimationPrefix");
+  lua_pushstring(L, weaponInfo.szAnimationPrefix);
+  lua_settable(L, -3);
+  lua_pushstring(L, "szClassName");
+  lua_pushstring(L, weaponInfo.szClassName);
+  lua_settable(L, -3);
+  lua_pushstring(L, "szPrintName");
+  lua_pushstring(L, weaponInfo.szPrintName);
+  lua_settable(L, -3);
+  lua_pushstring(L, "szViewModel");
+  lua_pushstring(L, weaponInfo.szViewModel);
+  lua_settable(L, -3);
+  lua_pushstring(L, "szWorldModel");
+  lua_pushstring(L, weaponInfo.szWorldModel);
+  lua_settable(L, -3);
+  return 1;
+}
+
+static int CBaseCombatWeapon_GiveDefaultAmmo (lua_State *L) {
+  luaL_checkweapon(L, 1)->GiveDefaultAmmo();
+  return 0;
+}
+
+static int CBaseCombatWeapon_HandleFireOnEmpty (lua_State *L) {
+  luaL_checkweapon(L, 1)->HandleFireOnEmpty();
+  return 0;
+}
+
+static int CBaseCombatWeapon_HasAmmo (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->HasAmmo());
+  return 1;
+}
+
+static int CBaseCombatWeapon_HasAnyAmmo (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->HasAnyAmmo());
+  return 1;
+}
+
+static int CBaseCombatWeapon_HasPrimaryAmmo (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->HasPrimaryAmmo());
+  return 1;
+}
+
+static int CBaseCombatWeapon_HasSecondaryAmmo (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->HasSecondaryAmmo());
+  return 1;
+}
+
+static int CBaseCombatWeapon_HasWeaponIdleTimeElapsed (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->HasWeaponIdleTimeElapsed());
+  return 1;
+}
+
+static int CBaseCombatWeapon_HideThink (lua_State *L) {
+  luaL_checkweapon(L, 1)->HideThink();
+  return 0;
+}
+
+static int CBaseCombatWeapon_IsAllowedToSwitch (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->IsAllowedToSwitch());
+  return 1;
+}
+
+static int CBaseCombatWeapon_IsLocked (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->IsLocked(luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int CBaseCombatWeapon_IsMeleeWeapon (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->IsMeleeWeapon());
+  return 1;
+}
+
+static int CBaseCombatWeapon_IsPredicted (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->IsPredicted());
+  return 1;
+}
+
+static int CBaseCombatWeapon_IsScripted (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->IsScripted());
+  return 1;
+}
+
+static int CBaseCombatWeapon_IsViewModelSequenceFinished (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->IsViewModelSequenceFinished());
+  return 1;
+}
+
+static int CBaseCombatWeapon_IsWeaponVisible (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->IsWeaponVisible());
+  return 1;
+}
+
+static int CBaseCombatWeapon_IsWeaponZoomed (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->IsWeaponZoomed());
+  return 1;
+}
+
+static int CBaseCombatWeapon_ItemBusyFrame (lua_State *L) {
+  luaL_checkweapon(L, 1)->ItemBusyFrame();
+  return 0;
+}
+
+static int CBaseCombatWeapon_ItemHolsterFrame (lua_State *L) {
+  luaL_checkweapon(L, 1)->ItemHolsterFrame();
+  return 0;
+}
+
+static int CBaseCombatWeapon_ItemPostFrame (lua_State *L) {
+  luaL_checkweapon(L, 1)->ItemPostFrame();
+  return 0;
+}
+
+static int CBaseCombatWeapon_ItemPreFrame (lua_State *L) {
+  luaL_checkweapon(L, 1)->ItemPreFrame();
+  return 0;
+}
+
+static int CBaseCombatWeapon_Lock (lua_State *L) {
+  luaL_checkweapon(L, 1)->Lock(luaL_checknumber(L, 2), luaL_checkentity(L, 3));
+  return 0;
+}
+
+static int CBaseCombatWeapon_Lower (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->Lower());
+  return 1;
+}
+
+static int CBaseCombatWeapon_MaintainIdealActivity (lua_State *L) {
+  luaL_checkweapon(L, 1)->MaintainIdealActivity();
+  return 0;
+}
+
+static int CBaseCombatWeapon_OnActiveStateChanged (lua_State *L) {
+  luaL_checkweapon(L, 1)->OnActiveStateChanged(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseCombatWeapon_OnRestore (lua_State *L) {
+  luaL_checkweapon(L, 1)->OnRestore();
+  return 0;
+}
+
+static int CBaseCombatWeapon_Precache (lua_State *L) {
+  luaL_checkweapon(L, 1)->Precache();
+  return 0;
+}
+
+static int CBaseCombatWeapon_PrimaryAttack (lua_State *L) {
+  luaL_checkweapon(L, 1)->PrimaryAttack();
+  return 0;
+}
+
+static int CBaseCombatWeapon_Ready (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->Ready());
+  return 1;
+}
+
+static int CBaseCombatWeapon_Reload (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->Reload());
+  return 1;
+}
+
+static int CBaseCombatWeapon_ReloadOrSwitchWeapons (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->ReloadOrSwitchWeapons());
+  return 1;
+}
+
+static int CBaseCombatWeapon_RescindAltFireHudHint (lua_State *L) {
+  luaL_checkweapon(L, 1)->RescindAltFireHudHint();
+  return 0;
+}
+
+static int CBaseCombatWeapon_RescindReloadHudHint (lua_State *L) {
+  luaL_checkweapon(L, 1)->RescindReloadHudHint();
+  return 0;
+}
+
+static int CBaseCombatWeapon_SecondaryAttack (lua_State *L) {
+  luaL_checkweapon(L, 1)->SecondaryAttack();
+  return 0;
+}
+
+static int CBaseCombatWeapon_SendViewModelAnim (lua_State *L) {
+  luaL_checkweapon(L, 1)->SendViewModelAnim(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseCombatWeapon_SendWeaponAnim (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->SendWeaponAnim(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseCombatWeapon_SetActivity (lua_State *L) {
+  luaL_checkweapon(L, 1)->SetActivity((Activity)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseCombatWeapon_SetIdealActivity (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->SetIdealActivity((Activity)luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseCombatWeapon_SetPickupTouch (lua_State *L) {
+  luaL_checkweapon(L, 1)->SetPickupTouch();
+  return 0;
+}
+
+static int CBaseCombatWeapon_SetPrimaryAmmoCount (lua_State *L) {
+  luaL_checkweapon(L, 1)->SetPrimaryAmmoCount(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseCombatWeapon_SetSecondaryAmmoCount (lua_State *L) {
+  luaL_checkweapon(L, 1)->SetSecondaryAmmoCount(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseCombatWeapon_SetSubType (lua_State *L) {
+  luaL_checkweapon(L, 1)->SetSubType(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseCombatWeapon_SetViewModel (lua_State *L) {
+  luaL_checkweapon(L, 1)->SetViewModel();
+  return 0;
+}
+
+static int CBaseCombatWeapon_SetViewModelIndex (lua_State *L) {
+  luaL_checkweapon(L, 1)->SetViewModelIndex(luaL_optint(L, 2, 0));
+  return 0;
+}
+
+static int CBaseCombatWeapon_SetWeaponIdleTime (lua_State *L) {
+  luaL_checkweapon(L, 1)->SetWeaponIdleTime(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseCombatWeapon_SetWeaponVisible (lua_State *L) {
+  luaL_checkweapon(L, 1)->SetWeaponVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBaseCombatWeapon_ShouldDisplayAltFireHUDHint (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->ShouldDisplayAltFireHUDHint());
+  return 1;
+}
+
+static int CBaseCombatWeapon_ShouldDisplayReloadHUDHint (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->ShouldDisplayReloadHUDHint());
+  return 1;
+}
+
+static int CBaseCombatWeapon_ShouldShowControlPanels (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->ShouldShowControlPanels());
+  return 1;
+}
+
+static int CBaseCombatWeapon_Spawn (lua_State *L) {
+  luaL_checkweapon(L, 1)->Spawn();
+  return 0;
+}
+
+static int CBaseCombatWeapon_StartSprinting (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->StartSprinting());
+  return 1;
+}
+
+static int CBaseCombatWeapon_StopSprinting (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->StopSprinting());
+  return 1;
+}
+
+static int CBaseCombatWeapon_StopWeaponSound (lua_State *L) {
+  luaL_checkweapon(L, 1)->StopWeaponSound((WeaponSound_t)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseCombatWeapon_UsesClipsForAmmo1 (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->UsesClipsForAmmo1());
+  return 1;
+}
+
+static int CBaseCombatWeapon_UsesClipsForAmmo2 (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->UsesClipsForAmmo2());
+  return 1;
+}
+
+static int CBaseCombatWeapon_UsesPrimaryAmmo (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->UsesPrimaryAmmo());
+  return 1;
+}
+
+static int CBaseCombatWeapon_UsesSecondaryAmmo (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->UsesSecondaryAmmo());
+  return 1;
+}
+
+static int CBaseCombatWeapon_VisibleInWeaponSelection (lua_State *L) {
+  lua_pushboolean(L, luaL_checkweapon(L, 1)->VisibleInWeaponSelection());
+  return 1;
+}
+
+static int CBaseCombatWeapon_WeaponAutoAimScale (lua_State *L) {
+  lua_pushnumber(L, luaL_checkweapon(L, 1)->WeaponAutoAimScale());
+  return 1;
+}
+
+static int CBaseCombatWeapon_WeaponIdle (lua_State *L) {
+  luaL_checkweapon(L, 1)->WeaponIdle();
+  return 0;
+}
+
+static int CBaseCombatWeapon_WeaponSound (lua_State *L) {
+  luaL_checkweapon(L, 1)->WeaponSound((WeaponSound_t)luaL_checkint(L, 2), luaL_optnumber(L, 2, 0.0f));
+  return 0;
+}
+
+static int CBaseCombatWeapon_WeaponState (lua_State *L) {
+  lua_pushinteger(L, luaL_checkweapon(L, 1)->WeaponState());
+  return 1;
+}
+
+static int CBaseCombatWeapon___index (lua_State *L) {
+  CBaseCombatWeapon *pWeapon = lua_toweapon(L, 1);
+  if (pWeapon == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "m_bAltFiresUnderwater") == 0)
+    lua_pushboolean(L, pWeapon->m_bAltFiresUnderwater);
+  else if (Q_strcmp(field, "m_bFireOnEmpty") == 0)
+    lua_pushboolean(L, pWeapon->m_bFireOnEmpty);
+  else if (Q_strcmp(field, "m_bFiresUnderwater") == 0)
+    lua_pushboolean(L, pWeapon->m_bFiresUnderwater);
+  else if (Q_strcmp(field, "m_bInReload") == 0)
+    lua_pushboolean(L, pWeapon->m_bInReload);
+  else if (Q_strcmp(field, "m_bReloadsSingly") == 0)
+    lua_pushboolean(L, pWeapon->m_bReloadsSingly);
+  else if (Q_strcmp(field, "m_fFireDuration") == 0)
+    lua_pushnumber(L, pWeapon->m_fFireDuration);
+  else if (Q_strcmp(field, "m_flNextEmptySoundTime") == 0)
+    lua_pushnumber(L, pWeapon->m_flNextEmptySoundTime);
+  else if (Q_strcmp(field, "m_flNextPrimaryAttack") == 0)
+    lua_pushnumber(L, pWeapon->m_flNextPrimaryAttack);
+  else if (Q_strcmp(field, "m_flNextSecondaryAttack") == 0)
+    lua_pushnumber(L, pWeapon->m_flNextSecondaryAttack);
+  else if (Q_strcmp(field, "m_flTimeWeaponIdle") == 0)
+    lua_pushnumber(L, pWeapon->m_flTimeWeaponIdle);
+  else if (Q_strcmp(field, "m_flUnlockTime") == 0)
+    lua_pushnumber(L, pWeapon->m_flUnlockTime);
+  else if (Q_strcmp(field, "m_fMaxRange1") == 0)
+    lua_pushnumber(L, pWeapon->m_fMaxRange1);
+  else if (Q_strcmp(field, "m_fMaxRange2") == 0)
+    lua_pushnumber(L, pWeapon->m_fMaxRange2);
+  else if (Q_strcmp(field, "m_fMinRange1") == 0)
+    lua_pushnumber(L, pWeapon->m_fMinRange1);
+  else if (Q_strcmp(field, "m_fMinRange2") == 0)
+    lua_pushnumber(L, pWeapon->m_fMinRange2);
+  else if (Q_strcmp(field, "m_iClip1") == 0)
+    lua_pushinteger(L, pWeapon->m_iClip1);
+  else if (Q_strcmp(field, "m_iClip2") == 0)
+    lua_pushinteger(L, pWeapon->m_iClip2);
+  else if (Q_strcmp(field, "m_iPrimaryAmmoType") == 0)
+    lua_pushinteger(L, pWeapon->m_iPrimaryAmmoType);
+  else if (Q_strcmp(field, "m_iSecondaryAmmoType") == 0)
+    lua_pushinteger(L, pWeapon->m_iSecondaryAmmoType);
+  else if (Q_strcmp(field, "m_iState") == 0)
+    lua_pushinteger(L, pWeapon->m_iState);
+  else if (Q_strcmp(field, "m_iSubType") == 0)
+    lua_pushinteger(L, pWeapon->m_iSubType);
+  else if (Q_strcmp(field, "m_iViewModelIndex") == 0)
+    lua_pushinteger(L, pWeapon->m_iViewModelIndex);
+  else if (Q_strcmp(field, "m_iWorldModelIndex") == 0)
+    lua_pushinteger(L, pWeapon->m_iWorldModelIndex);
+  else if (Q_strcmp(field, "m_nViewModelIndex") == 0)
+    lua_pushinteger(L, pWeapon->m_nViewModelIndex);
+  else if (pWeapon->m_nTableReference != LUA_NOREF) {
+    lua_getref(L, pWeapon->m_nTableReference);
+    lua_getfield(L, -1, field);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      lua_getmetatable(L, 1);
+      lua_getfield(L, -1, field);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "CBaseAnimating");
+        lua_getfield(L, -1, field);
+        if (lua_isnil(L, -1)) {
+          lua_pop(L, 2);
+          luaL_getmetatable(L, "CBaseEntity");
+          lua_getfield(L, -1, field);
+        }
+      }
+    }
+  }
+  else {
+    lua_getmetatable(L, 1);
+    lua_getfield(L, -1, field);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      luaL_getmetatable(L, "CBaseAnimating");
+      lua_getfield(L, -1, field);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "CBaseEntity");
+        lua_getfield(L, -1, field);
+      }
+    }
+  }
+  return 1;
+}
+
+static int CBaseCombatWeapon___newindex (lua_State *L) {
+  CBaseCombatWeapon *pWeapon = lua_toweapon(L, 1);
+  if (pWeapon == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "m_bAltFiresUnderwater") == 0)
+    pWeapon->m_bAltFiresUnderwater = luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_bFireOnEmpty") == 0)
+    pWeapon->m_bFireOnEmpty = luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_bFiresUnderwater") == 0)
+    pWeapon->m_bFiresUnderwater = luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_bInReload") == 0)
+    pWeapon->m_bInReload = luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_bReloadsSingly") == 0)
+    pWeapon->m_bReloadsSingly = luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_fFireDuration") == 0)
+    pWeapon->m_fFireDuration = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_flNextEmptySoundTime") == 0)
+    pWeapon->m_flNextEmptySoundTime = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_flNextPrimaryAttack") == 0)
+    pWeapon->m_flNextPrimaryAttack.GetForModify() = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_flNextSecondaryAttack") == 0)
+    pWeapon->m_flNextSecondaryAttack.GetForModify() = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_flTimeWeaponIdle") == 0)
+    pWeapon->m_flTimeWeaponIdle.GetForModify() = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_flUnlockTime") == 0)
+    pWeapon->m_flUnlockTime = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_fMaxRange1") == 0)
+    pWeapon->m_fMaxRange1 = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_fMaxRange2") == 0)
+    pWeapon->m_fMaxRange2 = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_fMinRange1") == 0)
+    pWeapon->m_fMinRange1 = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_fMinRange2") == 0)
+    pWeapon->m_fMinRange2 = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_iClip1") == 0)
+    pWeapon->m_iClip1.GetForModify() = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_iClip2") == 0)
+    pWeapon->m_iClip2.GetForModify() = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_iPrimaryAmmoType") == 0)
+    pWeapon->m_iPrimaryAmmoType.GetForModify() = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_iSecondaryAmmoType") == 0)
+    pWeapon->m_iSecondaryAmmoType.GetForModify() = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_iState") == 0)
+    pWeapon->m_iState.GetForModify() = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_iSubType") == 0)
+    pWeapon->m_iSubType = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_iViewModelIndex") == 0)
+    pWeapon->m_iViewModelIndex.GetForModify() = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_iWorldModelIndex") == 0)
+    pWeapon->m_iWorldModelIndex.GetForModify() = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_nViewModelIndex") == 0)
+    pWeapon->m_nViewModelIndex.GetForModify() = luaL_checkint(L, 3);
+  else {
+    if (pWeapon->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      pWeapon->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, pWeapon->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, field);
+	lua_pop(L, 1);
+  }
+  return 0;
+}
+
+static int CBaseCombatWeapon___eq (lua_State *L) {
+  lua_pushboolean(L, lua_toweapon(L, 1) == lua_toweapon(L, 2));
+  return 1;
+}
+
+static int CBaseCombatWeapon___tostring (lua_State *L) {
+  CBaseCombatWeapon *pWeapon = lua_toweapon(L, 1);
+  if (pWeapon == NULL)
+    lua_pushstring(L, "NULL");
+  else
+    lua_pushfstring(L, "CBaseCombatWeapon: %d %s", pWeapon->entindex(), pWeapon->GetClassname());
+  return 1;
+}
+
+
+static const luaL_Reg CBaseCombatWeaponmeta[] = {
+  {"AbortReload", CBaseCombatWeapon_AbortReload},
+  {"Activate", CBaseCombatWeapon_Activate},
+  {"ActivityListCount", CBaseCombatWeapon_ActivityListCount},
+  {"ActivityOverride", CBaseCombatWeapon_ActivityOverride},
+  {"AddViewKick", CBaseCombatWeapon_AddViewKick},
+  {"AllowsAutoSwitchFrom", CBaseCombatWeapon_AllowsAutoSwitchFrom},
+  {"AllowsAutoSwitchTo", CBaseCombatWeapon_AllowsAutoSwitchTo},
+  {"CalcViewmodelBob", CBaseCombatWeapon_CalcViewmodelBob},
+  {"CanBePickedUpByNPCs", CBaseCombatWeapon_CanBePickedUpByNPCs},
+  {"CanBeSelected", CBaseCombatWeapon_CanBeSelected},
+  {"CanDeploy", CBaseCombatWeapon_CanDeploy},
+  {"CanHolster", CBaseCombatWeapon_CanHolster},
+  {"CanLower", CBaseCombatWeapon_CanLower},
+  {"CheckReload", CBaseCombatWeapon_CheckReload},
+  {"Clip1", CBaseCombatWeapon_Clip1},
+  {"Clip2", CBaseCombatWeapon_Clip2},
+  {"DefaultDeploy", CBaseCombatWeapon_DefaultDeploy},
+  {"DefaultReload", CBaseCombatWeapon_DefaultReload},
+  {"DefaultTouch", CBaseCombatWeapon_DefaultTouch},
+  {"Deploy", CBaseCombatWeapon_Deploy},
+  {"DisplayAltFireHudHint", CBaseCombatWeapon_DisplayAltFireHudHint},
+  {"DisplayReloadHudHint", CBaseCombatWeapon_DisplayReloadHudHint},
+  {"Drop", CBaseCombatWeapon_Drop},
+  {"FinishReload", CBaseCombatWeapon_FinishReload},
+  {"GetActivity", CBaseCombatWeapon_GetActivity},
+  {"GetAnimPrefix", CBaseCombatWeapon_GetAnimPrefix},
+  {"GetBulletType", CBaseCombatWeapon_GetBulletType},
+  {"GetDamage", CBaseCombatWeapon_GetDamage},
+  {"GetDeathNoticeName", CBaseCombatWeapon_GetDeathNoticeName},
+  {"GetDefaultAnimSpeed", CBaseCombatWeapon_GetDefaultAnimSpeed},
+  {"GetDefaultClip1", CBaseCombatWeapon_GetDefaultClip1},
+  {"GetDefaultClip2", CBaseCombatWeapon_GetDefaultClip2},
+  {"GetDrawActivity", CBaseCombatWeapon_GetDrawActivity},
+  {"GetFireRate", CBaseCombatWeapon_GetFireRate},
+  {"GetIdealActivity", CBaseCombatWeapon_GetIdealActivity},
+  {"GetIdealSequence", CBaseCombatWeapon_GetIdealSequence},
+  {"GetMaxAutoAimDeflection", CBaseCombatWeapon_GetMaxAutoAimDeflection},
+  {"GetMaxBurst", CBaseCombatWeapon_GetMaxBurst},
+  {"GetMaxClip1", CBaseCombatWeapon_GetMaxClip1},
+  {"GetMaxClip2", CBaseCombatWeapon_GetMaxClip2},
+  {"GetMaxRestTime", CBaseCombatWeapon_GetMaxRestTime},
+  {"GetMinBurst", CBaseCombatWeapon_GetMinBurst},
+  {"GetMinRestTime", CBaseCombatWeapon_GetMinRestTime},
+  {"GetName", CBaseCombatWeapon_GetName},
+  {"GetOwner", CBaseCombatWeapon_GetOwner},
+  {"GetPosition", CBaseCombatWeapon_GetPosition},
+  {"GetPrimaryAmmoCount", CBaseCombatWeapon_GetPrimaryAmmoCount},
+  {"GetPrimaryAmmoType", CBaseCombatWeapon_GetPrimaryAmmoType},
+  {"GetPrimaryAttackActivity", CBaseCombatWeapon_GetPrimaryAttackActivity},
+  {"GetPrintName", CBaseCombatWeapon_GetPrintName},
+  {"GetRandomBurst", CBaseCombatWeapon_GetRandomBurst},
+  {"GetRumbleEffect", CBaseCombatWeapon_GetRumbleEffect},
+  {"GetSecondaryAmmoCount", CBaseCombatWeapon_GetSecondaryAmmoCount},
+  {"GetSecondaryAmmoType", CBaseCombatWeapon_GetSecondaryAmmoType},
+  {"GetSecondaryAttackActivity", CBaseCombatWeapon_GetSecondaryAttackActivity},
+  {"GetShootSound", CBaseCombatWeapon_GetShootSound},
+  {"GetSlot", CBaseCombatWeapon_GetSlot},
+  {"GetSubType", CBaseCombatWeapon_GetSubType},
+  {"GetViewModel", CBaseCombatWeapon_GetViewModel},
+  {"GetViewModelSequenceDuration", CBaseCombatWeapon_GetViewModelSequenceDuration},
+  {"GetWeaponFlags", CBaseCombatWeapon_GetWeaponFlags},
+  {"GetWeaponIdleTime", CBaseCombatWeapon_GetWeaponIdleTime},
+  {"GetWeight", CBaseCombatWeapon_GetWeight},
+  {"GetWorldModel", CBaseCombatWeapon_GetWorldModel},
+  {"GetWpnData", CBaseCombatWeapon_GetWpnData},
+  {"GiveDefaultAmmo", CBaseCombatWeapon_GiveDefaultAmmo},
+  {"HandleFireOnEmpty", CBaseCombatWeapon_HandleFireOnEmpty},
+  {"HasAmmo", CBaseCombatWeapon_HasAmmo},
+  {"HasAmmo", CBaseCombatWeapon_HasAnyAmmo},
+  {"HasPrimaryAmmo", CBaseCombatWeapon_HasPrimaryAmmo},
+  {"HasSecondaryAmmo", CBaseCombatWeapon_HasSecondaryAmmo},
+  {"HasWeaponIdleTimeElapsed", CBaseCombatWeapon_HasWeaponIdleTimeElapsed},
+  {"HideThink", CBaseCombatWeapon_HideThink},
+  {"IsAllowedToSwitch", CBaseCombatWeapon_IsAllowedToSwitch},
+  {"IsLocked", CBaseCombatWeapon_IsLocked},
+  {"IsMeleeWeapon", CBaseCombatWeapon_IsMeleeWeapon},
+  {"IsPredicted", CBaseCombatWeapon_IsPredicted},
+  {"IsScripted", CBaseCombatWeapon_IsScripted},
+  {"IsViewModelSequenceFinished", CBaseCombatWeapon_IsViewModelSequenceFinished},
+  {"IsWeaponVisible", CBaseCombatWeapon_IsWeaponVisible},
+  {"IsWeaponZoomed", CBaseCombatWeapon_IsWeaponZoomed},
+  {"ItemBusyFrame", CBaseCombatWeapon_ItemBusyFrame},
+  {"ItemHolsterFrame", CBaseCombatWeapon_ItemHolsterFrame},
+  {"ItemPostFrame", CBaseCombatWeapon_ItemPostFrame},
+  {"ItemPreFrame", CBaseCombatWeapon_ItemPreFrame},
+  {"Lock", CBaseCombatWeapon_Lock},
+  {"Lower", CBaseCombatWeapon_Lower},
+  {"MaintainIdealActivity", CBaseCombatWeapon_MaintainIdealActivity},
+  {"OnActiveStateChanged", CBaseCombatWeapon_OnActiveStateChanged},
+  {"OnRestore", CBaseCombatWeapon_OnRestore},
+  {"Precache", CBaseCombatWeapon_Precache},
+  {"PrimaryAttack", CBaseCombatWeapon_PrimaryAttack},
+  {"Ready", CBaseCombatWeapon_Ready},
+  {"Reload", CBaseCombatWeapon_Reload},
+  {"ReloadOrSwitchWeapons", CBaseCombatWeapon_ReloadOrSwitchWeapons},
+  {"RescindAltFireHudHint", CBaseCombatWeapon_RescindAltFireHudHint},
+  {"RescindReloadHudHint", CBaseCombatWeapon_RescindReloadHudHint},
+  {"SecondaryAttack", CBaseCombatWeapon_SecondaryAttack},
+  {"SendViewModelAnim", CBaseCombatWeapon_SendViewModelAnim},
+  {"SendWeaponAnim", CBaseCombatWeapon_SendWeaponAnim},
+  {"SetActivity", CBaseCombatWeapon_SetActivity},
+  {"SetIdealActivity", CBaseCombatWeapon_SetIdealActivity},
+  {"SetPickupTouch", CBaseCombatWeapon_SetPickupTouch},
+  {"SetPrimaryAmmoCount", CBaseCombatWeapon_SetPrimaryAmmoCount},
+  {"SetSecondaryAmmoCount", CBaseCombatWeapon_SetSecondaryAmmoCount},
+  {"SetSubType", CBaseCombatWeapon_SetSubType},
+  {"SetViewModel", CBaseCombatWeapon_SetViewModel},
+  {"SetViewModelIndex", CBaseCombatWeapon_SetViewModelIndex},
+  {"SetWeaponIdleTime", CBaseCombatWeapon_SetWeaponIdleTime},
+  {"SetWeaponVisible", CBaseCombatWeapon_SetWeaponVisible},
+  {"ShouldDisplayAltFireHUDHint", CBaseCombatWeapon_ShouldDisplayAltFireHUDHint},
+  {"ShouldDisplayReloadHUDHint", CBaseCombatWeapon_ShouldDisplayReloadHUDHint},
+  {"ShouldShowControlPanels", CBaseCombatWeapon_ShouldShowControlPanels},
+  {"Spawn", CBaseCombatWeapon_Spawn},
+  {"StartSprinting", CBaseCombatWeapon_StartSprinting},
+  {"StopSprinting", CBaseCombatWeapon_StopSprinting},
+  {"StopWeaponSound", CBaseCombatWeapon_StopWeaponSound},
+  {"UsesClipsForAmmo1", CBaseCombatWeapon_UsesClipsForAmmo1},
+  {"UsesClipsForAmmo2", CBaseCombatWeapon_UsesClipsForAmmo2},
+  {"UsesPrimaryAmmo", CBaseCombatWeapon_UsesPrimaryAmmo},
+  {"UsesSecondaryAmmo", CBaseCombatWeapon_UsesSecondaryAmmo},
+  {"VisibleInWeaponSelection", CBaseCombatWeapon_VisibleInWeaponSelection},
+  {"WeaponAutoAimScale", CBaseCombatWeapon_WeaponAutoAimScale},
+  {"WeaponIdle", CBaseCombatWeapon_WeaponIdle},
+  {"WeaponSound", CBaseCombatWeapon_WeaponSound},
+  {"WeaponState", CBaseCombatWeapon_WeaponState},
+  {"__index", CBaseCombatWeapon___index},
+  {"__newindex", CBaseCombatWeapon___newindex},
+  {"__eq", CBaseCombatWeapon___eq},
+  {"__tostring", CBaseCombatWeapon___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CBaseCombatWeapon object
+*/
+LUALIB_API int luaopen_CBaseCombatWeapon (lua_State *L) {
+  luaL_newmetatable(L, LUA_BASECOMBATWEAPONLIBNAME);
+  luaL_register(L, NULL, CBaseCombatWeaponmeta);
+  lua_pushstring(L, "entity");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "entity" */
+  return 1;
+}
+
diff --git a/src/game/shared/lbasecombatweapon_shared.h b/src/game/shared/lbasecombatweapon_shared.h
new file mode 100644
index 0000000..a0a0609
--- /dev/null
+++ b/src/game/shared/lbasecombatweapon_shared.h
@@ -0,0 +1,35 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+//===========================================================================//
+
+#ifndef LCOMBATWEAPON_SHARED_H
+#define LCOMBATWEAPON_SHARED_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for CBaseCombatWeapon functions */
+typedef CBaseCombatWeapon lua_CBaseCombatWeapon;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CBaseCombatWeapon     *(lua_toweapon) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushweapon) (lua_State *L, lua_CBaseCombatWeapon *pWeapon);
+
+
+
+LUALIB_API lua_CBaseCombatWeapon *(luaL_checkweapon) (lua_State *L, int narg);
+
+
+#endif // LCOMBATWEAPON_SHARED_H
diff --git a/src/game/shared/lbaseentity_shared.cpp b/src/game/shared/lbaseentity_shared.cpp
new file mode 100644
index 0000000..e2b2c01
--- /dev/null
+++ b/src/game/shared/lbaseentity_shared.cpp
@@ -0,0 +1,1747 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: The base class from which all game entities are derived.
+//
+//===========================================================================//
+
+#define lbaseentity_shared_cpp
+
+#include "cbase.h"
+#ifdef CLIENT_DLL
+#include "c_recipientfilter.h"
+#define CRecipientFilter C_RecipientFilter
+#else
+#include "recipientfilter.h"
+#endif
+#include "takedamageinfo.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lbaseentity_shared.h"
+#ifdef CLIENT_DLL
+#include "lc_baseanimating.h"
+#include "lc_recipientfilter.h"
+#else
+#include "lbaseanimating.h"
+#include "lrecipientfilter.h"
+#endif
+#include "lbaseplayer_shared.h"
+#include "lgametrace.h"
+#include "SoundEmitterSystem/lisoundemittersystembase.h"
+#include "lshareddefs.h"
+#include "ltakedamageinfo.h"
+#include "mathlib/lvector.h"
+#include "lvphysics_interface.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CBaseEntity *lua_toentity (lua_State *L, int idx) {
+  CBaseHandle *hEntity = dynamic_cast<CBaseHandle *>((CBaseHandle *)lua_touserdata(L, idx));
+  if (hEntity == NULL)
+    return NULL;
+  return dynamic_cast<lua_CBaseEntity *>(hEntity->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushentity (lua_State *L, CBaseEntity *pEntity) {
+  CBaseHandle *hEntity = (CBaseHandle *)lua_newuserdata(L, sizeof(CBaseHandle));
+  hEntity->Set(pEntity);
+  luaL_getmetatable(L, "CBaseEntity");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CBaseEntity *luaL_checkentity (lua_State *L, int narg) {
+  lua_CBaseEntity *d = lua_toentity(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "CBaseEntity expected, got NULL entity");
+  return d;
+}
+
+
+LUALIB_API lua_CBaseEntity *luaL_optentity (lua_State *L, int narg,
+                                                          CBaseEntity *def) {
+  return luaL_opt(L, luaL_checkentity, narg, def);
+}
+
+
+static int CBaseEntity_Activate (lua_State *L) {
+  luaL_checkentity(L, 1)->Activate();
+  return 0;
+}
+
+static int CBaseEntity_AddDataObjectType (lua_State *L) {
+  luaL_checkentity(L, 1)->AddDataObjectType(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_AddEffects (lua_State *L) {
+  luaL_checkentity(L, 1)->AddEffects(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_AddEFlags (lua_State *L) {
+  luaL_checkentity(L, 1)->AddEFlags(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_AddFlag (lua_State *L) {
+  luaL_checkentity(L, 1)->AddFlag(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_AddSolidFlags (lua_State *L) {
+  luaL_checkentity(L, 1)->AddSolidFlags(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_ApplyAbsVelocityImpulse (lua_State *L) {
+  luaL_checkentity(L, 1)->ApplyAbsVelocityImpulse(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_ApplyLocalAngularVelocityImpulse (lua_State *L) {
+  luaL_checkentity(L, 1)->ApplyLocalAngularVelocityImpulse((AngularImpulse &)luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_BlocksLOS (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->BlocksLOS());
+  return 1;
+}
+
+static int CBaseEntity_BloodColor (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->BloodColor());
+  return 1;
+}
+
+static int CBaseEntity_BoundingRadius (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->BoundingRadius());
+  return 1;
+}
+
+static int CBaseEntity_ChangeTeam (lua_State *L) {
+  luaL_checkentity(L, 1)->ChangeTeam(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_ClearEffects (lua_State *L) {
+  luaL_checkentity(L, 1)->ClearEffects();
+  return 0;
+}
+
+static int CBaseEntity_ClearFlags (lua_State *L) {
+  luaL_checkentity(L, 1)->ClearFlags();
+  return 0;
+}
+
+static int CBaseEntity_CollisionRulesChanged (lua_State *L) {
+  luaL_checkentity(L, 1)->CollisionRulesChanged();
+  return 0;
+}
+
+static int CBaseEntity_ComputeAbsDirection (lua_State *L) {
+  luaL_checkentity(L, 1)->ComputeAbsDirection(luaL_checkvector(L, 2), &luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_ComputeAbsPosition (lua_State *L) {
+  luaL_checkentity(L, 1)->ComputeAbsPosition(luaL_checkvector(L, 2), &luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_ComputeWorldSpaceSurroundingBox (lua_State *L) {
+  luaL_checkentity(L, 1)->ComputeWorldSpaceSurroundingBox(&luaL_checkvector(L, 2), &luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_CreateDataObject (lua_State *L) {
+  luaL_checkentity(L, 1)->CreateDataObject(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_CreatePredictedEntityByName (lua_State *L) {
+  lua_pushentity(L, CBaseEntity::CreatePredictedEntityByName(luaL_checkstring(L, 2), luaL_checkstring(L, 3), luaL_checkint(L, 4), luaL_optboolean(L, 5, 0)));
+  return 1;
+}
+
+static int CBaseEntity_CreateVPhysics (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->CreateVPhysics());
+  return 1;
+}
+
+static int CBaseEntity_DamageDecal (lua_State *L) {
+  lua_pushstring(L, luaL_checkentity(L, 1)->DamageDecal(luaL_checkint(L, 2), luaL_checkint(L, 3)));
+  return 1;
+}
+
+static int CBaseEntity_DecalTrace (lua_State *L) {
+  luaL_checkentity(L, 1)->DecalTrace(&luaL_checktrace(L, 2), luaL_checkstring(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_DestroyAllDataObjects (lua_State *L) {
+  luaL_checkentity(L, 1)->DestroyAllDataObjects();
+  return 0;
+}
+
+static int CBaseEntity_DestroyDataObject (lua_State *L) {
+  luaL_checkentity(L, 1)->DestroyDataObject(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_DispatchTraceAttack (lua_State *L) {
+  luaL_checkentity(L, 1)->DispatchTraceAttack(luaL_checkdamageinfo(L, 2), luaL_checkvector(L, 3), &luaL_checktrace(L, 4));
+  return 0;
+}
+
+static int CBaseEntity_DoImpactEffect (lua_State *L) {
+  luaL_checkentity(L, 1)->DoImpactEffect(luaL_checktrace(L, 2), luaL_checkint(L, 3));
+  return 1;
+}
+
+static int CBaseEntity_EarPosition (lua_State *L) {
+  lua_pushvector(L, luaL_checkentity(L, 1)->EarPosition());
+  return 1;
+}
+
+static int CBaseEntity_EmitAmbientSound (lua_State *L) {
+  float duration = luaL_optnumber(L, 6, 0);
+  CBaseEntity::EmitAmbientSound(luaL_checkint(L, 1), luaL_checkvector(L, 2), luaL_checkstring(L, 3), luaL_optint(L, 4, 0), luaL_optnumber(L, 5, 0.0f), &duration);
+  return 0;
+}
+
+static int CBaseEntity_EmitSound (lua_State *L) {
+  if (lua_isuserdata(L, 1) && lua_toentity(L, 1)) {
+    float duration = 0;
+	luaL_checkentity(L, 1)->EmitSound(luaL_checkstring(L, 2), luaL_optnumber(L, 3, 0.0f), &duration);
+	lua_pushnumber(L, duration);
+	return 1;
+  } else if (lua_isuserdata(L, 1) && dynamic_cast<CRecipientFilter *>((CRecipientFilter *)lua_touserdata(L, 1))) {
+    switch(lua_type(L, 3)) {
+      case LUA_TSTRING:
+        {
+          if (lua_gettop(L) <= 3)
+            CBaseEntity::EmitSound(luaL_checkrecipientfilter(L, 1), luaL_checkint(L, 2), luaL_checkstring(L, 3));
+          else {
+            float duration = 0;
+            CBaseEntity::EmitSound(luaL_checkrecipientfilter(L, 1), luaL_checkint(L, 2), luaL_checkstring(L, 3), &luaL_checkvector(L, 4), luaL_optnumber(L, 5, 0.0f), &duration);
+            lua_pushnumber(L, duration);
+            return 1;
+          }
+          break;
+        }
+      case LUA_TTABLE:
+        {
+          EmitSound_t ep;
+		  lua_toemitsound(L, 3, ep);
+
+          CBaseEntity::EmitSound(luaL_checkrecipientfilter(L, 1), luaL_checkint(L, 2), ep);
+          break;
+        }
+      default:
+        luaL_typerror(L, 3, "string or CRecipientFilter");
+        break;
+    }
+  } else
+    luaL_typerror(L, 1, "CBaseEntity or CRecipientFilter");
+  return 0;
+}
+
+static int CBaseEntity_EndGroundContact (lua_State *L) {
+  luaL_checkentity(L, 1)->EndGroundContact(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_EndTouch (lua_State *L) {
+  luaL_checkentity(L, 1)->EndTouch(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_entindex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->entindex());
+  return 1;
+}
+
+static int CBaseEntity_EntityToWorldSpace (lua_State *L) {
+  luaL_checkentity(L, 1)->EntityToWorldSpace(luaL_checkvector(L, 2), &luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_EyeAngles (lua_State *L) {
+  QAngle v = luaL_checkentity(L, 1)->EyeAngles();
+  lua_pushangle(L, v);
+  return 1;
+}
+
+static int CBaseEntity_EyePosition (lua_State *L) {
+  lua_pushvector(L, luaL_checkentity(L, 1)->EyePosition());
+  return 1;
+}
+
+static int CBaseEntity_FireBullets (lua_State *L) {
+  luaL_checkentity(L, 1)->FireBullets(lua_tofirebulletsinfo(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_FirstMoveChild (lua_State *L) {
+  lua_pushentity(L, luaL_checkentity(L, 1)->FirstMoveChild());
+  return 1;
+}
+
+static int CBaseEntity_FollowEntity (lua_State *L) {
+  luaL_checkentity(L, 1)->FollowEntity(luaL_checkentity(L, 2), luaL_checkboolean(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_GenderExpandString (lua_State *L) {
+  char out[128];
+  out[0] = '\0';
+  luaL_checkentity(L, 1)->GenderExpandString(luaL_checkstring(L, 2), out, sizeof( out ));
+  lua_pushstring(L, out);
+  return 1;
+}
+
+static int CBaseEntity_GetAbsAngles (lua_State *L) {
+  QAngle v = luaL_checkentity(L, 1)->GetAbsAngles();
+  lua_pushangle(L, v);
+  return 1;
+}
+
+static int CBaseEntity_GetAbsOrigin (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->GetAbsOrigin();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_GetAbsVelocity (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->GetAbsVelocity();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_GetAnimTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetAnimTime());
+  return 1;
+}
+
+static int CBaseEntity_GetBaseAnimating (lua_State *L) {
+  lua_pushanimating(L, luaL_checkentity(L, 1)->GetBaseAnimating());
+  return 1;
+}
+
+static int CBaseEntity_GetBaseEntity (lua_State *L) {
+  lua_pushentity(L, luaL_checkentity(L, 1)->GetBaseEntity());
+  return 1;
+}
+
+static int CBaseEntity_GetBaseVelocity (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->GetBaseVelocity();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_GetCheckUntouch (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->GetCheckUntouch());
+  return 1;
+}
+
+static int CBaseEntity_GetClassname (lua_State *L) {
+  lua_pushstring(L, luaL_checkentity(L, 1)->GetClassname());
+  return 1;
+}
+
+static int CBaseEntity_GetCollisionGroup (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetCollisionGroup());
+  return 1;
+}
+
+static int CBaseEntity_GetDataObject (lua_State *L) {
+  luaL_checkentity(L, 1)->GetDataObject(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_GetDebugName (lua_State *L) {
+  lua_pushstring(L, luaL_checkentity(L, 1)->GetDebugName());
+  return 1;
+}
+
+static int CBaseEntity_GetDLLType (lua_State *L) {
+  lua_pushstring(L, CBaseEntity::GetDLLType());
+  return 1;
+}
+
+static int CBaseEntity_GetEffectEntity (lua_State *L) {
+  lua_pushentity(L, luaL_checkentity(L, 1)->GetEffectEntity());
+  return 1;
+}
+
+static int CBaseEntity_GetEffects (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetEffects());
+  return 1;
+}
+
+static int CBaseEntity_GetEFlags (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetEFlags());
+  return 1;
+}
+
+static int CBaseEntity_GetElasticity (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetElasticity());
+  return 1;
+}
+
+static int CBaseEntity_GetFirstThinkTick (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetFirstThinkTick());
+  return 1;
+}
+
+static int CBaseEntity_GetFlags (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetFlags());
+  return 1;
+}
+
+static int CBaseEntity_GetFollowedEntity (lua_State *L) {
+  lua_pushentity(L, luaL_checkentity(L, 1)->GetFollowedEntity());
+  return 1;
+}
+
+static int CBaseEntity_GetGravity (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetGravity());
+  return 1;
+}
+
+static int CBaseEntity_GetGroundChangeTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetGroundChangeTime());
+  return 1;
+}
+
+static int CBaseEntity_GetGroundEntity (lua_State *L) {
+  lua_pushentity(L, luaL_checkentity(L, 1)->GetGroundEntity());
+  return 1;
+}
+
+static int CBaseEntity_GetHealth (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetHealth());
+  return 1;
+}
+
+static int CBaseEntity_GetKeyValue (lua_State *L) {
+  char szValue[256];
+  szValue[0] = '\0';
+  lua_pushboolean(L, luaL_checkentity(L, 1)->GetKeyValue(luaL_checkstring(L, 2), szValue, sizeof( szValue )));
+  lua_pushstring(L, szValue);
+  return 2;
+}
+
+static int CBaseEntity_GetLastThink (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetLastThink(luaL_optstring(L, 2, 0)));
+  return 1;
+}
+
+static int CBaseEntity_GetLastThinkTick (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetLastThinkTick(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_GetLocalAngles (lua_State *L) {
+  // Create an angle object, then push a copy of the angle
+  QAngle dst;
+  VectorCopy(luaL_checkentity(L, 1)->GetLocalAngles(), dst);
+  lua_pushangle(L, dst);
+  return 1;
+}
+
+static int CBaseEntity_GetLocalAngularVelocity (lua_State *L) {
+  QAngle v = luaL_checkentity(L, 1)->GetLocalAngularVelocity();
+  lua_pushangle(L, v);
+  return 1;
+}
+
+static int CBaseEntity_GetLocalOrigin (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->GetLocalOrigin();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_GetLocalVelocity (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->GetLocalVelocity();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_GetMaxHealth (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetMaxHealth());
+  return 1;
+}
+
+static int CBaseEntity_GetModelIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetModelIndex());
+  return 1;
+}
+
+static int CBaseEntity_GetModelName (lua_State *L) {
+  lua_pushstring(L, STRING( luaL_checkentity(L, 1)->GetModelName() ));
+  return 1;
+}
+
+static int CBaseEntity_GetMoveParent (lua_State *L) {
+  lua_pushentity(L, luaL_checkentity(L, 1)->GetMoveParent());
+  return 1;
+}
+
+static int CBaseEntity_GetMoveType (lua_State *L) {
+  lua_pushinteger(L, (MoveType_t)luaL_checkentity(L, 1)->GetMoveType());
+  return 1;
+}
+
+static int CBaseEntity_GetOwnerEntity (lua_State *L) {
+  lua_pushentity(L, luaL_checkentity(L, 1)->GetOwnerEntity());
+  return 1;
+}
+
+static int CBaseEntity_GetParametersForSound (lua_State *L) {
+  CSoundParameters params;
+  lua_pushboolean(L, CBaseEntity::GetParametersForSound(luaL_checkstring(L, 1), params, luaL_optstring(L, 2, NULL)));
+  lua_pushsoundparameters(L, params);
+  return 2;
+}
+
+static int CBaseEntity_GetPredictionPlayer (lua_State *L) {
+  lua_pushplayer(L, CBaseEntity::GetPredictionPlayer());
+  return 1;
+}
+
+static int CBaseEntity_GetPredictionRandomSeed (lua_State *L) {
+  lua_pushinteger(L, CBaseEntity::GetPredictionRandomSeed());
+  return 1;
+}
+
+static int CBaseEntity_GetRefTable (lua_State *L) {
+  CBaseEntity *pEntity = luaL_checkentity(L, 1);
+  if (pEntity->m_nTableReference == LUA_NOREF)
+    lua_pushnil(L);
+  else
+    lua_getref(L, pEntity->m_nTableReference);
+  return 1;
+}
+
+static int CBaseEntity_GetSimulatingPlayer (lua_State *L) {
+  lua_pushplayer(L, luaL_checkentity(L, 1)->GetSimulatingPlayer());
+  return 1;
+}
+
+static int CBaseEntity_GetSimulationTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkentity(L, 1)->GetSimulationTime());
+  return 1;
+}
+
+static int CBaseEntity_GetSolid (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetSolid());
+  return 1;
+}
+
+static int CBaseEntity_GetSolidFlags (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetSolidFlags());
+  return 1;
+}
+
+static int CBaseEntity_GetSoundDuration (lua_State *L) {
+  lua_pushnumber(L, CBaseEntity::GetSoundDuration(luaL_checkstring(L, 1), luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_GetSoundSourceIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetSoundSourceIndex());
+  return 1;
+}
+
+static int CBaseEntity_GetTeamNumber (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetTeamNumber());
+  return 1;
+}
+
+static int CBaseEntity_GetTextureFrameIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetTextureFrameIndex());
+  return 1;
+}
+
+static int CBaseEntity_GetTouchTrace (lua_State *L) {
+  trace_t tr = CBaseEntity::GetTouchTrace();
+  lua_pushtrace(L, tr);
+  return 1;
+}
+
+static int CBaseEntity_GetTracerAttachment (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetTracerAttachment());
+  return 1;
+}
+
+static int CBaseEntity_GetTracerType (lua_State *L) {
+  lua_pushstring(L, luaL_checkentity(L, 1)->GetTracerType());
+  return 1;
+}
+
+static int CBaseEntity_GetVectors (lua_State *L) {
+  Vector forward, right, up;
+  luaL_checkentity(L, 1)->GetVectors(&forward, &right, &up);
+  lua_pushvector(L, forward);
+  lua_pushvector(L, right);
+  lua_pushvector(L, up);
+  return 3;
+}
+
+static int CBaseEntity_GetViewOffset (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->GetViewOffset();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_GetWaterLevel (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetWaterLevel());
+  return 1;
+}
+
+static int CBaseEntity_GetWaterType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->GetWaterType());
+  return 1;
+}
+
+static int CBaseEntity_HasDataObjectType (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->HasDataObjectType(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_HasNPCsOnIt (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->HasNPCsOnIt());
+  return 1;
+}
+
+static int CBaseEntity_ImpactTrace (lua_State *L) {
+  luaL_checkentity(L, 1)->ImpactTrace(&luaL_checktrace(L, 2), luaL_checkint(L, 3), (char *)luaL_optstring(L, 4, 0));
+  return 0;
+}
+
+static int CBaseEntity_InSameTeam (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->InSameTeam(luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_IsAbsQueriesValid (lua_State *L) {
+  lua_pushboolean(L, CBaseEntity::IsAbsQueriesValid());
+  return 1;
+}
+
+static int CBaseEntity_IsAIWalkable (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsAIWalkable());
+  return 1;
+}
+
+static int CBaseEntity_IsAlive (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsAlive());
+  return 1;
+}
+
+static int CBaseEntity_IsAnimatedEveryTick (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsAnimatedEveryTick());
+  return 1;
+}
+
+static int CBaseEntity_IsBaseObject (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsBaseObject());
+  return 1;
+}
+
+static int CBaseEntity_IsBaseTrain (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsBaseTrain());
+  return 1;
+}
+
+static int CBaseEntity_IsBSPModel (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsBSPModel());
+  return 1;
+}
+
+static int CBaseEntity_IsClient (lua_State *L) {
+  lua_pushboolean(L, CBaseEntity::IsClient());
+  return 1;
+}
+
+static int CBaseEntity_IsCurrentlyTouching (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsCurrentlyTouching());
+  return 1;
+}
+
+static int CBaseEntity_IsDormant (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsDormant());
+  return 1;
+}
+
+static int CBaseEntity_IsEffectActive (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsEffectActive(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_IsEFlagSet (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsEFlagSet(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_IsFloating (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsFloating());
+  return 1;
+}
+
+static int CBaseEntity_IsFollowingEntity (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsFollowingEntity());
+  return 1;
+}
+
+static int CBaseEntity_IsInWorld (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsInWorld());
+  return 1;
+}
+
+static int CBaseEntity_IsMarkedForDeletion (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsMarkedForDeletion());
+  return 1;
+}
+
+static int CBaseEntity_IsNPC (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsNPC());
+  return 1;
+}
+
+static int CBaseEntity_IsPlayer (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsPlayer());
+  return 1;
+}
+
+static int CBaseEntity_IsPlayerSimulated (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsPlayerSimulated());
+  return 1;
+}
+
+static int CBaseEntity_IsPointSized (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsPointSized());
+  return 1;
+}
+
+static int CBaseEntity_IsPrecacheAllowed (lua_State *L) {
+  lua_pushboolean(L, CBaseEntity::IsPrecacheAllowed());
+  return 1;
+}
+
+static int CBaseEntity_IsServer (lua_State *L) {
+  lua_pushboolean(L, CBaseEntity::IsServer());
+  return 1;
+}
+
+static int CBaseEntity_IsSimulatedEveryTick (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsSimulatedEveryTick());
+  return 1;
+}
+
+static int CBaseEntity_IsSimulatingOnAlternateTicks (lua_State *L) {
+  lua_pushboolean(L, CBaseEntity::IsSimulatingOnAlternateTicks());
+  return 1;
+}
+
+static int CBaseEntity_IsSolid (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsSolid());
+  return 1;
+}
+
+static int CBaseEntity_IsSolidFlagSet (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsSolidFlagSet(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_IsStandable (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsStandable());
+  return 1;
+}
+
+static int CBaseEntity_IsTransparent (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsTransparent());
+  return 1;
+}
+
+static int CBaseEntity_IsWeapon (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->IsWeapon());
+  return 1;
+}
+
+static int CBaseEntity_KeyValue (lua_State *L) {
+  switch(lua_type(L, 3)) {
+	case LUA_TNUMBER:
+	  lua_pushboolean(L, luaL_checkentity(L, 1)->KeyValue(luaL_checkstring(L, 2), luaL_checknumber(L, 3)));
+	  break;
+	case LUA_TSTRING:
+	default:
+	  lua_pushboolean(L, luaL_checkentity(L, 1)->KeyValue(luaL_checkstring(L, 2), luaL_checkstring(L, 3)));
+	  break;
+	case LUA_TUSERDATA:
+      if (luaL_checkudata(L, 3, "Vector"))
+	    lua_pushboolean(L, luaL_checkentity(L, 1)->KeyValue(luaL_checkstring(L, 2), luaL_checkvector(L, 3)));
+	  else
+	    luaL_typerror(L, 3, "Vector");
+	  break;
+  }
+  return 1;
+}
+
+static int CBaseEntity_LocalEyeAngles (lua_State *L) {
+  QAngle v = luaL_checkentity(L, 1)->LocalEyeAngles();
+  lua_pushangle(L, v);
+  return 1;
+}
+
+static int CBaseEntity_NextMovePeer (lua_State *L) {
+  lua_pushentity(L, luaL_checkentity(L, 1)->NextMovePeer());
+  return 1;
+}
+
+static int CBaseEntity_ObjectCaps (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->ObjectCaps());
+  return 1;
+}
+
+static int CBaseEntity_OnRestore (lua_State *L) {
+  luaL_checkentity(L, 1)->OnRestore();
+  return 0;
+}
+
+static int CBaseEntity_PhysicsCheckForEntityUntouch (lua_State *L) {
+  luaL_checkentity(L, 1)->PhysicsCheckForEntityUntouch();
+  return 0;
+}
+
+static int CBaseEntity_PhysicsCheckWater (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->PhysicsCheckWater());
+  return 1;
+}
+
+static int CBaseEntity_PhysicsCheckWaterTransition (lua_State *L) {
+  luaL_checkentity(L, 1)->PhysicsCheckWaterTransition();
+  return 0;
+}
+
+static int CBaseEntity_PhysicsImpact (lua_State *L) {
+  luaL_checkentity(L, 1)->PhysicsImpact(luaL_checkentity(L, 2), luaL_checktrace(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_PhysicsMarkEntitiesAsTouching (lua_State *L) {
+  luaL_checkentity(L, 1)->PhysicsMarkEntitiesAsTouching(luaL_checkentity(L, 2), luaL_checktrace(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_PhysicsNotifyOtherOfGroundRemoval (lua_State *L) {
+  CBaseEntity::PhysicsNotifyOtherOfGroundRemoval(luaL_checkentity(L, 1), luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_PhysicsNotifyOtherOfUntouch (lua_State *L) {
+  CBaseEntity::PhysicsNotifyOtherOfUntouch(luaL_checkentity(L, 1), luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_PhysicsRemoveGroundList (lua_State *L) {
+  CBaseEntity::PhysicsRemoveGroundList(luaL_checkentity(L, 1));
+  return 0;
+}
+
+static int CBaseEntity_PhysicsRemoveTouchedList (lua_State *L) {
+  CBaseEntity::PhysicsRemoveTouchedList(luaL_checkentity(L, 1));
+  return 0;
+}
+
+static int CBaseEntity_PhysicsSimulate (lua_State *L) {
+  luaL_checkentity(L, 1)->PhysicsSimulate();
+  return 0;
+}
+
+static int CBaseEntity_PhysicsSolidMaskForEntity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->PhysicsSolidMaskForEntity());
+  return 1;
+}
+
+static int CBaseEntity_PhysicsStartGroundContact (lua_State *L) {
+  luaL_checkentity(L, 1)->PhysicsStartGroundContact(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_Precache (lua_State *L) {
+  luaL_checkentity(L, 1)->Precache();
+  return 0;
+}
+
+static int CBaseEntity_PrecacheModel (lua_State *L) {
+  lua_pushinteger(L, CBaseEntity::PrecacheModel(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int CBaseEntity_PrecacheScriptSound (lua_State *L) {
+  lua_pushinteger(L, CBaseEntity::PrecacheScriptSound(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int CBaseEntity_PrecacheSound (lua_State *L) {
+  lua_pushboolean(L, CBaseEntity::PrecacheSound(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int CBaseEntity_PrefetchScriptSound (lua_State *L) {
+  CBaseEntity::PrefetchScriptSound(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int CBaseEntity_PrefetchSound (lua_State *L) {
+  CBaseEntity::PrefetchSound(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int CBaseEntity_RegisterThinkContext (lua_State *L) {
+  lua_pushinteger(L, luaL_checkentity(L, 1)->RegisterThinkContext(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int CBaseEntity_Remove (lua_State *L) {
+  luaL_checkentity(L, 1)->Remove();
+  return 0;
+}
+
+static int CBaseEntity_RemoveAllDecals (lua_State *L) {
+  luaL_checkentity(L, 1)->RemoveAllDecals();
+  return 0;
+}
+
+static int CBaseEntity_RemoveDataObjectType (lua_State *L) {
+  luaL_checkentity(L, 1)->RemoveDataObjectType(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_RemoveEffects (lua_State *L) {
+  luaL_checkentity(L, 1)->RemoveEffects(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_RemoveEFlags (lua_State *L) {
+  luaL_checkentity(L, 1)->RemoveEFlags(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_RemoveFlag (lua_State *L) {
+  luaL_checkentity(L, 1)->RemoveFlag(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_RemoveSolidFlags (lua_State *L) {
+  luaL_checkentity(L, 1)->RemoveSolidFlags(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetAbsAngles (lua_State *L) {
+  luaL_checkentity(L, 1)->SetAbsAngles(luaL_checkangle(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetAbsOrigin (lua_State *L) {
+  luaL_checkentity(L, 1)->SetAbsOrigin(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetAbsQueriesValid (lua_State *L) {
+  CBaseEntity::SetAbsQueriesValid(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int CBaseEntity_SetAbsVelocity (lua_State *L) {
+  luaL_checkentity(L, 1)->SetAbsVelocity(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetAIWalkable (lua_State *L) {
+  luaL_checkentity(L, 1)->SetAIWalkable(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetAllowPrecache (lua_State *L) {
+  CBaseEntity::SetAllowPrecache(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int CBaseEntity_SetAnimatedEveryTick (lua_State *L) {
+  luaL_checkentity(L, 1)->SetAnimatedEveryTick(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetAnimTime (lua_State *L) {
+  luaL_checkentity(L, 1)->SetAnimTime(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetBaseVelocity (lua_State *L) {
+  luaL_checkentity(L, 1)->SetBaseVelocity(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetBlocksLOS (lua_State *L) {
+  luaL_checkentity(L, 1)->SetBlocksLOS(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetCheckUntouch (lua_State *L) {
+  luaL_checkentity(L, 1)->SetCheckUntouch(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetClassname (lua_State *L) {
+  luaL_checkentity(L, 1)->SetClassname(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetCollisionBounds (lua_State *L) {
+  luaL_checkentity(L, 1)->SetCollisionBounds(luaL_checkvector(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_SetCollisionGroup (lua_State *L) {
+  luaL_checkentity(L, 1)->SetCollisionGroup(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetEffectEntity (lua_State *L) {
+  luaL_checkentity(L, 1)->SetEffectEntity(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetEffects (lua_State *L) {
+  luaL_checkentity(L, 1)->SetEffects(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetEFlags (lua_State *L) {
+  luaL_checkentity(L, 1)->SetEFlags(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetFriction (lua_State *L) {
+  luaL_checkentity(L, 1)->SetFriction(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetGravity (lua_State *L) {
+  luaL_checkentity(L, 1)->SetGravity(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetGroundChangeTime (lua_State *L) {
+  luaL_checkentity(L, 1)->SetGroundChangeTime(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetGroundEntity (lua_State *L) {
+  luaL_checkentity(L, 1)->SetGroundEntity(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetHealth (lua_State *L) {
+  luaL_checkentity(L, 1)->SetHealth(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetLocalAngles (lua_State *L) {
+  luaL_checkentity(L, 1)->SetLocalAngles(luaL_checkangle(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetLocalAngularVelocity (lua_State *L) {
+  luaL_checkentity(L, 1)->SetLocalAngularVelocity(luaL_checkangle(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetLocalOrigin (lua_State *L) {
+  luaL_checkentity(L, 1)->SetLocalOrigin(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetLocalVelocity (lua_State *L) {
+  luaL_checkentity(L, 1)->SetLocalVelocity(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetModel (lua_State *L) {
+#ifdef CLIENT_DLL
+  lua_pushboolean(L, luaL_checkentity(L, 1)->SetModel(luaL_checkstring(L, 2)));
+  return 1;
+#else
+  luaL_checkentity(L, 1)->SetModel(luaL_checkstring(L, 2));
+  return 0;
+#endif
+}
+
+static int CBaseEntity_SetModelIndex (lua_State *L) {
+  luaL_checkentity(L, 1)->SetModelIndex(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetModelName (lua_State *L) {
+  string_t name = *(string_t *)luaL_checkstring(L, 2);
+  luaL_checkentity(L, 1)->SetModelName(name);
+  return 0;
+}
+
+static int CBaseEntity_SetMoveCollide (lua_State *L) {
+  luaL_checkentity(L, 1)->SetMoveCollide((MoveCollide_t)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetMoveType (lua_State *L) {
+  luaL_checkentity(L, 1)->SetMoveType((MoveType_t)luaL_checkint(L, 2), (MoveCollide_t)luaL_optint(L, 3, MOVECOLLIDE_DEFAULT));
+  return 0;
+}
+
+static int CBaseEntity_SetNextThink (lua_State *L) {
+  luaL_checkentity(L, 1)->SetNextThink(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetOwnerEntity (lua_State *L) {
+  luaL_checkentity(L, 1)->SetOwnerEntity(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetParent (lua_State *L) {
+  luaL_checkentity(L, 1)->SetParent(luaL_checkentity(L, 2), luaL_optint(L, 3, 0));
+  return 0;
+}
+
+static int CBaseEntity_SetPlayerSimulated (lua_State *L) {
+  luaL_checkentity(L, 1)->SetPlayerSimulated(luaL_checkplayer(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetPredictionEligible (lua_State *L) {
+  luaL_checkentity(L, 1)->SetPredictionEligible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetPredictionPlayer (lua_State *L) {
+  CBaseEntity::SetPredictionPlayer(luaL_checkplayer(L, 1));
+  return 0;
+}
+
+static int CBaseEntity_SetRenderColor (lua_State *L) {
+  luaL_checkentity(L, 1)->SetRenderColor(luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checknumber(L, 4), luaL_optnumber(L, 5, 255));
+  return 0;
+}
+
+static int CBaseEntity_SetRenderColorA (lua_State *L) {
+  luaL_checkentity(L, 1)->SetRenderColorA(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetRenderColorB (lua_State *L) {
+  luaL_checkentity(L, 1)->SetRenderColorB(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetRenderColorG (lua_State *L) {
+  luaL_checkentity(L, 1)->SetRenderColorG(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetRenderColorR (lua_State *L) {
+  luaL_checkentity(L, 1)->SetRenderColorR(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetSimulatedEveryTick (lua_State *L) {
+  luaL_checkentity(L, 1)->SetSimulatedEveryTick(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetSimulationTime (lua_State *L) {
+  luaL_checkentity(L, 1)->SetSimulationTime(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetSize (lua_State *L) {
+  luaL_checkentity(L, 1)->SetSize(luaL_checkvector(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int CBaseEntity_SetSolid (lua_State *L) {
+  luaL_checkentity(L, 1)->SetSolid((SolidType_t)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetSolidFlags (lua_State *L) {
+  luaL_checkentity(L, 1)->SetSolidFlags(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetTextureFrameIndex (lua_State *L) {
+  luaL_checkentity(L, 1)->SetTextureFrameIndex(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetViewOffset (lua_State *L) {
+  luaL_checkentity(L, 1)->SetViewOffset(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetWaterLevel (lua_State *L) {
+  luaL_checkentity(L, 1)->SetWaterLevel(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_SetWaterType (lua_State *L) {
+  luaL_checkentity(L, 1)->SetWaterType(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_ShouldCollide (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->ShouldCollide(luaL_checkint(L, 2), luaL_checkint(L, 3)));
+  return 1;
+}
+
+static int CBaseEntity_ShouldSavePhysics (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->ShouldSavePhysics());
+  return 1;
+}
+
+static int CBaseEntity_Spawn (lua_State *L) {
+  luaL_checkentity(L, 1)->Spawn();
+  return 0;
+}
+
+static int CBaseEntity_StartGroundContact (lua_State *L) {
+  luaL_checkentity(L, 1)->StartGroundContact(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_StartTouch (lua_State *L) {
+  luaL_checkentity(L, 1)->StartTouch(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_StopFollowingEntity (lua_State *L) {
+  luaL_checkentity(L, 1)->StopFollowingEntity();
+  return 0;
+}
+
+static int CBaseEntity_SUB_Remove (lua_State *L) {
+  luaL_checkentity(L, 1)->SUB_Remove();
+  return 0;
+}
+
+static int CBaseEntity_Think (lua_State *L) {
+  luaL_checkentity(L, 1)->Think();
+  return 0;
+}
+
+static int CBaseEntity_ToggleFlag (lua_State *L) {
+  luaL_checkentity(L, 1)->ToggleFlag(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_Touch (lua_State *L) {
+  luaL_checkentity(L, 1)->Touch(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_TraceBleed (lua_State *L) {
+  luaL_checkentity(L, 1)->TraceBleed(luaL_checknumber(L, 2), luaL_checkvector(L, 3), &luaL_checktrace(L, 4), luaL_checkint(L, 5));
+  return 0;
+}
+
+static int CBaseEntity_UnsetPlayerSimulated (lua_State *L) {
+  luaL_checkentity(L, 1)->UnsetPlayerSimulated();
+  return 0;
+}
+
+static int CBaseEntity_UpdateOnRemove (lua_State *L) {
+  luaL_checkentity(L, 1)->UpdateOnRemove();
+  return 0;
+}
+
+static int CBaseEntity_VPhysicsDestroyObject (lua_State *L) {
+  luaL_checkentity(L, 1)->VPhysicsDestroyObject();
+  return 0;
+}
+
+static int CBaseEntity_VPhysicsGetObject (lua_State *L) {
+  lua_pushphysicsobject(L, luaL_checkentity(L, 1)->VPhysicsGetObject());
+  return 1;
+}
+
+static int CBaseEntity_VPhysicsGetObjectList (lua_State *L) {
+  IPhysicsObject *pList[VPHYSICS_MAX_OBJECT_LIST_COUNT];
+  int count = luaL_checkentity(L, 1)->VPhysicsGetObjectList( pList, ARRAYSIZE(pList) );
+  lua_pushinteger(L, count);
+  lua_newtable(L);
+  for( int i = 0 ; i < count ; i++ )
+  {
+	  lua_pushinteger(L, i);
+	  lua_pushphysicsobject(L, pList[i]);
+	  lua_settable(L, -3);
+  }
+  return 2;
+}
+
+static int CBaseEntity_VPhysicsInitNormal (lua_State *L) {
+  // TODO: Implement a Lua solid_t object.
+  lua_pushphysicsobject(L, luaL_checkentity(L, 1)->VPhysicsInitNormal((SolidType_t)luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkboolean(L, 4)));
+  return 1;
+}
+
+static int CBaseEntity_VPhysicsInitStatic (lua_State *L) {
+  lua_pushphysicsobject(L, luaL_checkentity(L, 1)->VPhysicsInitStatic());
+  return 1;
+}
+
+static int CBaseEntity_VPhysicsIsFlesh (lua_State *L) {
+  lua_pushboolean(L, luaL_checkentity(L, 1)->VPhysicsIsFlesh());
+  return 1;
+}
+
+static int CBaseEntity_VPhysicsSetObject (lua_State *L) {
+  luaL_checkentity(L, 1)->VPhysicsSetObject(luaL_checkphysicsobject(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_VPhysicsUpdate (lua_State *L) {
+  luaL_checkentity(L, 1)->VPhysicsUpdate(luaL_checkphysicsobject(L, 2));
+  return 0;
+}
+
+static int CBaseEntity_WakeRestingObjects (lua_State *L) {
+  luaL_checkentity(L, 1)->WakeRestingObjects();
+  return 0;
+}
+
+static int CBaseEntity_WorldAlignMaxs (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->WorldAlignMaxs();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_WorldAlignMins (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->WorldAlignMins();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_WorldAlignSize (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->WorldAlignSize();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_WorldSpaceCenter (lua_State *L) {
+  Vector v = luaL_checkentity(L, 1)->WorldSpaceCenter();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBaseEntity_WorldToEntitySpace (lua_State *L) {
+  luaL_checkentity(L, 1)->WorldToEntitySpace(luaL_checkvector(L, 2), &luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int CBaseEntity___index (lua_State *L) {
+  CBaseEntity *pEntity = lua_toentity(L, 1);
+  if (pEntity == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "m_bAllowPrecache") == 0)
+    lua_pushboolean(L, pEntity->m_bAllowPrecache);
+  else if (Q_strcmp(field, "m_flAnimTime") == 0)
+    lua_pushnumber(L, pEntity->m_flAnimTime);
+  else if (Q_strcmp(field, "m_flSimulationTime") == 0)
+    lua_pushnumber(L, pEntity->m_flSimulationTime);
+  else if (Q_strcmp(field, "m_flSpeed") == 0)
+    lua_pushnumber(L, pEntity->m_flSpeed);
+  else if (Q_strcmp(field, "m_iClassname") == 0)
+    lua_pushstring(L, STRING( pEntity->m_iClassname ));
+  else if (Q_strcmp(field, "m_iHealth") == 0)
+    lua_pushinteger(L, pEntity->m_iHealth);
+  else if (Q_strcmp(field, "m_nLastThinkTick") == 0)
+    lua_pushinteger(L, pEntity->m_nLastThinkTick);
+  else if (Q_strcmp(field, "m_nModelIndex") == 0)
+    lua_pushinteger(L, pEntity->m_nModelIndex);
+  else if (Q_strcmp(field, "touchStamp") == 0)
+    lua_pushinteger(L, pEntity->touchStamp);
+  else if (pEntity->m_nTableReference != LUA_NOREF) {
+    lua_getref(L, pEntity->m_nTableReference);
+    lua_getfield(L, -1, field);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      lua_getmetatable(L, 1);
+      lua_getfield(L, -1, field);
+    }
+  }
+  else {
+    lua_getmetatable(L, 1);
+    lua_getfield(L, -1, field);
+  }
+  return 1;
+}
+
+static int CBaseEntity___newindex (lua_State *L) {
+  CBaseEntity *pEntity = lua_toentity(L, 1);
+  if (pEntity == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "m_bAllowPrecache") == 0)
+    pEntity->m_bAllowPrecache = luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_flAnimTime") == 0)
+    pEntity->m_flAnimTime = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_flSimulationTime") == 0)
+    pEntity->m_flSimulationTime = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_flSpeed") == 0)
+    pEntity->m_flSpeed = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_iClassname") == 0)
+    pEntity->m_iClassname = MAKE_STRING( luaL_checkstring(L, 3) );
+  else if (Q_strcmp(field, "m_iHealth") == 0)
+    pEntity->m_iHealth = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_nLastThinkTick") == 0)
+    pEntity->m_nLastThinkTick = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_nModelIndex") == 0)
+    pEntity->m_nModelIndex = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "touchStamp") == 0)
+    pEntity->touchStamp = luaL_checkint(L, 3);
+  else {
+    if (pEntity->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      pEntity->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, pEntity->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, field);
+	lua_pop(L, 1);
+  }
+  return 0;
+}
+
+static int CBaseEntity___eq (lua_State *L) {
+  lua_pushboolean(L, lua_toentity(L, 1) == lua_toentity(L, 2));
+  return 1;
+}
+
+static int CBaseEntity___tostring (lua_State *L) {
+  CBaseEntity *pEntity = lua_toentity(L, 1);
+  if (pEntity == NULL)
+    lua_pushstring(L, "NULL");
+  else
+    lua_pushfstring(L, "CBaseEntity: %d %s", pEntity->entindex(), pEntity->GetClassname());
+  return 1;
+}
+
+
+static const luaL_Reg CBaseEntitymeta[] = {
+  {"Activate", CBaseEntity_Activate},
+  {"AddDataObjectType", CBaseEntity_AddDataObjectType},
+  {"AddEffects", CBaseEntity_AddEffects},
+  {"AddEFlags", CBaseEntity_AddEFlags},
+  {"AddFlag", CBaseEntity_AddFlag},
+  {"AddSolidFlags", CBaseEntity_AddSolidFlags},
+  {"ApplyAbsVelocityImpulse", CBaseEntity_ApplyAbsVelocityImpulse},
+  {"ApplyLocalAngularVelocityImpulse", CBaseEntity_ApplyLocalAngularVelocityImpulse},
+  {"BlocksLOS", CBaseEntity_BlocksLOS},
+  {"BloodColor", CBaseEntity_BloodColor},
+  {"BoundingRadius", CBaseEntity_BoundingRadius},
+  {"ChangeTeam", CBaseEntity_ChangeTeam},
+  {"ClearEffects", CBaseEntity_ClearEffects},
+  {"ClearFlags", CBaseEntity_ClearFlags},
+  {"CollisionRulesChanged", CBaseEntity_CollisionRulesChanged},
+  {"ComputeAbsDirection", CBaseEntity_ComputeAbsDirection},
+  {"ComputeAbsPosition", CBaseEntity_ComputeAbsPosition},
+  {"ComputeWorldSpaceSurroundingBox", CBaseEntity_ComputeWorldSpaceSurroundingBox},
+  {"CreateDataObject", CBaseEntity_CreateDataObject},
+  {"CreatePredictedEntityByName", CBaseEntity_CreatePredictedEntityByName},
+  {"CreateVPhysics", CBaseEntity_CreateVPhysics},
+  {"DamageDecal", CBaseEntity_DamageDecal},
+  {"DecalTrace", CBaseEntity_DecalTrace},
+  {"DestroyAllDataObjects", CBaseEntity_DestroyAllDataObjects},
+  {"DestroyDataObject", CBaseEntity_DestroyDataObject},
+  {"DispatchTraceAttack", CBaseEntity_DispatchTraceAttack},
+  {"DoImpactEffect", CBaseEntity_DoImpactEffect},
+  {"EarPosition", CBaseEntity_EarPosition},
+  {"EmitSound", CBaseEntity_EmitSound},
+  {"EmitAmbientSound", CBaseEntity_EmitAmbientSound},
+  {"EndGroundContact", CBaseEntity_EndGroundContact},
+  {"EndTouch", CBaseEntity_EndTouch},
+  {"entindex", CBaseEntity_entindex},
+  {"EntityToWorldSpace", CBaseEntity_EntityToWorldSpace},
+  {"EyeAngles", CBaseEntity_EyeAngles},
+  {"EyePosition", CBaseEntity_EyePosition},
+  {"FireBullets", CBaseEntity_FireBullets},
+  {"FirstMoveChild", CBaseEntity_FirstMoveChild},
+  {"FollowEntity", CBaseEntity_FollowEntity},
+  {"GenderExpandString", CBaseEntity_GenderExpandString},
+  {"GetAbsAngles", CBaseEntity_GetAbsAngles},
+  {"GetAbsOrigin", CBaseEntity_GetAbsOrigin},
+  {"GetAbsVelocity", CBaseEntity_GetAbsVelocity},
+  {"GetAnimTime", CBaseEntity_GetAnimTime},
+  {"GetBaseAnimating", CBaseEntity_GetBaseAnimating},
+  {"GetBaseEntity", CBaseEntity_GetBaseEntity},
+  {"GetBaseVelocity", CBaseEntity_GetBaseVelocity},
+  {"GetCheckUntouch", CBaseEntity_GetCheckUntouch},
+  {"GetClassname", CBaseEntity_GetClassname},
+  {"GetCollisionGroup", CBaseEntity_GetCollisionGroup},
+  {"GetDataObject", CBaseEntity_GetDataObject},
+  {"GetDebugName", CBaseEntity_GetDebugName},
+  {"GetDLLType", CBaseEntity_GetDLLType},
+  {"GetEffectEntity", CBaseEntity_GetEffectEntity},
+  {"GetEffects", CBaseEntity_GetEffects},
+  {"GetEFlags", CBaseEntity_GetEFlags},
+  {"GetElasticity", CBaseEntity_GetElasticity},
+  {"GetFirstThinkTick", CBaseEntity_GetFirstThinkTick},
+  {"GetFlags", CBaseEntity_GetFlags},
+  {"GetFollowedEntity", CBaseEntity_GetFollowedEntity},
+  {"GetGravity", CBaseEntity_GetGravity},
+  {"GetGroundChangeTime", CBaseEntity_GetGroundChangeTime},
+  {"GetGroundEntity", CBaseEntity_GetGroundEntity},
+  {"GetHealth", CBaseEntity_GetHealth},
+  {"GetKeyValue", CBaseEntity_GetKeyValue},
+  {"GetLastThink", CBaseEntity_GetLastThink},
+  {"GetLastThinkTick", CBaseEntity_GetLastThinkTick},
+  {"GetLocalAngles", CBaseEntity_GetLocalAngles},
+  {"GetLocalAngularVelocity", CBaseEntity_GetLocalAngularVelocity},
+  {"GetLocalOrigin", CBaseEntity_GetLocalOrigin},
+  {"GetLocalVelocity", CBaseEntity_GetLocalVelocity},
+  {"GetMaxHealth", CBaseEntity_GetMaxHealth},
+  {"GetModelIndex", CBaseEntity_GetModelIndex},
+  {"GetModelName", CBaseEntity_GetModelName},
+  {"GetMoveParent", CBaseEntity_GetMoveParent},
+  {"GetMoveType", CBaseEntity_GetMoveType},
+  {"GetOwnerEntity", CBaseEntity_GetOwnerEntity},
+  {"GetParametersForSound", CBaseEntity_GetParametersForSound},
+  {"GetPredictionPlayer", CBaseEntity_GetPredictionPlayer},
+  {"GetPredictionRandomSeed", CBaseEntity_GetPredictionRandomSeed},
+  {"GetSimulatingPlayer", CBaseEntity_GetSimulatingPlayer},
+  {"GetSimulationTime", CBaseEntity_GetSimulationTime},
+  {"GetSolid", CBaseEntity_GetSolid},
+  {"GetSolidFlags", CBaseEntity_GetSolidFlags},
+  {"GetSoundDuration", CBaseEntity_GetSoundDuration},
+  {"GetSoundSourceIndex", CBaseEntity_GetSoundSourceIndex},
+  {"GetTeamNumber", CBaseEntity_GetTeamNumber},
+  {"GetTextureFrameIndex", CBaseEntity_GetTextureFrameIndex},
+  {"GetTouchTrace", CBaseEntity_GetTouchTrace},
+  {"GetTracerAttachment", CBaseEntity_GetTracerAttachment},
+  {"GetTracerType", CBaseEntity_GetTracerType},
+  {"GetVectors", CBaseEntity_GetVectors},
+  {"GetViewOffset", CBaseEntity_GetViewOffset},
+  {"GetWaterLevel", CBaseEntity_GetWaterLevel},
+  {"GetWaterType", CBaseEntity_GetWaterType},
+  {"HasDataObjectType", CBaseEntity_HasDataObjectType},
+  {"HasNPCsOnIt", CBaseEntity_HasNPCsOnIt},
+  {"ImpactTrace", CBaseEntity_ImpactTrace},
+  {"InSameTeam", CBaseEntity_InSameTeam},
+  {"IsAbsQueriesValid", CBaseEntity_IsAbsQueriesValid},
+  {"IsAIWalkable", CBaseEntity_IsAIWalkable},
+  {"IsAlive", CBaseEntity_IsAlive},
+  {"IsAnimatedEveryTick", CBaseEntity_IsAnimatedEveryTick},
+  {"IsBaseObject", CBaseEntity_IsBaseObject},
+  {"IsBaseTrain", CBaseEntity_IsBaseTrain},
+  {"IsBSPModel", CBaseEntity_IsBSPModel},
+  {"IsClient", CBaseEntity_IsClient},
+  {"IsCurrentlyTouching", CBaseEntity_IsCurrentlyTouching},
+  {"IsDormant", CBaseEntity_IsDormant},
+  {"IsEffectActive", CBaseEntity_IsEffectActive},
+  {"IsEFlagSet", CBaseEntity_IsEFlagSet},
+  {"IsFloating", CBaseEntity_IsFloating},
+  {"IsFollowingEntity", CBaseEntity_IsFollowingEntity},
+  {"IsInWorld", CBaseEntity_IsInWorld},
+  {"IsMarkedForDeletion", CBaseEntity_IsMarkedForDeletion},
+  {"IsNPC", CBaseEntity_IsNPC},
+  {"IsPlayer", CBaseEntity_IsPlayer},
+  {"IsPlayerSimulated", CBaseEntity_IsPlayerSimulated},
+  {"IsPointSized", CBaseEntity_IsPointSized},
+  {"IsPrecacheAllowed", CBaseEntity_IsPrecacheAllowed},
+  {"IsServer", CBaseEntity_IsServer},
+  {"IsSimulatedEveryTick", CBaseEntity_IsSimulatedEveryTick},
+  {"IsSimulatingOnAlternateTicks", CBaseEntity_IsSimulatingOnAlternateTicks},
+  {"IsSolid", CBaseEntity_IsSolid},
+  {"IsSolidFlagSet", CBaseEntity_IsSolidFlagSet},
+  {"IsStandable", CBaseEntity_IsStandable},
+  {"IsTransparent", CBaseEntity_IsTransparent},
+  {"IsWeapon", CBaseEntity_IsWeapon},
+  {"KeyValue", CBaseEntity_KeyValue},
+  {"LocalEyeAngles", CBaseEntity_LocalEyeAngles},
+  {"NextMovePeer", CBaseEntity_NextMovePeer},
+  {"ObjectCaps", CBaseEntity_ObjectCaps},
+  {"OnRestore", CBaseEntity_OnRestore},
+  {"PhysicsCheckForEntityUntouch", CBaseEntity_PhysicsCheckForEntityUntouch},
+  {"PhysicsCheckWater", CBaseEntity_PhysicsCheckWater},
+  {"PhysicsCheckWaterTransition", CBaseEntity_PhysicsCheckWaterTransition},
+  {"PhysicsImpact", CBaseEntity_PhysicsImpact},
+  {"PhysicsMarkEntitiesAsTouching", CBaseEntity_PhysicsMarkEntitiesAsTouching},
+  {"PhysicsNotifyOtherOfGroundRemoval", CBaseEntity_PhysicsNotifyOtherOfGroundRemoval},
+  {"PhysicsNotifyOtherOfUntouch", CBaseEntity_PhysicsNotifyOtherOfUntouch},
+  {"PhysicsRemoveGroundList", CBaseEntity_PhysicsRemoveGroundList},
+  {"PhysicsRemoveTouchedList", CBaseEntity_PhysicsRemoveTouchedList},
+  {"PhysicsSimulate", CBaseEntity_PhysicsSimulate},
+  {"PhysicsSolidMaskForEntity", CBaseEntity_PhysicsSolidMaskForEntity},
+  {"PhysicsStartGroundContact", CBaseEntity_PhysicsStartGroundContact},
+  {"Precache", CBaseEntity_Precache},
+  {"PrecacheModel", CBaseEntity_PrecacheModel},
+  {"PrecacheScriptSound", CBaseEntity_PrecacheScriptSound},
+  {"PrecacheSound", CBaseEntity_PrecacheSound},
+  {"PrefetchScriptSound", CBaseEntity_PrefetchScriptSound},
+  {"PrefetchSound", CBaseEntity_PrefetchSound},
+  {"RegisterThinkContext", CBaseEntity_RegisterThinkContext},
+  {"Remove", CBaseEntity_Remove},
+  {"RemoveAllDecals", CBaseEntity_RemoveAllDecals},
+  {"RemoveDataObjectType", CBaseEntity_RemoveDataObjectType},
+  {"RemoveEffects", CBaseEntity_RemoveEffects},
+  {"RemoveEFlags", CBaseEntity_RemoveEFlags},
+  {"RemoveFlag", CBaseEntity_RemoveFlag},
+  {"RemoveSolidFlags", CBaseEntity_RemoveSolidFlags},
+  {"SetAbsAngles", CBaseEntity_SetAbsAngles},
+  {"SetAbsOrigin", CBaseEntity_SetAbsOrigin},
+  {"SetAbsQueriesValid", CBaseEntity_SetAbsQueriesValid},
+  {"SetAbsVelocity", CBaseEntity_SetAbsVelocity},
+  {"SetAIWalkable", CBaseEntity_SetAIWalkable},
+  {"SetAllowPrecache", CBaseEntity_SetAllowPrecache},
+  {"SetAnimatedEveryTick", CBaseEntity_SetAnimatedEveryTick},
+  {"SetAnimTime", CBaseEntity_SetAnimTime},
+  {"SetBaseVelocity", CBaseEntity_SetBaseVelocity},
+  {"SetBlocksLOS", CBaseEntity_SetBlocksLOS},
+  {"SetCheckUntouch", CBaseEntity_SetCheckUntouch},
+  {"SetClassname", CBaseEntity_SetClassname},
+  {"SetCollisionBounds", CBaseEntity_SetCollisionBounds},
+  {"SetCollisionGroup", CBaseEntity_SetCollisionGroup},
+  {"SetEffectEntity", CBaseEntity_SetEffectEntity},
+  {"SetEffects", CBaseEntity_SetEffects},
+  {"SetEFlags", CBaseEntity_SetEFlags},
+  {"SetFriction", CBaseEntity_SetFriction},
+  {"SetGravity", CBaseEntity_SetGravity},
+  {"SetGroundChangeTime", CBaseEntity_SetGroundChangeTime},
+  {"SetGroundEntity", CBaseEntity_SetGroundEntity},
+  {"SetHealth", CBaseEntity_SetHealth},
+  {"SetLocalAngles", CBaseEntity_SetLocalAngles},
+  {"SetLocalAngularVelocity", CBaseEntity_SetLocalAngularVelocity},
+  {"SetLocalOrigin", CBaseEntity_SetLocalOrigin},
+  {"SetLocalVelocity", CBaseEntity_SetLocalVelocity},
+  {"SetModel", CBaseEntity_SetModel},
+  {"SetModelIndex", CBaseEntity_SetModelIndex},
+  {"SetModelName", CBaseEntity_SetModelName},
+  {"SetMoveCollide", CBaseEntity_SetMoveCollide},
+  {"SetMoveType", CBaseEntity_SetMoveType},
+  {"SetNextThink", CBaseEntity_SetNextThink},
+  {"SetOwnerEntity", CBaseEntity_SetOwnerEntity},
+  {"SetParent", CBaseEntity_SetParent},
+  {"SetPlayerSimulated", CBaseEntity_SetPlayerSimulated},
+  {"SetPredictionEligible", CBaseEntity_SetPredictionEligible},
+  {"SetPredictionPlayer", CBaseEntity_SetPredictionPlayer},
+  {"SetRenderColor", CBaseEntity_SetRenderColor},
+  {"SetRenderColorA", CBaseEntity_SetRenderColorA},
+  {"SetRenderColorB", CBaseEntity_SetRenderColorB},
+  {"SetRenderColorG", CBaseEntity_SetRenderColorG},
+  {"SetRenderColorR", CBaseEntity_SetRenderColorR},
+  {"SetSimulatedEveryTick", CBaseEntity_SetSimulatedEveryTick},
+  {"SetSimulationTime", CBaseEntity_SetSimulationTime},
+  {"SetSize", CBaseEntity_SetSize},
+  {"SetSolid", CBaseEntity_SetSolid},
+  {"SetSolidFlags", CBaseEntity_SetSolidFlags},
+  {"SetTextureFrameIndex", CBaseEntity_SetTextureFrameIndex},
+  {"SetViewOffset", CBaseEntity_SetViewOffset},
+  {"SetWaterLevel", CBaseEntity_SetWaterLevel},
+  {"SetWaterType", CBaseEntity_SetWaterType},
+  {"ShouldCollide", CBaseEntity_ShouldCollide},
+  {"ShouldSavePhysics", CBaseEntity_ShouldSavePhysics},
+  {"Spawn", CBaseEntity_Spawn},
+  {"StartGroundContact", CBaseEntity_StartGroundContact},
+  {"StartTouch", CBaseEntity_StartTouch},
+  {"StopFollowingEntity", CBaseEntity_StopFollowingEntity},
+  {"SUB_Remove", CBaseEntity_SUB_Remove},
+  {"Think", CBaseEntity_Think},
+  {"ToggleFlag", CBaseEntity_ToggleFlag},
+  {"Touch", CBaseEntity_Touch},
+  {"TraceBleed", CBaseEntity_TraceBleed},
+  {"UnsetPlayerSimulated", CBaseEntity_UnsetPlayerSimulated},
+  {"UpdateOnRemove", CBaseEntity_UpdateOnRemove},
+  {"VPhysicsDestroyObject", CBaseEntity_VPhysicsDestroyObject},
+  {"VPhysicsGetObject", CBaseEntity_VPhysicsGetObject},
+  {"VPhysicsGetObjectList", CBaseEntity_VPhysicsGetObjectList},
+  {"VPhysicsInitNormal", CBaseEntity_VPhysicsInitNormal},
+  {"VPhysicsInitStatic", CBaseEntity_VPhysicsInitStatic},
+  {"VPhysicsIsFlesh", CBaseEntity_VPhysicsIsFlesh},
+  {"VPhysicsSetObject", CBaseEntity_VPhysicsSetObject},
+  {"VPhysicsUpdate", CBaseEntity_VPhysicsUpdate},
+  {"WakeRestingObjects", CBaseEntity_WakeRestingObjects},
+  {"WorldAlignMaxs", CBaseEntity_WorldAlignMaxs},
+  {"WorldAlignMins", CBaseEntity_WorldAlignMins},
+  {"WorldAlignSize", CBaseEntity_WorldAlignSize},
+  {"WorldSpaceCenter", CBaseEntity_WorldSpaceCenter},
+  {"WorldToEntitySpace", CBaseEntity_WorldToEntitySpace},
+  {"__index", CBaseEntity___index},
+  {"__newindex", CBaseEntity___newindex},
+  {"__eq", CBaseEntity___eq},
+  {"__tostring", CBaseEntity___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_CreateEntityByName (lua_State *L) {
+  lua_pushentity(L, CreateEntityByName(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+
+static const luaL_Reg CBaseEntity_funcs[] = {
+  {"CreateEntityByName", luasrc_CreateEntityByName},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CBaseEntity object
+*/
+LUALIB_API int luaopen_CBaseEntity_shared (lua_State *L) {
+  luaL_getmetatable(L, LUA_BASEENTITYLIBNAME);
+  if (lua_isnoneornil(L, -1)) {
+    lua_pop(L, 1);
+    luaL_newmetatable(L, LUA_BASEENTITYLIBNAME);
+  }
+  luaL_register(L, NULL, CBaseEntitymeta);
+  lua_pushstring(L, "entity");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "entity" */
+  luaL_register(L, "_G", CBaseEntity_funcs);
+  lua_pop(L, 1);
+  lua_pushentity(L, NULL);
+  lua_setglobal(L, "NULL");  /* set global NULL */
+  return 1;
+}
+
diff --git a/src/game/shared/lbaseentity_shared.h b/src/game/shared/lbaseentity_shared.h
new file mode 100644
index 0000000..0dc42f5
--- /dev/null
+++ b/src/game/shared/lbaseentity_shared.h
@@ -0,0 +1,38 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LBASEENTITY_SHARED_H
+#define LBASEENTITY_SHARED_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for CBaseEntity functions */
+typedef CBaseEntity lua_CBaseEntity;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CBaseEntity     *(lua_toentity) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushentity) (lua_State *L, lua_CBaseEntity *pEntity);
+
+
+
+LUALIB_API lua_CBaseEntity *(luaL_checkentity) (lua_State *L, int narg);
+LUALIB_API lua_CBaseEntity *(luaL_optentity) (lua_State *L, int narg,
+                                                            lua_CBaseEntity *def);
+
+
+#endif // LBASEENTITY_SHARED_H
diff --git a/src/game/shared/lbaseplayer_shared.cpp b/src/game/shared/lbaseplayer_shared.cpp
new file mode 100644
index 0000000..1ba8471
--- /dev/null
+++ b/src/game/shared/lbaseplayer_shared.cpp
@@ -0,0 +1,1065 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Implements shared baseplayer class functionality
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define lbaseplayer_shared_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lbaseplayer_shared.h"
+#ifdef CLIENT_DLL
+#include "lc_baseanimating.h"
+#else
+#include "lbaseanimating.h"
+#endif
+#include "lbasecombatweapon_shared.h"
+#include "lbaseentity_shared.h"
+#include "SoundEmitterSystem/lisoundemittersystembase.h"
+#include "mathlib/lvector.h"
+#include "lvphysics_interface.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CBasePlayer *lua_toplayer (lua_State *L, int idx) {
+  CBaseHandle *phPlayer = dynamic_cast<CBaseHandle *>((CBaseHandle *)lua_touserdata(L, idx));
+  if (phPlayer == NULL)
+    return NULL;
+  return dynamic_cast<lua_CBasePlayer *>(phPlayer->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushplayer (lua_State *L, CBasePlayer *pPlayer) {
+  CBaseHandle *phPlayer = (CBaseHandle *)lua_newuserdata(L, sizeof(CBaseHandle));
+  phPlayer->Set(pPlayer);
+  luaL_getmetatable(L, "CBasePlayer");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CBasePlayer *luaL_checkplayer (lua_State *L, int narg) {
+  lua_CBasePlayer *d = lua_toplayer(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "CBasePlayer expected, got NULL entity");
+  return d;
+}
+
+
+LUALIB_API lua_CBasePlayer *luaL_optplayer (lua_State *L, int narg,
+                                                          CBasePlayer *def) {
+  return luaL_opt(L, luaL_checkplayer, narg, def);
+}
+
+
+static int CBasePlayer_AbortReload (lua_State *L) {
+  luaL_checkplayer(L, 1)->AbortReload();
+  return 0;
+}
+
+static int CBasePlayer_AddToPlayerSimulationList (lua_State *L) {
+  luaL_checkplayer(L, 1)->AddToPlayerSimulationList(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_CacheVehicleView (lua_State *L) {
+  luaL_checkplayer(L, 1)->CacheVehicleView();
+  return 0;
+}
+
+static int CBasePlayer_ClearPlayerSimulationList (lua_State *L) {
+  luaL_checkplayer(L, 1)->ClearPlayerSimulationList();
+  return 0;
+}
+
+static int CBasePlayer_ClearZoomOwner (lua_State *L) {
+  luaL_checkplayer(L, 1)->ClearZoomOwner();
+  return 0;
+}
+
+static int CBasePlayer_CurrentCommandNumber (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->CurrentCommandNumber());
+  return 1;
+}
+
+static int CBasePlayer_DoMuzzleFlash (lua_State *L) {
+  luaL_checkplayer(L, 1)->DoMuzzleFlash();
+  return 0;
+}
+
+static int CBasePlayer_ExitLadder (lua_State *L) {
+  luaL_checkplayer(L, 1)->ExitLadder();
+  return 0;
+}
+
+static int CBasePlayer_EyeAngles (lua_State *L) {
+  QAngle v = luaL_checkplayer(L, 1)->EyeAngles();
+  lua_pushangle(L, v);
+  return 1;
+}
+
+static int CBasePlayer_EyePosition (lua_State *L) {
+  Vector v = luaL_checkplayer(L, 1)->EyePosition();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBasePlayer_EyePositionAndVectors (lua_State *L) {
+  luaL_checkplayer(L, 1)->EyePositionAndVectors(&luaL_checkvector(L, 2), &luaL_checkvector(L, 3), &luaL_checkvector(L, 4), &luaL_checkvector(L, 5));
+  return 0;
+}
+
+static int CBasePlayer_EyeVectors (lua_State *L) {
+  luaL_checkplayer(L, 1)->EyeVectors(&luaL_checkvector(L, 2), &luaL_optvector(L, 3, NULL), &luaL_optvector(L, 4, NULL));
+  return 0;
+}
+
+static int CBasePlayer_FindUseEntity (lua_State *L) {
+  CBaseEntity *pUseEntity = luaL_checkplayer(L, 1)->FindUseEntity();
+  lua_pushentity(L, pUseEntity);
+  return 1;
+}
+
+static int CBasePlayer_GetActiveWeapon (lua_State *L) {
+  CBaseCombatWeapon *pWeapon = luaL_checkplayer(L, 1)->GetActiveWeapon();
+  lua_pushweapon(L, pWeapon);
+  return 1;
+}
+
+// FIXME: move to CBaseCombatCharacter
+static int CBasePlayer_GetAmmoCount (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+	default:
+      lua_pushinteger(L, luaL_checkplayer(L, 1)->GetAmmoCount(luaL_checkint(L, 2)));
+	  break;
+	case LUA_TSTRING:
+      lua_pushinteger(L, luaL_checkplayer(L, 1)->GetAmmoCount((char *)luaL_checkstring(L, 2)));
+	  break;
+  }
+  return 1;
+}
+
+static int CBasePlayer_GetAutoaimVector (lua_State *L) {
+  Vector v = luaL_checkplayer(L, 1)->GetAutoaimVector(luaL_checknumber(L, 2));
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBasePlayer_GetBonusChallenge (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetBonusChallenge());
+  return 1;
+}
+
+static int CBasePlayer_GetBonusProgress (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetBonusProgress());
+  return 1;
+}
+
+static int CBasePlayer_GetDeathTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkplayer(L, 1)->GetDeathTime());
+  return 1;
+}
+
+static int CBasePlayer_GetDefaultFOV (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetDefaultFOV());
+  return 1;
+}
+
+static int CBasePlayer_GetEFNoInterpParity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetEFNoInterpParity());
+  return 1;
+}
+
+static int CBasePlayer_GetFOV (lua_State *L) {
+  lua_pushnumber(L, luaL_checkplayer(L, 1)->GetFOV());
+  return 1;
+}
+
+static int CBasePlayer_GetFOVDistanceAdjustFactor (lua_State *L) {
+  lua_pushnumber(L, luaL_checkplayer(L, 1)->GetFOVDistanceAdjustFactor());
+  return 1;
+}
+
+static int CBasePlayer_GetFOVTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkplayer(L, 1)->GetFOVTime());
+  return 1;
+}
+
+static int CBasePlayer_GetHealth (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetHealth());
+  return 1;
+}
+
+static int CBasePlayer_GetImpulse (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetImpulse());
+  return 1;
+}
+
+static int CBasePlayer_GetLaggedMovementValue (lua_State *L) {
+  lua_pushnumber(L, luaL_checkplayer(L, 1)->GetLaggedMovementValue());
+  return 1;
+}
+
+static int CBasePlayer_GetLastKnownPlaceName (lua_State *L) {
+  lua_pushstring(L, luaL_checkplayer(L, 1)->GetLastKnownPlaceName());
+  return 1;
+}
+
+static int CBasePlayer_GetNextAttack (lua_State *L) {
+  lua_pushnumber(L, luaL_checkplayer(L, 1)->GetNextAttack());
+  return 1;
+}
+
+static int CBasePlayer_GetObserverMode (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetObserverMode());
+  return 1;
+}
+
+static int CBasePlayer_GetObserverTarget (lua_State *L) {
+  lua_pushentity(L, luaL_checkplayer(L, 1)->GetObserverTarget());
+  return 1;
+}
+
+static int CBasePlayer_GetOffset_m_Local (lua_State *L) {
+  lua_pushinteger(L, CBasePlayer::GetOffset_m_Local());
+  return 1;
+}
+
+static int CBasePlayer_GetPlayerLocalData (lua_State *L) {
+  CBasePlayer *pPlayer = luaL_checkplayer(L, 1);
+  lua_newtable(L);
+  lua_pushinteger(L, pPlayer->m_Local.m_iHideHUD);
+  lua_setfield(L, -2, "m_iHideHUD");
+
+  lua_pushnumber(L, pPlayer->m_Local.m_flFOVRate);
+  lua_setfield(L, -2, "m_flFOVRate");
+
+  lua_pushboolean(L, pPlayer->m_Local.m_bDucked);
+  lua_setfield(L, -2, "m_bDucked");
+  lua_pushboolean(L, pPlayer->m_Local.m_bDucking);
+  lua_setfield(L, -2, "m_bDucking");
+  lua_pushboolean(L, pPlayer->m_Local.m_bInDuckJump);
+  lua_setfield(L, -2, "m_bInDuckJump");
+  lua_pushnumber(L, pPlayer->m_Local.m_flDucktime);
+  lua_setfield(L, -2, "m_flDucktime");
+  lua_pushnumber(L, pPlayer->m_Local.m_flDuckJumpTime);
+  lua_setfield(L, -2, "m_flDuckJumpTime");
+  lua_pushnumber(L, pPlayer->m_Local.m_flJumpTime);
+  lua_setfield(L, -2, "m_flJumpTime");
+  lua_pushinteger(L, pPlayer->m_Local.m_nStepside);
+  lua_setfield(L, -2, "m_nStepside");
+  lua_pushnumber(L, pPlayer->m_Local.m_flFallVelocity);
+  lua_setfield(L, -2, "m_flFallVelocity");
+  lua_pushinteger(L, pPlayer->m_Local.m_nOldButtons);
+  lua_setfield(L, -2, "m_nOldButtons");
+
+#ifdef CLIENT_DLL
+  lua_pushvector(L, pPlayer->m_Local.m_vecClientBaseVelocity);
+  lua_setfield(L, -2, "m_vecClientBaseVelocity");
+#endif
+  QAngle v = pPlayer->m_Local.m_vecPunchAngle;
+  lua_pushangle(L, v);
+  lua_setfield(L, -2, "m_vecPunchAngle");
+
+  v = pPlayer->m_Local.m_vecPunchAngleVel;
+  lua_pushangle(L, v);
+  lua_setfield(L, -2, "m_vecPunchAngleVel");
+  lua_pushboolean(L, pPlayer->m_Local.m_bDrawViewmodel);
+  lua_setfield(L, -2, "m_bDrawViewmodel");
+  lua_pushboolean(L, pPlayer->m_Local.m_bWearingSuit);
+  lua_setfield(L, -2, "m_bWearingSuit");
+  lua_pushboolean(L, pPlayer->m_Local.m_bPoisoned);
+  lua_setfield(L, -2, "m_bPoisoned");
+  lua_pushnumber(L, pPlayer->m_Local.m_flStepSize);
+  lua_setfield(L, -2, "m_flStepSize");
+  lua_pushboolean(L, pPlayer->m_Local.m_bAllowAutoMovement);
+  lua_setfield(L, -2, "m_bAllowAutoMovement");
+
+  lua_pushboolean(L, pPlayer->m_Local.m_bSlowMovement);
+  lua_setfield(L, -2, "m_bSlowMovement");
+  return 1;
+}
+
+static int CBasePlayer_GetPlayerMaxs (lua_State *L) {
+  Vector v = luaL_checkplayer(L, 1)->GetPlayerMaxs();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBasePlayer_GetPlayerMins (lua_State *L) {
+  Vector v = luaL_checkplayer(L, 1)->GetPlayerMins();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBasePlayer_GetPlayerName (lua_State *L) {
+  lua_pushstring(L, luaL_checkplayer(L, 1)->GetPlayerName());
+  return 1;
+}
+
+static int CBasePlayer_GetPreviouslyPredictedOrigin (lua_State *L) {
+  Vector v = luaL_checkplayer(L, 1)->GetPreviouslyPredictedOrigin();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBasePlayer_GetPunchAngle (lua_State *L) {
+  QAngle v = luaL_checkplayer(L, 1)->GetPunchAngle();
+  lua_pushangle(L, v);
+  return 1;
+}
+
+static int CBasePlayer_GetStepSoundCache (lua_State *L) {
+  CBasePlayer *pPlayer = luaL_checkplayer(L, 1);
+  lua_newtable(L);
+  lua_pushinteger(L, 0);
+  lua_newtable(L);
+  lua_pushsoundparameters(L, pPlayer->m_StepSoundCache[ 0 ].m_SoundParameters);
+  lua_setfield(L, -2, "m_SoundParameters");
+  lua_pushinteger(L, pPlayer->m_StepSoundCache[ 0 ].m_usSoundNameIndex);
+  lua_setfield(L, -2, "m_usSoundNameIndex");
+  lua_settable(L, -3);
+  lua_pushinteger(L, 1);
+  lua_newtable(L);
+  lua_pushsoundparameters(L, pPlayer->m_StepSoundCache[ 1 ].m_SoundParameters);
+  lua_setfield(L, -2, "m_SoundParameters");
+  lua_pushinteger(L, pPlayer->m_StepSoundCache[ 1 ].m_usSoundNameIndex);
+  lua_setfield(L, -2, "m_usSoundNameIndex");
+  lua_settable(L, -3);
+  return 1;
+}
+
+static int CBasePlayer_GetStepSoundVelocities (lua_State *L) {
+  float velwalk, velrun;
+  luaL_checkplayer(L, 1)->GetStepSoundVelocities(&velwalk, &velrun);
+  lua_pushnumber(L, velwalk);
+  lua_pushnumber(L, velrun);
+  return 2;
+}
+
+static int CBasePlayer_GetSwimSoundTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkplayer(L, 1)->GetSwimSoundTime());
+  return 1;
+}
+
+static int CBasePlayer_GetTimeBase (lua_State *L) {
+  lua_pushnumber(L, luaL_checkplayer(L, 1)->GetTimeBase());
+  return 1;
+}
+
+static int CBasePlayer_GetTracerType (lua_State *L) {
+  lua_pushstring(L, luaL_checkplayer(L, 1)->GetTracerType());
+  return 1;
+}
+
+static int CBasePlayer_GetUseEntity (lua_State *L) {
+  lua_pushentity(L, luaL_checkplayer(L, 1)->GetUseEntity());
+  return 1;
+}
+
+static int CBasePlayer_GetUserID (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->GetUserID());
+  return 1;
+}
+
+// FIXME: push CBaseViewModel instead
+static int CBasePlayer_GetViewModel (lua_State *L) {
+  lua_pushanimating(L, luaL_checkplayer(L, 1)->GetViewModel(luaL_optint(L, 2, 0)));
+  return 1;
+}
+
+static int CBasePlayer_GetWaterJumpTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checkplayer(L, 1)->GetWaterJumpTime());
+  return 1;
+}
+
+static int CBasePlayer_GetWeapon (lua_State *L) {
+  lua_pushweapon(L, luaL_checkplayer(L, 1)->GetWeapon(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_HintMessage (lua_State *L) {
+  luaL_checkplayer(L, 1)->HintMessage(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_IncrementEFNoInterpParity (lua_State *L) {
+  luaL_checkplayer(L, 1)->IncrementEFNoInterpParity();
+  return 0;
+}
+
+static int CBasePlayer_IsBot (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsBot());
+  return 1;
+}
+
+static int CBasePlayer_IsHLTV (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsHLTV());
+  return 1;
+}
+
+static int CBasePlayer_IsInAVehicle (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsInAVehicle());
+  return 1;
+}
+
+static int CBasePlayer_IsObserver (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsObserver());
+  return 1;
+}
+
+static int CBasePlayer_IsPlayer (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsPlayer());
+  return 1;
+}
+
+static int CBasePlayer_IsPlayerUnderwater (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsPlayerUnderwater());
+  return 1;
+}
+
+static int CBasePlayer_IsSuitEquipped (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsSuitEquipped());
+  return 1;
+}
+
+static int CBasePlayer_IsUseableEntity (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->IsUseableEntity(luaL_checkentity(L, 2), luaL_checkint(L, 3)));
+  return 1;
+}
+
+static int CBasePlayer_ItemPostFrame (lua_State *L) {
+  luaL_checkplayer(L, 1)->ItemPostFrame();
+  return 0;
+}
+
+static int CBasePlayer_ItemPreFrame (lua_State *L) {
+  luaL_checkplayer(L, 1)->ItemPreFrame();
+  return 0;
+}
+
+static int CBasePlayer_LeaveVehicle (lua_State *L) {
+  luaL_checkplayer(L, 1)->LeaveVehicle();
+  return 0;
+}
+
+static int CBasePlayer_LocalEyeAngles (lua_State *L) {
+  QAngle v = luaL_checkplayer(L, 1)->LocalEyeAngles();
+  lua_pushangle(L, v);
+  return 1;
+}
+
+static int CBasePlayer_MaxSpeed (lua_State *L) {
+  lua_pushnumber(L, luaL_checkplayer(L, 1)->MaxSpeed());
+  return 1;
+}
+
+static int CBasePlayer_MyCombatCharacterPointer (lua_State *L) {
+  lua_pushplayer(L, (CBasePlayer *)luaL_checkplayer(L, 1)->MyCombatCharacterPointer());
+  return 1;
+}
+
+static int CBasePlayer_OnRestore (lua_State *L) {
+  luaL_checkplayer(L, 1)->OnRestore();
+  return 0;
+}
+
+static int CBasePlayer_PhysicsSimulate (lua_State *L) {
+  luaL_checkplayer(L, 1)->PhysicsSimulate();
+  return 0;
+}
+
+static int CBasePlayer_PhysicsSolidMaskForEntity (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->PhysicsSolidMaskForEntity());
+  return 1;
+}
+
+static int CBasePlayer_PlayerUse (lua_State *L) {
+  luaL_checkplayer(L, 1)->PlayerUse();
+  return 0;
+}
+
+static int CBasePlayer_PlayStepSound (lua_State *L) {
+  luaL_checkplayer(L, 1)->PlayStepSound(luaL_checkvector(L, 2), &lua_tosurfacedata(L, 3), luaL_checknumber(L, 4), luaL_checkboolean(L, 5));
+  return 0;
+}
+
+static int CBasePlayer_PostThink (lua_State *L) {
+  luaL_checkplayer(L, 1)->PostThink();
+  return 0;
+}
+
+static int CBasePlayer_PreThink (lua_State *L) {
+  luaL_checkplayer(L, 1)->PreThink();
+  return 0;
+}
+
+static int CBasePlayer_RemoveAllAmmo (lua_State *L) {
+  luaL_checkplayer(L, 1)->RemoveAllAmmo();
+  return 0;
+}
+
+static int CBasePlayer_RemoveAmmo (lua_State *L) {
+  switch(lua_type(L, 3)) {
+	case LUA_TNUMBER:
+	default:
+	  luaL_checkplayer(L, 1)->RemoveAmmo(luaL_checkint(L, 2), luaL_checkint(L, 3));
+	  break;
+	case LUA_TSTRING:
+      luaL_checkplayer(L, 1)->RemoveAmmo(luaL_checkint(L, 2), luaL_checkstring(L, 3));
+	  break;
+  }
+  return 0;
+}
+
+static int CBasePlayer_RemoveFromPlayerSimulationList (lua_State *L) {
+  luaL_checkplayer(L, 1)->RemoveFromPlayerSimulationList(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_ResetAutoaim (lua_State *L) {
+  luaL_checkplayer(L, 1)->ResetAutoaim();
+  return 0;
+}
+
+static int CBasePlayer_ResetObserverMode (lua_State *L) {
+  luaL_checkplayer(L, 1)->ResetObserverMode();
+  return 0;
+}
+
+static int CBasePlayer_SelectItem (lua_State *L) {
+  luaL_checkplayer(L, 1)->SelectItem(luaL_checkstring(L, 2), luaL_optint(L, 3, 0));
+  return 0;
+}
+
+static int CBasePlayer_SelectLastItem (lua_State *L) {
+  luaL_checkplayer(L, 1)->SelectLastItem();
+  return 0;
+}
+
+static int CBasePlayer_SetAmmoCount (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetAmmoCount(luaL_checkint(L, 2), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int CBasePlayer_SetAnimation (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetAnimation((PLAYER_ANIM)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SetAnimationExtension (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetAnimationExtension(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SetBloodColor (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetBloodColor(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SetFOV (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->SetFOV(luaL_checkentity(L, 2), luaL_checkint(L, 3), luaL_checknumber(L, 4), luaL_optint(L, 5, 0)));
+  return 1;
+}
+
+static int CBasePlayer_SetLadderNormal (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetLadderNormal(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SetMaxSpeed (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetMaxSpeed(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SetNextAttack (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetNextAttack(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SetPlayerLocalData (lua_State *L) {
+  CBasePlayer *pPlayer = luaL_checkplayer(L, 1);
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "m_iHideHUD") == 0)
+    pPlayer->m_Local.m_iHideHUD = luaL_checkint(L, 3);
+
+  else if (Q_strcmp(field, "m_flFOVRate") == 0)
+    pPlayer->m_Local.m_flFOVRate = luaL_checknumber(L, 3);
+
+  else if (Q_strcmp(field, "m_bDucked") == 0)
+    pPlayer->m_Local.m_bDucked = (bool)luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_bDucking") == 0)
+    pPlayer->m_Local.m_bDucking = (bool)luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_bInDuckJump") == 0)
+    pPlayer->m_Local.m_bInDuckJump = (bool)luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_flDucktime") == 0)
+    pPlayer->m_Local.m_flDucktime = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_flDuckJumpTime") == 0)
+    pPlayer->m_Local.m_flDuckJumpTime = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_flJumpTime") == 0)
+    pPlayer->m_Local.m_flJumpTime = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_nStepside") == 0)
+    pPlayer->m_Local.m_nStepside = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_flFallVelocity") == 0)
+    pPlayer->m_Local.m_flFallVelocity = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_nOldButtons") == 0)
+    pPlayer->m_Local.m_nOldButtons = luaL_checkint(L, 3);
+
+#ifdef CLIENT_DLL
+  else if (Q_strcmp(field, "m_vecClientBaseVelocity") == 0)
+    pPlayer->m_Local.m_vecClientBaseVelocity = luaL_checkvector(L, 3);
+#endif
+  else if (Q_strcmp(field, "m_vecPunchAngle") == 0)
+    pPlayer->m_Local.m_vecPunchAngle = luaL_checkangle(L, 3);
+
+  else if (Q_strcmp(field, "m_vecPunchAngleVel") == 0)
+    pPlayer->m_Local.m_vecPunchAngleVel = luaL_checkangle(L, 3);
+  else if (Q_strcmp(field, "m_bDrawViewmodel") == 0)
+    pPlayer->m_Local.m_bDrawViewmodel = (bool)luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_bWearingSuit") == 0)
+    pPlayer->m_Local.m_bWearingSuit = (bool)luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_bPoisoned") == 0)
+    pPlayer->m_Local.m_bPoisoned = (bool)luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "m_flStepSize") == 0)
+    pPlayer->m_Local.m_flStepSize = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_bAllowAutoMovement") == 0)
+    pPlayer->m_Local.m_bAllowAutoMovement = (bool)luaL_checkboolean(L, 3);
+
+  else if (Q_strcmp(field, "m_bSlowMovement") == 0)
+    pPlayer->m_Local.m_bSlowMovement = (bool)luaL_checkboolean(L, 3);
+  return 0;
+}
+
+static int CBasePlayer_SetPlayerUnderwater (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetPlayerUnderwater(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SetPreviouslyPredictedOrigin (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetPreviouslyPredictedOrigin(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SetPunchAngle (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetPunchAngle(luaL_checkangle(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SetStepSoundCache (lua_State *L) {
+  CBasePlayer *pPlayer = luaL_checkplayer(L, 1);
+  int index = luaL_checkint(L, 2);
+  const char *field = luaL_checkstring(L, 3);
+  if (index == 0) {
+    if (Q_strcmp(field, "m_SoundParameters") == 0)
+      pPlayer->m_StepSoundCache[ 0 ].m_SoundParameters = lua_tosoundparameters(L, 4);
+    else if (Q_strcmp(field, "m_usSoundNameIndex") == 0)
+	  pPlayer->m_StepSoundCache[ 0 ].m_usSoundNameIndex = (unsigned short)luaL_checkinteger(L, 4);
+  } else if (index == 1) {
+    if (Q_strcmp(field, "m_SoundParameters") == 0)
+      pPlayer->m_StepSoundCache[ 1 ].m_SoundParameters = lua_tosoundparameters(L, 4);
+    else if (Q_strcmp(field, "m_usSoundNameIndex") == 0)
+	  pPlayer->m_StepSoundCache[ 1 ].m_usSoundNameIndex = (unsigned short)luaL_checkinteger(L, 4);
+  }
+  return 1;
+}
+
+static int CBasePlayer_SetSuitUpdate (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetSuitUpdate((char *)luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int CBasePlayer_SetSwimSoundTime (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetSwimSoundTime(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SetWaterJumpTime (lua_State *L) {
+  luaL_checkplayer(L, 1)->SetWaterJumpTime(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_SharedSpawn (lua_State *L) {
+  luaL_checkplayer(L, 1)->SharedSpawn();
+  return 0;
+}
+
+static int CBasePlayer_ShouldShowHints (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->ShouldShowHints());
+  return 1;
+}
+
+static int CBasePlayer_SimulatePlayerSimulatedEntities (lua_State *L) {
+  luaL_checkplayer(L, 1)->SimulatePlayerSimulatedEntities();
+  return 0;
+}
+
+static int CBasePlayer_SmoothViewOnStairs (lua_State *L) {
+  luaL_checkplayer(L, 1)->SmoothViewOnStairs(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_Spawn (lua_State *L) {
+  luaL_checkplayer(L, 1)->Spawn();
+  return 0;
+}
+
+static int CBasePlayer_SwitchToNextBestWeapon (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->SwitchToNextBestWeapon(luaL_checkweapon(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_UpdateClientData (lua_State *L) {
+  luaL_checkplayer(L, 1)->UpdateClientData();
+  return 0;
+}
+
+static int CBasePlayer_UpdateUnderwaterState (lua_State *L) {
+  luaL_checkplayer(L, 1)->UpdateUnderwaterState();
+  return 0;
+}
+
+static int CBasePlayer_UsingStandardWeaponsInVehicle (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->UsingStandardWeaponsInVehicle());
+  return 1;
+}
+
+static int CBasePlayer_ViewPunch (lua_State *L) {
+  luaL_checkplayer(L, 1)->ViewPunch(luaL_checkangle(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_ViewPunchReset (lua_State *L) {
+  luaL_checkplayer(L, 1)->ViewPunchReset(luaL_optnumber(L, 2, 0));
+  return 0;
+}
+
+static int CBasePlayer_Weapon_CanSwitchTo (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->Weapon_CanSwitchTo(luaL_checkweapon(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_Weapon_OwnsThisType (lua_State *L) {
+  lua_pushweapon(L, luaL_checkplayer(L, 1)->Weapon_OwnsThisType(luaL_checkstring(L, 2), luaL_optint(L, 3, 0)));
+  return 1;
+}
+
+static int CBasePlayer_Weapon_SetLast (lua_State *L) {
+  luaL_checkplayer(L, 1)->Weapon_SetLast(luaL_checkweapon(L, 2));
+  return 0;
+}
+
+static int CBasePlayer_Weapon_ShootPosition (lua_State *L) {
+  Vector v = luaL_checkplayer(L, 1)->Weapon_ShootPosition();
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int CBasePlayer_Weapon_ShouldSelectItem (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->Weapon_ShouldSelectItem(luaL_checkweapon(L, 2)));
+  return 1;
+}
+
+static int CBasePlayer_Weapon_ShouldSetLast (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->Weapon_ShouldSetLast(luaL_checkweapon(L, 2), luaL_checkweapon(L, 3)));
+  return 1;
+}
+
+static int CBasePlayer_Weapon_Switch (lua_State *L) {
+  lua_pushboolean(L, luaL_checkplayer(L, 1)->Weapon_Switch(luaL_checkweapon(L, 2), luaL_optint(L, 3, 0)));
+  return 1;
+}
+
+static int CBasePlayer_WeaponCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkplayer(L, 1)->WeaponCount());
+  return 1;
+}
+
+static int CBasePlayer___index (lua_State *L) {
+  CBasePlayer *pPlayer = lua_toplayer(L, 1);
+  if (pPlayer == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "m_afButtonLast") == 0)
+    lua_pushinteger(L, pPlayer->m_afButtonLast);
+  else if (Q_strcmp(field, "m_afButtonPressed") == 0)
+    lua_pushinteger(L, pPlayer->m_afButtonPressed);
+  else if (Q_strcmp(field, "m_afButtonReleased") == 0)
+    lua_pushinteger(L, pPlayer->m_afButtonReleased);
+  else if (Q_strcmp(field, "m_flNextAttack") == 0)
+    lua_pushnumber(L, pPlayer->m_flNextAttack);
+  else if (Q_strcmp(field, "m_fOnTarget") == 0)
+    lua_pushboolean(L, pPlayer->m_fOnTarget);
+  else if (Q_strcmp(field, "m_nButtons") == 0)
+    lua_pushinteger(L, pPlayer->m_nButtons);
+  else if (Q_strcmp(field, "m_StuckLast") == 0)
+    lua_pushinteger(L, pPlayer->m_StuckLast);
+  else if (Q_strcmp(field, "m_szAnimExtension") == 0)
+    lua_pushstring(L, pPlayer->m_szAnimExtension);
+  else if (pPlayer->m_nTableReference != LUA_NOREF) {
+    lua_getref(L, pPlayer->m_nTableReference);
+    lua_getfield(L, -1, field);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      lua_getmetatable(L, 1);
+      lua_getfield(L, -1, field);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "CBaseAnimating");
+        lua_getfield(L, -1, field);
+        if (lua_isnil(L, -1)) {
+          lua_pop(L, 2);
+          luaL_getmetatable(L, "CBaseEntity");
+          lua_getfield(L, -1, field);
+        }
+      }
+    }
+  }
+  else {
+    lua_getmetatable(L, 1);
+    lua_getfield(L, -1, field);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      luaL_getmetatable(L, "CBaseAnimating");
+      lua_getfield(L, -1, field);
+      if (lua_isnil(L, -1)) {
+        lua_pop(L, 2);
+        luaL_getmetatable(L, "CBaseEntity");
+        lua_getfield(L, -1, field);
+      }
+    }
+  }
+  return 1;
+}
+
+static int CBasePlayer___newindex (lua_State *L) {
+  CBasePlayer *pPlayer = lua_toplayer(L, 1);
+  if (pPlayer == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index a NULL entity", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "m_afButtonLast") == 0)
+    pPlayer->m_afButtonLast = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_afButtonPressed") == 0)
+    pPlayer->m_afButtonPressed = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_afButtonReleased") == 0)
+    pPlayer->m_afButtonReleased = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_flNextAttack") == 0)
+    pPlayer->m_flNextAttack = luaL_checknumber(L, 3);
+#ifdef CLIENT_DLL
+  else if (Q_strcmp(field, "m_fOnTarget") == 0)
+    pPlayer->m_fOnTarget = luaL_checkboolean(L, 3);
+#else
+  else if (Q_strcmp(field, "m_fOnTarget") == 0)
+    pPlayer->m_fOnTarget.GetForModify() = (bool)luaL_checkboolean(L, 3);
+#endif
+  else if (Q_strcmp(field, "m_nButtons") == 0)
+    pPlayer->m_nButtons = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_StuckLast") == 0)
+    pPlayer->m_StuckLast = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_szAnimExtension") == 0)
+    Q_strcpy(pPlayer->m_szAnimExtension, luaL_checkstring(L, 3));
+  else {
+    if (pPlayer->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      pPlayer->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, pPlayer->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, field);
+	lua_pop(L, 1);
+  }
+  return 0;
+}
+
+static int CBasePlayer___eq (lua_State *L) {
+  lua_pushboolean(L, lua_toplayer(L, 1) == lua_toplayer(L, 2));
+  return 1;
+}
+
+static int CBasePlayer___tostring (lua_State *L) {
+  CBasePlayer *pPlayer = lua_toplayer(L, 1);
+  if (pPlayer == NULL)
+    lua_pushstring(L, "NULL");
+  else
+    lua_pushfstring(L, "CBasePlayer: %d \"%s\"", pPlayer->GetUserID(), pPlayer->GetPlayerName());
+  return 1;
+}
+
+
+static const luaL_Reg CBasePlayermeta[] = {
+  {"AbortReload", CBasePlayer_AbortReload},
+  {"AddToPlayerSimulationList", CBasePlayer_AddToPlayerSimulationList},
+  {"ClearZoomOwner", CBasePlayer_ClearZoomOwner},
+  {"CurrentCommandNumber", CBasePlayer_CurrentCommandNumber},
+  {"DoMuzzleFlash", CBasePlayer_DoMuzzleFlash},
+  {"ExitLadder", CBasePlayer_ExitLadder},
+  {"EyeAngles", CBasePlayer_EyeAngles},
+  {"EyePosition", CBasePlayer_EyePosition},
+  {"EyePositionAndVectors", CBasePlayer_EyePositionAndVectors},
+  {"EyeVectors", CBasePlayer_EyeVectors},
+  {"FindUseEntity", CBasePlayer_FindUseEntity},
+  {"GetActiveWeapon", CBasePlayer_GetActiveWeapon},
+  {"GetAmmoCount", CBasePlayer_GetAmmoCount},
+  {"GetAutoaimVector", CBasePlayer_GetAutoaimVector},
+  {"GetBonusChallenge", CBasePlayer_GetBonusChallenge},
+  {"GetBonusProgress", CBasePlayer_GetBonusProgress},
+  {"GetDeathTime", CBasePlayer_GetDeathTime},
+  {"GetDefaultFOV", CBasePlayer_GetDefaultFOV},
+  {"GetEFNoInterpParity", CBasePlayer_GetEFNoInterpParity},
+  {"GetFOV", CBasePlayer_GetFOV},
+  {"GetFOVDistanceAdjustFactor", CBasePlayer_GetFOVDistanceAdjustFactor},
+  {"GetFOVTime", CBasePlayer_GetFOVTime},
+  {"GetHealth", CBasePlayer_GetHealth},
+  {"GetImpulse", CBasePlayer_GetImpulse},
+  {"GetLaggedMovementValue", CBasePlayer_GetLaggedMovementValue},
+  {"GetLastKnownPlaceName", CBasePlayer_GetLastKnownPlaceName},
+  {"GetNextAttack", CBasePlayer_GetNextAttack},
+  {"GetObserverMode", CBasePlayer_GetObserverMode},
+  {"GetObserverTarget", CBasePlayer_GetObserverTarget},
+  {"GetOffset_m_Local", CBasePlayer_GetOffset_m_Local},
+  {"GetPlayerLocalData", CBasePlayer_GetPlayerLocalData},
+  {"GetPlayerMaxs", CBasePlayer_GetPlayerMaxs},
+  {"GetPlayerMins", CBasePlayer_GetPlayerMins},
+  {"GetPlayerName", CBasePlayer_GetPlayerName},
+  {"GetPreviouslyPredictedOrigin", CBasePlayer_GetPreviouslyPredictedOrigin},
+  {"GetPunchAngle", CBasePlayer_GetPunchAngle},
+  {"GetStepSoundCache", CBasePlayer_GetStepSoundCache},
+  {"GetStepSoundVelocities", CBasePlayer_GetStepSoundVelocities},
+  {"GetSwimSoundTime", CBasePlayer_GetSwimSoundTime},
+  {"GetTimeBase", CBasePlayer_GetTimeBase},
+  {"GetTracerType", CBasePlayer_GetTracerType},
+  {"GetUseEntity", CBasePlayer_GetUseEntity},
+  {"GetUserID", CBasePlayer_GetUserID},
+  {"GetViewModel", CBasePlayer_GetViewModel},
+  {"GetWaterJumpTime", CBasePlayer_GetWaterJumpTime},
+  {"GetWeapon", CBasePlayer_GetWeapon},
+  {"HintMessage", CBasePlayer_HintMessage},
+  {"IncrementEFNoInterpParity", CBasePlayer_IncrementEFNoInterpParity},
+  {"IsBot", CBasePlayer_IsBot},
+  {"IsHLTV", CBasePlayer_IsHLTV},
+  {"IsInAVehicle", CBasePlayer_IsInAVehicle},
+  {"IsObserver", CBasePlayer_IsObserver},
+  {"IsPlayer", CBasePlayer_IsPlayer},
+  {"IsPlayerUnderwater", CBasePlayer_IsPlayerUnderwater},
+  {"IsSuitEquipped", CBasePlayer_IsSuitEquipped},
+  {"IsUseableEntity", CBasePlayer_IsUseableEntity},
+  {"ItemPostFrame", CBasePlayer_ItemPostFrame},
+  {"ItemPreFrame", CBasePlayer_ItemPreFrame},
+  {"LeaveVehicle", CBasePlayer_LeaveVehicle},
+  {"LocalEyeAngles", CBasePlayer_LocalEyeAngles},
+  {"MaxSpeed", CBasePlayer_MaxSpeed},
+  {"MyCombatCharacterPointer", CBasePlayer_MyCombatCharacterPointer},
+  {"OnRestore", CBasePlayer_OnRestore},
+  {"PhysicsSimulate", CBasePlayer_PhysicsSimulate},
+  {"PhysicsSolidMaskForEntity", CBasePlayer_PhysicsSolidMaskForEntity},
+  {"PlayerUse", CBasePlayer_PlayerUse},
+  {"PlayStepSound", CBasePlayer_PlayStepSound},
+  {"PostThink", CBasePlayer_PostThink},
+  {"PreThink", CBasePlayer_PreThink},
+  {"RemoveAllAmmo", CBasePlayer_RemoveAllAmmo},
+  {"RemoveAmmo", CBasePlayer_RemoveAmmo},
+  {"RemoveFromPlayerSimulationList", CBasePlayer_RemoveFromPlayerSimulationList},
+  {"ResetAutoaim", CBasePlayer_ResetAutoaim},
+  {"ResetObserverMode", CBasePlayer_ResetObserverMode},
+  {"SelectItem", CBasePlayer_SelectItem},
+  {"SelectLastItem", CBasePlayer_SelectLastItem},
+  {"SetAmmoCount", CBasePlayer_SetAmmoCount},
+  {"SetAnimation", CBasePlayer_SetAnimation},
+  {"SetAnimationExtension", CBasePlayer_SetAnimationExtension},
+  {"SetBloodColor", CBasePlayer_SetBloodColor},
+  {"SetFOV", CBasePlayer_SetFOV},
+  {"SetLadderNormal", CBasePlayer_SetLadderNormal},
+  {"SetMaxSpeed", CBasePlayer_SetMaxSpeed},
+  {"SetNextAttack", CBasePlayer_SetNextAttack},
+  {"SetPlayerLocalData", CBasePlayer_SetPlayerLocalData},
+  {"SetPlayerUnderwater", CBasePlayer_SetPlayerUnderwater},
+  {"SetPreviouslyPredictedOrigin", CBasePlayer_SetPreviouslyPredictedOrigin},
+  {"SetPunchAngle", CBasePlayer_SetPunchAngle},
+  {"SetStepSoundCache", CBasePlayer_SetStepSoundCache},
+  {"SetSuitUpdate", CBasePlayer_SetSuitUpdate},
+  {"SetSwimSoundTime", CBasePlayer_SetSwimSoundTime},
+  {"SetWaterJumpTime", CBasePlayer_SetWaterJumpTime},
+  {"SharedSpawn", CBasePlayer_SharedSpawn},
+  {"ShouldShowHints", CBasePlayer_ShouldShowHints},
+  {"SimulatePlayerSimulatedEntities", CBasePlayer_SimulatePlayerSimulatedEntities},
+  {"SmoothViewOnStairs", CBasePlayer_SmoothViewOnStairs},
+  {"Spawn", CBasePlayer_Spawn},
+  {"SwitchToNextBestWeapon", CBasePlayer_SwitchToNextBestWeapon},
+  {"UpdateClientData", CBasePlayer_UpdateClientData},
+  {"UpdateUnderwaterState", CBasePlayer_UpdateUnderwaterState},
+  {"UsingStandardWeaponsInVehicle", CBasePlayer_UsingStandardWeaponsInVehicle},
+  {"ViewPunch", CBasePlayer_ViewPunch},
+  {"ViewPunchReset", CBasePlayer_ViewPunchReset},
+  {"Weapon_CanSwitchTo", CBasePlayer_Weapon_CanSwitchTo},
+  {"Weapon_OwnsThisType", CBasePlayer_Weapon_OwnsThisType},
+  {"Weapon_SetLast", CBasePlayer_Weapon_SetLast},
+  {"Weapon_ShootPosition", CBasePlayer_Weapon_ShootPosition},
+  {"Weapon_ShouldSelectItem", CBasePlayer_Weapon_ShouldSelectItem},
+  {"Weapon_ShouldSetLast", CBasePlayer_Weapon_ShouldSetLast},
+  {"Weapon_Switch", CBasePlayer_Weapon_Switch},
+  {"WeaponCount", CBasePlayer_WeaponCount},
+  {"__index", CBasePlayer___index},
+  {"__newindex", CBasePlayer___newindex},
+  {"__eq", CBasePlayer___eq},
+  {"__tostring", CBasePlayer___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_ToBasePlayer (lua_State *L) {
+  lua_pushplayer(L, ToBasePlayer(luaL_checkentity(L, 1)));
+  return 1;
+}
+
+
+static const luaL_Reg CBasePlayer_funcs[] = {
+  {"ToBasePlayer", luasrc_ToBasePlayer},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CBasePlayer object
+*/
+LUALIB_API int luaopen_CBasePlayer_shared (lua_State *L) {
+  luaL_getmetatable(L, LUA_BASEPLAYERLIBNAME);
+  if (lua_isnoneornil(L, -1)) {
+    lua_pop(L, 1);
+    luaL_newmetatable(L, LUA_BASEPLAYERLIBNAME);
+  }
+  luaL_register(L, NULL, CBasePlayermeta);
+  lua_pushstring(L, "entity");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "entity" */
+  luaL_register(L, "_G", CBasePlayer_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
diff --git a/src/game/shared/lbaseplayer_shared.h b/src/game/shared/lbaseplayer_shared.h
new file mode 100644
index 0000000..4d24e5a
--- /dev/null
+++ b/src/game/shared/lbaseplayer_shared.h
@@ -0,0 +1,38 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LBASEPLAYER_SHARED_H
+#define LBASEPLAYER_SHARED_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for CBasePlayer functions */
+typedef CBasePlayer lua_CBasePlayer;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CBasePlayer     *(lua_toplayer) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushplayer) (lua_State *L, lua_CBasePlayer *pPlayer);
+
+
+
+LUALIB_API lua_CBasePlayer *(luaL_checkplayer) (lua_State *L, int narg);
+LUALIB_API lua_CBasePlayer *(luaL_optplayer) (lua_State *L, int narg,
+                                                            lua_CBasePlayer *def);
+
+
+#endif // LBASEPLAYER_SHARED_H
diff --git a/src/game/shared/leffect_dispatch_data.cpp b/src/game/shared/leffect_dispatch_data.cpp
new file mode 100644
index 0000000..f578314
--- /dev/null
+++ b/src/game/shared/leffect_dispatch_data.cpp
@@ -0,0 +1,211 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define leffect_dispatch_data_cpp
+
+#include "cbase.h"
+#if CLIENT_DLL
+#include "c_te_effect_dispatch.h"
+#else
+#include "te_effect_dispatch.h"
+#endif
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "leffect_dispatch_data.h"
+#include "lbaseentity_shared.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CEffectData &lua_toeffect (lua_State *L, int idx) {
+  lua_CEffectData *data = (lua_CEffectData *)lua_touserdata(L, idx);
+  return *data;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pusheffect (lua_State *L, lua_CEffectData &data) {
+  lua_CEffectData *pData = (lua_CEffectData *)lua_newuserdata(L, sizeof(lua_CEffectData));
+  *pData = data;
+  luaL_getmetatable(L, "CEffectData");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CEffectData &luaL_checkeffect (lua_State *L, int narg) {
+  lua_CEffectData *d = (lua_CEffectData *)luaL_checkudata(L, narg, "CEffectData");
+  return *d;
+}
+
+
+#ifdef CLIENT_DLL
+  static int CEffectData_entindex (lua_State *L) {
+    lua_pushinteger(L, luaL_checkeffect(L, 1).entindex());
+    return 1;
+  }
+#endif
+
+static int CEffectData_GetEffectNameIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkeffect(L, 1).GetEffectNameIndex());
+  return 1;
+}
+
+#ifdef CLIENT_DLL
+  static int CEffectData_GetEntity (lua_State *L) {
+    lua_pushentity(L, luaL_checkeffect(L, 1).GetEntity());
+    return 1;
+  }
+#endif
+
+static int CEffectData___index (lua_State *L) {
+  CEffectData data = luaL_checkeffect(L, 1);
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "m_fFlags") == 0)
+    lua_pushinteger(L, data.m_fFlags);
+  else if (Q_strcmp(field, "m_flMagnitude") == 0)
+    lua_pushnumber(L, data.m_flMagnitude);
+  else if (Q_strcmp(field, "m_flRadius") == 0)
+    lua_pushnumber(L, data.m_flRadius);
+  else if (Q_strcmp(field, "m_flScale") == 0)
+    lua_pushnumber(L, data.m_flScale);
+#ifdef CLIENT_DLL
+  else if (Q_strcmp(field, "m_hEntity") == 0)
+    lua_pushentity(L, C_BaseEntity::Instance( data.m_hEntity ));
+#else
+  else if (Q_strcmp(field, "m_nEntIndex") == 0)
+    lua_pushinteger(L, data.m_nEntIndex);
+#endif
+  else if (Q_strcmp(field, "m_nAttachmentIndex") == 0)
+    lua_pushinteger(L, data.m_nAttachmentIndex);
+  else if (Q_strcmp(field, "m_nDamageType") == 0)
+    lua_pushinteger(L, data.m_nDamageType);
+  else if (Q_strcmp(field, "m_nHitBox") == 0)
+    lua_pushinteger(L, data.m_nHitBox);
+  else if (Q_strcmp(field, "m_nMaterial") == 0)
+    lua_pushinteger(L, data.m_nMaterial);
+  else if (Q_strcmp(field, "m_nSurfaceProp") == 0)
+    lua_pushinteger(L, data.m_nSurfaceProp);
+  else if (Q_strcmp(field, "m_vAngles") == 0)
+    lua_pushangle(L, data.m_vAngles);
+  else if (Q_strcmp(field, "m_vNormal") == 0)
+    lua_pushvector(L, data.m_vNormal);
+  else if (Q_strcmp(field, "m_vOrigin") == 0)
+    lua_pushvector(L, data.m_vOrigin);
+  else if (Q_strcmp(field, "m_vStart") == 0)
+    lua_pushvector(L, data.m_vStart);
+  else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+  }
+  return 1;
+}
+
+static int CEffectData___newindex (lua_State *L) {
+  CEffectData data = luaL_checkeffect(L, 1);
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "m_fFlags") == 0)
+    data.m_fFlags = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_flMagnitude") == 0)
+    data.m_flMagnitude = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_flRadius") == 0)
+    data.m_flRadius = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "m_flScale") == 0)
+    data.m_flScale = luaL_checknumber(L, 3);
+#ifdef CLIENT_DLL
+  else if (Q_strcmp(field, "m_hEntity") == 0)
+    data.m_hEntity = lua_toentity(L, 3)->GetRefEHandle();
+#else
+  else if (Q_strcmp(field, "m_nEntIndex") == 0)
+    data.m_nEntIndex = luaL_checkint(L, 3);
+#endif
+  else if (Q_strcmp(field, "m_nAttachmentIndex") == 0)
+    data.m_nAttachmentIndex = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_nDamageType") == 0)
+    data.m_nDamageType = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_nHitBox") == 0)
+    data.m_nHitBox = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_nMaterial") == 0)
+    data.m_nMaterial = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_nSurfaceProp") == 0)
+    data.m_nSurfaceProp = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_vAngles") == 0)
+    data.m_vAngles = luaL_checkangle(L, 3);
+  else if (Q_strcmp(field, "m_vNormal") == 0)
+    data.m_vNormal = luaL_checkvector(L, 3);
+  else if (Q_strcmp(field, "m_vOrigin") == 0)
+    data.m_vOrigin = luaL_checkvector(L, 3);
+  else if (Q_strcmp(field, "m_vStart") == 0)
+    data.m_vStart = luaL_checkvector(L, 3);
+  return 0;
+}
+
+static int CEffectData___tostring (lua_State *L) {
+  lua_pushfstring(L, "CEffectData: %p", luaL_checkudata(L, 1, "CEffectData"));
+  return 1;
+}
+
+
+static const luaL_Reg CEffectDatameta[] = {
+#ifdef CLIENT_DLL
+  {"entindex", CEffectData_entindex},
+#endif
+  {"GetEffectNameIndex", CEffectData_GetEffectNameIndex},
+#ifdef CLIENT_DLL
+  {"GetEntity", CEffectData_GetEntity},
+#endif
+  {"__index", CEffectData___index},
+  {"__newindex", CEffectData___newindex},
+  {"__tostring", CEffectData___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_CEffectData (lua_State *L) {
+  CEffectData data = CEffectData();
+  lua_pusheffect(L, data);
+  return 1;
+}
+
+static int luasrc_DispatchEffect (lua_State *L) {
+  DispatchEffect( luaL_checkstring(L, 1), luaL_checkeffect(L, 2) );
+  return 0;
+}
+
+
+static const luaL_Reg CEffectData_funcs[] = {
+  {"CEffectData", luasrc_CEffectData},
+  {"DispatchEffect", luasrc_DispatchEffect},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CEffectData object
+*/
+LUALIB_API int luaopen_CEffectData (lua_State *L) {
+  luaL_newmetatable(L, LUA_EFFECTDATALIBNAME);
+  luaL_register(L, NULL, CEffectDatameta);
+  lua_pushstring(L, "effect");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "effect" */
+  luaL_register(L, "_G", CEffectData_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
diff --git a/src/game/shared/leffect_dispatch_data.h b/src/game/shared/leffect_dispatch_data.h
new file mode 100644
index 0000000..014185a
--- /dev/null
+++ b/src/game/shared/leffect_dispatch_data.h
@@ -0,0 +1,37 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#ifndef LEFFECT_DISPATCH_DATA_H
+#define LEFFECT_DISPATCH_DATA_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+/* type for CEffectData functions */
+typedef CEffectData lua_CEffectData;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CEffectData     &(lua_toeffect) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pusheffect) (lua_State *L, lua_CEffectData &data);
+
+
+
+LUALIB_API lua_CEffectData &(luaL_checkeffect) (lua_State *L, int narg);
+
+
+#endif // LEFFECT_DISPATCH_DATA_H
diff --git a/src/game/shared/limovehelper.cpp b/src/game/shared/limovehelper.cpp
new file mode 100644
index 0000000..abec3ec
--- /dev/null
+++ b/src/game/shared/limovehelper.cpp
@@ -0,0 +1,136 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define limovehelper_cpp
+
+#include "cbase.h"
+#include "imovehelper.h"
+#include "lua.hpp"
+#include "limovehelper.h"
+#include "lbaseentity_shared.h"
+#include "lgametrace.h"
+#include "mathlib/lvector.h"
+#include "lvphysics_interface.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_IMoveHelper *lua_tomovehelper (lua_State *L, int idx) {
+  lua_IMoveHelper **ppHelper = (lua_IMoveHelper **)lua_touserdata(L, idx);
+  return *ppHelper;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushmovehelper (lua_State *L, lua_IMoveHelper *pHelper) {
+  if (pHelper == NULL)
+    lua_pushnil(L);
+  else {
+    lua_IMoveHelper **ppHelper = (lua_IMoveHelper **)lua_newuserdata(L, sizeof(lua_IMoveHelper));
+    *ppHelper = pHelper;
+    luaL_getmetatable(L, "IMoveHelper");
+    lua_setmetatable(L, -2);
+  }
+}
+
+
+LUALIB_API lua_IMoveHelper *luaL_checkmovehelper (lua_State *L, int narg) {
+  lua_IMoveHelper **d = (lua_IMoveHelper **)luaL_checkudata(L, narg, "IMoveHelper");
+  return *d;
+}
+
+
+static int IMoveHelper_ResetTouchList (lua_State *L) {
+  luaL_checkmovehelper(L, 1)->ResetTouchList();
+  return 0;
+}
+
+static int IMoveHelper_AddToTouched (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmovehelper(L, 1)->AddToTouched(luaL_checktrace(L, 2), luaL_checkvector(L, 3)));
+  return 1;
+}
+
+static int IMoveHelper_ProcessImpacts (lua_State *L) {
+  luaL_checkmovehelper(L, 1)->ProcessImpacts();
+  return 0;
+}
+
+static int IMoveHelper_Con_NPrintf (lua_State *L) {
+  luaL_checkmovehelper(L, 1)->Con_NPrintf(luaL_checkint(L, 2), luaL_checkstring(L, 3));
+  return 0;
+}
+
+static int IMoveHelper_PlayerFallingDamage (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmovehelper(L, 1)->PlayerFallingDamage());
+  return 1;
+}
+
+static int IMoveHelper_PlayerSetAnimation (lua_State *L) {
+  luaL_checkmovehelper(L, 1)->PlayerSetAnimation((PLAYER_ANIM)luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int IMoveHelper_GetSurfaceProps (lua_State *L) {
+  lua_pushphysicssurfaceprops(L, luaL_checkmovehelper(L, 1)->GetSurfaceProps());
+  return 1;
+}
+
+static int IMoveHelper___tostring (lua_State *L) {
+  lua_pushfstring(L, "IMoveHelper: %p", luaL_checkudata(L, 1, "IMoveHelper"));
+  return 1;
+}
+
+
+static const luaL_Reg IMoveHelpermeta[] = {
+  {"ResetTouchList", IMoveHelper_ResetTouchList},
+  {"AddToTouched", IMoveHelper_AddToTouched},
+  {"ProcessImpacts", IMoveHelper_ProcessImpacts},
+  {"Con_NPrintf", IMoveHelper_Con_NPrintf},
+  {"PlayerSetAnimation", IMoveHelper_PlayerSetAnimation},
+  {"GetSurfaceProps", IMoveHelper_GetSurfaceProps},
+  {"__tostring", IMoveHelper___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_MoveHelper (lua_State *L) {
+  lua_pushmovehelper(L, MoveHelper());
+  return 1;
+}
+
+
+static const luaL_Reg IMoveHelper_funcs[] = {
+  {"MoveHelper", luasrc_MoveHelper},
+  {NULL, NULL}
+};
+
+
+/*
+** Open IMoveHelper object
+*/
+LUALIB_API int luaopen_IMoveHelper (lua_State *L) {
+  luaL_newmetatable(L, "IMoveHelper");
+  luaL_register(L, NULL, IMoveHelpermeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "movehelper");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "movehelper" */
+  luaL_register(L, "_G", IMoveHelper_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
diff --git a/src/game/shared/limovehelper.h b/src/game/shared/limovehelper.h
new file mode 100644
index 0000000..be47806
--- /dev/null
+++ b/src/game/shared/limovehelper.h
@@ -0,0 +1,38 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LIMOVEHELPER_H
+#define LIMOVEHELPER_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+/* type for IMoveHelper functions */
+typedef IMoveHelper lua_IMoveHelper;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_IMoveHelper             *(lua_tomovehelper) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushmovehelper) (lua_State *L, lua_IMoveHelper *pHelper);
+
+
+
+LUALIB_API lua_IMoveHelper *(luaL_checkmovehelper) (lua_State *L, int narg);
+
+
+#endif // LIMOVEHELPER_H
diff --git a/src/game/shared/lin_buttons.cpp b/src/game/shared/lin_buttons.cpp
new file mode 100644
index 0000000..2fa99f6
--- /dev/null
+++ b/src/game/shared/lin_buttons.cpp
@@ -0,0 +1,48 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+#define lin_buttons_cpp
+
+#include "cbase.h"
+#include "in_buttons.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+
+
+/*
+** Open IN library
+*/
+LUALIB_API int luaopen_IN (lua_State *L) {
+  BEGIN_LUA_SET_ENUM_LIB(L, LUA_INLIBNAME);
+    lua_pushenum(L, IN_ATTACK, "ATTACK");
+    lua_pushenum(L, IN_JUMP, "JUMP");
+    lua_pushenum(L, IN_DUCK, "DUCK");
+    lua_pushenum(L, IN_FORWARD, "FORWARD");
+    lua_pushenum(L, IN_BACK, "BACK");
+    lua_pushenum(L, IN_USE, "USE");
+    lua_pushenum(L, IN_CANCEL, "CANCEL");
+    lua_pushenum(L, IN_LEFT, "LEFT");
+    lua_pushenum(L, IN_RIGHT, "RIGHT");
+    lua_pushenum(L, IN_MOVELEFT, "MOVELEFT");
+    lua_pushenum(L, IN_MOVERIGHT, "MOVERIGHT");
+    lua_pushenum(L, IN_ATTACK2, "ATTACK2");
+    lua_pushenum(L, IN_RUN, "RUN");
+    lua_pushenum(L, IN_RELOAD, "RELOAD");
+    lua_pushenum(L, IN_ALT1, "ALT1");
+    lua_pushenum(L, IN_ALT2, "ALT2");
+    lua_pushenum(L, IN_SCORE, "SCORE");
+    lua_pushenum(L, IN_SPEED, "SPEED");
+    lua_pushenum(L, IN_WALK, "WALK");
+    lua_pushenum(L, IN_ZOOM, "ZOOM");
+    lua_pushenum(L, IN_WEAPON1, "WEAPON1");
+    lua_pushenum(L, IN_WEAPON2, "WEAPON2");
+    lua_pushenum(L, IN_BULLRUSH, "BULLRUSH");
+    lua_pushenum(L, IN_GRENADE1, "GRENADE1");
+    lua_pushenum(L, IN_GRENADE2, "GRENADE2");
+  END_LUA_SET_ENUM_LIB(L);
+  return 0;
+}
\ No newline at end of file
diff --git a/src/game/shared/lipredictionsystem.cpp b/src/game/shared/lipredictionsystem.cpp
new file mode 100644
index 0000000..ab14d0a
--- /dev/null
+++ b/src/game/shared/lipredictionsystem.cpp
@@ -0,0 +1,43 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define lipredictionsystem_cpp
+
+#include "cbase.h"
+#include "ipredictionsystem.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lbaseentity_shared.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int IPredictionSystem_SuppressEvents (lua_State *L) {
+  IPredictionSystem::SuppressEvents(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int IPredictionSystem_SuppressHostEvents (lua_State *L) {
+  IPredictionSystem::SuppressHostEvents(lua_toentity(L, 1));
+  return 0;
+}
+
+
+static const luaL_Reg IPredictionSystemlib[] = {
+  {"SuppressEvents",   IPredictionSystem_SuppressEvents},
+  {"SuppressHostEvents", IPredictionSystem_SuppressHostEvents},
+  {NULL, NULL}
+};
+
+
+/*
+** Open IPredictionSystem library
+*/
+LUALIB_API int luaopen_IPredictionSystem (lua_State *L) {
+  luaL_register(L, LUA_PREDICTIONSYSTEMLIBNAME, IPredictionSystemlib);
+  return 1;
+}
diff --git a/src/game/shared/lshareddefs.cpp b/src/game/shared/lshareddefs.cpp
new file mode 100644
index 0000000..0b146ef
--- /dev/null
+++ b/src/game/shared/lshareddefs.cpp
@@ -0,0 +1,129 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Definitions that are shared by the game DLL and the client DLL.
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define lshareddefs_cpp
+
+#include "cbase.h"
+#include "ammodef.h"
+#include "luamanager.h"
+#include "lshareddefs.h"
+#include "lbaseentity_shared.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_FireBulletsInfo_t lua_tofirebulletsinfo (lua_State *L, int idx) {
+  luaL_checktype(L, idx, LUA_TTABLE);
+  FireBulletsInfo_t info;
+  lua_getfield(L, idx, "m_bPrimaryAttack");
+  if (!lua_isnil(L, -1))
+    info.m_bPrimaryAttack = luaL_checkboolean(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_flDamageForceScale");
+  if (!lua_isnil(L, -1))
+    info.m_flDamageForceScale = luaL_checknumber(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_flDistance");
+  if (!lua_isnil(L, -1))
+    info.m_flDistance = luaL_checknumber(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_iAmmoType");
+  if (!lua_isnil(L, -1))
+    info.m_iAmmoType = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_iDamage");
+  if (!lua_isnil(L, -1))
+    info.m_iDamage = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_iPlayerDamage");
+  if (!lua_isnil(L, -1))
+    info.m_iPlayerDamage = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_iShots");
+  if (!lua_isnil(L, -1))
+    info.m_iShots = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_iTracerFreq");
+  if (!lua_isnil(L, -1))
+    info.m_iTracerFreq = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_nFlags");
+  if (!lua_isnil(L, -1))
+    info.m_nFlags = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_pAdditionalIgnoreEnt");
+  if (!lua_isnil(L, -1))
+    info.m_pAdditionalIgnoreEnt = lua_toentity(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_pAttacker");
+  if (!lua_isnil(L, -1))
+    info.m_pAttacker = lua_toentity(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_vecDirShooting");
+  if (!lua_isnil(L, -1))
+    info.m_vecDirShooting = luaL_checkvector(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_vecSpread");
+  if (!lua_isnil(L, -1))
+    info.m_vecSpread = luaL_checkvector(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_vecSrc");
+  if (!lua_isnil(L, -1))
+    info.m_vecSrc = luaL_checkvector(L, -1);
+  lua_pop(L, 1);
+  return info;
+}
+
+LUA_API void lua_toemitsound (lua_State *L, int idx, EmitSound_t &ep) {
+  luaL_checktype(L, idx, LUA_TTABLE);
+  lua_getfield(L, idx, "m_nChannel");
+  if (!lua_isnil(L, -1))
+    ep.m_nChannel = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_pSoundName");
+  if (!lua_isnil(L, -1))
+    ep.m_pSoundName = luaL_checkstring(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_flVolume");
+  if (!lua_isnil(L, -1))
+    ep.m_flVolume = luaL_checknumber(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_SoundLevel");
+  if (!lua_isnil(L, -1))
+    ep.m_SoundLevel = (soundlevel_t)luaL_checkinteger(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_nFlags");
+  if (!lua_isnil(L, -1))
+    ep.m_nFlags = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_nPitch");
+  if (!lua_isnil(L, -1))
+    ep.m_nPitch = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_pOrigin");
+  if (!lua_isnil(L, -1))
+    ep.m_pOrigin = &luaL_checkvector(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_flSoundTime");
+  if (!lua_isnil(L, -1))
+    ep.m_flSoundTime = luaL_checknumber(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "m_pflSoundDuration");
+  if (!lua_isnil(L, -1)) {
+    float duration = luaL_checknumber(L, -1);
+    ep.m_pflSoundDuration = &duration;
+  }
+  lua_pop(L, 1);
+}
+
diff --git a/src/game/shared/lshareddefs.h b/src/game/shared/lshareddefs.h
new file mode 100644
index 0000000..c5ad2c1
--- /dev/null
+++ b/src/game/shared/lshareddefs.h
@@ -0,0 +1,32 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Definitions that are shared by the game DLL and the client DLL.
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LSHAREDDEFS_H
+#define LSHAREDDEFS_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+/* type for FireBulletsInfo_t in Lua */
+typedef FireBulletsInfo_t lua_FireBulletsInfo_t;
+
+
+/* type for EmitSound_t in Lua */
+typedef EmitSound_t lua_EmitSound_t;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_FireBulletsInfo_t      (lua_tofirebulletsinfo) (lua_State *L, int idx);
+LUA_API void                       (lua_toemitsound) (lua_State *L, int idx, EmitSound_t &ep);
+
+
+#endif // LSHAREDDEFS_H
diff --git a/src/game/shared/lsrcinit.cpp b/src/game/shared/lsrcinit.cpp
new file mode 100644
index 0000000..907c769
--- /dev/null
+++ b/src/game/shared/lsrcinit.cpp
@@ -0,0 +1,119 @@
+//========== Copyleft  2011, Team Sandbox, Some rights reserved. ===========//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+
+#define lsrcinit_cpp
+
+#include "cbase.h"
+#include "lua.hpp"
+
+#include "luasrclib.h"
+#include "lauxlib.h"
+
+
+static const luaL_Reg luasrclibs[] = {
+  {LUA_BASEANIMATINGLIBNAME, luaopen_CBaseAnimating},
+  {LUA_BASECOMBATWEAPONLIBNAME, luaopen_CBaseCombatWeapon},
+  {LUA_BASEENTITYLIBNAME, luaopen_CBaseEntity},
+  {LUA_BASEENTITYLIBNAME, luaopen_CBaseEntity_shared},
+  {LUA_BASEPLAYERLIBNAME, luaopen_CBasePlayer},
+  {LUA_BASEPLAYERLIBNAME, luaopen_CBasePlayer_shared},
+  {LUA_EFFECTDATALIBNAME, luaopen_CEffectData},
+  {LUA_GAMETRACELIBNAME, luaopen_CGameTrace},
+#ifndef CLIENT_DLL
+  {LUA_HL2MPPLAYERLIBNAME, luaopen_CHL2MP_Player},
+#endif
+  {LUA_HL2MPPLAYERLIBNAME, luaopen_CHL2MP_Player_shared},
+  {LUA_COLORLIBNAME, luaopen_Color},
+  {LUA_CONCOMMANDLIBNAME, luaopen_ConCommand},
+  {LUA_CONTENTSLIBNAME, luaopen_CONTENTS},
+  {LUA_CONVARLIBNAME, luaopen_ConVar},
+  {LUA_PASFILTERLIBNAME, luaopen_CPASFilter},
+  {LUA_RECIPIENTFILTERLIBNAME, luaopen_CRecipientFilter},
+  {LUA_TAKEDAMAGEINFOLIBNAME, luaopen_CTakeDamageInfo},
+  {LUA_CVARLIBNAME, luaopen_cvar},
+  {LUA_DBGLIBNAME, luaopen_dbg},
+  {LUA_DEBUGOVERLAYLIBNAME, luaopen_debugoverlay},
+  {LUA_ENGINELIBNAME, luaopen_engine},
+#ifdef CLIENT_DLL
+  // FIXME: obsolete? should be passing VPANELs, but passes Panel instead,
+  // which always ends up being invalid (we can't access them by pointer)
+  {LUA_ENGINEVGUILIBNAME, luaopen_enginevgui},
+#endif
+  {LUA_FCVARLIBNAME, luaopen_FCVAR},
+  {LUA_FILESYSTEMLIBNAME, luaopen_filesystem},
+#ifdef CLIENT_DLL
+  {LUA_FONTFLAGLIBNAME, luaopen_FONTFLAG},
+#endif
+#ifndef CLIENT_DLL
+  {LUA_ENTLISTLIBNAME, luaopen_gEntList},
+#endif
+  {LUA_GLOBALSLIBNAME, luaopen_gpGlobals},
+#ifdef CLIENT_DLL
+  {LUA_CLIENTSHADOWMGRLIBNAME, luaopen_g_pClientShadowMgr},
+  {LUA_FONTLIBNAME, luaopen_HFont},
+  {LUA_HSCHEMELIBNAME, luaopen_HScheme},
+#endif
+  {LUA_MATERIALLIBNAME, luaopen_IMaterial},
+  {LUA_MOVEHELPERLIBNAME, luaopen_IMoveHelper},
+  {LUA_INLIBNAME, luaopen_IN},
+#ifndef CLIENT_DLL
+  {LUA_NETCHANNELINFOLIBNAME, luaopen_INetChannelInfo},
+#endif
+  {LUA_INETWORKSTRINGTABLELIBNAME, luaopen_INetworkStringTable},
+#ifdef CLIENT_DLL
+  {LUA_INPUTLIBNAME, luaopen_input},
+#endif
+  {LUA_PHYSICSOBJECTLIBNAME, luaopen_IPhysicsObject},
+  {LUA_PHYSICSSURFACEPROPSLIBNAME, luaopen_IPhysicsSurfaceProps},
+  {LUA_PREDICTIONSYSTEMLIBNAME, luaopen_IPredictionSystem},
+#ifdef CLIENT_DLL
+  {LUA_ISCHEMELIBNAME, luaopen_IScheme},
+#endif
+  {LUA_STEAMFRIENDSLIBNAME, luaopen_ISteamFriends},
+  {LUA_KEYVALUESLIBNAME, luaopen_KeyValues},
+  {LUA_MASKLIBNAME, luaopen_MASK},
+  {LUA_MATHLIBLIBNAME, luaopen_mathlib},
+  {LUA_MATRIXLIBNAME, luaopen_matrix3x4_t},
+  {LUA_NETWORKSTRINGTABLELIBNAME, luaopen_networkstringtable},
+#ifdef CLIENT_DLL
+  {LUA_PANELLIBNAME, luaopen_Panel},
+#endif
+  {LUA_PHYSENVLIBNAME, luaopen_physenv},
+#ifdef CLIENT_DLL
+  {LUA_PREDICTIONLIBNAME, luaopen_prediction},
+#endif
+  {LUA_QANGLELIBNAME, luaopen_QAngle},
+  {LUA_RANDOMLIBNAME, luaopen_random},
+#ifdef CLIENT_DLL
+  {LUA_SCHEMELIBNAME, luaopen_scheme},
+#endif
+  {LUA_STEAMAPICONTEXTLIBNAME, luaopen_steamapicontext},
+  {LUA_SURFLIBNAME, luaopen_SURF},
+#ifdef CLIENT_DLL
+  {LUA_SURFACELIBNAME, luaopen_surface},
+#endif
+  {LUA_UTILLIBNAME, luaopen_UTIL},
+  {LUA_UTILLIBNAME, luaopen_UTIL_shared},
+  {LUA_VECTORLIBNAME, luaopen_Vector},
+#ifdef CLIENT_DLL
+  {LUA_VGUILIBNAME, luaopen_vgui},
+#endif
+  {LUA_VMATRIXLIBNAME, luaopen_VMatrix},
+  {NULL, NULL}
+};
+
+
+LUALIB_API void luasrc_openlibs (lua_State *L) {
+  const luaL_Reg *lib = luasrclibs;
+  for (; lib->func; lib++) {
+    lua_pushcfunction(L, lib->func);
+    lua_pushstring(L, lib->name);
+    lua_call(L, 1, 0);
+  }
+}
+
diff --git a/src/game/shared/ltakedamageinfo.cpp b/src/game/shared/ltakedamageinfo.cpp
new file mode 100644
index 0000000..d7d19bc
--- /dev/null
+++ b/src/game/shared/ltakedamageinfo.cpp
@@ -0,0 +1,371 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#include "cbase.h"
+#include "takedamageinfo.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "ltakedamageinfo.h"
+#include "lbaseentity_shared.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CTakeDamageInfo &lua_todamageinfo (lua_State *L, int idx) {
+  lua_CTakeDamageInfo *info = (lua_CTakeDamageInfo *)lua_touserdata(L, idx);
+  return *info;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushdamageinfo (lua_State *L, lua_CTakeDamageInfo &info) {
+  lua_CTakeDamageInfo *pInfo = (lua_CTakeDamageInfo *)lua_newuserdata(L, sizeof(lua_CTakeDamageInfo));
+  *pInfo = info;
+  luaL_getmetatable(L, "CTakeDamageInfo");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CTakeDamageInfo &luaL_checkdamageinfo (lua_State *L, int narg) {
+  lua_CTakeDamageInfo *d = (lua_CTakeDamageInfo *)luaL_checkudata(L, narg, "CTakeDamageInfo");
+  return *d;
+}
+
+
+static int CTakeDamageInfo_AddDamage (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).AddDamage(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_AddDamageType (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).AddDamageType(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_AdjustPlayerDamageInflictedForSkillLevel (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).AdjustPlayerDamageInflictedForSkillLevel();
+  return 0;
+}
+
+static int CTakeDamageInfo_AdjustPlayerDamageTakenForSkillLevel (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).AdjustPlayerDamageTakenForSkillLevel();
+  return 0;
+}
+
+static int CTakeDamageInfo_BaseDamageIsValid (lua_State *L) {
+  lua_pushboolean(L, luaL_checkdamageinfo(L, 1).BaseDamageIsValid());
+  return 1;
+}
+
+static int CTakeDamageInfo_CopyDamageToBaseDamage (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).CopyDamageToBaseDamage();
+  return 0;
+}
+
+static int CTakeDamageInfo_DebugGetDamageTypeString (lua_State *L) {
+  char outbuf[256];
+  outbuf[0] = '\0';
+  luaL_checkdamageinfo(L, 1).DebugGetDamageTypeString(luaL_checkint(L, 2), outbuf, sizeof( outbuf ));
+  lua_pushstring(L, outbuf);
+  return 1;
+}
+
+static int CTakeDamageInfo_GetAmmoName (lua_State *L) {
+  lua_pushstring(L, luaL_checkdamageinfo(L, 1).GetAmmoName());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetAmmoType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkdamageinfo(L, 1).GetAmmoType());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetAttacker (lua_State *L) {
+  lua_pushentity(L, luaL_checkdamageinfo(L, 1).GetAttacker());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetBaseDamage (lua_State *L) {
+  lua_pushnumber(L, luaL_checkdamageinfo(L, 1).GetBaseDamage());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetDamage (lua_State *L) {
+  lua_pushnumber(L, luaL_checkdamageinfo(L, 1).GetDamage());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetDamageCustom (lua_State *L) {
+  lua_pushinteger(L, luaL_checkdamageinfo(L, 1).GetDamageCustom());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetDamageForce (lua_State *L) {
+  lua_pushvector(L, luaL_checkdamageinfo(L, 1).GetDamageForce());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetDamagePosition (lua_State *L) {
+  lua_pushvector(L, luaL_checkdamageinfo(L, 1).GetDamagePosition());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetDamageStats (lua_State *L) {
+  lua_pushinteger(L, luaL_checkdamageinfo(L, 1).GetDamageStats());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetDamageType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkdamageinfo(L, 1).GetDamageType());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetInflictor (lua_State *L) {
+  lua_pushentity(L, luaL_checkdamageinfo(L, 1).GetInflictor());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetMaxDamage (lua_State *L) {
+  lua_pushnumber(L, luaL_checkdamageinfo(L, 1).GetMaxDamage());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetReportedPosition (lua_State *L) {
+  lua_pushvector(L, luaL_checkdamageinfo(L, 1).GetReportedPosition());
+  return 1;
+}
+
+static int CTakeDamageInfo_GetWeapon (lua_State *L) {
+  lua_pushentity(L, luaL_checkdamageinfo(L, 1).GetWeapon());
+  return 1;
+}
+
+static int CTakeDamageInfo_ScaleDamage (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).ScaleDamage(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_ScaleDamageForce (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).ScaleDamageForce(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetAmmoType (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetAmmoType(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetAttacker (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetAttacker(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetDamage (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetDamage(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetDamageCustom (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetDamageCustom(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetDamageForce (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetDamageForce(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetDamagePosition (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetDamagePosition(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetDamageStats (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetDamageStats(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetDamageType (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetDamageType(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetInflictor (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetInflictor(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetMaxDamage (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetMaxDamage(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetReportedPosition (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetReportedPosition(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SetWeapon (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SetWeapon(luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo_SubtractDamage (lua_State *L) {
+  luaL_checkdamageinfo(L, 1).SubtractDamage(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int CTakeDamageInfo___tostring (lua_State *L) {
+  lua_pushfstring(L, "CTakeDamageInfo: %p", luaL_checkudata(L, 1, "CTakeDamageInfo"));
+  return 1;
+}
+
+
+static const luaL_Reg CTakeDamageInfometa[] = {
+  {"AddDamage", CTakeDamageInfo_AddDamage},
+  {"AddDamageType", CTakeDamageInfo_AddDamageType},
+  {"AdjustPlayerDamageInflictedForSkillLevel", CTakeDamageInfo_AdjustPlayerDamageInflictedForSkillLevel},
+  {"AdjustPlayerDamageTakenForSkillLevel", CTakeDamageInfo_AdjustPlayerDamageTakenForSkillLevel},
+  {"BaseDamageIsValid", CTakeDamageInfo_BaseDamageIsValid},
+  {"CopyDamageToBaseDamage", CTakeDamageInfo_CopyDamageToBaseDamage},
+  {"DebugGetDamageTypeString", CTakeDamageInfo_DebugGetDamageTypeString},
+  {"GetAmmoName", CTakeDamageInfo_GetAmmoName},
+  {"GetAmmoType", CTakeDamageInfo_GetAmmoType},
+  {"GetAttacker", CTakeDamageInfo_GetAttacker},
+  {"GetBaseDamage", CTakeDamageInfo_GetBaseDamage},
+  {"GetDamage", CTakeDamageInfo_GetDamage},
+  {"GetDamageCustom", CTakeDamageInfo_GetDamageCustom},
+  {"GetDamageForce", CTakeDamageInfo_GetDamageForce},
+  {"GetDamagePosition", CTakeDamageInfo_GetDamagePosition},
+  {"GetDamageStats", CTakeDamageInfo_GetDamageStats},
+  {"GetDamageType", CTakeDamageInfo_GetDamageType},
+  {"GetInflictor", CTakeDamageInfo_GetInflictor},
+  {"GetMaxDamage", CTakeDamageInfo_GetMaxDamage},
+  {"GetReportedPosition", CTakeDamageInfo_GetReportedPosition},
+  {"GetWeapon", CTakeDamageInfo_GetWeapon},
+  {"ScaleDamage", CTakeDamageInfo_ScaleDamage},
+  {"ScaleDamageForce", CTakeDamageInfo_ScaleDamageForce},
+  {"SetAmmoType", CTakeDamageInfo_SetAmmoType},
+  {"SetAttacker", CTakeDamageInfo_SetAttacker},
+  {"SetDamage", CTakeDamageInfo_SetDamage},
+  {"SetDamageCustom", CTakeDamageInfo_SetDamageCustom},
+  {"SetDamageForce", CTakeDamageInfo_SetDamageForce},
+  {"SetDamagePosition", CTakeDamageInfo_SetDamagePosition},
+  {"SetDamageStats", CTakeDamageInfo_SetDamageStats},
+  {"SetDamageType", CTakeDamageInfo_SetDamageType},
+  {"SetInflictor", CTakeDamageInfo_SetInflictor},
+  {"SetMaxDamage", CTakeDamageInfo_SetMaxDamage},
+  {"SetReportedPosition", CTakeDamageInfo_SetReportedPosition},
+  {"SetWeapon", CTakeDamageInfo_SetWeapon},
+  {"SubtractDamage", CTakeDamageInfo_SubtractDamage},
+  {"__tostring", CTakeDamageInfo___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_CTakeDamageInfo (lua_State *L) {
+  if (lua_gettop(L) < 4) {
+    CTakeDamageInfo info = CTakeDamageInfo();
+    lua_pushdamageinfo(L, info);
+  } else if (lua_gettop(L) <= 5) {
+    CTakeDamageInfo info = CTakeDamageInfo(luaL_checkentity(L, 1), luaL_checkentity(L, 2), luaL_checknumber(L, 3), luaL_checkint(L, 4), luaL_optint(L, 5, 0));
+    lua_pushdamageinfo(L, info);
+  } else if (lua_gettop(L) <= 6) {
+    CTakeDamageInfo info = CTakeDamageInfo(luaL_checkentity(L, 1), luaL_checkentity(L, 2), luaL_checkentity(L, 3), luaL_checknumber(L, 4), luaL_checkint(L, 5), luaL_optint(L, 6, 0));
+    lua_pushdamageinfo(L, info);
+  } else if (lua_gettop(L) < 9) {
+    CTakeDamageInfo info = CTakeDamageInfo(luaL_checkentity(L, 1), luaL_checkentity(L, 2), luaL_checkvector(L, 3), luaL_checkvector(L, 4), luaL_checknumber(L, 5), luaL_checkint(L, 6), luaL_optint(L, 7, 0), &luaL_optvector(L, 8, NULL));
+    lua_pushdamageinfo(L, info);
+  } else {
+    CTakeDamageInfo info = CTakeDamageInfo(luaL_checkentity(L, 1), luaL_checkentity(L, 2), luaL_checkentity(L, 3), luaL_checkvector(L, 4), luaL_checkvector(L, 5), luaL_checknumber(L, 6), luaL_checkint(L, 7), luaL_optint(L, 8, 0), &luaL_optvector(L, 9, NULL));
+    lua_pushdamageinfo(L, info);
+  }
+  return 1;
+}
+
+static int luasrc_ClearMultiDamage (lua_State *L) {
+  ClearMultiDamage();
+  return 0;
+}
+
+static int luasrc_ApplyMultiDamage (lua_State *L) {
+  ApplyMultiDamage();
+  return 0;
+}
+
+static int luasrc_AddMultiDamage (lua_State *L) {
+  AddMultiDamage(luaL_checkdamageinfo(L, 1), luaL_checkentity(L, 2));
+  return 0;
+}
+
+static int luasrc_ImpulseScale (lua_State *L) {
+  lua_pushnumber(L, ImpulseScale(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int luasrc_CalculateExplosiveDamageForce (lua_State *L) {
+  CalculateExplosiveDamageForce(&luaL_checkdamageinfo(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_optnumber(L, 4, 1.0));
+  return 0;
+}
+
+static int luasrc_CalculateBulletDamageForce (lua_State *L) {
+  CalculateBulletDamageForce(&luaL_checkdamageinfo(L, 1), luaL_checkint(L, 2), luaL_checkvector(L, 3), luaL_checkvector(L, 4), luaL_optnumber(L, 5, 1.0));
+  return 0;
+}
+
+static int luasrc_CalculateMeleeDamageForce (lua_State *L) {
+  CalculateMeleeDamageForce(&luaL_checkdamageinfo(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_optnumber(L, 4, 1.0));
+  return 0;
+}
+
+static int luasrc_GuessDamageForce (lua_State *L) {
+  GuessDamageForce(&luaL_checkdamageinfo(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_optnumber(L, 4, 1.0));
+  return 0;
+}
+
+
+static const luaL_Reg CTakeDamageInfo_funcs[] = {
+  {"CTakeDamageInfo", luasrc_CTakeDamageInfo},
+  {"ClearMultiDamage", luasrc_ClearMultiDamage},
+  {"ApplyMultiDamage", luasrc_ApplyMultiDamage},
+  {"AddMultiDamage", luasrc_AddMultiDamage},
+  {"ImpulseScale", luasrc_ImpulseScale},
+  {"CalculateExplosiveDamageForce", luasrc_CalculateExplosiveDamageForce},
+  {"CalculateBulletDamageForce", luasrc_CalculateBulletDamageForce},
+  {"CalculateMeleeDamageForce", luasrc_CalculateMeleeDamageForce},
+  {"GuessDamageForce", luasrc_GuessDamageForce},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CTakeDamageInfo object
+*/
+LUALIB_API int luaopen_CTakeDamageInfo (lua_State *L) {
+  luaL_newmetatable(L, LUA_TAKEDAMAGEINFOLIBNAME);
+  luaL_register(L, NULL, CTakeDamageInfometa);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "damageinfo");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "damageinfo" */
+  luaL_register(L, "_G", CTakeDamageInfo_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
diff --git a/src/game/shared/ltakedamageinfo.h b/src/game/shared/ltakedamageinfo.h
new file mode 100644
index 0000000..662645a
--- /dev/null
+++ b/src/game/shared/ltakedamageinfo.h
@@ -0,0 +1,37 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LTAKEDAMAGEINFO_H
+#define LTAKEDAMAGEINFO_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+/* type for CTakeDamageInfo functions */
+typedef CTakeDamageInfo lua_CTakeDamageInfo;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CTakeDamageInfo     &(lua_todamageinfo) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushdamageinfo) (lua_State *L, lua_CTakeDamageInfo &info);
+
+
+
+LUALIB_API lua_CTakeDamageInfo &(luaL_checkdamageinfo) (lua_State *L, int narg);
+
+
+#endif // LTAKEDAMAGEINFO_H
diff --git a/src/game/shared/luacachefile.cpp b/src/game/shared/luacachefile.cpp
new file mode 100644
index 0000000..70c5980
--- /dev/null
+++ b/src/game/shared/luacachefile.cpp
@@ -0,0 +1,358 @@
+//========== Copyleft  2011, Team Sandbox, Some rights reserved. ===========//
+//
+// Purpose: Handles the creation of Lua Cache Files for multiplayer.
+//
+//===========================================================================//
+
+#include "cbase.h"
+#include "filesystem.h"
+#ifdef WIN32
+#include "winlite.h"
+#endif
+#include "zip/XUnzip.h"
+#include "utldict.h"
+#include "luamanager.h"
+#include "luacachefile.h"
+
+#ifdef GAME_DLL
+#include "networkstringtable_gamedll.h"
+#else
+#include "networkstringtable_clientdll.h"
+#endif
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static IZip *s_lcfFile = 0;
+
+//-----------------------------------------------------------------------------
+// Purpose: // Get a lcffile instance
+// Output : IZip*
+//-----------------------------------------------------------------------------
+LUA_API IZip* luasrc_GetLcfFile( void )
+{
+	if ( !s_lcfFile )
+	{
+		s_lcfFile = IZip::CreateZip();
+	}
+	return s_lcfFile;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Add file from disk to .lcf
+// Input  : *relativename - 
+//			*fullpath - 
+//-----------------------------------------------------------------------------
+LUA_API void luasrc_AddFileToLcf( const char *relativename, const char *fullpath )
+{
+	s_lcfFile->AddFileToZip( relativename, fullpath );
+}
+
+#ifdef CLIENT_DLL
+
+LUA_API void luasrc_ExtractLcf ()
+{
+	INetworkStringTable *downloadables = networkstringtable->FindTable( "downloadables" );
+	const char *pFilename = NULL;
+	for ( int i=0; i<downloadables->GetNumStrings(); i++ )
+	{
+		pFilename = downloadables->GetString( i );
+		char ext[ 10 ];
+		Q_ExtractFileExtension( pFilename, ext, sizeof( ext ) );
+
+		if ( !Q_stricmp( ext, "lcf" ) )
+		{
+			char current[ 512 ] = { 0 };
+			char cachePath[MAX_PATH];
+			bool bGetCurrentDirectory = V_GetCurrentDirectory( current, sizeof( current ) );
+			if ( bGetCurrentDirectory )
+			{
+#ifdef CLIENT_DLL
+				const char *gamePath = engine->GetGameDirectory();
+#else
+				char gamePath[ 256 ];
+				engine->GetGameDir( gamePath, 256 );
+#endif
+				Q_strncpy( cachePath, gamePath, sizeof( cachePath ) );
+				Q_strncat( cachePath, "\\"LUA_PATH_CACHE, sizeof( cachePath ), COPY_ALL_CHARACTERS );
+				V_SetCurrentDirectory( cachePath );
+			}
+
+			char fullpath[MAX_PATH];
+			filesystem->RelativePathToFullPath( pFilename, "MOD", fullpath, sizeof( fullpath ) );
+			HZIP hz = OpenZip( fullpath, 0, ZIP_FILENAME );
+			ZIPENTRY ze;
+			GetZipItem( hz, -1, &ze );
+			int numitems = ze.index;
+			for ( int i = 0; i < numitems; i++ )
+			{
+				GetZipItem( hz, i, &ze );
+				// forget directories, we create hierarchies from file names
+				if ((ze.attr & FILE_ATTRIBUTE_DIRECTORY) != 1)
+				{
+					char fullpath[MAX_PATH];
+					char path[MAX_PATH];
+					Q_snprintf( path, sizeof( path ), LUA_PATH_CACHE"\\%s", ze.name );
+					Q_StripFilename( path );
+					filesystem->CreateDirHierarchy( path, "MOD" );
+					Q_snprintf( fullpath, sizeof( fullpath ), "%s%s", cachePath, path + Q_strlen( LUA_PATH_CACHE ) );
+					// DevMsg( "LCF: setting current directory to %s...\n", fullpath );
+					V_SetCurrentDirectory( fullpath );
+					// DevMsg( "LCF: unpacking %s...\n", ze.name );
+					UnzipItem( hz, i, (void *)V_UnqualifiedFileName( ze.name ), 0, ZIP_FILENAME );
+				}
+			}
+			CloseZip( hz );
+
+			if ( bGetCurrentDirectory )
+				V_SetCurrentDirectory( current );
+
+			break;
+		}
+	}
+}
+
+#else
+
+static CUtlDict< char *, int > m_LcfDatabase;
+
+static const char *UTIL_StripAddonName( char *addonName )
+{
+	char *pc = addonName;
+	int i = 0;
+	while ( *pc )
+	{
+		char c = *pc;
+
+		if ( c == '/' || c == '\\' )
+		{
+			*pc = 0;
+			++i;
+			return addonName + i;
+		}
+		else
+		{
+			*pc = 0;
+			++i;
+		}
+		++pc;
+	}
+	Assert( false );
+	return addonName + i;
+}
+
+static int luasrc_sendfile (lua_State *L) {
+  // Can only send files in multiplayer!!!
+  if ( gpGlobals->maxClients == 1 )
+  {
+  	return 0;
+  }
+  lua_Debug ar1;
+  lua_getstack(L, 1, &ar1);
+  lua_getinfo(L, "f", &ar1);
+  lua_Debug ar2;
+  lua_getinfo(L, ">S", &ar2);
+  int iLength = Q_strlen( ar2.source );
+  char source[MAX_PATH];
+  Q_StrRight( ar2.source, iLength-1, source, sizeof( source ) );
+  Q_StripFilename( source );
+  char filename[MAX_PATH];
+  Q_snprintf( filename, sizeof( filename ), "%s\\%s", source, luaL_checkstring(L, 1) );
+  char relativePath[MAX_PATH];
+  if ( filesystem->FullPathToRelativePathEx( filename, "MOD", relativePath, MAX_PATH ) )
+  {
+	const char *zipPath = NULL;
+	if ( Q_strnicmp( relativePath, "addons/", 7 ) )
+	{
+		char *substring = strstr( relativePath, "addons\\" );
+		if ( substring )
+		{
+			*substring = 0;
+			zipPath = UTIL_StripAddonName( relativePath + 7 );
+		}
+	}
+	char gamePath[ 256 ];
+	engine->GetGameDir( gamePath, 256 );
+	// DevMsg( "LCF: adding %s to the Lua cache file...\n", zipPath );
+	m_LcfDatabase.Insert( zipPath, strdup( filename ) );
+  }
+  else
+  {
+	DevMsg( "LCF: couldn't find relative path to %s!\n", filename );
+  }
+  return 0;
+}
+
+
+static const luaL_Reg lcf_funcs[] = {
+  {"sendfile", luasrc_sendfile},
+  {NULL, NULL}
+};
+
+
+#endif
+
+extern void lcf_open (lua_State *L) {
+#ifndef CLIENT_DLL
+  /* open lib into global table */
+  luaL_register(L, "_G", lcf_funcs);
+  lua_pop(L, 1);
+#else
+  // force create this directory incase it doesn't exist
+  filesystem->CreateDirHierarchy( LUA_PATH_CACHE, "MOD");
+#endif
+}
+
+extern void lcf_recursivedeletefile( const char *current ) {
+	FileFindHandle_t fh;
+
+	char path[ 512 ];
+	if ( current[ 0 ] )
+	{
+        Q_snprintf( path, sizeof( path ), "%s/*.*", current );
+	}
+	else
+	{
+		Q_snprintf( path, sizeof( path ), "*.*" );
+	}
+
+	Q_FixSlashes( path );
+
+	char const *fn = g_pFullFileSystem->FindFirstEx( path, "MOD", &fh );
+	while ( fn )
+	{
+		if ( fn[0] != '.' )
+		{
+			if ( g_pFullFileSystem->FindIsDirectory( fh ) )
+			{
+				char nextdir[ 512 ];
+				if ( current[ 0 ] )
+				{
+					Q_snprintf( nextdir, sizeof( nextdir ), "%s/%s", current, fn );
+				}
+				else
+				{
+					Q_snprintf( nextdir, sizeof( nextdir ), "%s", fn );
+				}
+
+				lcf_recursivedeletefile( nextdir );
+			}
+			else
+			{
+				char relative[ 512 ];
+				if ( current[ 0 ] )
+				{
+					Q_snprintf( relative, sizeof( relative ), "%s/%s", current, fn );
+				}
+				else
+				{
+					Q_snprintf( relative, sizeof( relative ), "%s", fn );
+				}
+				DevMsg( "Deleting '%s/%s'...\n", current, fn );
+
+				Q_FixSlashes( relative );
+				g_pFullFileSystem->SetFileWritable( relative, true, "MOD" );
+				g_pFullFileSystem->RemoveFile( relative, "MOD" );
+			}
+		}
+
+		fn = g_pFullFileSystem->FindNext( fh );
+	}
+	g_pFullFileSystem->FindClose( fh );
+}
+
+extern void lcf_close (lua_State *L) {
+#ifndef CLIENT_DLL
+	int c = m_LcfDatabase.Count(); 
+	for ( int i = 0; i < c; ++i )
+	{
+		delete m_LcfDatabase[ i ];
+	}
+	m_LcfDatabase.RemoveAll();
+#else
+	lcf_recursivedeletefile( LUA_PATH_CACHE );
+#endif
+}
+
+#ifndef CLIENT_DLL
+
+extern void lcf_preparecachefile (void) {
+	int c = m_LcfDatabase.Count();
+	if ( c > 0 )
+	{
+		DevMsg( "Preparing Lua cache file...\n" );
+	}
+	else
+	{
+		return;
+	}
+	IZip *pZip = luasrc_GetLcfFile();
+	for ( int i = 0; i < c; i++ )
+	{
+		pZip->AddFileToZip( m_LcfDatabase.GetElementName( i ), m_LcfDatabase[ i ] ); 
+	}
+	// force create this directory incase it doesn't exist
+	filesystem->CreateDirHierarchy( "cache", "MOD");
+	FileHandle_t fh = g_pFullFileSystem->Open( "cache\\cache_temp.lcf", "wb", "MOD" );
+	if ( FILESYSTEM_INVALID_HANDLE != fh )
+	{
+		pZip->SaveToDisk( fh );
+	}
+	g_pFullFileSystem->Close( fh );
+
+	byte *buffer;
+
+	fh = g_pFullFileSystem->Open( "cache\\cache_temp.lcf", "rb", "MOD" );
+
+	int size = g_pFullFileSystem->Size( fh );
+	buffer = new byte[ size + 1 ];
+	if ( !buffer )
+	{
+		Warning( "lcf_preparecachefile:  Couldn't allocate buffer of size %i\n", size + 1 );
+		g_pFullFileSystem->Close( fh );
+		return;
+	}
+	g_pFullFileSystem->Read( buffer, size, fh );
+	g_pFullFileSystem->Close( fh );
+
+	// Ensure null terminator
+	// buffer[ size ] =0;
+
+	CRC32_t crc;
+
+	CRC32_Init( &crc );
+	// CRC32_ProcessBuffer( &crc, buffer, sizeof( buffer ) );
+	CRC32_ProcessBuffer( &crc, buffer, size );
+	CRC32_Final( &crc );
+
+	delete[] buffer;
+
+	char filename[ MAX_PATH ];
+	char hexname[ 16 ];
+	Q_binarytohex( (const byte *)&crc, sizeof( crc ), hexname, sizeof( hexname ) );
+	Q_snprintf( filename, sizeof( filename ), "cache\\%s.lcf", hexname );
+	if ( g_pFullFileSystem->FileExists( filename, "MOD" ) )
+	{
+		g_pFullFileSystem->RemoveFile( "cache\\cache_temp.lcf", "MOD" );
+	}
+	else
+	{
+		g_pFullFileSystem->RenameFile( "cache\\cache_temp.lcf", filename, "MOD" );
+	}
+
+	INetworkStringTable *downloadables = networkstringtable->FindTable( "downloadables" );
+	downloadables->AddString( true, filename, -1 );
+	IZip::ReleaseZip( pZip );
+	s_lcfFile = 0;
+}
+
+CON_COMMAND(dumpluacachefile, "Dump the contents of the Lua cache file database to the console.")
+{
+	int c = m_LcfDatabase.Count();
+	for ( int i = 0; i < c; i++ )
+	{
+		Msg( "%s: %s\n", m_LcfDatabase.GetElementName( i ), m_LcfDatabase[ i ] );
+	}
+}
+
+#endif
diff --git a/src/game/shared/luacachefile.h b/src/game/shared/luacachefile.h
new file mode 100644
index 0000000..fde120a
--- /dev/null
+++ b/src/game/shared/luacachefile.h
@@ -0,0 +1,31 @@
+//========== Copyleft  2011, Team Sandbox, Some rights reserved. ===========//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#ifndef LUACACHEFILE_H
+#define LUACACHEFILE_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include "zip_utils.h"
+
+// Embedded pack/pak file
+IZip				*luasrc_GetLcfFile( void );
+void				luasrc_AddFileToLcf( const char *pRelativeName, const char *fullpath );
+#ifdef CLIENT_DLL
+void				luasrc_ExtractLcf( void );
+#endif
+
+extern void lcf_recursivedeletefile( const char *current );
+extern void lcf_open (lua_State *L);
+extern void lcf_close (lua_State *L);
+
+#ifndef CLIENT_DLL
+extern void lcf_preparecachefile( void );
+#endif
+
+#endif // LUACACHEFILE_H
diff --git a/src/game/shared/luamanager.cpp b/src/game/shared/luamanager.cpp
new file mode 100644
index 0000000..21a6b73
--- /dev/null
+++ b/src/game/shared/luamanager.cpp
@@ -0,0 +1,821 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: Contains the implementation of Lua for scripting.
+//
+//===========================================================================//
+
+#include "cbase.h"
+#include "filesystem.h"
+#ifndef CLIENT_DLL
+#include "gameinterface.h"
+#endif
+#include "steam/isteamfriends.h"
+#include "networkstringtabledefs.h"
+#ifndef CLIENT_DLL
+#include "basescriptedtrigger.h"
+#endif
+#include "basescripted.h"
+#include "weapon_hl2mpbase_scriptedweapon.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "luacachefile.h"
+#include "lconvar.h"
+#include "licvar.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+ConVar gamemode( "gamemode", "sandbox", FCVAR_ARCHIVE | FCVAR_REPLICATED );
+static char contentSearchPath[MAX_PATH];
+
+static void tag_error (lua_State *L, int narg, int tag) {
+  luaL_typerror(L, narg, lua_typename(L, tag));
+}
+
+
+LUALIB_API int luaL_checkboolean (lua_State *L, int narg) {
+  int d = lua_toboolean(L, narg);
+  if (d == 0 && !lua_isboolean(L, narg))  /* avoid extra test when d is not 0 */
+    tag_error(L, narg, LUA_TBOOLEAN);
+  return d;
+}
+
+
+LUALIB_API int luaL_optboolean (lua_State *L, int narg,
+                                              int def) {
+  return luaL_opt(L, luaL_checkboolean, narg, def);
+}
+
+
+#ifdef CLIENT_DLL
+lua_State *LGameUI;
+#endif
+
+lua_State *L;
+
+// Lua system
+bool g_bLuaInitialized;
+
+static int luasrc_print (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  lua_getglobal(L, "tostring");
+  for (i=1; i<=n; i++) {
+    const char *s;
+    lua_pushvalue(L, -1);  /* function to be called */
+    lua_pushvalue(L, i);   /* value to print */
+    lua_call(L, 1, 1);
+    s = lua_tostring(L, -1);  /* get result */
+    if (s == NULL)
+      return luaL_error(L, LUA_QL("tostring") " must return a string to "
+                           LUA_QL("print"));
+    if (i>1) Msg("\t");
+    Msg(s);
+    lua_pop(L, 1);  /* pop result */
+  }
+  Msg("\n");
+  return 0;
+}
+
+
+static int luasrc_type (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (lua_getmetatable(L, 1)) {
+    lua_pushstring(L, "__type");
+	lua_rawget(L, -2);
+	lua_remove(L, -2);
+	if (!lua_isstring(L, -1))
+	  lua_pop(L, 1);
+	else
+	  return 1;
+  }
+  lua_pushstring(L, luaL_typename(L, 1));
+  return 1;
+}
+
+
+static int luasrc_include (lua_State *L) {
+  lua_Debug ar1;
+  lua_getstack(L, 1, &ar1);
+  lua_getinfo(L, "f", &ar1);
+  lua_Debug ar2;
+  lua_getinfo(L, ">S", &ar2);
+  int iLength = Q_strlen( ar2.source );
+  char source[MAX_PATH];
+  Q_StrRight( ar2.source, iLength-1, source, sizeof( source ) );
+  Q_StripFilename( source );
+  char filename[MAX_PATH];
+  Q_snprintf( filename, sizeof( filename ), "%s\\%s", source, luaL_checkstring(L, 1) );
+  luasrc_dofile(L, filename);
+  return 0;
+}
+
+
+static const luaL_Reg base_funcs[] = {
+  {"print", luasrc_print},
+  {"type", luasrc_type},
+  {"include", luasrc_include},
+  {NULL, NULL}
+};
+
+
+static void base_open (lua_State *L) {
+  /* set global _R */
+  lua_pushvalue(L, LUA_REGISTRYINDEX);
+  lua_setglobal(L, "_R");
+  /* open lib into global table */
+  luaL_register(L, "_G", base_funcs);
+  lua_pop(L, 1);
+  /* set global _E */
+  lua_newtable(L);
+  lua_setglobal(L, "_E");
+#ifdef CLIENT_DLL
+  lua_pushboolean(L, 1);
+  lua_setglobal(L, "_CLIENT");  /* set global _CLIENT */
+#else
+  lua_pushboolean(L, 1);
+  lua_setglobal(L, "_GAME");  /* set global _GAME */
+#endif
+}
+
+
+void luasrc_setmodulepaths(lua_State *L) {
+  lua_getglobal(L, LUA_LOADLIBNAME);
+#ifdef CLIENT_DLL
+	const char *gamePath = engine->GetGameDirectory();
+#else
+	char gamePath[ 256 ];
+	engine->GetGameDir( gamePath, 256 );
+#endif
+
+  //Andrew; set package.cpath.
+  lua_getfield(L, -1, "cpath");
+  //MAX_PATH + package.cpath:len();
+  char lookupCPath[MAX_PATH+99];
+  Q_snprintf( lookupCPath, sizeof( lookupCPath ), "%s\\%s;%s", gamePath,
+#ifdef _WIN32
+    LUA_PATH_MODULES "\\?.dll",
+#elif _LINUX
+    LUA_PATH_MODULES "\\?.so",
+#endif
+	luaL_checkstring(L, -1) );
+  Q_strlower( lookupCPath );
+  Q_FixSlashes( lookupCPath );
+  lua_pop(L, 1);  /* pop result */
+  lua_pushstring(L, lookupCPath);
+  lua_setfield(L, -2, "cpath");
+
+  //Andrew; set package.path.
+  lua_getfield(L, -1, "path");
+  //MAX_PATH + package.path:len();
+  char lookupPath[MAX_PATH+197];
+  Q_snprintf( lookupPath, sizeof( lookupPath ), "%s\\%s;%s", gamePath, LUA_PATH_MODULES "\\?.lua", luaL_checkstring(L, -1) );
+  Q_strlower( lookupPath );
+  Q_FixSlashes( lookupPath );
+  lua_pop(L, 1);  /* pop result */
+  lua_pushstring(L, lookupPath);
+  lua_setfield(L, -2, "path");
+
+  lua_pop(L, 1);  /* pop result */
+}
+
+#ifdef CLIENT_DLL
+void luasrc_init_gameui (void) {
+  LGameUI = luaL_newstate();
+
+  luaL_openlibs(LGameUI);
+  base_open(LGameUI);
+  lua_pushboolean(LGameUI, 1);
+  lua_setglobal(LGameUI, "_GAMEUI");  /* set global _GAMEUI */
+
+  luasrc_setmodulepaths(LGameUI);
+
+  luaopen_ConCommand(LGameUI);
+  luaopen_dbg(LGameUI);
+  luaopen_engine(LGameUI);
+  luaopen_enginevgui(LGameUI);
+  luaopen_FCVAR(LGameUI);
+  luaopen_KeyValues(LGameUI);
+  luaopen_Panel(LGameUI);
+  luaopen_surface(LGameUI);
+  luaopen_vgui(LGameUI);
+}
+
+void luasrc_shutdown_gameui (void) {
+  ResetGameUIConCommandDatabase();
+
+  lua_close(LGameUI);
+}
+#endif
+
+void luasrc_init (void) {
+  if (g_bLuaInitialized)
+	  return;
+  g_bLuaInitialized = true;
+
+  L = lua_open();
+
+  luaL_openlibs(L);
+  base_open(L);
+  lcf_open(L);
+
+  // Andrew; Someone set us up the path for great justice
+  luasrc_setmodulepaths(L);
+
+  luasrc_openlibs(L);
+
+  Msg( "Lua initialized (" LUA_VERSION ")\n" );
+}
+
+void luasrc_shutdown (void) {
+  if (!g_bLuaInitialized)
+	  return;
+
+  g_bLuaInitialized = false;
+
+  filesystem->RemoveSearchPath( contentSearchPath, "MOD" );
+
+  ResetConCommandDatabase();
+
+  RemoveGlobalChangeCallbacks();
+  ResetConVarDatabase();
+
+#ifndef CLIENT_DLL
+  ResetTriggerFactoryDatabase();
+#endif
+  ResetEntityFactoryDatabase();
+  ResetWeaponFactoryDatabase();
+
+  lcf_close(L);
+  lua_close(L);
+}
+
+LUA_API int luasrc_dostring (lua_State *L, const char *string) {
+  int iError = luaL_dostring(L, string);
+  if (iError != 0) {
+    Warning( "%s\n", lua_tostring(L, -1) );
+    lua_pop(L, 1);
+  }
+  return iError;
+}
+
+LUA_API int luasrc_dofile (lua_State *L, const char *filename) {
+  int iError = luaL_dofile(L, filename);
+  if (iError != 0) {
+    Warning( "%s\n", lua_tostring(L, -1) );
+    lua_pop(L, 1);
+  }
+  return iError;
+}
+
+LUA_API void luasrc_dofolder (lua_State *L, const char *path)
+{
+	FileFindHandle_t fh;
+
+	char searchPath[ 512 ];
+	Q_snprintf( searchPath, sizeof( searchPath ), "%s\\*.lua", path );
+
+	char const *fn = g_pFullFileSystem->FindFirstEx( searchPath, "MOD", &fh );
+	while ( fn )
+	{
+		if ( fn[0] != '.' )
+		{
+			char ext[ 10 ];
+			Q_ExtractFileExtension( fn, ext, sizeof( ext ) );
+
+			if ( !Q_stricmp( ext, "lua" ) )
+			{
+				char relative[ 512 ];
+				char loadname[ 512 ];
+				Q_snprintf( relative, sizeof( relative ), "%s\\%s", path, fn );
+				filesystem->RelativePathToFullPath( relative, "MOD", loadname, sizeof( loadname ) );
+				luasrc_dofile( L, loadname );
+			}
+		}
+
+		fn = g_pFullFileSystem->FindNext( fh );
+	}
+	g_pFullFileSystem->FindClose( fh );
+}
+
+LUA_API int luasrc_pcall (lua_State *L, int nargs, int nresults, int errfunc) {
+  int iError = lua_pcall(L, nargs, nresults, errfunc);
+  if (iError != 0) {
+	Warning( "%s\n", lua_tostring(L, -1) );
+	lua_pop(L, 1);
+  }
+  return iError;
+}
+
+LUA_API void luasrc_print(lua_State *L, int narg) {
+  lua_getglobal(L, "tostring");
+  const char *s;
+  lua_pushvalue(L, -1);  /* function to be called */
+  lua_pushvalue(L, narg);   /* value to print */
+  lua_call(L, 1, 1);
+  s = lua_tostring(L, -1);  /* get result */
+  Msg( " %d:\t%s\n", narg, s );
+  lua_pop(L, 1);  /* pop result */
+  lua_pop(L, 1);  /* pop function */
+}
+
+LUA_API void luasrc_dumpstack(lua_State *L) {
+  int n = lua_gettop(L);  /* number of objects */
+  int i;
+  lua_getglobal(L, "tostring");
+  for (i=1; i<=n; i++) {
+	const char *s;
+	lua_pushvalue(L, -1);  /* function to be called */
+	lua_pushvalue(L, i);   /* value to print */
+	lua_call(L, 1, 1);
+	s = lua_tostring(L, -1);  /* get result */
+	Msg( " %d:\t%s\n", i, s );
+	lua_pop(L, 1);  /* pop result */
+  }
+  lua_pop(L, 1);  /* pop function */
+}
+
+void luasrc_LoadEntities (const char *path)
+{
+	FileFindHandle_t fh;
+
+	if ( !path )
+	{
+		path = "";
+	}
+
+	char root[ MAX_PATH ] = { 0 };
+
+	char filename[ MAX_PATH ] = { 0 };
+	char fullpath[ MAX_PATH ] = { 0 };
+	char className[ 255 ] = { 0 };
+
+	Q_snprintf( root, sizeof( root ), "%s" LUA_PATH_ENTITIES "\\*", path );
+
+	char const *fn = g_pFullFileSystem->FindFirstEx( root, "MOD", &fh );
+	while ( fn )
+	{
+		Q_strcpy( className, fn );
+		Q_strlower( className );
+		if ( fn[0] != '.' )
+		{
+			if ( g_pFullFileSystem->FindIsDirectory( fh ) )
+			{
+#ifdef CLIENT_DLL
+				Q_snprintf( filename, sizeof( filename ), "%s" LUA_PATH_ENTITIES "\\%s\\cl_init.lua", path, className );
+#else
+				Q_snprintf( filename, sizeof( filename ), "%s" LUA_PATH_ENTITIES "\\%s\\init.lua", path, className );
+#endif
+				if ( filesystem->FileExists( filename, "MOD" ) )
+				{
+					filesystem->RelativePathToFullPath( filename, "MOD", fullpath, sizeof( fullpath ) );
+					lua_newtable( L );
+					char entDir[ MAX_PATH ];
+					Q_snprintf( entDir, sizeof( entDir ), "entities\\%s", className );
+					lua_pushstring( L, entDir );
+					lua_setfield( L, -2, "__folder" );
+					lua_pushstring( L, LUA_BASE_ENTITY_CLASS );
+					lua_setfield( L, -2, "__base" );
+					lua_pushstring( L, LUA_BASE_ENTITY_FACTORY );
+					lua_setfield( L, -2, "__factory" );
+					lua_setglobal( L, "ENT" );
+					if ( luasrc_dofile( L, fullpath ) == 0 )
+					{
+						lua_getglobal( L, "entity" );
+						if ( lua_istable( L, -1 ) )
+						{
+							lua_getfield( L, -1, "register" );
+							if ( lua_isfunction( L, -1 ) )
+							{
+								lua_remove( L, -2 );
+								lua_getglobal( L, "ENT" );
+								lua_pushstring( L, className );
+								luasrc_pcall( L, 2, 0, 0 );
+								lua_getglobal( L, "ENT" );
+								if ( lua_istable( L, -1 ) )
+								{
+									lua_getfield( L, -1, "__factory" );
+									if ( lua_isstring( L, -1 ) )
+									{
+										const char *pszClassname = lua_tostring( L, -1 );
+										if (Q_strcmp(pszClassname, "CBaseAnimating") == 0)
+											RegisterScriptedEntity( className );
+#ifndef CLIENT_DLL
+										else if (Q_strcmp(pszClassname, "CBaseTrigger") == 0)
+											RegisterScriptedTrigger( className );
+#endif
+									}
+									lua_pop( L, 2 );
+								}
+								else
+								{
+									lua_pop( L, 1 );
+								}
+							}
+							else
+							{
+								lua_pop( L, 2 );
+							}
+						}
+						else
+						{
+							lua_pop( L, 1 );
+						}
+					}
+					lua_pushnil( L );
+					lua_setglobal( L, "ENT" );
+				}
+			}
+		}
+
+		fn = g_pFullFileSystem->FindNext( fh );
+	}
+	g_pFullFileSystem->FindClose( fh );
+}
+
+void luasrc_LoadWeapons (const char *path)
+{
+	FileFindHandle_t fh;
+
+	if ( !path )
+	{
+		path = "";
+	}
+
+	char root[ MAX_PATH ] = { 0 };
+
+	char filename[ MAX_PATH ] = { 0 };
+	char fullpath[ MAX_PATH ] = { 0 };
+	char className[ MAX_WEAPON_STRING ] = { 0 };
+
+	Q_snprintf( root, sizeof( root ), "%s" LUA_PATH_WEAPONS "\\*", path );
+
+	char const *fn = g_pFullFileSystem->FindFirstEx( root, "MOD", &fh );
+	while ( fn )
+	{
+		Q_strcpy( className, fn );
+		Q_strlower( className );
+		if ( fn[0] != '.' )
+		{
+			if ( g_pFullFileSystem->FindIsDirectory( fh ) )
+			{
+#ifdef CLIENT_DLL
+				Q_snprintf( filename, sizeof( filename ), "%s" LUA_PATH_WEAPONS "\\%s\\cl_init.lua", path, className );
+#else
+				Q_snprintf( filename, sizeof( filename ), "%s" LUA_PATH_WEAPONS "\\%s\\init.lua", path, className );
+#endif
+				if ( filesystem->FileExists( filename, "MOD" ) )
+				{
+					filesystem->RelativePathToFullPath( filename, "MOD", fullpath, sizeof( fullpath ) );
+					lua_newtable( L );
+					char entDir[ MAX_PATH ];
+					Q_snprintf( entDir, sizeof( entDir ), "weapons\\%s", className );
+					lua_pushstring( L, entDir );
+					lua_setfield( L, -2, "__folder" );
+					lua_pushstring( L, LUA_BASE_WEAPON );
+					lua_setfield( L, -2, "__base" );
+					lua_setglobal( L, "SWEP" );
+					if ( luasrc_dofile( L, fullpath ) == 0 )
+					{
+						lua_getglobal( L, "weapon" );
+						if ( lua_istable( L, -1 ) )
+						{
+							lua_getfield( L, -1, "register" );
+							if ( lua_isfunction( L, -1 ) )
+							{
+								lua_remove( L, -2 );
+								lua_getglobal( L, "SWEP" );
+								lua_pushstring( L, className );
+								luasrc_pcall( L, 2, 0, 0 );
+								RegisterScriptedWeapon( className );
+							}
+							else
+							{
+								lua_pop( L, 2 );
+							}
+						}
+						else
+						{
+							lua_pop( L, 1 );
+						}
+					}
+					lua_pushnil( L );
+					lua_setglobal( L, "SWEP" );
+				}
+			}
+		}
+
+		fn = g_pFullFileSystem->FindNext( fh );
+	}
+	g_pFullFileSystem->FindClose( fh );
+}
+
+bool luasrc_LoadGamemode (const char *gamemode) {
+  lua_newtable(L);
+  lua_pushstring(L, "__folder");
+  char gamemodepath[MAX_PATH];
+  Q_snprintf( gamemodepath, sizeof( gamemodepath ), "gamemodes\\%s", gamemode );
+  lua_pushstring(L, gamemodepath);
+  lua_settable(L, -3);
+  lua_setglobal(L, "GM");
+  char filename[MAX_PATH];
+  char fullpath[MAX_PATH];
+#ifdef CLIENT_DLL
+  Q_snprintf( filename, sizeof( filename ), "%s\\gamemode\\cl_init.lua", gamemodepath );
+#else
+  Q_snprintf( filename, sizeof( filename ), "%s\\gamemode\\init.lua", gamemodepath );
+#endif
+  if ( filesystem->FileExists( filename, "MOD" ) )
+  {
+    filesystem->RelativePathToFullPath( filename, "MOD", fullpath, sizeof( fullpath ) );
+	if (luasrc_dofile(L, fullpath) == 0) {
+	  lua_getglobal(L, "gamemode");
+	  lua_getfield(L, -1, "register");
+	  lua_remove(L, -2);
+	  lua_getglobal(L, "GM");
+	  lua_pushstring(L, gamemode);
+	  lua_getfield(L, -2, "__base");
+	  if (lua_isnoneornil(L, -1) && Q_strcmp(gamemode, LUA_BASE_GAMEMODE) != 0) {
+	    lua_pop(L, 1);
+		lua_pushstring(L, LUA_BASE_GAMEMODE);
+	  }
+	  luasrc_pcall(L, 3, 0, 0);
+	  lua_pushnil(L);
+	  lua_setglobal(L, "GM");
+	  return true;
+	}
+	else
+	{
+	  lua_pushnil(L);
+	  lua_setglobal(L, "GM");
+	  Warning( "ERROR: Attempted to load an invalid gamemode!\n" );
+	  return false;
+	}
+  }
+  else
+  {
+    lua_pushnil(L);
+	lua_setglobal(L, "GM");
+	Warning( "ERROR: Attempted to load an invalid gamemode!\n" );
+    return false;
+  }
+}
+
+bool luasrc_SetGamemode (const char *gamemode) {
+  lua_getglobal(L, "gamemode");
+  if (lua_istable(L, -1)) {
+    lua_getfield(L, -1, "get");
+	if (lua_isfunction(L, -1)) {
+	  lua_remove(L, -2);
+	  lua_pushstring(L, gamemode);
+	  luasrc_pcall(L, 1, 1, 0);
+	  lua_setglobal(L, "_GAMEMODE");
+	  Q_snprintf( contentSearchPath, sizeof( contentSearchPath ), "gamemodes\\%s\\content", gamemode );
+	  filesystem->AddSearchPath( contentSearchPath, "MOD" );
+	  char loadPath[MAX_PATH];
+	  Q_snprintf( loadPath, sizeof( loadPath ), "%s\\", contentSearchPath );
+	  luasrc_LoadWeapons( loadPath );
+	  luasrc_LoadEntities( loadPath );
+	  // luasrc_LoadEffects( loadPath );
+	  BEGIN_LUA_CALL_HOOK("Initialize");
+	  END_LUA_CALL_HOOK(0,0);
+	  return true;
+	}
+	else
+	{
+	  lua_pop(L, 2);
+	  Warning( "ERROR: Failed to set gamemode!\n" );
+	  return false;
+	}
+  }
+  else
+  {
+    lua_pop(L, 1);
+	Warning( "ERROR: Failed to load gamemode module!\n" );
+	return false;
+  }
+}
+
+#ifdef LUA_SDK
+#ifdef CLIENT_DLL
+	CON_COMMAND( lua_dostring_cl, "Run a Lua string" )
+	{
+		if ( !g_bLuaInitialized )
+			return;
+
+		if ( args.ArgC() == 1 )
+		{
+			Msg( "Usage: lua_dostring_cl <string>\n" );
+			return;
+		}
+
+		int status = luasrc_dostring( L, args.ArgS() );
+		if (status == 0 && lua_gettop(L) > 0) {  /* any result to print? */
+		  lua_getglobal(L, "print");
+		  lua_insert(L, 1);
+		  if (lua_pcall(L, lua_gettop(L)-1, 0, 0) != 0)
+			Warning("%s", lua_pushfstring(L,
+							  "error calling " LUA_QL("print") " (%s)",
+							  lua_tostring(L, -1)));
+		}
+		lua_settop(L, 0);  /* clear stack */
+	}
+#else
+	CON_COMMAND( lua_dostring, "Run a Lua string" )
+	{
+		if ( !g_bLuaInitialized )
+			return;
+
+		if ( !UTIL_IsCommandIssuedByServerAdmin() )
+			return;
+
+		if ( args.ArgC() == 1 )
+		{
+			Msg( "Usage: lua_dostring <string>\n" );
+			return;
+		}
+
+		int status = luasrc_dostring( L, args.ArgS() );
+		if (status == 0 && lua_gettop(L) > 0) {  /* any result to print? */
+		  lua_getglobal(L, "print");
+		  lua_insert(L, 1);
+		  if (lua_pcall(L, lua_gettop(L)-1, 0, 0) != 0)
+			Warning("%s", lua_pushfstring(L,
+							  "error calling " LUA_QL("print") " (%s)",
+							  lua_tostring(L, -1)));
+		}
+		lua_settop(L, 0);  /* clear stack */
+	}
+#endif
+
+static int DoFileCompletion( const char *partial, char commands[ COMMAND_COMPLETION_MAXITEMS ][ COMMAND_COMPLETION_ITEM_LENGTH ] )
+{
+	int current = 0;
+
+#ifdef CLIENT_DLL
+	const char *cmdname = "lua_dofile_cl";
+#else
+	const char *cmdname = "lua_dofile";
+#endif
+	char *substring = NULL;
+	int substringLen = 0;
+	if ( Q_strstr( partial, cmdname ) && strlen(partial) > strlen(cmdname) + 1 )
+	{
+		substring = (char *)partial + strlen( cmdname ) + 1;
+		substringLen = strlen(substring);
+	}
+	
+	FileFindHandle_t fh;
+
+	char WildCard[ MAX_PATH ] = { 0 };
+	if ( substring == NULL )
+		substring = "";
+	Q_snprintf( WildCard, sizeof( WildCard ), LUA_ROOT "\\%s*", substring );
+	Q_FixSlashes( WildCard );
+	char const *fn = g_pFullFileSystem->FindFirstEx( WildCard, "MOD", &fh );
+	while ( fn && current < COMMAND_COMPLETION_MAXITEMS )
+	{
+		if ( fn[0] != '.' )
+		{
+			char filename[ MAX_PATH ] = { 0 };
+			Q_snprintf( filename, sizeof( filename ), LUA_ROOT "\\%s\\%s", substring, fn );
+			Q_FixSlashes( filename );
+			if ( filesystem->FileExists( filename, "MOD" ) )
+			{
+				Q_snprintf( commands[ current ], sizeof( commands[ current ] ), "%s %s%s", cmdname, substring, fn );
+				current++;
+			}
+		}
+
+		fn = g_pFullFileSystem->FindNext( fh );
+	}
+	g_pFullFileSystem->FindClose( fh );
+
+	return current;
+}
+
+#ifdef CLIENT_DLL
+	CON_COMMAND_F_COMPLETION( lua_dofile_cl, "Load and run a Lua file", 0, DoFileCompletion )
+	{
+		if ( !g_bLuaInitialized )
+			return;
+
+		if ( args.ArgC() == 1 )
+		{
+			Msg( "Usage: lua_dofile_cl <filename>\n" );
+			return;
+		}
+
+		char fullpath[ 512 ] = { 0 };
+		char filename[ 256 ] = { 0 };
+		Q_snprintf( filename, sizeof( filename ), LUA_ROOT "\\%s", args.ArgS() );
+		Q_strlower( filename );
+		Q_FixSlashes( filename );
+		if ( filesystem->FileExists( filename, "MOD" ) )
+		{
+			filesystem->RelativePathToFullPath( filename, "MOD", fullpath, sizeof( fullpath ) );
+		}
+		else
+		{
+			Q_snprintf( fullpath, sizeof( fullpath ), "%s\\" LUA_ROOT "\\%s", engine->GetGameDirectory(), args.ArgS() );
+			Q_strlower( fullpath );
+			Q_FixSlashes( fullpath );
+		}
+
+		if ( Q_strstr( fullpath, ".." ) )
+		{
+			return;
+		}
+		Msg( "Running file %s...\n", args.ArgS() );
+		luasrc_dofile( L, fullpath );
+	}
+#else
+	CON_COMMAND_F_COMPLETION( lua_dofile, "Load and run a Lua file", 0, DoFileCompletion )
+	{
+		if ( !g_bLuaInitialized )
+			return;
+
+		if ( !UTIL_IsCommandIssuedByServerAdmin() )
+			return;
+
+		if ( args.ArgC() == 1 )
+		{
+			Msg( "Usage: lua_dofile <filename>\n" );
+			return;
+		}
+
+		char fullpath[ 512 ] = { 0 };
+		char filename[ 256 ] = { 0 };
+		Q_snprintf( filename, sizeof( filename ), LUA_ROOT "lua\\%s", args.ArgS() );
+		Q_strlower( filename );
+		Q_FixSlashes( filename );
+		if ( filesystem->FileExists( filename, "MOD" ) )
+		{
+			filesystem->RelativePathToFullPath( filename, "MOD", fullpath, sizeof( fullpath ) );
+		}
+		else
+		{
+			// filename is local to game dir for Steam, so we need to prepend game dir for regular file load
+			char gamePath[256];
+			engine->GetGameDir( gamePath, 256 );
+			Q_StripTrailingSlash( gamePath );
+			Q_snprintf( fullpath, sizeof( fullpath ), "%s\\" LUA_ROOT "\\%s", gamePath, args.ArgS() );
+			Q_strlower( fullpath );
+			Q_FixSlashes( fullpath );
+		}
+
+		if ( Q_strstr( fullpath, ".." ) )
+		{
+			return;
+		}
+		Msg( "Running file %s...\n", args.ArgS() );
+		luasrc_dofile( L, fullpath );
+	}
+#endif
+
+#if DEBUG
+#ifdef CLIENT_DLL
+	CON_COMMAND( lua_dumpstack_cl, "Prints the Lua stack" )
+	{
+	  if (!g_bLuaInitialized)
+	    return;
+	  int n = lua_gettop(L);  /* number of objects */
+	  int i;
+	  lua_getglobal(L, "tostring");
+	  for (i=1; i<=n; i++) {
+		const char *s;
+		lua_pushvalue(L, -1);  /* function to be called */
+		lua_pushvalue(L, i);   /* value to print */
+		lua_call(L, 1, 1);
+		s = lua_tostring(L, -1);  /* get result */
+		Warning( " %d:\t%s\n", i, s );
+		lua_pop(L, 1);  /* pop result */
+	  }
+	  lua_pop(L, 1);  /* pop function */
+	  if (n>0)
+	    Warning( "Warning: %d object(s) left on the stack!\n", n );
+	}
+#else
+	CON_COMMAND( lua_dumpstack, "Prints the Lua stack" )
+	{
+	  if (!g_bLuaInitialized)
+	    return;
+	  int n = lua_gettop(L);  /* number of objects */
+	  int i;
+	  lua_getglobal(L, "tostring");
+	  for (i=1; i<=n; i++) {
+		const char *s;
+		lua_pushvalue(L, -1);  /* function to be called */
+		lua_pushvalue(L, i);   /* value to print */
+		lua_call(L, 1, 1);
+		s = lua_tostring(L, -1);  /* get result */
+		Warning( " %d:\t%s\n", i, s );
+		lua_pop(L, 1);  /* pop result */
+	  }
+	  lua_pop(L, 1);  /* pop function */
+	  if (n>0)
+	    Warning( "Warning: %d object(s) left on the stack!\n", n );
+	}
+#endif
+#endif
+#endif
diff --git a/src/game/shared/luamanager.h b/src/game/shared/luamanager.h
new file mode 100644
index 0000000..46e3148
--- /dev/null
+++ b/src/game/shared/luamanager.h
@@ -0,0 +1,341 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LUAMANAGER_H
+#define LUAMANAGER_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include "lua.hpp"
+
+#define LUA_ROOT					"lua" // Can't be "LUA_PATH" because luaconf.h uses it.
+#define LUA_PATH_CACHE				"lua_cache"
+#define LUA_PATH_ADDONS				"addons"
+#define LUA_PATH_ENUM				LUA_ROOT "\\includes\\enum"
+#define LUA_PATH_EXTENSIONS			LUA_ROOT "\\includes\\extensions"
+#define LUA_PATH_MODULES			LUA_ROOT "\\includes\\modules"
+#define LUA_PATH_INCLUDES			LUA_ROOT "\\includes"
+#define LUA_PATH_GAME_CLIENT		LUA_ROOT "\\game\\client"
+#define LUA_PATH_GAME_SERVER		LUA_ROOT "\\game\\server"
+#define LUA_PATH_GAME_SHARED		LUA_ROOT "\\game\\shared"
+#define LUA_PATH_EFFECTS			LUA_ROOT "\\effects"
+#define LUA_PATH_ENTITIES			LUA_ROOT "\\entities"
+#define LUA_PATH_GAMEUI				LUA_ROOT "\\gameui"
+#define LUA_PATH_WEAPONS			LUA_ROOT "\\weapons"
+
+
+#define LUA_BASE_ENTITY_CLASS		"prop_scripted"
+#define LUA_BASE_ENTITY_FACTORY		"CBaseAnimating"
+#define LUA_BASE_WEAPON				"weapon_hl2mpbase_scriptedweapon"
+#define LUA_BASE_GAMEMODE			"deathmatch"
+
+
+#define LUA_MAX_WEAPON_ACTIVITIES	32
+
+
+#pragma warning( disable: 4800 )	// forcing value to bool 'true' or 'false' (performance warning)
+
+#define BEGIN_LUA_SET_ENUM_LIB(L, libraryName) \
+  const char *lib = libraryName; \
+  lua_getglobal(L, "_E"); \
+  lua_newtable(L);
+
+#define lua_pushenum(L, enum, shortname) \
+  lua_pushinteger(L, enum); \
+  lua_setfield(L, -2, shortname);
+
+#define END_LUA_SET_ENUM_LIB(L) \
+  lua_setfield(L, -2, lib); \
+  lua_pop(L, 1);
+
+#define BEGIN_LUA_CALL_HOOK(functionName) \
+  lua_getglobal(L, "hook"); \
+  if (lua_istable(L, -1)) { \
+    lua_getfield(L, -1, "call"); \
+	if (lua_isfunction(L, -1)) { \
+	  lua_remove(L, -2); \
+	  int args = 0; \
+	  lua_pushstring(L, functionName); \
+	  lua_getglobal(L, "_GAMEMODE"); \
+	  args = 2;
+
+#define END_LUA_CALL_HOOK(nArgs, nresults) \
+	  args += nArgs; \
+	  luasrc_pcall(L, args, nresults, 0); \
+	} \
+	else \
+	  lua_pop(L, 2); \
+  } \
+  else \
+    lua_pop(L, 1);
+
+#define BEGIN_LUA_CALL_WEAPON_METHOD(functionName) \
+  lua_getref(L, m_nTableReference); \
+  lua_getfield(L, -1, functionName); \
+  lua_remove(L, -2); \
+  if (lua_isfunction(L, -1)) { \
+    int args = 0; \
+	lua_pushweapon(L, this); \
+	++args;
+
+#define END_LUA_CALL_WEAPON_METHOD(nArgs, nresults) \
+	args += nArgs; \
+	luasrc_pcall(L, args, nresults, 0); \
+  } \
+  else \
+    lua_pop(L, 1);
+
+#define BEGIN_LUA_CALL_WEAPON_HOOK(functionName, pWeapon) \
+  if (pWeapon->IsScripted()) { \
+    lua_getref(L, pWeapon->m_nTableReference); \
+    lua_getfield(L, -1, functionName); \
+    lua_remove(L, -2); \
+    int args = 0; \
+    lua_pushweapon(L, pWeapon); \
+    ++args;
+
+#define END_LUA_CALL_WEAPON_HOOK(nArgs, nresults) \
+    args += nArgs; \
+    luasrc_pcall(L, args, nresults, 0); \
+  }
+
+#define BEGIN_LUA_CALL_ENTITY_METHOD(functionName) \
+  lua_getref(L, m_nTableReference); \
+  lua_getfield(L, -1, functionName); \
+  lua_remove(L, -2); \
+  if (lua_isfunction(L, -1)) { \
+    int args = 0; \
+	lua_pushanimating(L, this); \
+	++args;
+
+#define END_LUA_CALL_ENTITY_METHOD(nArgs, nresults) \
+	args += nArgs; \
+	luasrc_pcall(L, args, nresults, 0); \
+  } \
+  else \
+    lua_pop(L, 1);
+
+#define BEGIN_LUA_CALL_TRIGGER_METHOD(functionName) \
+  lua_getref(L, m_nTableReference); \
+  lua_getfield(L, -1, functionName); \
+  lua_remove(L, -2); \
+  if (lua_isfunction(L, -1)) { \
+    int args = 0; \
+	lua_pushentity(L, this); \
+	++args;
+
+#define END_LUA_CALL_TRIGGER_METHOD(nArgs, nresults) \
+	args += nArgs; \
+	luasrc_pcall(L, args, nresults, 0); \
+  } \
+  else \
+    lua_pop(L, 1);
+
+#define BEGIN_LUA_CALL_PANEL_METHOD(functionName) \
+  if (m_nTableReference >= 0) { \
+    lua_getref(m_lua_State, m_nTableReference); \
+    lua_getfield(m_lua_State, -1, functionName); \
+    lua_remove(m_lua_State, -2); \
+    if (lua_isfunction(m_lua_State, -1)) { \
+      int args = 0; \
+	  lua_pushpanel(m_lua_State, this); \
+	  ++args;
+
+#define END_LUA_CALL_PANEL_METHOD(nArgs, nresults) \
+	  args += nArgs; \
+	  luasrc_pcall(m_lua_State, args, nresults, 0); \
+    } \
+    else \
+      lua_pop(m_lua_State, 1); \
+  }
+
+#define RETURN_LUA_NONE() \
+  if (lua_gettop(L) == 1) { \
+    if (lua_isboolean(L, -1)) { \
+	  bool res = (bool)luaL_checkboolean(L, -1); \
+	  lua_pop(L, 1); \
+	  if (!res) \
+	    return; \
+	} \
+    else \
+	  lua_pop(L, 1); \
+  }
+
+#define RETURN_LUA_PANEL_NONE() \
+  if (lua_gettop(m_lua_State) == 1) { \
+    if (lua_isboolean(m_lua_State, -1)) { \
+	  bool res = (bool)luaL_checkboolean(m_lua_State, -1); \
+	  lua_pop(m_lua_State, 1); \
+	  if (!res) \
+	    return; \
+	} \
+    else \
+	  lua_pop(m_lua_State, 1); \
+  }
+
+#define RETURN_LUA_BOOLEAN() \
+  if (lua_gettop(L) == 1) { \
+    if (lua_isboolean(L, -1)) { \
+	  bool res = (bool)luaL_checkboolean(L, -1); \
+	  lua_pop(L, 1); \
+	  return res; \
+	} \
+    else \
+	  lua_pop(L, 1); \
+  }
+
+#define RETURN_LUA_PANEL_BOOLEAN() \
+  if (lua_gettop(m_lua_State) == 1) { \
+    if (lua_isboolean(m_lua_State, -1)) { \
+	  bool res = (bool)luaL_checkboolean(m_lua_State, -1); \
+	  lua_pop(m_lua_State, 1); \
+	  return res; \
+	} \
+    else \
+	  lua_pop(m_lua_State, 1); \
+  }
+
+#define RETURN_LUA_NUMBER() \
+  if (lua_gettop(L) == 1) { \
+    if (lua_isnumber(L, -1)) { \
+	  float res = luaL_checknumber(L, -1); \
+	  lua_pop(L, 1); \
+	  return res; \
+	} \
+    else \
+	  lua_pop(L, 1); \
+  }
+
+#define RETURN_LUA_INTEGER() \
+  if (lua_gettop(L) == 1) { \
+    if (lua_isnumber(L, -1)) { \
+	  int res = luaL_checkint(L, -1); \
+	  lua_pop(L, 1); \
+	  return res; \
+	} \
+    else \
+	  lua_pop(L, 1); \
+  }
+
+#define RETURN_LUA_ACTIVITY() \
+  if (lua_gettop(L) == 1) { \
+    if (lua_isnumber(L, -1)) { \
+	  int res = luaL_checkint(L, -1); \
+	  lua_pop(L, 1); \
+	  return (Activity)res; \
+	} \
+    else \
+	  lua_pop(L, 1); \
+  }
+
+#define RETURN_LUA_STRING() \
+  if (lua_gettop(L) == 1) { \
+    if (lua_isstring(L, -1)) { \
+	  const char *res = luaL_checkstring(L, -1); \
+	  lua_pop(L, 1); \
+	  return res; \
+	} \
+    else \
+	  lua_pop(L, 1); \
+  }
+
+#define RETURN_LUA_WEAPON() \
+  if (lua_gettop(L) == 1) { \
+    if (lua_isuserdata(L, -1) && luaL_checkudata(L, -1, "CBaseCombatWeapon")) { \
+	  CBaseCombatWeapon *res = luaL_checkweapon(L, -1); \
+	  lua_pop(L, 1); \
+	  return res; \
+	} \
+    else \
+	  lua_pop(L, 1); \
+  }
+
+#define RETURN_LUA_ENTITY() \
+  if (lua_gettop(L) == 1) { \
+    if (lua_isuserdata(L, -1) && luaL_checkudata(L, -1, "CBaseEntity")) { \
+	  CBaseEntity *res = luaL_checkentity(L, -1); \
+	  lua_pop(L, 1); \
+	  return res; \
+	} \
+    else \
+	  lua_pop(L, 1); \
+  }
+
+#define RETURN_LUA_PLAYER() \
+  if (lua_gettop(L) == 1) { \
+    if (lua_isuserdata(L, -1) && luaL_checkudata(L, -1, "CBasePlayer")) { \
+	  CBasePlayer *res = luaL_checkplayer(L, -1); \
+	  lua_pop(L, 1); \
+	  return res; \
+	} \
+    else \
+	  lua_pop(L, 1); \
+  }
+
+#define RETURN_LUA_VECTOR() \
+  if (lua_gettop(L) == 1) { \
+    if (lua_isuserdata(L, -1) && luaL_checkudata(L, -1, "Vector")) { \
+	  Vector res = luaL_checkvector(L, -1); \
+	  lua_pop(L, 1); \
+	  return res; \
+	} \
+    else \
+	  lua_pop(L, 1); \
+  }
+
+#define RETURN_LUA_ANGLE() \
+  if (lua_gettop(L) == 1) { \
+    if (lua_isuserdata(L, -1) && luaL_checkudata(L, -1, "QAngle")) { \
+	  QAngle res = luaL_checkangle(L, -1); \
+	  lua_pop(L, 1); \
+	  return res; \
+	} \
+    else \
+	  lua_pop(L, 1); \
+  }
+
+extern ConVar gamemode;
+
+LUALIB_API int luaL_checkboolean (lua_State *L, int narg);
+LUALIB_API int luaL_optboolean (lua_State *L, int narg,
+                                              int def);
+
+#ifdef CLIENT_DLL
+extern lua_State *LGameUI; // gameui state
+#endif
+
+extern lua_State *L;
+
+
+// Set to true between LevelInit and LevelShutdown.
+extern bool	g_bLuaInitialized;
+
+#ifdef CLIENT_DLL
+void       luasrc_init_gameui (void);
+void       luasrc_shutdown_gameui (void);
+#endif
+
+void       luasrc_init (void);
+void       luasrc_shutdown (void);
+
+LUA_API int   (luasrc_dostring) (lua_State *L, const char *string);
+LUA_API int   (luasrc_dofile) (lua_State *L, const char *filename);
+LUA_API void  (luasrc_dofolder) (lua_State *L, const char *path);
+
+LUA_API int   (luasrc_pcall) (lua_State *L, int nargs, int nresults, int errfunc);
+LUA_API void  (luasrc_print) (lua_State *L, int narg);
+LUA_API void  (luasrc_dumpstack) (lua_State *L);
+
+// void    luasrc_LoadEffects (const char *path = 0);
+void       luasrc_LoadEntities (const char *path = 0);
+void       luasrc_LoadWeapons (const char *path = 0);
+
+bool       luasrc_LoadGamemode (const char *gamemode);
+bool       luasrc_SetGamemode (const char *gamemode);
+
+#endif // LUAMANAGER_H
diff --git a/src/game/shared/luasrclib.h b/src/game/shared/luasrclib.h
new file mode 100644
index 0000000..d74fb36
--- /dev/null
+++ b/src/game/shared/luasrclib.h
@@ -0,0 +1,194 @@
+//========== Copyleft  2011, Team Sandbox, Some rights reserved. ===========//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+
+#ifndef LUASRCLIB_H
+#define LUASRCLIB_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+#define LUA_BASEANIMATINGLIBNAME		"CBaseAnimating"
+LUALIB_API int (luaopen_CBaseAnimating) (lua_State *L);
+
+#define LUA_BASECOMBATWEAPONLIBNAME		"CBaseCombatWeapon"
+LUALIB_API int (luaopen_CBaseCombatWeapon) (lua_State *L);
+
+#define LUA_BASEENTITYLIBNAME			"CBaseEntity"
+LUALIB_API int (luaopen_CBaseEntity) (lua_State *L);
+LUALIB_API int (luaopen_CBaseEntity_shared) (lua_State *L);
+
+#define LUA_BASEPLAYERLIBNAME			"CBasePlayer"
+LUALIB_API int (luaopen_CBasePlayer) (lua_State *L);
+LUALIB_API int (luaopen_CBasePlayer_shared) (lua_State *L);
+
+#define LUA_EFFECTDATALIBNAME			"CEffectData"
+LUALIB_API int (luaopen_CEffectData) (lua_State *L);
+
+#define LUA_GAMETRACELIBNAME			"CGameTrace"
+LUALIB_API int (luaopen_CGameTrace) (lua_State *L);
+
+#define LUA_HL2MPPLAYERLIBNAME			"CHL2MP_Player"
+LUALIB_API int (luaopen_CHL2MP_Player) (lua_State *L);
+LUALIB_API int (luaopen_CHL2MP_Player_shared) (lua_State *L);
+
+#define LUA_COLORLIBNAME				"Color"
+LUALIB_API int (luaopen_Color) (lua_State *L);
+
+#define LUA_CONCOMMANDLIBNAME			"ConCommand"
+LUALIB_API int (luaopen_ConCommand) (lua_State *L);
+
+#define LUA_CONTENTSLIBNAME				"CONTENTS"
+LUALIB_API int (luaopen_CONTENTS) (lua_State *L);
+
+#define LUA_CONVARLIBNAME				"ConVar"
+LUALIB_API int (luaopen_ConVar) (lua_State *L);
+
+#define LUA_PASFILTERLIBNAME			"CPASFilter"
+LUALIB_API int (luaopen_CPASFilter) (lua_State *L);
+
+#define LUA_RECIPIENTFILTERLIBNAME		"CRecipientFilter"
+LUALIB_API int (luaopen_CRecipientFilter) (lua_State *L);
+
+#define LUA_TAKEDAMAGEINFOLIBNAME		"CTakeDamageInfo"
+LUALIB_API int (luaopen_CTakeDamageInfo) (lua_State *L);
+
+#define LUA_CVARLIBNAME					"cvar"
+LUALIB_API int (luaopen_cvar) (lua_State *L);
+
+#define LUA_DBGLIBNAME					"dbg"
+LUALIB_API int (luaopen_dbg) (lua_State *L);
+
+#define LUA_DEBUGOVERLAYLIBNAME			"debugoverlay"
+LUALIB_API int (luaopen_debugoverlay) (lua_State *L);
+
+#define LUA_ENGINELIBNAME				"engine"
+LUALIB_API int (luaopen_engine) (lua_State *L);
+
+#define LUA_ENGINEVGUILIBNAME			"enginevgui"
+LUALIB_API int (luaopen_enginevgui) (lua_State *L);
+
+#define LUA_FCVARLIBNAME				"FCVAR"
+LUALIB_API int (luaopen_FCVAR) (lua_State *L);
+
+#define LUA_FILESYSTEMLIBNAME			"filesystem"
+LUALIB_API int (luaopen_filesystem) (lua_State *L);
+
+#define LUA_FONTFLAGLIBNAME				"FONTFLAG"
+LUALIB_API int (luaopen_FONTFLAG) (lua_State *L);
+
+#define LUA_ENTLISTLIBNAME				"gEntList"
+LUALIB_API int (luaopen_gEntList) (lua_State *L);
+
+#define LUA_GLOBALSLIBNAME				"gpGlobals"
+LUALIB_API int (luaopen_gpGlobals) (lua_State *L);
+
+#define LUA_CLIENTSHADOWMGRLIBNAME		"g_pClientShadowMgr"
+LUALIB_API int (luaopen_g_pClientShadowMgr) (lua_State *L);
+
+#define LUA_FONTLIBNAME					"HFont"
+LUALIB_API int (luaopen_HFont) (lua_State *L);
+
+#define LUA_HSCHEMELIBNAME				"HScheme"
+LUALIB_API int (luaopen_HScheme) (lua_State *L);
+
+#define LUA_MATERIALLIBNAME				"IMaterial"
+LUALIB_API int (luaopen_IMaterial) (lua_State *L);
+
+#define LUA_MOVEHELPERLIBNAME			"IMoveHelper"
+LUALIB_API int (luaopen_IMoveHelper) (lua_State *L);
+
+#define LUA_INLIBNAME					"IN"
+LUALIB_API int (luaopen_IN) (lua_State *L);
+
+#define LUA_NETCHANNELINFOLIBNAME		"INetChannelInfo"
+LUALIB_API int (luaopen_INetChannelInfo) (lua_State *L);
+
+#define LUA_INETWORKSTRINGTABLELIBNAME	"INetworkStringTable"
+LUALIB_API int (luaopen_INetworkStringTable) (lua_State *L);
+
+#define LUA_INPUTLIBNAME				"input"
+LUALIB_API int (luaopen_input) (lua_State *L);
+
+#define LUA_PHYSICSOBJECTLIBNAME		"IPhysicsObject"
+LUALIB_API int (luaopen_IPhysicsObject) (lua_State *L);
+
+#define LUA_PHYSICSSURFACEPROPSLIBNAME	"IPhysicsSurfaceProps"
+LUALIB_API int (luaopen_IPhysicsSurfaceProps) (lua_State *L);
+
+#define LUA_PREDICTIONSYSTEMLIBNAME		"IPredictionSystem"
+LUALIB_API int (luaopen_IPredictionSystem) (lua_State *L);
+
+#define LUA_ISCHEMELIBNAME				"IScheme"
+LUALIB_API int (luaopen_IScheme) (lua_State *L);
+
+#define LUA_STEAMFRIENDSLIBNAME			"ISteamFriends"
+LUALIB_API int (luaopen_ISteamFriends) (lua_State *L);
+
+#define LUA_KEYVALUESLIBNAME			"KeyValues"
+LUALIB_API int (luaopen_KeyValues) (lua_State *L);
+
+#define LUA_MASKLIBNAME					"MASK"
+LUALIB_API int (luaopen_MASK) (lua_State *L);
+
+#define LUA_MATHLIBLIBNAME				"mathlib"
+LUALIB_API int (luaopen_mathlib) (lua_State *L);
+
+#define LUA_MATRIXLIBNAME				"matrix3x4_t"
+LUALIB_API int (luaopen_matrix3x4_t) (lua_State *L);
+
+#define LUA_NETWORKSTRINGTABLELIBNAME	"networkstringtable"
+LUALIB_API int (luaopen_networkstringtable) (lua_State *L);
+
+#define LUA_PANELLIBNAME				"Panel"
+LUALIB_API int (luaopen_Panel) (lua_State *L);
+
+#define LUA_PHYSENVLIBNAME				"physenv"
+LUALIB_API int (luaopen_physenv) (lua_State *L);
+
+#define LUA_PREDICTIONLIBNAME			"prediction"
+LUALIB_API int (luaopen_prediction) (lua_State *L);
+
+#define LUA_QANGLELIBNAME				"QAngle"
+LUALIB_API int (luaopen_QAngle) (lua_State *L);
+
+#define LUA_RANDOMLIBNAME				"random"
+LUALIB_API int (luaopen_random) (lua_State *L);
+
+#define LUA_SCHEMELIBNAME				"scheme"
+LUALIB_API int (luaopen_scheme) (lua_State *L);
+
+#define LUA_STEAMAPICONTEXTLIBNAME		"steamapicontext"
+LUALIB_API int (luaopen_steamapicontext) (lua_State *L);
+
+#define LUA_SURFLIBNAME					"SURF"
+LUALIB_API int (luaopen_SURF) (lua_State *L);
+
+#define LUA_SURFACELIBNAME				"surface"
+LUALIB_API int (luaopen_surface) (lua_State *L);
+
+#define LUA_UTILLIBNAME					"UTIL"
+LUALIB_API int (luaopen_UTIL) (lua_State *L);
+LUALIB_API int (luaopen_UTIL_shared) (lua_State *L);
+
+#define LUA_VECTORLIBNAME				"Vector"
+LUALIB_API int (luaopen_Vector) (lua_State *L);
+
+#define LUA_VGUILIBNAME					"vgui"
+LUALIB_API int (luaopen_vgui) (lua_State *L);
+
+#define LUA_VMATRIXLIBNAME				"vmatrix"
+LUALIB_API int (luaopen_VMatrix) (lua_State *L);
+
+
+/* open all Source Engine libraries */
+LUALIB_API void (luasrc_openlibs) (lua_State *L); 
+
+
+
+#endif // LUASRCLIB_H
diff --git a/src/game/shared/lutil_shared.cpp b/src/game/shared/lutil_shared.cpp
new file mode 100644
index 0000000..340d492
--- /dev/null
+++ b/src/game/shared/lutil_shared.cpp
@@ -0,0 +1,190 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+//=============================================================================//
+
+#define lutil_shared_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "lbaseentity_shared.h"
+#include "lbaseplayer_shared.h"
+#include "lgametrace.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+
+static int luasrc_UTIL_VecToYaw (lua_State *L) {
+  lua_pushnumber(L, UTIL_VecToYaw(luaL_checkvector(L, 1)));
+  return 1;
+}
+
+static int luasrc_UTIL_VecToPitch (lua_State *L) {
+  lua_pushnumber(L, UTIL_VecToPitch(luaL_checkvector(L, 1)));
+  return 1;
+}
+
+static int luasrc_UTIL_YawToVector (lua_State *L) {
+  Vector v = UTIL_YawToVector(luaL_checknumber(L, 1));
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int luasrc_SharedRandomFloat (lua_State *L) {
+  lua_pushnumber(L, SharedRandomFloat(luaL_checkstring(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_optint(L, 4, 0)));
+  return 1;
+}
+
+static int luasrc_SharedRandomInt (lua_State *L) {
+  lua_pushinteger(L, SharedRandomInt(luaL_checkstring(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_optint(L, 4, 0)));
+  return 1;
+}
+
+static int luasrc_SharedRandomVector (lua_State *L) {
+  lua_pushvector(L, SharedRandomVector(luaL_checkstring(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_optint(L, 4, 0)));
+  return 1;
+}
+
+static int luasrc_SharedRandomAngle (lua_State *L) {
+  lua_pushangle(L, SharedRandomAngle(luaL_checkstring(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_optint(L, 4, 0)));
+  return 1;
+}
+
+static int luasrc_UTIL_TraceLine (lua_State *L) {
+  UTIL_TraceLine(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkint(L, 3), lua_toentity(L, 4), luaL_checkint(L, 5), &luaL_checktrace(L, 6));
+  return 0;
+}
+
+static int luasrc_UTIL_TraceHull (lua_State *L) {
+  UTIL_TraceHull(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkvector(L, 4), luaL_checkint(L, 5), luaL_checkentity(L, 6), luaL_checkint(L, 7), &luaL_checktrace(L, 8));
+  return 0;
+}
+
+static int luasrc_UTIL_TraceEntity (lua_State *L) {
+  UTIL_TraceEntity(luaL_checkentity(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkint(L, 4), luaL_checkentity(L, 5), luaL_checkint(L, 5), &luaL_checktrace(L, 6));
+  return 0;
+}
+
+static int luasrc_UTIL_EntityHasMatchingRootParent (lua_State *L) {
+  lua_pushboolean(L, UTIL_EntityHasMatchingRootParent(luaL_checkentity(L, 1), luaL_checkentity(L, 2)));
+  return 1;
+}
+
+static int luasrc_UTIL_PointContents (lua_State *L) {
+  lua_pushinteger(L, UTIL_PointContents(luaL_checkvector(L, 1)));
+  return 1;
+}
+
+static int luasrc_UTIL_TraceModel (lua_State *L) {
+  UTIL_TraceModel(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkvector(L, 4), luaL_checkentity(L, 5), luaL_checkint(L, 6), &luaL_checktrace(L, 7));
+  return 0;
+}
+
+static int luasrc_UTIL_ParticleTracer (lua_State *L) {
+  UTIL_ParticleTracer(luaL_checkstring(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_optint(L, 4, 0), luaL_optint(L, 5, 0), luaL_optboolean(L, 6, 0));
+  return 0;
+}
+
+static int luasrc_UTIL_Tracer (lua_State *L) {
+  UTIL_Tracer(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_optint(L, 3, 0), luaL_optint(L, 4, -1), luaL_optnumber(L, 5, 0), luaL_optboolean(L, 6, 0), luaL_optstring(L, 7, 0), luaL_optint(L, 8, 0));
+  return 0;
+}
+
+static int luasrc_UTIL_BloodDrips (lua_State *L) {
+  UTIL_BloodDrips(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int luasrc_UTIL_IsLowViolence (lua_State *L) {
+  lua_pushboolean(L, UTIL_IsLowViolence());
+  return 1;
+}
+
+static int luasrc_UTIL_ShouldShowBlood (lua_State *L) {
+  lua_pushboolean(L, UTIL_ShouldShowBlood(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int luasrc_UTIL_BloodImpact (lua_State *L) {
+  UTIL_BloodImpact(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int luasrc_UTIL_BloodDecalTrace (lua_State *L) {
+  UTIL_BloodDecalTrace(&luaL_checktrace(L, 1), luaL_checkint(L, 2));
+  return 0;
+}
+
+static int luasrc_UTIL_DecalTrace (lua_State *L) {
+  UTIL_DecalTrace(&luaL_checktrace(L, 1), luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int luasrc_UTIL_IsSpaceEmpty (lua_State *L) {
+  lua_pushboolean(L, UTIL_IsSpaceEmpty(luaL_checkentity(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3)));
+  return 1;
+}
+
+static int luasrc_UTIL_PlayerByIndex (lua_State *L) {
+  lua_pushplayer(L, UTIL_PlayerByIndex(luaL_checkint(L, 1)));
+  return 1;
+}
+
+
+static const luaL_Reg util_funcs[] = {
+  // {"UTIL_VecToYaw",  luasrc_UTIL_VecToYaw},
+  {"VecToYaw",  luasrc_UTIL_VecToYaw},
+  // {"UTIL_VecToPitch",  luasrc_UTIL_VecToPitch},
+  {"VecToPitch",  luasrc_UTIL_VecToPitch},
+  // {"UTIL_YawToVector",  luasrc_UTIL_YawToVector},
+  {"YawToVector",  luasrc_UTIL_YawToVector},
+  {"SharedRandomFloat",  luasrc_SharedRandomFloat},
+  {"SharedRandomInt",  luasrc_SharedRandomInt},
+  {"SharedRandomVector",  luasrc_SharedRandomVector},
+  {"SharedRandomAngle",  luasrc_SharedRandomAngle},
+  // {"UTIL_TraceLine",  luasrc_UTIL_TraceLine},
+  {"TraceLine",  luasrc_UTIL_TraceLine},
+  // {"UTIL_TraceHull",  luasrc_UTIL_TraceHull},
+  {"TraceHull",  luasrc_UTIL_TraceHull},
+  // {"UTIL_TraceEntity",  luasrc_UTIL_TraceEntity},
+  {"TraceEntity",  luasrc_UTIL_TraceEntity},
+  // {"UTIL_EntityHasMatchingRootParent",  luasrc_UTIL_EntityHasMatchingRootParent},
+  {"EntityHasMatchingRootParent",  luasrc_UTIL_EntityHasMatchingRootParent},
+  // {"UTIL_PointContents",  luasrc_UTIL_PointContents},
+  {"PointContents",  luasrc_UTIL_PointContents},
+  // {"UTIL_TraceModel",  luasrc_UTIL_TraceModel},
+  {"TraceModel",  luasrc_UTIL_TraceModel},
+  // {"UTIL_ParticleTracer",  luasrc_UTIL_ParticleTracer},
+  {"ParticleTracer",  luasrc_UTIL_ParticleTracer},
+  // {"UTIL_Tracer",  luasrc_UTIL_Tracer},
+  {"Tracer",  luasrc_UTIL_Tracer},
+  // {"UTIL_IsLowViolence",  luasrc_UTIL_IsLowViolence},
+  {"IsLowViolence",  luasrc_UTIL_IsLowViolence},
+  // {"UTIL_ShouldShowBlood",  luasrc_UTIL_ShouldShowBlood},
+  {"ShouldShowBlood",  luasrc_UTIL_ShouldShowBlood},
+  // {"UTIL_BloodDrips",  luasrc_UTIL_BloodDrips},
+  {"BloodDrips",  luasrc_UTIL_BloodDrips},
+  // {"UTIL_BloodImpact",  luasrc_UTIL_BloodImpact},
+  {"BloodImpact",  luasrc_UTIL_BloodImpact},
+  // {"UTIL_BloodDecalTrace",  luasrc_UTIL_BloodDecalTrace},
+  {"BloodDecalTrace",  luasrc_UTIL_BloodDecalTrace},
+  // {"UTIL_DecalTrace",  luasrc_UTIL_DecalTrace},
+  {"DecalTrace",  luasrc_UTIL_DecalTrace},
+  // {"UTIL_IsSpaceEmpty",  luasrc_UTIL_IsSpaceEmpty},
+  {"IsSpaceEmpty",  luasrc_UTIL_IsSpaceEmpty},
+  // {"UTIL_PlayerByIndex",  luasrc_UTIL_PlayerByIndex},
+  {"PlayerByIndex",  luasrc_UTIL_PlayerByIndex},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_UTIL_shared (lua_State *L) {
+  // luaL_register(L, "_G", util_funcs);
+  luaL_register(L, "UTIL", util_funcs);
+  return 1;
+}
+
diff --git a/src/game/shared/mountaddons.cpp b/src/game/shared/mountaddons.cpp
new file mode 100644
index 0000000..3e838da
--- /dev/null
+++ b/src/game/shared/mountaddons.cpp
@@ -0,0 +1,73 @@
+//========== Copyleft  2011, Team Sandbox, Some rights reserved. ===========//
+//
+// Purpose:
+//
+//===========================================================================//
+
+#include "cbase.h"
+#include "filesystem.h"
+#include "luamanager.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+void MountAddons()
+{
+	// Andrew; mount the Lua cache directory first. We consider this a temporary
+	// addon used across servers
+	char fullpath[ 512 ] = { 0 };
+	bool bGetCurrentDirectory = V_GetCurrentDirectory( fullpath, sizeof( fullpath ) );
+	if ( bGetCurrentDirectory )
+	{
+#ifdef CLIENT_DLL
+		const char *gamePath = engine->GetGameDirectory();
+#else
+		char gamePath[ 256 ];
+		engine->GetGameDir( gamePath, 256 );
+#endif
+		V_SetCurrentDirectory( gamePath );
+	}
+	filesystem->AddSearchPath( LUA_PATH_CACHE, "MOD", PATH_ADD_TO_TAIL );
+	if ( bGetCurrentDirectory )
+		V_SetCurrentDirectory( fullpath );
+
+	FileFindHandle_t fh;
+
+	char relativepath[ MAX_PATH ] = { 0 };
+	char addonName[ 255 ] = { 0 };
+
+	char const *fn = g_pFullFileSystem->FindFirstEx( LUA_PATH_ADDONS "\\*", "MOD", &fh );
+	while ( fn )
+	{
+		Q_strcpy( addonName, fn );
+		if ( fn[0] != '.' )
+		{
+			if ( g_pFullFileSystem->FindIsDirectory( fh ) )
+			{
+#ifdef GAME_DLL
+				Msg( "Mounting addon \"%s\"...\n", addonName );
+#endif
+
+				Q_snprintf( relativepath, sizeof( relativepath ), LUA_PATH_ADDONS "\\%s", addonName );
+				char fullpath[ 512 ] = { 0 };
+				bool bGetCurrentDirectory = V_GetCurrentDirectory( fullpath, sizeof( fullpath ) );
+				if ( bGetCurrentDirectory )
+				{
+#ifdef CLIENT_DLL
+					const char *gamePath = engine->GetGameDirectory();
+#else
+					char gamePath[ 256 ];
+					engine->GetGameDir( gamePath, 256 );
+#endif
+					V_SetCurrentDirectory( gamePath );
+				}
+				filesystem->AddSearchPath( relativepath, "MOD", PATH_ADD_TO_TAIL );
+				if ( bGetCurrentDirectory )
+					V_SetCurrentDirectory( fullpath );
+			}
+		}
+
+		fn = g_pFullFileSystem->FindNext( fh );
+	}
+	g_pFullFileSystem->FindClose( fh );
+}
diff --git a/src/game/shared/mountaddons.h b/src/game/shared/mountaddons.h
new file mode 100644
index 0000000..716e3b3
--- /dev/null
+++ b/src/game/shared/mountaddons.h
@@ -0,0 +1,16 @@
+//========== Copyleft  2011, Team Sandbox, Some rights reserved. ===========//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#ifndef MOUNTADDONS_H
+#define MOUNTADDONS_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+void MountAddons();
+
+#endif // MOUNTADDONS_H
diff --git a/src/game/shared/mountsteamcontent.cpp b/src/game/shared/mountsteamcontent.cpp
new file mode 100644
index 0000000..2d26295
--- /dev/null
+++ b/src/game/shared/mountsteamcontent.cpp
@@ -0,0 +1,194 @@
+//========== Copyleft  2011, Team Sandbox, Some rights reserved. ===========//
+//
+// Purpose:
+//
+//===========================================================================//
+
+#include "cbase.h"
+#include "filesystem.h"
+#include "KeyValues.h"
+#include "mountsteamcontent.h"
+// Andrew; grab only what we need from Open Steamworks.
+#include "SteamTypes.h"
+#include "ISteam006.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+bool Steam_MountSteamContent( int nExtraAppId )
+{
+	CreateInterfaceFn CreateInterface = Sys_GetFactory( "Steam.dll" );
+	if( !CreateInterface )
+		return false;
+
+	int nStatus = 0;
+
+	IAppSystem* pAppSystem = (IAppSystem *)CreateInterface( "SteamDLLAppsystem001", &nStatus );
+	if( !pAppSystem )
+		return false;
+
+	ISteam006* pSteam006 = (ISteam006 *)pAppSystem->QueryInterface( STEAM_INTERFACE_VERSION_006 );
+	if( !pSteam006 )
+		return false;
+
+	TSteamApp App;
+	App.szName = new char[ 255 ];
+	App.uMaxNameChars = 255;
+	App.szLatestVersionLabel = new char[ 255 ];
+	App.uMaxLatestVersionLabelChars = 255;
+	App.szCurrentVersionLabel = new char[ 255 ];
+	App.uMaxCurrentVersionLabelChars = 255;
+	App.szInstallDirName = new char[ 255 ];
+	App.uMaxInstallDirNameChars = 255;
+	App.szUnkString = new char[ 255 ];
+
+	TSteamError Error;
+
+	if( pSteam006->EnumerateApp( nExtraAppId, &App, &Error ) != 1 || Error.eSteamError != eSteamErrorNone )
+	{
+		delete[] App.szName;
+		delete[] App.szLatestVersionLabel;
+		delete[] App.szCurrentVersionLabel;
+		delete[] App.szInstallDirName;
+		delete[] App.szUnkString;
+
+		return false;
+	}
+
+	int bIsAppSubscribed = 0;
+	int Reserved = 0;
+	pSteam006->IsAppSubscribed( nExtraAppId, &bIsAppSubscribed, &Reserved, &Error );
+
+	if ( !bIsAppSubscribed )
+	{
+		return false;
+	}
+
+#ifdef GAME_DLL
+	Msg( "Mounting %s...\n", App.szName );
+#endif
+
+	for( unsigned int n = 0; n < App.uNumDependencies; n++ )
+	{
+		TSteamAppDependencyInfo Info;
+
+		if( pSteam006->EnumerateAppDependency( nExtraAppId, n, &Info, &Error ) != 1 || Error.eSteamError != eSteamErrorNone )
+			continue;
+
+		if( !pSteam006->MountFilesystem( Info.AppId, Info.szMountName, &Error ) || Error.eSteamError != eSteamErrorNone )
+		{
+#ifdef GAME_DLL
+			Warning( "%s\n", Error.szDesc );
+#endif
+		}
+	}
+
+	delete[] App.szName;
+	delete[] App.szLatestVersionLabel;
+	delete[] App.szCurrentVersionLabel;
+	delete[] App.szInstallDirName;
+	delete[] App.szUnkString;
+
+	return true;
+}
+
+typedef struct
+{
+	const char *m_pPathName;
+	int m_nAppId;
+} gamePaths_t;
+gamePaths_t g_GamePaths[10] =
+{
+	{ "hl2",		220 },
+	{ "cstrike",	240 },
+	{ "hl1",		280 },
+	{ "dod",		300 },
+	{ "lostcoast",	340 },
+	{ "hl1mp",		360 },
+	{ "episodic",	380 },
+	{ "portal",		400 },
+	{ "ep2",		420 },
+	{ "tf",			440 }
+};
+
+void AddSearchPathByAppId( int nAppId )
+{
+	for ( int i=0; i < ARRAYSIZE( g_GamePaths ); i++ )
+	{
+		int iVal = g_GamePaths[i].m_nAppId;
+		if ( iVal == 360 )
+		{
+			//Andrew; Half-Life Deathmatch: Source requires Half-Life: Source's path added!!
+			const char *pathName = g_GamePaths[2].m_pPathName;
+			filesystem->AddSearchPath( pathName, "GAME", PATH_ADD_TO_TAIL );
+		}
+		if ( iVal == nAppId )
+		{
+			const char *pathName = g_GamePaths[i].m_pPathName;
+			filesystem->AddSearchPath( pathName, "GAME", PATH_ADD_TO_TAIL );
+		}
+	}
+}
+
+//Andrew; this allows us to mount content the user wants on top of the existing
+//game content which is automatically loaded by the engine, and then by the
+//game code
+void MountUserContent()
+{
+	KeyValues *pMainFile, *pFileSystemInfo;
+#ifdef CLIENT_DLL
+	const char *gamePath = engine->GetGameDirectory();
+#else
+	char gamePath[256];
+	engine->GetGameDir( gamePath, 256 );
+	Q_StripTrailingSlash( gamePath );
+#endif
+
+	pMainFile = new KeyValues( "gamecontent.txt" );
+#ifdef CLIENT_DLL
+#define UTIL_VarArgs VarArgs //Andrew; yep.
+#endif
+//On linux because of case sensitiviy we need to check for both.
+#ifdef _LINUX
+	if ( pMainFile->LoadFromFile( filesystem, UTIL_VarArgs("%s/GameContent.txt", gamePath), "MOD" ) )
+	{
+		pFileSystemInfo = pMainFile->FindKey( "FileSystem" );
+		if (pFileSystemInfo)
+		{
+			for ( KeyValues *pKey = pFileSystemInfo->GetFirstSubKey(); pKey; pKey = pKey->GetNextKey() )
+			{
+				if ( strcmp( pKey->GetName(), "AppId" ) == 0 )
+				{
+					int nExtraContentId = pKey->GetInt();
+					if (nExtraContentId)
+					{
+						AddSearchPathByAppId( nExtraContentId );
+						Steam_MountSteamContent( nExtraContentId );
+					}
+				}
+			}
+		}
+	}
+	else
+#endif
+	if ( pMainFile->LoadFromFile( filesystem, UTIL_VarArgs("%s/gamecontent.txt", gamePath), "MOD" ) )
+	{
+		pFileSystemInfo = pMainFile->FindKey( "FileSystem" );
+		if (pFileSystemInfo)
+		{
+			for ( KeyValues *pKey = pFileSystemInfo->GetFirstSubKey(); pKey; pKey = pKey->GetNextKey() )
+			{
+				if ( strcmp( pKey->GetName(), "AppId" ) == 0 )
+				{
+					int nExtraContentId = pKey->GetInt();
+					if (nExtraContentId)
+					{
+						AddSearchPathByAppId( nExtraContentId );
+						Steam_MountSteamContent( nExtraContentId );
+					}
+				}
+			}
+		}
+	}
+	pMainFile->deleteThis();
+}
diff --git a/src/game/shared/mountsteamcontent.h b/src/game/shared/mountsteamcontent.h
new file mode 100644
index 0000000..d813575
--- /dev/null
+++ b/src/game/shared/mountsteamcontent.h
@@ -0,0 +1,21 @@
+//========== Copyleft  2011, Team Sandbox, Some rights reserved. ===========//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#ifndef MOUNTSTEAMCONTENT_H
+#define MOUNTSTEAMCONTENT_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+//-----------------------------------------------------------------------------
+// Mounts content directly through Steam instead of the engine filesystem
+//-----------------------------------------------------------------------------
+bool Steam_MountSteamContent( int nExtraAppId = -1 );
+
+void MountUserContent();
+
+#endif // MOUNTSTEAMCONTENT_H
diff --git a/src/game/shared/multiplay_gamerules.cpp b/src/game/shared/multiplay_gamerules.cpp
index 907b60e..9f8a3d1 100644
--- a/src/game/shared/multiplay_gamerules.cpp
+++ b/src/game/shared/multiplay_gamerules.cpp
@@ -307,7 +307,52 @@ bool CMultiplayRules::Init()
 #endif
 	}
 
+#endif
+#ifdef LUA_SDK
+	//=========================================================
+	//=========================================================
+	void CMultiplayRules::Think ( void )
+	{
+#ifndef CLIENT_DLL
+		BaseClass::Think();
+		
+		///// Check game rules /////
+
+		if ( g_fGameOver )   // someone else quit the game already
+		{
+			// Tony; wait for intermission to end
+			if ( m_flIntermissionEndTime && ( m_flIntermissionEndTime < gpGlobals->curtime ) )
+				ChangeLevel(); // intermission is over
+			return;
+		}
 
+		float flTimeLimit = mp_timelimit.GetFloat() * 60;
+		float flFragLimit = fraglimit.GetFloat();
+		
+		if ( flTimeLimit != 0 && gpGlobals->curtime >= flTimeLimit )
+		{
+			GoToIntermission();
+			return;
+		}
+
+		if ( flFragLimit )
+		{
+			// check if any player is over the frag limit
+			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
+			{
+				CBasePlayer *pPlayer = UTIL_PlayerByIndex( i );
+
+				if ( pPlayer && pPlayer->FragCount() >= flFragLimit )
+				{
+					GoToIntermission();
+					return;
+				}
+			}
+		}
+#endif
+	}
+#else
+#ifndef CLIENT_DLL
 	//=========================================================
 	//=========================================================
 	void CMultiplayRules::Think ( void )
@@ -348,6 +393,9 @@ bool CMultiplayRules::Init()
 			}
 		}
 	}
+#endif
+#endif
+#ifndef CLIENT_DLL
 
 
 	//=========================================================
diff --git a/src/game/shared/multiplay_gamerules.h b/src/game/shared/multiplay_gamerules.h
index 901ee10..0d89c09 100644
--- a/src/game/shared/multiplay_gamerules.h
+++ b/src/game/shared/multiplay_gamerules.h
@@ -95,8 +95,17 @@ public:
 
 #ifndef CLIENT_DLL
 
+#endif
+#ifdef LUA_SDK
+// GR_Think
+	virtual void Think( void );
+#else
+#ifndef CLIENT_DLL
 // GR_Think
 	virtual void Think( void );
+#endif
+#endif
+#ifndef CLIENT_DLL
 	virtual void RefreshSkillData( bool forceUpdate );
 	virtual bool IsAllowedToSpawn( CBaseEntity *pEntity );
 	virtual bool FAllowFlashlight( void );
diff --git a/src/game/shared/takedamageinfo.h b/src/game/shared/takedamageinfo.h
index b21fb34..5478f34 100644
--- a/src/game/shared/takedamageinfo.h
+++ b/src/game/shared/takedamageinfo.h
@@ -33,6 +33,12 @@ public:
 					CTakeDamageInfo( CBaseEntity *pInflictor, CBaseEntity *pAttacker, CBaseEntity *pWeapon, const Vector &damageForce, const Vector &damagePosition, float flDamage, int bitsDamageType, int iKillType = 0, Vector *reportedPosition = NULL );
 	
 
+#if 0
+#ifdef LUA_SDK
+					CTakeDamageInfo &operator=( const CTakeDamageInfo &from );
+#endif
+#endif
+
 	// Inflictor is the weapon or rocket (or player) that is dealing the damage.
 	CBaseEntity*	GetInflictor() const;
 	void			SetInflictor( CBaseEntity *pInflictor );
@@ -330,6 +336,18 @@ inline void CTakeDamageInfo::CopyDamageToBaseDamage()
 	m_flBaseDamage = m_flDamage;
 }
 
+// Andrew; we need a test case to prove this is necessary
+#if 0
+#ifdef LUA_SDK
+CTakeDamageInfo& CTakeDamageInfo::operator=( const CTakeDamageInfo& from )
+{
+	memcpy( this, &from, sizeof(*this) );
+
+	return *this;
+}
+#endif
+#endif
+
 
 // -------------------------------------------------------------------------------------------------- //
 // Inlines.
diff --git a/src/game/shared/teamplay_gamerules.cpp b/src/game/shared/teamplay_gamerules.cpp
index b7a1ddd..11750da 100644
--- a/src/game/shared/teamplay_gamerules.cpp
+++ b/src/game/shared/teamplay_gamerules.cpp
@@ -61,6 +61,49 @@ void CTeamplayRules::Precache( void )
 	}
 }
 
+#endif
+#ifdef LUA_SDK
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+void CTeamplayRules::Think ( void )
+{
+#ifndef CLIENT_DLL
+	BaseClass::Think();
+
+	///// Check game rules /////
+
+	if ( g_fGameOver )   // someone else quit the game already
+	{
+		BaseClass::Think();
+		return;
+	}
+
+	float flTimeLimit = mp_timelimit.GetFloat() * 60;
+	
+	if ( flTimeLimit != 0 && gpGlobals->curtime >= flTimeLimit )
+	{
+		ChangeLevel();
+		return;
+	}
+
+	float flFragLimit = fraglimit.GetFloat();
+	if ( flFragLimit )
+	{
+		// check if any team is over the frag limit
+		for ( int i = 0; i < num_teams; i++ )
+		{
+			if ( team_scores[i] >= flFragLimit )
+			{
+				ChangeLevel();
+				return;
+			}
+		}
+	}
+#endif
+}
+#else
+#ifndef CLIENT_DLL
 //-----------------------------------------------------------------------------
 // Purpose: 
 //-----------------------------------------------------------------------------
@@ -98,6 +141,9 @@ void CTeamplayRules::Think ( void )
 		}
 	}
 }
+#endif
+#endif
+#ifndef CLIENT_DLL
 
 //=========================================================
 // ClientCommand
diff --git a/src/game/shared/teamplay_gamerules.h b/src/game/shared/teamplay_gamerules.h
index 4f593d8..7952c7c 100644
--- a/src/game/shared/teamplay_gamerules.h
+++ b/src/game/shared/teamplay_gamerules.h
@@ -77,7 +77,15 @@ public:
 	virtual void DeathNotice( CBasePlayer *pVictim, const CTakeDamageInfo &info );
 	virtual const char *GetGameDescription( void ) { return "Teamplay"; }  // this is the game name that gets seen in the server browser
 	virtual void PlayerKilled( CBasePlayer *pVictim, const CTakeDamageInfo &info );
+#endif
+#ifdef LUA_SDK
+	virtual void Think ( void );
+#else
+#ifndef CLIENT_DLL
 	virtual void Think ( void );
+#endif
+#endif
+#ifndef CLIENT_DLL
 	virtual int GetTeamIndex( const char *pTeamName );
 	virtual const char *GetIndexedTeamName( int teamIndex );
 	virtual bool IsValidTeam( const char *pTeamName );
diff --git a/src/game/shared/util_shared.cpp b/src/game/shared/util_shared.cpp
index 1cfd01a..2d539cd 100644
--- a/src/game/shared/util_shared.cpp
+++ b/src/game/shared/util_shared.cpp
@@ -762,6 +762,11 @@ void UTIL_Tracer( const Vector &vecStart, const Vector &vecEnd, int iEntIndex,
 
 void UTIL_BloodDrips( const Vector &origin, const Vector &direction, int color, int amount )
 {
+#ifdef HL2SB
+	//Andrew; see https://developer.valvesoftware.com/wiki/Fixing_AI_in_multiplayer#Blood
+	IPredictionSystem::SuppressHostEvents( NULL );
+#endif
+
 	if ( !UTIL_ShouldShowBlood( color ) )
 		return;
 
diff --git a/src/game/shared/voice_status.cpp b/src/game/shared/voice_status.cpp
index b36f3a8..d9cf944 100644
--- a/src/game/shared/voice_status.cpp
+++ b/src/game/shared/voice_status.cpp
@@ -29,6 +29,10 @@
 #include "tier0/dbg.h"
 #include "cdll_int.h"
 #include <vgui/IPanel.h>
+#ifdef LUA_SDK
+#include "luamanager.h"
+#include "lbaseplayer_shared.h"
+#endif
 
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
@@ -223,6 +227,14 @@ void CVoiceStatus::DrawHeadLabels()
 		if( !pPlayer )
 			continue;
 
+#if defined ( LUA_SDK )
+		BEGIN_LUA_CALL_HOOK( "DrawHeadLabels" );
+			lua_pushplayer( L, pPlayer );
+		END_LUA_CALL_HOOK( 1, 1 );
+
+		RETURN_LUA_NONE();
+#endif
+
 		// Don't show an icon for dead or spectating players (ie: invisible entities).
 		if( pPlayer->IsPlayerDead() )
 			continue;
diff --git a/src/public/XUnzip_src.cpp b/src/public/XUnzip_src.cpp
new file mode 100644
index 0000000..8895f0b
--- /dev/null
+++ b/src/public/XUnzip_src.cpp
@@ -0,0 +1,4369 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+// XUnzip.cpp  Version 1.1
+//
+// Authors:      Mark Adler et al. (see below)
+//
+// Modified by:  Lucian Wischik
+//               lu@wischik.com
+//
+// Version 1.0   - Turned C files into just a single CPP file
+//               - Made them compile cleanly as C++ files
+//               - Gave them simpler APIs
+//               - Added the ability to zip/unzip directly in memory without 
+//                 any intermediate files
+// 
+// Modified by:  Hans Dietrich
+//               hdietrich2@hotmail.com
+//
+// Version 1.1:  - Added Unicode support to CreateZip() and ZipAdd()
+//               - Changed file names to avoid conflicts with Lucian's files
+//
+///////////////////////////////////////////////////////////////////////////////
+//
+// Lucian Wischik's comments:
+// --------------------------
+// THIS FILE is almost entirely based upon code by Info-ZIP.
+// It has been modified by Lucian Wischik.
+// The original code may be found at http://www.info-zip.org
+// The original copyright text follows.
+//
+///////////////////////////////////////////////////////////////////////////////
+//
+// Original authors' comments:
+// ---------------------------
+// This is version 2002-Feb-16 of the Info-ZIP copyright and license. The 
+// definitive version of this document should be available at 
+// ftp://ftp.info-zip.org/pub/infozip/license.html indefinitely.
+// 
+// Copyright (c) 1990-2002 Info-ZIP.  All rights reserved.
+//
+// For the purposes of this copyright and license, "Info-ZIP" is defined as
+// the following set of individuals:
+//
+//   Mark Adler, John Bush, Karl Davis, Harald Denker, Jean-Michel Dubois,
+//   Jean-loup Gailly, Hunter Goatley, Ian Gorman, Chris Herborth, Dirk Haase,
+//   Greg Hartwig, Robert Heath, Jonathan Hudson, Paul Kienitz, 
+//   David Kirschbaum, Johnny Lee, Onno van der Linden, Igor Mandrichenko, 
+//   Steve P. Miller, Sergio Monesi, Keith Owens, George Petrov, Greg Roelofs, 
+//   Kai Uwe Rommel, Steve Salisbury, Dave Smith, Christian Spieler, 
+//   Antoine Verheijen, Paul von Behren, Rich Wales, Mike White
+//
+// This software is provided "as is", without warranty of any kind, express
+// or implied.  In no event shall Info-ZIP or its contributors be held liable
+// for any direct, indirect, incidental, special or consequential damages
+// arising out of the use of or inability to use this software.
+//
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+//
+//    1. Redistributions of source code must retain the above copyright notice,
+//       definition, disclaimer, and this list of conditions.
+//
+//    2. Redistributions in binary form (compiled executables) must reproduce 
+//       the above copyright notice, definition, disclaimer, and this list of 
+//       conditions in documentation and/or other materials provided with the 
+//       distribution. The sole exception to this condition is redistribution 
+//       of a standard UnZipSFX binary as part of a self-extracting archive; 
+//       that is permitted without inclusion of this license, as long as the 
+//       normal UnZipSFX banner has not been removed from the binary or disabled.
+//
+//    3. Altered versions--including, but not limited to, ports to new 
+//       operating systems, existing ports with new graphical interfaces, and 
+//       dynamic, shared, or static library versions--must be plainly marked 
+//       as such and must not be misrepresented as being the original source.  
+//       Such altered versions also must not be misrepresented as being 
+//       Info-ZIP releases--including, but not limited to, labeling of the 
+//       altered versions with the names "Info-ZIP" (or any variation thereof, 
+//       including, but not limited to, different capitalizations), 
+//       "Pocket UnZip", "WiZ" or "MacZip" without the explicit permission of 
+//       Info-ZIP.  Such altered versions are further prohibited from 
+//       misrepresentative use of the Zip-Bugs or Info-ZIP e-mail addresses or 
+//       of the Info-ZIP URL(s).
+//
+//    4. Info-ZIP retains the right to use the names "Info-ZIP", "Zip", "UnZip",
+//       "UnZipSFX", "WiZ", "Pocket UnZip", "Pocket Zip", and "MacZip" for its 
+//       own source and binary releases.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#if defined( PROTECTED_THINGS_ENABLE )
+#undef PROTECTED_THINGS_ENABLE // from protected_things.h
+#endif
+
+#include "cbase.h"
+#include "tier0/platform.h"
+
+#ifdef IS_WINDOWS_PC
+#define STRICT
+#define WIN32_LEAN_AND_MEAN
+#include <winlite.h>
+#endif
+#include <time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <tchar.h>
+#include "zip/XUnzip.h"
+#if defined( _X360 )
+#include "xbox/xbox_win32stubs.h"
+#endif
+
+// THIS FILE is almost entirely based upon code by Jean-loup Gailly
+// and Mark Adler. It has been modified by Lucian Wischik.
+// The original code may be found at http://www.gzip.org/zlib/
+// The original copyright text follows.
+//
+//
+//
+// zlib.h -- interface of the 'zlib' general purpose compression library
+//  version 1.1.3, July 9th, 1998
+//
+//  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler
+//
+//  This software is provided 'as-is', without any express or implied
+//  warranty.  In no event will the authors be held liable for any damages
+//  arising from the use of this software.
+//
+//  Permission is granted to anyone to use this software for any purpose,
+//  including commercial applications, and to alter it and redistribute it
+//  freely, subject to the following restrictions:
+//
+//  1. The origin of this software must not be misrepresented; you must not
+//     claim that you wrote the original software. If you use this software
+//     in a product, an acknowledgment in the product documentation would be
+//     appreciated but is not required.
+//  2. Altered source versions must be plainly marked as such, and must not be
+//     misrepresented as being the original software.
+//  3. This notice may not be removed or altered from any source distribution.
+//
+//  Jean-loup Gailly        Mark Adler
+//  jloup@gzip.org          madler@alumni.caltech.edu
+//
+//
+//  The data format used by the zlib library is described by RFCs (Request for
+//  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
+//  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+//
+//
+//     The 'zlib' compression library provides in-memory compression and
+//  decompression functions, including integrity checks of the uncompressed
+//  data.  This version of the library supports only one compression method
+//  (deflation) but other algorithms will be added later and will have the same
+//  stream interface.
+//
+//     Compression can be done in a single step if the buffers are large
+//  enough (for example if an input file is mmap'ed), or can be done by
+//  repeated calls of the compression function.  In the latter case, the
+//  application must provide more input and/or consume the output
+//  (providing more output space) before each call.
+//
+//     The library also supports reading and writing files in gzip (.gz) format
+//  with an interface similar to that of stdio.
+//
+//     The library does not install any signal handler. The decoder checks
+//  the consistency of the compressed data, so the library should never
+//  crash even in case of corrupted input.
+//
+// for more info about .ZIP format, see ftp://ftp.cdrom.com/pub/infozip/doc/appnote-970311-iz.zip
+//   PkWare has also a specification at ftp://ftp.pkware.com/probdesc.zip
+
+#define zmalloc(len) malloc(len)
+
+#define zfree(p) free(p)
+
+/*
+void *zmalloc(unsigned int len)
+{ char *buf = new char[len+32];
+  for (int i=0; i<16; i++)
+  { buf[i]=i;
+    buf[len+31-i]=i;
+  }
+  *((unsigned int*)buf) = len;
+  char c[1000]; wsprintf(c,"malloc 0x%lx  - %lu",buf+16,len);
+  OutputDebugString(c);
+  return buf+16;
+}
+
+void zfree(void *buf)
+{ char c[1000]; wsprintf(c,"free   0x%lx",buf);
+  OutputDebugString(c);
+  char *p = ((char*)buf)-16;
+  unsigned int len = *((unsigned int*)p);
+  bool blown=false;
+  for (int i=0; i<16; i++)
+  { char lo = p[i];
+    char hi = p[len+31-i];
+    if (hi!=i || (lo!=i && i>4)) blown=true;
+  }
+  if (blown)
+  { OutputDebugString("BLOWN!!!");
+  }
+  delete[] p;
+}
+*/
+
+#pragma warning(disable : 4702)   // unreachable code
+
+typedef struct tm_unz_s
+{ unsigned int tm_sec;            // seconds after the minute - [0,59]
+  unsigned int tm_min;            // minutes after the hour - [0,59]
+  unsigned int tm_hour;           // hours since midnight - [0,23]
+  unsigned int tm_mday;           // day of the month - [1,31]
+  unsigned int tm_mon;            // months since January - [0,11]
+  unsigned int tm_year;           // years - [1980..2044]
+} tm_unz;
+
+
+// unz_global_info structure contain global data about the ZIPfile
+typedef struct unz_global_info_s
+{ unsigned long number_entry;         // total number of entries in the central dir on this disk
+  unsigned long size_comment;         // size of the global comment of the zipfile
+} unz_global_info;
+
+// unz_file_info contain information about a file in the zipfile
+typedef struct unz_file_info_s
+{ unsigned long version;              // version made by                 2 bytes
+  unsigned long version_needed;       // version needed to extract       2 bytes
+  unsigned long flag;                 // general purpose bit flag        2 bytes
+  unsigned long compression_method;   // compression method              2 bytes
+  unsigned long dosDate;              // last mod file date in Dos fmt   4 bytes
+  unsigned long crc;                  // crc-32                          4 bytes
+  unsigned long compressed_size;      // compressed size                 4 bytes
+  unsigned long uncompressed_size;    // uncompressed size               4 bytes
+  unsigned long size_filename;        // filename length                 2 bytes
+  unsigned long size_file_extra;      // extra field length              2 bytes
+  unsigned long size_file_comment;    // file comment length             2 bytes
+  unsigned long disk_num_start;       // disk number start               2 bytes
+  unsigned long internal_fa;          // internal file attributes        2 bytes
+  unsigned long external_fa;          // external file attributes        4 bytes
+  tm_unz tmu_date;
+} unz_file_info;
+
+
+#define UNZ_OK                  (0)
+#define UNZ_END_OF_LIST_OF_FILE (-100)
+#define UNZ_ERRNO               (Z_ERRNO)
+#define UNZ_EOF                 (0)
+#define UNZ_PARAMERROR          (-102)
+#define UNZ_BADZIPFILE          (-103)
+#define UNZ_INTERNALERROR       (-104)
+#define UNZ_CRCERROR            (-105)
+
+
+
+
+
+
+
+#define ZLIB_VERSION "1.1.3"
+
+
+// Allowed flush values; see deflate() for details
+#define Z_NO_FLUSH      0
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+
+
+// compression levels
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+
+// compression strategy; see deflateInit2() for details
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_DEFAULT_STRATEGY    0
+
+// Possible values of the data_type field
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+
+// The deflate compression method (the only one supported in this version)
+#define Z_DEFLATED   8
+
+// for initializing zalloc, zfree, opaque
+#define Z_NULL  0
+
+// case sensitivity when searching for filenames
+#define CASE_SENSITIVE 1
+#define CASE_INSENSITIVE 2
+
+
+// Return codes for the compression/decompression functions. Negative
+// values are errors, positive values are used for special but normal events.
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+
+
+
+// Basic data types
+typedef unsigned char  Byte;  // 8 bits
+typedef unsigned int   uInt;  // 16 bits or more
+typedef unsigned long  uLong; // 32 bits or more
+typedef void *voidpf;
+typedef void     *voidp;
+typedef long z_off_t;
+
+
+
+
+
+
+
+
+
+
+
+
+typedef voidpf (*alloc_func) (voidpf opaque, uInt items, uInt size);
+typedef void   (*free_func)  (voidpf opaque, voidpf address);
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Byte    *next_in;  // next input byte
+    uInt     avail_in;  // number of bytes available at next_in
+    uLong    total_in;  // total nb of input bytes read so far
+
+    Byte    *next_out; // next output byte should be put there
+    uInt     avail_out; // remaining free space at next_out
+    uLong    total_out; // total nb of bytes output so far
+
+    char     *msg;      // last error message, NULL if no error
+    struct internal_state *state; // not visible by applications
+
+    alloc_func zalloc;  // used to allocate the internal state
+    free_func  zfree;   // used to free the internal state
+    voidpf     opaque;  // private data object passed to zalloc and zfree
+
+    int     data_type;  // best guess about the data type: ascii or binary
+    uLong   adler;      // adler32 value of the uncompressed data
+    uLong   reserved;   // reserved for future use
+} z_stream;
+
+typedef z_stream *z_streamp;
+
+
+//   The application must update next_in and avail_in when avail_in has
+//   dropped to zero. It must update next_out and avail_out when avail_out
+//   has dropped to zero. The application must initialize zalloc, zfree and
+//   opaque before calling the init function. All other fields are set by the
+//   compression library and must not be updated by the application.
+//
+//   The opaque value provided by the application will be passed as the first
+//   parameter for calls of zalloc and zfree. This can be useful for custom
+//   memory management. The compression library attaches no meaning to the
+//   opaque value.
+//
+//   zalloc must return Z_NULL if there is not enough memory for the object.
+//   If zlib is used in a multi-threaded application, zalloc and zfree must be
+//   thread safe.
+//
+//   The fields total_in and total_out can be used for statistics or
+//   progress reports. After compression, total_in holds the total size of
+//   the uncompressed data and may be saved for use in the decompressor
+//   (particularly if the decompressor wants to decompress everything in
+//   a single step).
+//
+
+
+// basic functions
+
+const char *zlibVersion ();
+// The application can compare zlibVersion and ZLIB_VERSION for consistency.
+// If the first character differs, the library code actually used is
+// not compatible with the zlib.h header file used by the application.
+// This check is automatically made by inflateInit.
+
+
+
+
+
+
+int inflate (z_streamp strm, int flush);
+//
+//    inflate decompresses as much data as possible, and stops when the input
+//  buffer becomes empty or the output buffer becomes full. It may some
+//  introduce some output latency (reading input without producing any output)
+//  except when forced to flush.
+//
+//  The detailed semantics are as follows. inflate performs one or both of the
+//  following actions:
+//
+//  - Decompress more input starting at next_in and update next_in and avail_in
+//    accordingly. If not all input can be processed (because there is not
+//    enough room in the output buffer), next_in is updated and processing
+//    will resume at this point for the next call of inflate().
+//
+//  - Provide more output starting at next_out and update next_out and avail_out
+//    accordingly.  inflate() provides as much output as possible, until there
+//    is no more input data or no more space in the output buffer (see below
+//    about the flush parameter).
+//
+//  Before the call of inflate(), the application should ensure that at least
+//  one of the actions is possible, by providing more input and/or consuming
+//  more output, and updating the next_* and avail_* values accordingly.
+//  The application can consume the uncompressed output when it wants, for
+//  example when the output buffer is full (avail_out == 0), or after each
+//  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+//  must be called again after making room in the output buffer because there
+//  might be more output pending.
+//
+//    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
+//  output as possible to the output buffer. The flushing behavior of inflate is
+//  not specified for values of the flush parameter other than Z_SYNC_FLUSH
+//  and Z_FINISH, but the current implementation actually flushes as much output
+//  as possible anyway.
+//
+//    inflate() should normally be called until it returns Z_STREAM_END or an
+//  error. However if all decompression is to be performed in a single step
+//  (a single call of inflate), the parameter flush should be set to
+//  Z_FINISH. In this case all pending input is processed and all pending
+//  output is flushed; avail_out must be large enough to hold all the
+//  uncompressed data. (The size of the uncompressed data may have been saved
+//  by the compressor for this purpose.) The next operation on this stream must
+//  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+//  is never required, but can be used to inform inflate that a faster routine
+//  may be used for the single inflate() call.
+//
+//     If a preset dictionary is needed at this point (see inflateSetDictionary
+//  below), inflate sets strm-adler to the adler32 checksum of the
+//  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise
+//  it sets strm->adler to the adler32 checksum of all output produced
+//  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
+//  an error code as described below. At the end of the stream, inflate()
+//  checks that its computed adler32 checksum is equal to that saved by the
+//  compressor and returns Z_STREAM_END only if the checksum is correct.
+//
+//    inflate() returns Z_OK if some progress has been made (more input processed
+//  or more output produced), Z_STREAM_END if the end of the compressed data has
+//  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+//  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+//  corrupted (input stream not conforming to the zlib format or incorrect
+//  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
+//  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
+//  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
+//  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
+//  case, the application may then call inflateSync to look for a good
+//  compression block.
+//
+
+
+int inflateEnd (z_streamp strm);
+//
+//     All dynamically allocated data structures for this stream are freed.
+//   This function discards any unprocessed input and does not flush any
+//   pending output.
+//
+//     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+//   was inconsistent. In the error case, msg may be set but then points to a
+//   static string (which must not be deallocated).
+
+                        // Advanced functions 
+
+//  The following functions are needed only in some special applications.
+
+
+
+
+
+int inflateSetDictionary (z_streamp strm,
+                                             const Byte *dictionary,
+                                             uInt  dictLength);
+//
+//     Initializes the decompression dictionary from the given uncompressed byte
+//   sequence. This function must be called immediately after a call of inflate
+//   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
+//   can be determined from the Adler32 value returned by this call of
+//   inflate. The compressor and decompressor must use exactly the same
+//   dictionary. 
+//
+//     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+//   parameter is invalid (such as NULL dictionary) or the stream state is
+//   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+//   expected one (incorrect Adler32 value). inflateSetDictionary does not
+//   perform any decompression: this will be done by subsequent calls of
+//   inflate().
+
+
+int inflateSync (z_streamp strm);
+// 
+//    Skips invalid compressed data until a full flush point can be found, or until all
+//  available input is skipped. No output is provided.
+//
+//    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+//  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+//  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+//  case, the application may save the current current value of total_in which
+//  indicates where valid compressed data was found. In the error case, the
+//  application may repeatedly call inflateSync, providing more input each time,
+//  until success or end of the input data.
+
+
+int inflateReset (z_streamp strm);
+//     This function is equivalent to inflateEnd followed by inflateInit,
+//   but does not free and reallocate all the internal decompression state.
+//   The stream will keep attributes that may have been set by inflateInit2.
+//
+//      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+//   stream state was inconsistent (such as zalloc or state being NULL).
+//
+
+
+
+// checksum functions
+// These functions are not related to compression but are exported
+// anyway because they might be useful in applications using the
+// compression library.
+
+uLong adler32 (uLong adler, const Byte *buf, uInt len);
+//     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+//   return the updated checksum. If buf is NULL, this function returns
+//   the required initial value for the checksum.
+//   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+//   much faster. Usage example:
+//
+//     uLong adler = adler32(0L, Z_NULL, 0);
+//
+//     while (read_buffer(buffer, length) != EOF) {
+//       adler = adler32(adler, buffer, length);
+//     }
+//     if (adler != original_adler) error();
+
+uLong ucrc32   (uLong crc, const Byte *buf, uInt len);
+//     Update a running crc with the bytes buf[0..len-1] and return the updated
+//   crc. If buf is NULL, this function returns the required initial value
+//   for the crc. Pre- and post-conditioning (one's complement) is performed
+//   within this function so it shouldn't be done by the application.
+//   Usage example:
+//
+//     uLong crc = crc32(0L, Z_NULL, 0);
+//
+//     while (read_buffer(buffer, length) != EOF) {
+//       crc = crc32(crc, buffer, length);
+//     }
+//     if (crc != original_crc) error();
+
+
+
+
+const char   *zError           (int err);
+int           inflateSyncPoint (z_streamp z);
+const uLong *get_crc_table    (void);
+
+
+
+typedef unsigned char  uch;
+typedef uch uchf;
+typedef unsigned short ush;
+typedef ush ushf;
+typedef unsigned long  ulg;
+
+
+
+const char * const z_errmsg[10] = { // indexed by 2-zlib_error
+"need dictionary",     // Z_NEED_DICT       2
+"stream end",          // Z_STREAM_END      1
+"",                    // Z_OK              0
+"file error",          // Z_ERRNO         (-1)
+"stream error",        // Z_STREAM_ERROR  (-2)
+"data error",          // Z_DATA_ERROR    (-3)
+"insufficient memory", // Z_MEM_ERROR     (-4)
+"buffer error",        // Z_BUF_ERROR     (-5)
+"incompatible version",// Z_VERSION_ERROR (-6)
+""};
+
+
+#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
+
+#define ERR_RETURN(strm,err) \
+  return (strm->msg = (char*)ERR_MSG(err), (err))
+// To be used only when the state is known to be valid 
+
+        // common constants
+
+
+#define STORED_BLOCK 0
+#define STATIC_TREES 1
+#define DYN_TREES    2
+// The three kinds of block type 
+
+#define MIN_MATCH  3
+#define MAX_MATCH  258
+// The minimum and maximum match lengths 
+
+#define PRESET_DICT 0x20 // preset dictionary flag in zlib header 
+
+        // target dependencies 
+
+#define OS_CODE  0x0b  // Window 95 & Windows NT
+
+
+
+         // functions 
+
+#define zmemzero(dest, len) memset(dest, 0, len)
+
+// Diagnostic functions
+#undef Assert
+#undef Trace
+#undef Tracev
+#undef Tracevv
+#undef Tracec
+#undef Tracecv
+
+#ifdef DEBUG
+  int z_verbose = 0;
+  void z_error (char *m) {fprintf(stderr, "%s\n", m); exit(1);}
+#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
+#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
+#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
+#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+
+typedef uLong (*check_func) (uLong check, const Byte *buf, uInt len);
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size);
+void   zcfree  (voidpf opaque, voidpf ptr);
+
+#define ZALLOC(strm, items, size) \
+           (*((strm)->zalloc))((strm)->opaque, (items), (size))
+#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
+
+//void ZFREE(z_streamp strm,voidpf addr)
+//{ *((strm)->zfree))((strm)->opaque, addr);
+//}
+
+#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
+
+
+
+
+// Huffman code lookup table entry--this entry is four bytes for machines
+// that have 16-bit pointers (e.g. PC's in the small or medium model).
+
+
+typedef struct inflate_huft_s inflate_huft;
+
+struct inflate_huft_s {
+  union {
+    struct {
+      Byte Exop;        // number of extra bits or operation
+      Byte Bits;        // number of bits in this code or subcode
+    } what;
+    uInt pad;           // pad structure to a power of 2 (4 bytes for
+  } word;               //  16-bit, 8 bytes for 32-bit int's)
+  uInt base;            // literal, length base, distance base, or table offset
+};
+
+// Maximum size of dynamic tree.  The maximum found in a long but non-
+//   exhaustive search was 1004 huft structures (850 for length/literals
+//   and 154 for distances, the latter actually the result of an
+//   exhaustive search).  The actual maximum is not known, but the
+//   value below is more than safe.
+#define MANY 1440
+
+int inflate_trees_bits (
+    uInt *,                    // 19 code lengths
+    uInt *,                    // bits tree desired/actual depth
+    inflate_huft * *,       // bits tree result
+    inflate_huft *,             // space for trees
+    z_streamp);                // for messages
+
+int inflate_trees_dynamic (
+    uInt,                       // number of literal/length codes
+    uInt,                       // number of distance codes
+    uInt *,                    // that many (total) code lengths
+    uInt *,                    // literal desired/actual bit depth
+    uInt *,                    // distance desired/actual bit depth
+    inflate_huft * *,       // literal/length tree result
+    inflate_huft * *,       // distance tree result
+    inflate_huft *,             // space for trees
+    z_streamp);                // for messages
+
+int inflate_trees_fixed (
+    uInt *,                    // literal desired/actual bit depth
+    uInt *,                    // distance desired/actual bit depth
+    const inflate_huft * *,       // literal/length tree result
+    const inflate_huft * *,       // distance tree result
+    z_streamp);                // for memory allocation
+
+
+
+
+
+struct inflate_blocks_state;
+typedef struct inflate_blocks_state inflate_blocks_statef;
+
+inflate_blocks_statef * inflate_blocks_new (
+    z_streamp z,
+    check_func c,               // check function
+    uInt w);                   // window size
+
+int inflate_blocks (
+    inflate_blocks_statef *,
+    z_streamp ,
+    int);                      // initial return code
+
+void inflate_blocks_reset (
+    inflate_blocks_statef *,
+    z_streamp ,
+    uLong *);                  // check value on output
+
+int inflate_blocks_free (
+    inflate_blocks_statef *,
+    z_streamp);
+
+void inflate_set_dictionary (
+    inflate_blocks_statef *s,
+    const Byte *d,  // dictionary
+    uInt  n);       // dictionary length
+
+int inflate_blocks_sync_point (
+    inflate_blocks_statef *s);
+
+
+
+
+struct inflate_codes_state;
+typedef struct inflate_codes_state inflate_codes_statef;
+
+inflate_codes_statef *inflate_codes_new (
+    uInt, uInt,
+    const inflate_huft *, const inflate_huft *,
+    z_streamp );
+
+int inflate_codes (
+    inflate_blocks_statef *,
+    z_streamp ,
+    int);
+
+void inflate_codes_free (
+    inflate_codes_statef *,
+    z_streamp );
+
+
+
+
+typedef enum {
+      IBM_TYPE,     // get type bits (3, including end bit)
+      IBM_LENS,     // get lengths for stored
+      IBM_STORED,   // processing stored block
+      IBM_TABLE,    // get table lengths
+      IBM_BTREE,    // get bit lengths tree for a dynamic block
+      IBM_DTREE,    // get length, distance trees for a dynamic block
+      IBM_CODES,    // processing fixed or dynamic block
+      IBM_DRY,      // output remaining window bytes
+      IBM_DONE,     // finished last block, done 
+      IBM_BAD}      // got a data error--stuck here 
+inflate_block_mode;
+
+// inflate blocks semi-private state 
+struct inflate_blocks_state {
+
+  // mode 
+  inflate_block_mode  mode;     // current inflate_block mode 
+
+  // mode dependent information 
+  union {
+    uInt left;          // if STORED, bytes left to copy 
+    struct {
+      uInt table;               // table lengths (14 bits) 
+      uInt index;               // index into blens (or border)
+      uInt *blens;             // bit lengths of codes
+      uInt bb;                  // bit length tree depth 
+      inflate_huft *tb;         // bit length decoding tree 
+    } trees;            // if DTREE, decoding info for trees 
+    struct {
+      inflate_codes_statef 
+         *codes;
+    } decode;           // if CODES, current state 
+  } sub;                // submode
+  uInt last;            // true if this block is the last block 
+
+  // mode independent information 
+  uInt bitk;            // bits in bit buffer 
+  uLong bitb;           // bit buffer 
+  inflate_huft *hufts;  // single malloc for tree space 
+  Byte *window;        // sliding window 
+  Byte *end;           // one byte after sliding window 
+  Byte *read;          // window read pointer 
+  Byte *write;         // window write pointer 
+  check_func checkfn;   // check function 
+  uLong check;          // check on output 
+
+};
+
+
+// defines for inflate input/output
+//   update pointers and return 
+#define UPDBITS {s->bitb=b;s->bitk=k;}
+#define UPDIN {z->avail_in=n;z->total_in+=(uLong)(p-z->next_in);z->next_in=p;}
+#define UPDOUT {s->write=q;}
+#define UPDATE {UPDBITS UPDIN UPDOUT}
+#define LEAVE {UPDATE return inflate_flush(s,z,r);}
+//   get bytes and bits 
+#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
+#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
+#define NEXTBYTE (n--,*p++)
+#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define DUMPBITS(j) {b>>=(j);k-=(j);}
+//   output bytes 
+#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
+#define LOADOUT {q=s->write;m=(uInt)WAVAIL;m;}
+#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
+#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
+#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
+#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
+//   load local pointers 
+#define LOAD {LOADIN LOADOUT}
+
+// masks for lower bits (size given to avoid silly warnings with Visual C++) 
+// And'ing with mask[n] masks the lower n bits
+const uInt inflate_mask[17] = {
+    0x0000,
+    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
+    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
+};
+
+// copy as much as possible from the sliding window to the output area
+int inflate_flush (inflate_blocks_statef *, z_streamp, int);
+
+int inflate_fast (uInt, uInt, const inflate_huft *, const inflate_huft *, inflate_blocks_statef *, z_streamp );
+
+
+
+const uInt fixed_bl = 9;
+const uInt fixed_bd = 5;
+const inflate_huft fixed_tl[] = {
+    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
+    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},
+    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},
+    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},
+    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},
+    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},
+    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},
+    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},
+    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
+    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},
+    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},
+    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},
+    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},
+    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},
+    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},
+    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},
+    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
+    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},
+    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},
+    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},
+    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},
+    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},
+    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},
+    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},
+    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},
+    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},
+    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},
+    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},
+    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},
+    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},
+    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},
+    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
+    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},
+    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},
+    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},
+    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},
+    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},
+    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},
+    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},
+    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
+    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},
+    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},
+    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},
+    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},
+    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},
+    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},
+    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},
+    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
+    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},
+    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},
+    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},
+    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},
+    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},
+    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},
+    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},
+    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},
+    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},
+    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},
+    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},
+    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},
+    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},
+    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},
+    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
+    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},
+    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},
+    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},
+    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},
+    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},
+    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},
+    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},
+    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
+    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},
+    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},
+    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},
+    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},
+    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},
+    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},
+    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},
+    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
+    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},
+    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},
+    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},
+    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},
+    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},
+    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},
+    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},
+    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},
+    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},
+    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},
+    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},
+    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},
+    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},
+    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},
+    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
+    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},
+    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},
+    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},
+    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},
+    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},
+    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},
+    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},
+    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
+    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},
+    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},
+    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},
+    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},
+    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},
+    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},
+    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},
+    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
+    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},
+    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},
+    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},
+    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},
+    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},
+    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},
+    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},
+    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},
+    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},
+    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},
+    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},
+    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},
+    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},
+    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}
+  };
+const inflate_huft fixed_td[] = {
+    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},
+    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},
+    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},
+    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},
+    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},
+    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},
+    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},
+    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}
+  };
+
+
+
+
+
+
+
+// copy as much as possible from the sliding window to the output area
+int inflate_flush(inflate_blocks_statef *s,z_streamp z,int r)
+{
+  uInt n;
+  Byte *p;
+  Byte *q;
+
+  // local copies of source and destination pointers 
+  p = z->next_out;
+  q = s->read;
+
+  // compute number of bytes to copy as far as end of window 
+  n = (uInt)((q <= s->write ? s->write : s->end) - q);
+  if (n > z->avail_out) n = z->avail_out;
+  if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+  // update counters
+  z->avail_out -= n;
+  z->total_out += n;
+
+  // update check information 
+  if (s->checkfn != Z_NULL)
+    z->adler = s->check = (*s->checkfn)(s->check, q, n);
+
+  // copy as far as end of window 
+  if (n!=0)          // check for n!=0 to avoid waking up CodeGuard
+  { memcpy(p, q, n);
+    p += n;
+    q += n;
+  }
+
+  // see if more to copy at beginning of window
+  if (q == s->end)
+  {
+    // wrap pointers 
+    q = s->window;
+    if (s->write == s->end)
+      s->write = s->window;
+
+    // compute bytes to copy 
+    n = (uInt)(s->write - q);
+    if (n > z->avail_out) n = z->avail_out;
+    if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+    // update counters 
+    z->avail_out -= n;
+    z->total_out += n;
+
+    // update check information 
+    if (s->checkfn != Z_NULL)
+      z->adler = s->check = (*s->checkfn)(s->check, q, n);
+
+    // copy
+    memcpy(p, q, n);
+    p += n;
+    q += n;
+  }
+
+  // update pointers
+  z->next_out = p;
+  s->read = q;
+
+  // done
+  return r;
+}
+
+
+
+
+
+
+// simplify the use of the inflate_huft type with some defines
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+typedef enum {        // waiting for "i:"=input, "o:"=output, "x:"=nothing 
+      START,    // x: set up for LEN 
+      LEN,      // i: get length/literal/eob next 
+      LENEXT,   // i: getting length extra (have base) 
+      DIST,     // i: get distance next 
+      DISTEXT,  // i: getting distance extra 
+      COPY,     // o: copying bytes in window, waiting for space
+      LIT,      // o: got literal, waiting for output space 
+      WASH,     // o: got eob, possibly still output waiting 
+      END,      // x: got eob and all data flushed 
+      BADCODE}  // x: got error 
+inflate_codes_mode;
+
+// inflate codes private state
+struct inflate_codes_state {
+
+  // mode 
+  inflate_codes_mode mode;      // current inflate_codes mode 
+
+  // mode dependent information 
+  uInt len;
+  union {
+    struct {
+      const inflate_huft *tree;       // pointer into tree 
+      uInt need;                // bits needed 
+    } code;             // if LEN or DIST, where in tree 
+    uInt lit;           // if LIT, literal 
+    struct {
+      uInt get;                 // bits to get for extra 
+      uInt dist;                // distance back to copy from 
+    } copy;             // if EXT or COPY, where and how much 
+  } sub;                // submode
+
+  // mode independent information 
+  Byte lbits;           // ltree bits decoded per branch 
+  Byte dbits;           // dtree bits decoder per branch 
+  const inflate_huft *ltree;          // literal/length/eob tree
+  const inflate_huft *dtree;          // distance tree
+
+};
+
+
+inflate_codes_statef *inflate_codes_new(
+uInt bl, uInt bd,
+const inflate_huft *tl,
+const inflate_huft *td, // need separate declaration for Borland C++
+z_streamp z)
+{
+  inflate_codes_statef *c;
+
+  if ((c = (inflate_codes_statef *)
+       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
+  {
+    c->mode = START;
+    c->lbits = (Byte)bl;
+    c->dbits = (Byte)bd;
+    c->ltree = tl;
+    c->dtree = td;
+    Tracev((stderr, "inflate:       codes new\n"));
+  }
+  return c;
+}
+
+
+int inflate_codes(inflate_blocks_statef *s, z_streamp z, int r)
+{
+  uInt j;               // temporary storage
+  const inflate_huft *t;      // temporary pointer
+  uInt e;               // extra bits or operation
+  uLong b;              // bit buffer
+  uInt k;               // bits in bit buffer
+  Byte *p;             // input data pointer
+  uInt n;               // bytes available there
+  Byte *q;             // output window write pointer
+  uInt m;               // bytes to end of window or read pointer
+  Byte *f;             // pointer to copy strings from
+  inflate_codes_statef *c = s->sub.decode.codes;  // codes state
+
+  // copy input/output information to locals (UPDATE macro restores)
+  LOAD
+
+  // process input and output based on current state
+  for(;;) switch (c->mode)
+  {             // waiting for "i:"=input, "o:"=output, "x:"=nothing
+    case START:         // x: set up for LEN
+#ifndef SLOW
+      if (m >= 258 && n >= 10)
+      {
+        UPDATE
+        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
+        LOAD
+        if (r != Z_OK)
+        {
+          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
+          break;
+        }
+      }
+#endif // !SLOW
+      c->sub.code.need = c->lbits;
+      c->sub.code.tree = c->ltree;
+      c->mode = LEN;
+    case LEN:           // i: get length/literal/eob next
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e == 0)               // literal 
+      {
+        c->sub.lit = t->base;
+        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                 "inflate:         literal '%c'\n" :
+                 "inflate:         literal 0x%02x\n", t->base));
+        c->mode = LIT;
+        break;
+      }
+      if (e & 16)               // length 
+      {
+        c->sub.copy.get = e & 15;
+        c->len = t->base;
+        c->mode = LENEXT;
+        break;
+      }
+      if ((e & 64) == 0)        // next table 
+      {
+        c->sub.code.need = e;
+        c->sub.code.tree = t + t->base;
+        break;
+      }
+      if (e & 32)               // end of block 
+      {
+        Tracevv((stderr, "inflate:         end of block\n"));
+        c->mode = WASH;
+        break;
+      }
+      c->mode = BADCODE;        // invalid code 
+      z->msg = (char*)"invalid literal/length code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case LENEXT:        // i: getting length extra (have base) 
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->len += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      c->sub.code.need = c->dbits;
+      c->sub.code.tree = c->dtree;
+      Tracevv((stderr, "inflate:         length %u\n", c->len));
+      c->mode = DIST;
+    case DIST:          // i: get distance next 
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e & 16)               // distance 
+      {
+        c->sub.copy.get = e & 15;
+        c->sub.copy.dist = t->base;
+        c->mode = DISTEXT;
+        break;
+      }
+      if ((e & 64) == 0)        // next table 
+      {
+        c->sub.code.need = e;
+        c->sub.code.tree = t + t->base;
+        break;
+      }
+      c->mode = BADCODE;        // invalid code 
+      z->msg = (char*)"invalid distance code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case DISTEXT:       // i: getting distance extra 
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->sub.copy.dist += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
+      c->mode = COPY;
+    case COPY:          // o: copying bytes in window, waiting for space 
+      f = (uInt)(q - s->window) < c->sub.copy.dist ?
+          s->end - (c->sub.copy.dist - (q - s->window)) :
+          q - c->sub.copy.dist;
+      while (c->len)
+      {
+        NEEDOUT
+        OUTBYTE(*f++)
+        if (f == s->end)
+          f = s->window;
+        c->len--;
+      }
+      c->mode = START;
+      break;
+    case LIT:           // o: got literal, waiting for output space 
+      NEEDOUT
+      OUTBYTE(c->sub.lit)
+      c->mode = START;
+      break;
+    case WASH:          // o: got eob, possibly more output 
+      if (k > 7)        // return unused byte, if any 
+      {
+        Assert(k < 16, "inflate_codes grabbed too many bytes")
+        k -= 8;
+        n++;
+        p--;            // can always return one 
+      }
+      FLUSH
+      if (s->read != s->write)
+        LEAVE
+      c->mode = END;
+    case END:
+      r = Z_STREAM_END;
+      LEAVE
+    case BADCODE:       // x: got error
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+}
+
+
+void inflate_codes_free(inflate_codes_statef *c,z_streamp z)
+{ ZFREE(z, c);
+  Tracev((stderr, "inflate:       codes free\n"));
+}
+
+
+
+// infblock.c -- interpret and process block types to last block
+// Copyright (C) 1995-1998 Mark Adler
+// For conditions of distribution and use, see copyright notice in zlib.h
+
+//struct inflate_codes_state {int dummy;}; // for buggy compilers 
+
+
+
+// Table for deflate from PKZIP's appnote.txt.
+const uInt border[] = { // Order of the bit length code lengths
+        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+//
+// Notes beyond the 1.93a appnote.txt:
+//
+// 1. Distance pointers never point before the beginning of the output stream.
+// 2. Distance pointers can point back across blocks, up to 32k away.
+// 3. There is an implied maximum of 7 bits for the bit length table and
+//    15 bits for the actual data.
+// 4. If only one code exists, then it is encoded using one bit.  (Zero
+//    would be more efficient, but perhaps a little confusing.)  If two
+//    codes exist, they are coded using one bit each (0 and 1).
+// 5. There is no way of sending zero distance codes--a dummy must be
+//    sent if there are none.  (History: a pre 2.0 version of PKZIP would
+//    store blocks with no distance codes, but this was discovered to be
+//    too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
+//    zero distance codes, which is sent as one code of zero bits in
+//    length.
+// 6. There are up to 286 literal/length codes.  Code 256 represents the
+//    end-of-block.  Note however that the static length tree defines
+//    288 codes just to fill out the Huffman codes.  Codes 286 and 287
+//    cannot be used though, since there is no length base or extra bits
+//    defined for them.  Similarily, there are up to 30 distance codes.
+//    However, static trees define 32 codes (all 5 bits) to fill out the
+//    Huffman codes, but the last two had better not show up in the data.
+// 7. Unzip can check dynamic Huffman blocks for complete code sets.
+//    The exception is that a single code would not be complete (see #4).
+// 8. The five bits following the block type is really the number of
+//    literal codes sent minus 257.
+// 9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
+//    (1+6+6).  Therefore, to output three times the length, you output
+//    three codes (1+1+1), whereas to output four times the same length,
+//    you only need two codes (1+3).  Hmm.
+//10. In the tree reconstruction algorithm, Code = Code + Increment
+//    only if BitLength(i) is not zero.  (Pretty obvious.)
+//11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
+//12. Note: length code 284 can represent 227-258, but length code 285
+//    really is 258.  The last length deserves its own, short code
+//    since it gets used a lot in very redundant files.  The length
+//    258 is special since 258 - 3 (the min match length) is 255.
+//13. The literal/length and distance code bit lengths are read as a
+//    single stream of lengths.  It is possible (and advantageous) for
+//    a repeat code (16, 17, or 18) to go across the boundary between
+//    the two sets of lengths.
+
+
+void inflate_blocks_reset(inflate_blocks_statef *s, z_streamp z, uLong *c)
+{
+  if (c != Z_NULL)
+    *c = s->check;
+  if (s->mode == IBM_BTREE || s->mode == IBM_DTREE)
+    ZFREE(z, s->sub.trees.blens);
+  if (s->mode == IBM_CODES)
+    inflate_codes_free(s->sub.decode.codes, z);
+  s->mode = IBM_TYPE;
+  s->bitk = 0;
+  s->bitb = 0;
+  s->read = s->write = s->window;
+  if (s->checkfn != Z_NULL)
+    z->adler = s->check = (*s->checkfn)(0L, (const Byte *)Z_NULL, 0);
+  Tracev((stderr, "inflate:   blocks reset\n"));
+}
+
+
+inflate_blocks_statef *inflate_blocks_new(z_streamp z, check_func c, uInt w)
+{
+  inflate_blocks_statef *s;
+
+  if ((s = (inflate_blocks_statef *)ZALLOC
+       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
+    return s;
+  if ((s->hufts =
+       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)
+  {
+    ZFREE(z, s);
+    return Z_NULL;
+  }
+  if ((s->window = (Byte *)ZALLOC(z, 1, w)) == Z_NULL)
+  {
+    ZFREE(z, s->hufts);
+    ZFREE(z, s);
+    return Z_NULL;
+  }
+  s->end = s->window + w;
+  s->checkfn = c;
+  s->mode = IBM_TYPE;
+  Tracev((stderr, "inflate:   blocks allocated\n"));
+  inflate_blocks_reset(s, z, Z_NULL);
+  return s;
+}
+
+
+int inflate_blocks(inflate_blocks_statef *s, z_streamp z, int r)
+{
+  uInt t;               // temporary storage
+  uLong b;              // bit buffer
+  uInt k;               // bits in bit buffer
+  Byte *p;             // input data pointer
+  uInt n;               // bytes available there
+  Byte *q;             // output window write pointer
+  uInt m;               // bytes to end of window or read pointer 
+
+  // copy input/output information to locals (UPDATE macro restores) 
+  LOAD
+
+  // process input based on current state 
+  for(;;) switch (s->mode)
+  {
+    case IBM_TYPE:
+      NEEDBITS(3)
+      t = (uInt)b & 7;
+      s->last = t & 1;
+      switch (t >> 1)
+      {
+        case 0:                         // stored 
+          Tracev((stderr, "inflate:     stored block%s\n",
+                 s->last ? " (last)" : ""));
+          DUMPBITS(3)
+          t = k & 7;                    // go to byte boundary 
+          DUMPBITS(t)
+          s->mode = IBM_LENS;               // get length of stored block
+          break;
+        case 1:                         // fixed 
+          Tracev((stderr, "inflate:     fixed codes block%s\n",
+                 s->last ? " (last)" : ""));
+          {
+            uInt bl, bd;
+            const inflate_huft *tl, *td;
+
+            inflate_trees_fixed(&bl, &bd, &tl, &td, z);
+            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
+            if (s->sub.decode.codes == Z_NULL)
+            {
+              r = Z_MEM_ERROR;
+              LEAVE
+            }
+          }
+          DUMPBITS(3)
+          s->mode = IBM_CODES;
+          break;
+        case 2:                         // dynamic 
+          Tracev((stderr, "inflate:     dynamic codes block%s\n",
+                 s->last ? " (last)" : ""));
+          DUMPBITS(3)
+          s->mode = IBM_TABLE;
+          break;
+        case 3:                         // illegal
+          DUMPBITS(3)
+          s->mode = IBM_BAD;
+          z->msg = (char*)"invalid block type";
+          r = Z_DATA_ERROR;
+          LEAVE
+      }
+      break;
+    case IBM_LENS:
+      NEEDBITS(32)
+      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
+      {
+        s->mode = IBM_BAD;
+        z->msg = (char*)"invalid stored block lengths";
+        r = Z_DATA_ERROR;
+        LEAVE
+      }
+      s->sub.left = (uInt)b & 0xffff;
+      b = k = 0;                      // dump bits 
+      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
+      s->mode = s->sub.left ? IBM_STORED : (s->last ? IBM_DRY : IBM_TYPE);
+      break;
+    case IBM_STORED:
+      if (n == 0)
+        LEAVE
+      NEEDOUT
+      t = s->sub.left;
+      if (t > n) t = n;
+      if (t > m) t = m;
+      memcpy(q, p, t);
+      p += t;  n -= t;
+      q += t;  m -= t;
+      if ((s->sub.left -= t) != 0)
+        break;
+      Tracev((stderr, "inflate:       stored end, %lu total out\n",
+              z->total_out + (q >= s->read ? q - s->read :
+              (s->end - s->read) + (q - s->window))));
+      s->mode = s->last ? IBM_DRY : IBM_TYPE;
+      break;
+    case IBM_TABLE:
+      NEEDBITS(14)
+      s->sub.trees.table = t = (uInt)b & 0x3fff;
+      // remove this section to workaround bug in pkzip
+      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
+      {
+        s->mode = IBM_BAD;
+        z->msg = (char*)"too many length or distance symbols";
+        r = Z_DATA_ERROR;
+        LEAVE
+      }
+      // end remove
+      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
+      if ((s->sub.trees.blens = (uInt*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
+      {
+        r = Z_MEM_ERROR;
+        LEAVE
+      }
+      DUMPBITS(14)
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       table sizes ok\n"));
+      s->mode = IBM_BTREE;
+    case IBM_BTREE:
+      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
+      {
+        NEEDBITS(3)
+        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
+        DUMPBITS(3)
+      }
+      while (s->sub.trees.index < 19)
+        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
+      s->sub.trees.bb = 7;
+      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
+                             &s->sub.trees.tb, s->hufts, z);
+      if (t != Z_OK)
+      {
+        ZFREE(z, s->sub.trees.blens);
+        r = t;
+        if (r == Z_DATA_ERROR)
+          s->mode = IBM_BAD;
+        LEAVE
+      }
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       bits tree ok\n"));
+      s->mode = IBM_DTREE;
+    case IBM_DTREE:
+      while (t = s->sub.trees.table,
+             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
+      {
+        inflate_huft *h;
+        uInt i, j, c;
+
+        t = s->sub.trees.bb;
+        NEEDBITS(t)
+        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
+        t = h->bits;
+        c = h->base;
+        if (c < 16)
+        {
+          DUMPBITS(t)
+          s->sub.trees.blens[s->sub.trees.index++] = c;
+        }
+        else // c == 16..18 
+        {
+          i = c == 18 ? 7 : c - 14;
+          j = c == 18 ? 11 : 3;
+          NEEDBITS(t + i)
+          DUMPBITS(t)
+          j += (uInt)b & inflate_mask[i];
+          DUMPBITS(i)
+          i = s->sub.trees.index;
+          t = s->sub.trees.table;
+          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
+              (c == 16 && i < 1))
+          {
+            ZFREE(z, s->sub.trees.blens);
+            s->mode = IBM_BAD;
+            z->msg = (char*)"invalid bit length repeat";
+            r = Z_DATA_ERROR;
+            LEAVE
+          }
+          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
+          do {
+            s->sub.trees.blens[i++] = c;
+          } while (--j);
+          s->sub.trees.index = i;
+        }
+      }
+      s->sub.trees.tb = Z_NULL;
+      {
+        uInt bl, bd;
+        inflate_huft *tl, *td;
+        inflate_codes_statef *c;
+
+        bl = 9;         // must be <= 9 for lookahead assumptions 
+        bd = 6;         // must be <= 9 for lookahead assumptions
+        t = s->sub.trees.table;
+        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
+                                  s->sub.trees.blens, &bl, &bd, &tl, &td,
+                                  s->hufts, z);
+        ZFREE(z, s->sub.trees.blens);
+        if (t != Z_OK)
+        {
+          if (t == (uInt)Z_DATA_ERROR)
+            s->mode = IBM_BAD;
+          r = t;
+          LEAVE
+        }
+        Tracev((stderr, "inflate:       trees ok\n"));
+        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
+        {
+          r = Z_MEM_ERROR;
+          LEAVE
+        }
+        s->sub.decode.codes = c;
+      }
+      s->mode = IBM_CODES;
+    case IBM_CODES:
+      UPDATE
+      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
+        return inflate_flush(s, z, r);
+      r = Z_OK;
+      inflate_codes_free(s->sub.decode.codes, z);
+      LOAD
+      Tracev((stderr, "inflate:       codes end, %lu total out\n",
+              z->total_out + (q >= s->read ? q - s->read :
+              (s->end - s->read) + (q - s->window))));
+      if (!s->last)
+      {
+        s->mode = IBM_TYPE;
+        break;
+      }
+      s->mode = IBM_DRY;
+    case IBM_DRY:
+      FLUSH
+      if (s->read != s->write)
+        LEAVE
+      s->mode = IBM_DONE;
+    case IBM_DONE:
+      r = Z_STREAM_END;
+      LEAVE
+    case IBM_BAD:
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+}
+
+
+int inflate_blocks_free(inflate_blocks_statef *s, z_streamp z)
+{
+  inflate_blocks_reset(s, z, Z_NULL);
+  ZFREE(z, s->window);
+  ZFREE(z, s->hufts);
+  ZFREE(z, s);
+  Tracev((stderr, "inflate:   blocks freed\n"));
+  return Z_OK;
+}
+
+
+
+// inftrees.c -- generate Huffman trees for efficient decoding
+// Copyright (C) 1995-1998 Mark Adler
+// For conditions of distribution and use, see copyright notice in zlib.h
+//
+
+
+
+extern const char inflate_copyright[] =
+   " inflate 1.1.3 Copyright 1995-1998 Mark Adler ";
+// If you use the zlib library in a product, an acknowledgment is welcome
+// in the documentation of your product. If for some reason you cannot
+// include such an acknowledgment, I would appreciate that you keep this
+// copyright string in the executable of your product.
+
+
+
+int huft_build (
+    uInt *,            // code lengths in bits
+    uInt,               // number of codes
+    uInt,               // number of "simple" codes
+    const uInt *,      // list of base values for non-simple codes
+    const uInt *,      // list of extra bits for non-simple codes
+    inflate_huft **,// result: starting table
+    uInt *,            // maximum lookup bits (returns actual) 
+    inflate_huft *,     // space for trees 
+    uInt *,             // hufts used in space 
+    uInt * );         // space for values 
+
+// Tables for deflate from PKZIP's appnote.txt. 
+const uInt cplens[31] = { // Copy lengths for literal codes 257..285
+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
+        // see note #13 above about 258
+const uInt cplext[31] = { // Extra bits for literal codes 257..285
+        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
+        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; // 112==invalid
+const uInt cpdist[30] = { // Copy offsets for distance codes 0..29
+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+        8193, 12289, 16385, 24577};
+const uInt cpdext[30] = { // Extra bits for distance codes 
+        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
+        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
+        12, 12, 13, 13};
+
+//
+//   Huffman code decoding is performed using a multi-level table lookup.
+//   The fastest way to decode is to simply build a lookup table whose
+//   size is determined by the longest code.  However, the time it takes
+//   to build this table can also be a factor if the data being decoded
+//   is not very long.  The most common codes are necessarily the
+//   shortest codes, so those codes dominate the decoding time, and hence
+//   the speed.  The idea is you can have a shorter table that decodes the
+//   shorter, more probable codes, and then point to subsidiary tables for
+//   the longer codes.  The time it costs to decode the longer codes is
+//   then traded against the time it takes to make longer tables.
+//
+//   This results of this trade are in the variables lbits and dbits
+//   below.  lbits is the number of bits the first level table for literal/
+//   length codes can decode in one step, and dbits is the same thing for
+//   the distance codes.  Subsequent tables are also less than or equal to
+//   those sizes.  These values may be adjusted either when all of the
+//   codes are shorter than that, in which case the longest code length in
+//   bits is used, or when the shortest code is *longer* than the requested
+//   table size, in which case the length of the shortest code in bits is
+//   used.
+//
+//   There are two different values for the two tables, since they code a
+//   different number of possibilities each.  The literal/length table
+//   codes 286 possible values, or in a flat code, a little over eight
+//   bits.  The distance table codes 30 possible values, or a little less
+//   than five bits, flat.  The optimum values for speed end up being
+//   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
+//   The optimum values may differ though from machine to machine, and
+//   possibly even between compilers.  Your mileage may vary.
+//
+
+
+// If BMAX needs to be larger than 16, then h and x[] should be uLong. 
+#define BMAX 15         // maximum bit length of any code
+
+int huft_build(
+uInt *b,               // code lengths in bits (all assumed <= BMAX)
+uInt n,                 // number of codes (assumed <= 288)
+uInt s,                 // number of simple-valued codes (0..s-1)
+const uInt *d,         // list of base values for non-simple codes
+const uInt *e,         // list of extra bits for non-simple codes
+inflate_huft * *t,  // result: starting table
+uInt *m,               // maximum lookup bits, returns actual
+inflate_huft *hp,       // space for trees
+uInt *hn,               // hufts used in space
+uInt *v)               // working area: values in order of bit length
+// Given a list of code lengths and a maximum table size, make a set of
+// tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
+// if the given code set is incomplete (the tables are still built in this
+// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
+// lengths), or Z_MEM_ERROR if not enough memory.
+{
+
+  uInt a;                       // counter for codes of length k
+  uInt c[BMAX+1];               // bit length count table
+  uInt f;                       // i repeats in table every f entries 
+  int g;                        // maximum code length 
+  int h;                        // table level 
+  register uInt i;              // counter, current code 
+  register uInt j;              // counter
+  register int k;               // number of bits in current code 
+  int l;                        // bits per table (returned in m) 
+  uInt mask;                    // (1 << w) - 1, to avoid cc -O bug on HP 
+  register uInt *p;            // pointer into c[], b[], or v[]
+  inflate_huft *q;              // points to current table 
+  struct inflate_huft_s r;      // table entry for structure assignment 
+  inflate_huft *u[BMAX];        // table stack 
+  register int w;               // bits before this table == (l * h) 
+  uInt x[BMAX+1];               // bit offsets, then code stack 
+  uInt *xp;                    // pointer into x 
+  int y;                        // number of dummy codes added 
+  uInt z;                       // number of entries in current table 
+
+
+  // Generate counts for each bit length 
+  p = c;
+#define C0 *p++ = 0;
+#define C2 C0 C0 C0 C0
+#define C4 C2 C2 C2 C2
+  C4; p;                          // clear c[]--assume BMAX+1 is 16
+  p = b;  i = n;
+  do {
+    c[*p++]++;                  // assume all entries <= BMAX 
+  } while (--i);
+  if (c[0] == n)                // null input--all zero length codes 
+  {
+    *t = (inflate_huft *)Z_NULL;
+    *m = 0;
+    return Z_OK;
+  }
+
+
+  // Find minimum and maximum length, bound *m by those 
+  l = *m;
+  for (j = 1; j <= BMAX; j++)
+    if (c[j])
+      break;
+  k = j;                        // minimum code length 
+  if ((uInt)l < j)
+    l = j;
+  for (i = BMAX; i; i--)
+    if (c[i])
+      break;
+  g = i;                        // maximum code length 
+  if ((uInt)l > i)
+    l = i;
+  *m = l;
+
+
+  // Adjust last length count to fill out codes, if needed 
+  for (y = 1 << j; j < i; j++, y <<= 1)
+    if ((y -= c[j]) < 0)
+      return Z_DATA_ERROR;
+  if ((y -= c[i]) < 0)
+    return Z_DATA_ERROR;
+  c[i] += y;
+
+
+  // Generate starting offsets into the value table for each length 
+  x[1] = j = 0;
+  p = c + 1;  xp = x + 2;
+  while (--i) {                 // note that i == g from above 
+    *xp++ = (j += *p++);
+  }
+
+
+  // Make a table of values in order of bit lengths 
+  p = b;  i = 0;
+  do {
+    if ((j = *p++) != 0)
+      v[x[j]++] = i;
+  } while (++i < n);
+  n = x[g];                     // set n to length of v 
+
+
+  // Generate the Huffman codes and for each, make the table entries 
+  x[0] = i = 0;                 // first Huffman code is zero 
+  p = v;                        // grab values in bit order 
+  h = -1;                       // no tables yet--level -1 
+  w = -l;                       // bits decoded == (l * h) 
+  u[0] = (inflate_huft *)Z_NULL;        // just to keep compilers happy 
+  q = (inflate_huft *)Z_NULL;   // ditto 
+  z = 0;                        // ditto 
+
+  // go through the bit lengths (k already is bits in shortest code) 
+  for (; k <= g; k++)
+  {
+    a = c[k];
+    while (a--)
+    {
+      // here i is the Huffman code of length k bits for value *p 
+      // make tables up to required level 
+      while (k > w + l)
+      {
+        h++;
+        w += l;                 // previous table always l bits 
+
+        // compute minimum size table less than or equal to l bits
+        z = g - w;
+        z = z > (uInt)l ? l : z;        // table size upper limit 
+        if ((f = 1 << (j = k - w)) > a + 1)     // try a k-w bit table 
+        {                       // too few codes for k-w bit table 
+          f -= a + 1;           // deduct codes from patterns left 
+          xp = c + k;
+          if (j < z)
+            while (++j < z)     // try smaller tables up to z bits 
+            {
+              if ((f <<= 1) <= *++xp)
+                break;          // enough codes to use up j bits 
+              f -= *xp;         // else deduct codes from patterns
+            }
+        }
+        z = 1 << j;             // table entries for j-bit table 
+
+        // allocate new table 
+        if (*hn + z > MANY)     // (note: doesn't matter for fixed) 
+          return Z_MEM_ERROR;   // not enough memory 
+        u[h] = q = hp + *hn;
+        *hn += z;
+
+        // connect to last table, if there is one 
+        if (h)
+        {
+          x[h] = i;             // save pattern for backing up
+          r.bits = (Byte)l;     // bits to dump before this table 
+          r.exop = (Byte)j;     // bits in this table 
+          j = i >> (w - l);
+          r.base = (uInt)(q - u[h-1] - j);   // offset to this table 
+          u[h-1][j] = r;        // connect to last table 
+        }
+        else
+          *t = q;               // first table is returned result 
+      }
+
+      // set up table entry in r 
+      r.bits = (Byte)(k - w);
+      if (p >= v + n)
+        r.exop = 128 + 64;      // out of values--invalid code 
+      else if (*p < s)
+      {
+        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     // 256 is end-of-block 
+        r.base = *p++;          // simple code is just the value 
+      }
+      else
+      {
+        r.exop = (Byte)(e[*p - s] + 16 + 64);// non-simple--look up in lists 
+        r.base = d[*p++ - s];
+      }
+
+      // fill code-like entries with r
+      f = 1 << (k - w);
+      for (j = i >> w; j < z; j += f)
+        q[j] = r;
+
+      // backwards increment the k-bit code i 
+      for (j = 1 << (k - 1); i & j; j >>= 1)
+        i ^= j;
+      i ^= j;
+
+      // backup over finished tables 
+      mask = (1 << w) - 1;      // needed on HP, cc -O bug 
+      while ((i & mask) != x[h])
+      {
+        h--;                    // don't need to update q
+        w -= l;
+        mask = (1 << w) - 1;
+      }
+    }
+  }
+
+
+  // Return Z_BUF_ERROR if we were given an incomplete table 
+  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
+}
+
+
+int inflate_trees_bits(
+uInt *c,               // 19 code lengths
+uInt *bb,              // bits tree desired/actual depth
+inflate_huft * *tb, // bits tree result
+inflate_huft *hp,       // space for trees
+z_streamp z)            // for messages
+{
+  int r;
+  uInt hn = 0;          // hufts used in space 
+  uInt *v;             // work area for huft_build 
+
+  if ((v = (uInt*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)
+    return Z_MEM_ERROR;
+  r = huft_build(c, 19, 19, (uInt*)Z_NULL, (uInt*)Z_NULL,
+                 tb, bb, hp, &hn, v);
+  if (r == Z_DATA_ERROR)
+    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
+  else if (r == Z_BUF_ERROR || *bb == 0)
+  {
+    z->msg = (char*)"incomplete dynamic bit lengths tree";
+    r = Z_DATA_ERROR;
+  }
+  ZFREE(z, v);
+  return r;
+}
+
+
+int inflate_trees_dynamic(
+uInt nl,                // number of literal/length codes
+uInt nd,                // number of distance codes
+uInt *c,               // that many (total) code lengths
+uInt *bl,              // literal desired/actual bit depth
+uInt *bd,              // distance desired/actual bit depth
+inflate_huft * *tl, // literal/length tree result
+inflate_huft * *td, // distance tree result
+inflate_huft *hp,       // space for trees
+z_streamp z)            // for messages
+{
+  int r;
+  uInt hn = 0;          // hufts used in space 
+  uInt *v;             // work area for huft_build 
+
+  // allocate work area 
+  if ((v = (uInt*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
+    return Z_MEM_ERROR;
+
+  // build literal/length tree 
+  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);
+  if (r != Z_OK || *bl == 0)
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = (char*)"oversubscribed literal/length tree";
+    else if (r != Z_MEM_ERROR)
+    {
+      z->msg = (char*)"incomplete literal/length tree";
+      r = Z_DATA_ERROR;
+    }
+    ZFREE(z, v);
+    return r;
+  }
+
+  // build distance tree 
+  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);
+  if (r != Z_OK || (*bd == 0 && nl > 257))
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = (char*)"oversubscribed distance tree";
+    else if (r == Z_BUF_ERROR) {
+      z->msg = (char*)"incomplete distance tree";
+      r = Z_DATA_ERROR;
+    }
+    else if (r != Z_MEM_ERROR)
+    {
+      z->msg = (char*)"empty distance tree with lengths";
+      r = Z_DATA_ERROR;
+    }
+    ZFREE(z, v);
+    return r;
+  }
+
+  // done 
+  ZFREE(z, v);
+  return Z_OK;
+}
+
+
+
+
+
+int inflate_trees_fixed(
+uInt *bl,               // literal desired/actual bit depth
+uInt *bd,               // distance desired/actual bit depth
+const inflate_huft * * tl,     // literal/length tree result
+const inflate_huft * *td,     // distance tree result
+z_streamp )             // for memory allocation
+{
+  *bl = fixed_bl;
+  *bd = fixed_bd;
+  *tl = fixed_tl;
+  *td = fixed_td;
+  return Z_OK;
+}
+
+
+// inffast.c -- process literals and length/distance pairs fast
+// Copyright (C) 1995-1998 Mark Adler
+// For conditions of distribution and use, see copyright notice in zlib.h
+//
+
+
+//struct inflate_codes_state {int dummy;}; // for buggy compilers 
+
+
+// macros for bit input with no checking and for returning unused bytes 
+#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}
+
+// Called with number of bytes left to write in window at least 258
+// (the maximum string length) and number of input bytes available
+// at least ten.  The ten bytes are six bytes for the longest length/
+// distance pair plus four bytes for overloading the bit buffer. 
+
+int inflate_fast(
+uInt bl, uInt bd,
+const inflate_huft *tl,
+const inflate_huft *td, // need separate declaration for Borland C++
+inflate_blocks_statef *s,
+z_streamp z)
+{
+  const inflate_huft *t;      // temporary pointer 
+  uInt e;               // extra bits or operation 
+  uLong b;              // bit buffer 
+  uInt k;               // bits in bit buffer 
+  Byte *p;             // input data pointer 
+  uInt n;               // bytes available there 
+  Byte *q;             // output window write pointer 
+  uInt m;               // bytes to end of window or read pointer 
+  uInt ml;              // mask for literal/length tree
+  uInt md;              // mask for distance tree 
+  uInt c;               // bytes to copy 
+  uInt d;               // distance back to copy from 
+  Byte *r;             // copy source pointer 
+
+  // load input, output, bit values 
+  LOAD
+
+  // initialize masks 
+  ml = inflate_mask[bl];
+  md = inflate_mask[bd];
+
+  // do until not enough input or output space for fast loop 
+  do {                          // assume called with m >= 258 && n >= 10 
+    // get literal/length code 
+    GRABBITS(20)                // max bits for literal/length code 
+    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
+    {
+      DUMPBITS(t->bits)
+      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                "inflate:         * literal '%c'\n" :
+                "inflate:         * literal 0x%02x\n", t->base));
+      *q++ = (Byte)t->base;
+      m--;
+      continue;
+    }
+    for (;;) {
+      DUMPBITS(t->bits)
+      if (e & 16)
+      {
+        // get extra bits for length 
+        e &= 15;
+        c = t->base + ((uInt)b & inflate_mask[e]);
+        DUMPBITS(e)
+        Tracevv((stderr, "inflate:         * length %u\n", c));
+
+        // decode distance base of block to copy 
+        GRABBITS(15);           // max bits for distance code 
+        e = (t = td + ((uInt)b & md))->exop;
+        for (;;) {
+          DUMPBITS(t->bits)
+          if (e & 16)
+          {
+            // get extra bits to add to distance base 
+            e &= 15;
+            GRABBITS(e)         // get extra bits (up to 13) 
+            d = t->base + ((uInt)b & inflate_mask[e]);
+            DUMPBITS(e)
+            Tracevv((stderr, "inflate:         * distance %u\n", d));
+
+            // do the copy 
+            m -= c;
+            if ((uInt)(q - s->window) >= d)     // offset before dest 
+            {                                   //  just copy 
+              r = q - d;
+              *q++ = *r++;  c--;        // minimum count is three, 
+              *q++ = *r++;  c--;        //  so unroll loop a little 
+            }
+            else                        // else offset after destination 
+            {
+              e = d - (uInt)(q - s->window); // bytes from offset to end 
+              r = s->end - e;           // pointer to offset 
+              if (c > e)                // if source crosses, 
+              {
+                c -= e;                 // copy to end of window 
+                do {
+                  *q++ = *r++;
+                } while (--e);
+                r = s->window;          // copy rest from start of window 
+              }
+            }
+            do {                        // copy all or what's left 
+              *q++ = *r++;
+            } while (--c);
+            break;
+          }
+          else if ((e & 64) == 0)
+          {
+            t += t->base;
+            e = (t += ((uInt)b & inflate_mask[e]))->exop;
+          }
+          else
+          {
+            z->msg = (char*)"invalid distance code";
+            UNGRAB
+            UPDATE
+            return Z_DATA_ERROR;
+          }
+        };
+        break;
+      }
+      if ((e & 64) == 0)
+      {
+        t += t->base;
+        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)
+        {
+          DUMPBITS(t->bits)
+          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                    "inflate:         * literal '%c'\n" :
+                    "inflate:         * literal 0x%02x\n", t->base));
+          *q++ = (Byte)t->base;
+          m--;
+          break;
+        }
+      }
+      else if (e & 32)
+      {
+        Tracevv((stderr, "inflate:         * end of block\n"));
+        UNGRAB
+        UPDATE
+        return Z_STREAM_END;
+      }
+      else
+      {
+        z->msg = (char*)"invalid literal/length code";
+        UNGRAB
+        UPDATE
+        return Z_DATA_ERROR;
+      }
+    };
+  } while (m >= 258 && n >= 10);
+
+  // not enough input or output--restore pointers and return
+  UNGRAB
+  UPDATE
+  return Z_OK;
+}
+
+
+
+
+
+
+// crc32.c -- compute the CRC-32 of a data stream
+// Copyright (C) 1995-1998 Mark Adler
+// For conditions of distribution and use, see copyright notice in zlib.h
+
+// @(#) $Id$
+
+
+
+
+
+
+// Table of CRC-32's of all single-byte values (made by make_crc_table)
+const uLong crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+
+const uLong * get_crc_table()
+{ return (const uLong *)crc_table;
+}
+
+#define CRC_DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define CRC_DO2(buf)  CRC_DO1(buf); CRC_DO1(buf);
+#define CRC_DO4(buf)  CRC_DO2(buf); CRC_DO2(buf);
+#define CRC_DO8(buf)  CRC_DO4(buf); CRC_DO4(buf);
+
+uLong ucrc32(uLong crc, const Byte *buf, uInt len)
+{ if (buf == Z_NULL) return 0L;
+  crc = crc ^ 0xffffffffL;
+  while (len >= 8)  {CRC_DO8(buf); len -= 8;}
+  if (len) do {CRC_DO1(buf);} while (--len);
+  return crc ^ 0xffffffffL;
+}
+
+
+// adler32.c -- compute the Adler-32 checksum of a data stream
+// Copyright (C) 1995-1998 Mark Adler
+// For conditions of distribution and use, see copyright notice in zlib.h
+
+// @(#) $Id$
+
+
+#define BASE 65521L // largest prime smaller than 65536
+#define NMAX 5552
+// NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1
+
+#define AD_DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
+#define AD_DO2(buf,i)  AD_DO1(buf,i); AD_DO1(buf,i+1);
+#define AD_DO4(buf,i)  AD_DO2(buf,i); AD_DO2(buf,i+2);
+#define AD_DO8(buf,i)  AD_DO4(buf,i); AD_DO4(buf,i+4);
+#define AD_DO16(buf)   AD_DO8(buf,0); AD_DO8(buf,8);
+
+// =========================================================================
+uLong adler32(uLong adler, const Byte *buf, uInt len)
+{
+    unsigned long s1 = adler & 0xffff;
+    unsigned long s2 = (adler >> 16) & 0xffff;
+    int k;
+
+    if (buf == Z_NULL) return 1L;
+
+    while (len > 0) {
+        k = len < NMAX ? len : NMAX;
+        len -= k;
+        while (k >= 16) {
+            AD_DO16(buf);
+	    buf += 16;
+            k -= 16;
+        }
+        if (k != 0) do {
+            s1 += *buf++;
+	    s2 += s1;
+        } while (--k);
+        s1 %= BASE;
+        s2 %= BASE;
+    }
+    return (s2 << 16) | s1;
+}
+
+
+
+// zutil.c -- target dependent utility functions for the compression library
+// Copyright (C) 1995-1998 Jean-loup Gailly.
+// For conditions of distribution and use, see copyright notice in zlib.h
+// @(#) $Id$
+
+
+
+
+
+
+const char * zlibVersion()
+{
+    return ZLIB_VERSION;
+}
+
+// exported to allow conversion of error code to string for compress() and
+// uncompress()
+const char * zError(int err)
+{ return ERR_MSG(err);
+}
+
+
+
+
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    if (opaque) items += size - size; // make compiler happy
+    return (voidpf)calloc(items, size);
+}
+
+void  zcfree (voidpf opaque, voidpf ptr)
+{
+    zfree(ptr);
+    if (opaque) return; // make compiler happy
+}
+
+
+
+// inflate.c -- zlib interface to inflate modules
+// Copyright (C) 1995-1998 Mark Adler
+// For conditions of distribution and use, see copyright notice in zlib.h
+
+//struct inflate_blocks_state {int dummy;}; // for buggy compilers
+
+typedef enum {
+      IM_METHOD,   // waiting for method byte
+      IM_FLAG,     // waiting for flag byte
+      IM_DICT4,    // four dictionary check bytes to go
+      IM_DICT3,    // three dictionary check bytes to go
+      IM_DICT2,    // two dictionary check bytes to go
+      IM_DICT1,    // one dictionary check byte to go
+      IM_DICT0,    // waiting for inflateSetDictionary
+      IM_BLOCKS,   // decompressing blocks
+      IM_CHECK4,   // four check bytes to go
+      IM_CHECK3,   // three check bytes to go
+      IM_CHECK2,   // two check bytes to go
+      IM_CHECK1,   // one check byte to go
+      IM_DONE,     // finished check, done
+      IM_BAD}      // got an error--stay here
+inflate_mode;
+
+// inflate private state
+struct internal_state {
+
+  // mode
+  inflate_mode  mode;   // current inflate mode
+
+  // mode dependent information
+  union {
+    uInt method;        // if IM_FLAGS, method byte
+    struct {
+      uLong was;                // computed check value
+      uLong need;               // stream check value
+    } check;            // if CHECK, check values to compare
+    uInt marker;        // if IM_BAD, inflateSync's marker bytes count
+  } sub;        // submode
+
+  // mode independent information
+  int  nowrap;          // flag for no wrapper
+  uInt wbits;           // log2(window size)  (8..15, defaults to 15)
+  inflate_blocks_statef
+    *blocks;            // current inflate_blocks state
+
+};
+
+int inflateReset(z_streamp z)
+{
+  if (z == Z_NULL || z->state == Z_NULL)
+    return Z_STREAM_ERROR;
+  z->total_in = z->total_out = 0;
+  z->msg = Z_NULL;
+  z->state->mode = z->state->nowrap ? IM_BLOCKS : IM_METHOD;
+  inflate_blocks_reset(z->state->blocks, z, Z_NULL);
+  Tracev((stderr, "inflate: reset\n"));
+  return Z_OK;
+}
+
+int inflateEnd(z_streamp z)
+{
+  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
+    return Z_STREAM_ERROR;
+  if (z->state->blocks != Z_NULL)
+    inflate_blocks_free(z->state->blocks, z);
+  ZFREE(z, z->state);
+  z->state = Z_NULL;
+  Tracev((stderr, "inflate: end\n"));
+  return Z_OK;
+}
+
+
+int inflateInit2(z_streamp z)
+{ const char *version = ZLIB_VERSION; int stream_size = sizeof(z_stream);
+  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] || stream_size != sizeof(z_stream)) return Z_VERSION_ERROR;
+
+  int w = -15; // MAX_WBITS: 32K LZ77 window.
+  // Warning: reducing MAX_WBITS makes minigzip unable to extract .gz files created by gzip.
+  // The memory requirements for deflate are (in bytes):
+  //            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+  // that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+  // plus a few kilobytes for small objects. For example, if you want to reduce
+  // the default memory requirements from 256K to 128K, compile with
+  //     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+  // Of course this will generally degrade compression (there's no free lunch).
+  //
+  //   The memory requirements for inflate are (in bytes) 1 << windowBits
+  // that is, 32K for windowBits=15 (default value) plus a few kilobytes
+  // for small objects.
+
+  // initialize state
+  if (z == Z_NULL) return Z_STREAM_ERROR;
+  z->msg = Z_NULL;
+  if (z->zalloc == Z_NULL)
+  {
+    z->zalloc = zcalloc;
+    z->opaque = (voidpf)0;
+  }
+  if (z->zfree == Z_NULL) z->zfree = zcfree;
+  if ((z->state = (struct internal_state *)
+       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
+    return Z_MEM_ERROR;
+  z->state->blocks = Z_NULL;
+
+  // handle undocumented nowrap option (no zlib header or check)
+  z->state->nowrap = 0;
+  if (w < 0)
+  {
+    w = - w;
+    z->state->nowrap = 1;
+  }
+
+  // set window size
+  if (w < 8 || w > 15)
+  {
+    inflateEnd(z);
+    return Z_STREAM_ERROR;
+  }
+  z->state->wbits = (uInt)w;
+
+  // create inflate_blocks state
+  if ((z->state->blocks =
+      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
+      == Z_NULL)
+  {
+    inflateEnd(z);
+    return Z_MEM_ERROR;
+  }
+  Tracev((stderr, "inflate: allocated\n"));
+
+  // reset state 
+  inflateReset(z);
+  return Z_OK;
+}
+
+
+
+#define IM_NEEDBYTE {if(z->avail_in==0)return r;r=f;}
+#define IM_NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
+
+int inflate(z_streamp z, int f)
+{
+  int r;
+  uInt b;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)
+    return Z_STREAM_ERROR;
+  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
+  r = Z_BUF_ERROR;
+  for (;;) switch (z->state->mode)
+  {
+    case IM_METHOD:
+      IM_NEEDBYTE
+      if (((z->state->sub.method = IM_NEXTBYTE) & 0xf) != Z_DEFLATED)
+      {
+        z->state->mode = IM_BAD;
+        z->msg = (char*)"unknown compression method";
+        z->state->sub.marker = 5;       // can't try inflateSync
+        break;
+      }
+      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
+      {
+        z->state->mode = IM_BAD;
+        z->msg = (char*)"invalid window size";
+        z->state->sub.marker = 5;       // can't try inflateSync
+        break;
+      }
+      z->state->mode = IM_FLAG;
+    case IM_FLAG:
+      IM_NEEDBYTE
+      b = IM_NEXTBYTE;
+      if (((z->state->sub.method << 8) + b) % 31)
+      {
+        z->state->mode = IM_BAD;
+        z->msg = (char*)"incorrect header check";
+        z->state->sub.marker = 5;       // can't try inflateSync 
+        break;
+      }
+      Tracev((stderr, "inflate: zlib header ok\n"));
+      if (!(b & PRESET_DICT))
+      {
+        z->state->mode = IM_BLOCKS;
+        break;
+      }
+      z->state->mode = IM_DICT4;
+    case IM_DICT4:
+      IM_NEEDBYTE
+      z->state->sub.check.need = (uLong)IM_NEXTBYTE << 24;
+      z->state->mode = IM_DICT3;
+    case IM_DICT3:
+      IM_NEEDBYTE
+      z->state->sub.check.need += (uLong)IM_NEXTBYTE << 16;
+      z->state->mode = IM_DICT2;
+    case IM_DICT2:
+      IM_NEEDBYTE
+      z->state->sub.check.need += (uLong)IM_NEXTBYTE << 8;
+      z->state->mode = IM_DICT1;
+    case IM_DICT1:
+      IM_NEEDBYTE; r;
+      z->state->sub.check.need += (uLong)IM_NEXTBYTE;
+      z->adler = z->state->sub.check.need;
+      z->state->mode = IM_DICT0;
+      return Z_NEED_DICT;
+    case IM_DICT0:
+      z->state->mode = IM_BAD;
+      z->msg = (char*)"need dictionary";
+      z->state->sub.marker = 0;       // can try inflateSync 
+      return Z_STREAM_ERROR;
+    case IM_BLOCKS:
+      r = inflate_blocks(z->state->blocks, z, r);
+      if (r == Z_DATA_ERROR)
+      {
+        z->state->mode = IM_BAD;
+        z->state->sub.marker = 0;       // can try inflateSync 
+        break;
+      }
+      if (r == Z_OK)
+        r = f;
+      if (r != Z_STREAM_END)
+        return r;
+      r = f;
+      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
+      if (z->state->nowrap)
+      {
+        z->state->mode = IM_DONE;
+        break;
+      }
+      z->state->mode = IM_CHECK4;
+    case IM_CHECK4:
+      IM_NEEDBYTE
+      z->state->sub.check.need = (uLong)IM_NEXTBYTE << 24;
+      z->state->mode = IM_CHECK3;
+    case IM_CHECK3:
+      IM_NEEDBYTE
+      z->state->sub.check.need += (uLong)IM_NEXTBYTE << 16;
+      z->state->mode = IM_CHECK2;
+    case IM_CHECK2:
+      IM_NEEDBYTE
+      z->state->sub.check.need += (uLong)IM_NEXTBYTE << 8;
+      z->state->mode = IM_CHECK1;
+    case IM_CHECK1:
+      IM_NEEDBYTE
+      z->state->sub.check.need += (uLong)IM_NEXTBYTE;
+
+      if (z->state->sub.check.was != z->state->sub.check.need)
+      {
+        z->state->mode = IM_BAD;
+        z->msg = (char*)"incorrect data check";
+        z->state->sub.marker = 5;       // can't try inflateSync 
+        break;
+      }
+      Tracev((stderr, "inflate: zlib check ok\n"));
+      z->state->mode = IM_DONE;
+    case IM_DONE:
+      return Z_STREAM_END;
+    case IM_BAD:
+      return Z_DATA_ERROR;
+    default:
+      return Z_STREAM_ERROR;
+  }
+}
+
+
+
+#ifdef _UNICODE
+
+static int GetAnsiFileName(LPCWSTR name, char * buf, int nBufSize)
+{
+	memset(buf, 0, nBufSize);
+
+	int n = WideCharToMultiByte(CP_ACP,	// code page
+								0,						// performance and mapping flags
+								name,					// wide-character string
+								-1,						// number of chars in string
+								buf,					// buffer for new string
+								nBufSize,				// size of buffer
+								NULL,					// default for unmappable chars
+								NULL);					// set when default char used
+	return n;
+}
+
+static int GetUnicodeFileName(const char * name, LPWSTR buf, int nBufSize)
+{
+	memset(buf, 0, nBufSize*sizeof(TCHAR));
+
+	int n = MultiByteToWideChar(CP_ACP,		// code page
+								0,			// character-type options
+								name,		// string to map
+								-1,			// number of bytes in string
+								buf,		// wide-character buffer
+								nBufSize);	// size of buffer
+
+	return n;
+}
+
+#endif
+
+
+// unzip.c -- IO on .zip files using zlib
+// Version 0.15 beta, Mar 19th, 1998,
+// Read unzip.h for more info
+
+
+
+
+#define UNZ_BUFSIZE (16384)
+#define UNZ_MAXFILENAMEINZIP (256)
+#define SIZECENTRALDIRITEM (0x2e)
+#define SIZEZIPLOCALHEADER (0x1e)
+
+
+
+
+const char unz_copyright[] = " unzip 0.15 Copyright 1998 Gilles Vollant ";
+
+// unz_file_info_interntal contain internal info about a file in zipfile
+typedef struct unz_file_info_internal_s
+{
+    uLong offset_curfile;// relative offset of local header 4 bytes
+} unz_file_info_internal;
+
+
+typedef struct
+{ bool is_handle; // either a handle or memory
+  bool canseek;
+  // for handles:
+  HANDLE h; bool herr; unsigned long initial_offset;
+  // for memory:
+  void *buf; unsigned int len,pos; // if it's a memory block
+} LUFILE;
+
+
+LUFILE *lufopen(void *z,unsigned int len,DWORD flags,ZRESULT *err)
+{ 
+	if (flags!=ZIP_HANDLE && flags!=ZIP_FILENAME && flags!=ZIP_MEMORY) 
+	{
+		*err=ZR_ARGS; 
+		return NULL;
+	}
+	//
+	HANDLE h=0; bool canseek=false; *err=ZR_OK;
+	if (flags==ZIP_HANDLE||flags==ZIP_FILENAME)
+	{ 
+		if (flags==ZIP_HANDLE)
+		{ 
+			HANDLE hf = z;
+		
+			BOOL res = DuplicateHandle(GetCurrentProcess(),hf,GetCurrentProcess(),&h,0,FALSE,DUPLICATE_SAME_ACCESS);
+		
+			if (!res) 
+			{
+				*err=ZR_NODUPH; 
+				return NULL;
+			}
+		}
+		else
+		{ 
+			h = CreateFile((const TCHAR *)z, GENERIC_READ, FILE_SHARE_READ, 
+					NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+		
+			if (h == INVALID_HANDLE_VALUE) 
+			{
+				*err = ZR_NOFILE; 
+				return NULL;
+			}
+		}
+		DWORD type = GetFileType(h);
+		canseek = (type==FILE_TYPE_DISK);
+	}
+	LUFILE *lf = new LUFILE;
+	if (flags==ZIP_HANDLE||flags==ZIP_FILENAME)
+	{ 
+		lf->is_handle=true;
+		lf->canseek=canseek;
+		lf->h=h; lf->herr=false;
+		lf->initial_offset=0;
+		if (canseek) 
+			lf->initial_offset = SetFilePointer(h,0,NULL,FILE_CURRENT);
+	}
+	else
+	{ 
+		lf->is_handle=false;
+		lf->canseek=true;
+		lf->buf=z; 
+		lf->len=len; 
+		lf->pos=0; 
+		lf->initial_offset=0;
+	}
+	*err=ZR_OK;
+	return lf;
+}
+
+
+int lufclose(LUFILE *stream)
+{ if (stream==NULL) return EOF;
+  if (stream->is_handle) CloseHandle(stream->h);
+  delete stream;
+  return 0;
+}
+
+int luferror(LUFILE *stream)
+{ if (stream->is_handle && stream->herr) return 1;
+  else return 0;
+}
+
+long int luftell(LUFILE *stream)
+{ if (stream->is_handle && stream->canseek) return SetFilePointer(stream->h,0,NULL,FILE_CURRENT)-stream->initial_offset;
+  else if (stream->is_handle) return 0;
+  else return stream->pos;
+}
+
+int lufseek(LUFILE *stream, long offset, int whence)
+{ if (stream->is_handle && stream->canseek)
+  { if (whence==SEEK_SET) SetFilePointer(stream->h,stream->initial_offset+offset,0,FILE_BEGIN);
+    else if (whence==SEEK_CUR) SetFilePointer(stream->h,offset,NULL,FILE_CURRENT);
+    else if (whence==SEEK_END) SetFilePointer(stream->h,offset,NULL,FILE_END);
+    else return 19; // EINVAL
+    return 0;
+  }
+  else if (stream->is_handle) return 29; // ESPIPE
+  else
+  { if (whence==SEEK_SET) stream->pos=offset;
+    else if (whence==SEEK_CUR) stream->pos+=offset;
+    else if (whence==SEEK_END) stream->pos=stream->len+offset;
+    return 0;
+  }
+}
+
+
+size_t lufread(void *ptr,size_t size,size_t n,LUFILE *stream)
+{ unsigned int toread = (unsigned int)(size*n);
+  if (stream->is_handle)
+  { DWORD red; BOOL res = ReadFile(stream->h,ptr,toread,&red,NULL);
+    if (!res) stream->herr=true;
+    return red/size;
+  }
+  if (stream->pos+toread > stream->len) toread = stream->len-stream->pos;
+  memcpy(ptr, (char*)stream->buf + stream->pos, toread); DWORD red = toread;
+  stream->pos += red;
+  return red/size;
+}
+
+
+
+
+// file_in_zip_read_info_s contain internal information about a file in zipfile,
+//  when reading and decompress it
+typedef struct
+{
+	char  *read_buffer;         // internal buffer for compressed data
+	z_stream stream;            // zLib stream structure for inflate
+
+	uLong pos_in_zipfile;       // position in byte on the zipfile, for fseek
+	uLong stream_initialised;   // flag set if stream structure is initialised
+
+	uLong offset_local_extrafield;// offset of the local extra field
+	uInt  size_local_extrafield;// size of the local extra field
+	uLong pos_local_extrafield;   // position in the local extra field in read
+
+	uLong crc32;                // crc32 of all data uncompressed
+	uLong crc32_wait;           // crc32 we must obtain after decompress all
+	uLong rest_read_compressed; // number of byte to be decompressed
+	uLong rest_read_uncompressed;//number of byte to be obtained after decomp
+	LUFILE* file;                 // io structore of the zipfile
+	uLong compression_method;   // compression method (0==store)
+	uLong byte_before_the_zipfile;// byte before the zipfile, (>0 for sfx)
+} file_in_zip_read_info_s;
+
+
+// unz_s contain internal information about the zipfile
+typedef struct
+{
+	LUFILE* file;               // io structore of the zipfile
+	unz_global_info gi;         // public global information
+	uLong byte_before_the_zipfile;// byte before the zipfile, (>0 for sfx)
+	uLong num_file;             // number of the current file in the zipfile
+	uLong pos_in_central_dir;   // pos of the current file in the central dir
+	uLong current_file_ok;      // flag about the usability of the current file
+	uLong central_pos;          // position of the beginning of the central dir
+
+	uLong size_central_dir;     // size of the central directory
+	uLong offset_central_dir;   // offset of start of central directory with respect to the starting disk number
+
+	unz_file_info cur_file_info; // public info about the current file in zip
+	unz_file_info_internal cur_file_info_internal; // private info about it
+    file_in_zip_read_info_s* pfile_in_zip_read; // structure about the current file if we are decompressing it
+} unz_s, *unzFile;
+
+
+int unzStringFileNameCompare (const char* fileName1,const char* fileName2,int iCaseSensitivity);
+//   Compare two filename (fileName1,fileName2).
+
+z_off_t unztell (unzFile file);
+//  Give the current position in uncompressed data
+
+int unzeof (unzFile file);
+//  return 1 if the end of file was reached, 0 elsewhere
+
+int unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len);
+//  Read extra field from the current file (opened by unzOpenCurrentFile)
+//  This is the local-header version of the extra field (sometimes, there is
+//    more info in the local-header version than in the central-header)
+//
+//  if buf==NULL, it return the size of the local extra field
+//
+//  if buf!=NULL, len is the size of the buffer, the extra header is copied in
+//	buf.
+//  the return value is the number of bytes copied in buf, or (if <0)
+//	the error code
+
+
+
+// ===========================================================================
+//   Read a byte from a gz_stream; update next_in and avail_in. Return EOF
+// for end of file.
+// IN assertion: the stream s has been sucessfully opened for reading.
+
+int unzlocal_getByte(LUFILE *fin,int *pi)
+{ unsigned char c;
+  int err = (int)lufread(&c, 1, 1, fin);
+  if (err==1)
+  { *pi = (int)c;
+    return UNZ_OK;
+  }
+  else
+  { if (luferror(fin)) return UNZ_ERRNO;
+    else return UNZ_EOF;
+  }
+}
+
+
+// ===========================================================================
+// Reads a long in LSB order from the given gz_stream. Sets
+int unzlocal_getShort (LUFILE *fin,uLong *pX)
+{
+    uLong x ;
+    int i;
+    int err;
+
+    err = unzlocal_getByte(fin,&i);
+    x = (uLong)i;
+
+    if (err==UNZ_OK)
+        err = unzlocal_getByte(fin,&i);
+    x += ((uLong)i)<<8;
+
+    if (err==UNZ_OK)
+        *pX = x;
+    else
+        *pX = 0;
+    return err;
+}
+
+int unzlocal_getLong (LUFILE *fin,uLong *pX)
+{
+    uLong x ;
+    int i;
+    int err;
+
+    err = unzlocal_getByte(fin,&i);
+    x = (uLong)i;
+    
+    if (err==UNZ_OK)
+        err = unzlocal_getByte(fin,&i);
+    x += ((uLong)i)<<8;
+
+    if (err==UNZ_OK)
+        err = unzlocal_getByte(fin,&i);
+    x += ((uLong)i)<<16;
+
+    if (err==UNZ_OK)
+        err = unzlocal_getByte(fin,&i);
+    x += ((uLong)i)<<24;
+   
+    if (err==UNZ_OK)
+        *pX = x;
+    else
+        *pX = 0;
+    return err;
+}
+
+
+// My own strcmpi / strcasecmp 
+int strcmpcasenosensitive_internal (const char* fileName1,const char *fileName2)
+{
+	for (;;)
+	{
+		char c1=*(fileName1++);
+		char c2=*(fileName2++);
+		if ((c1>='a') && (c1<='z'))
+			c1 -= (char)0x20;
+		if ((c2>='a') && (c2<='z'))
+			c2 -= (char)0x20;
+		if (c1=='\0')
+			return ((c2=='\0') ? 0 : -1);
+		if (c2=='\0')
+			return 1;
+		if (c1<c2)
+			return -1;
+		if (c1>c2)
+			return 1;
+	}
+}
+
+
+
+
+//
+// Compare two filename (fileName1,fileName2).
+// If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
+// If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi or strcasecmp)
+//
+int unzStringFileNameCompare (const char*fileName1,const char*fileName2,int iCaseSensitivity)
+{ if (iCaseSensitivity==1) return strcmp(fileName1,fileName2);
+  else return strcmpcasenosensitive_internal(fileName1,fileName2);
+} 
+
+#define BUFREADCOMMENT (0x400)
+
+
+//  Locate the Central directory of a zipfile (at the end, just before
+// the global comment)
+uLong unzlocal_SearchCentralDir(LUFILE *fin)
+{ if (lufseek(fin,0,SEEK_END) != 0) return 0;
+  uLong uSizeFile = luftell(fin);
+
+  uLong uMaxBack=0xffff; // maximum size of global comment
+  if (uMaxBack>uSizeFile) uMaxBack = uSizeFile;
+
+  unsigned char *buf = (unsigned char*)zmalloc(BUFREADCOMMENT+4);
+  if (buf==NULL) return 0;
+  uLong uPosFound=0;
+
+  uLong uBackRead = 4;
+  while (uBackRead<uMaxBack)
+  { uLong uReadSize,uReadPos ;
+    int i;
+    if (uBackRead+BUFREADCOMMENT>uMaxBack) uBackRead = uMaxBack;
+    else uBackRead+=BUFREADCOMMENT;
+    uReadPos = uSizeFile-uBackRead ;
+    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ? (BUFREADCOMMENT+4) : (uSizeFile-uReadPos);
+    if (lufseek(fin,uReadPos,SEEK_SET)!=0) break;
+    if (lufread(buf,(uInt)uReadSize,1,fin)!=1) break;
+    for (i=(int)uReadSize-3; (i--)>0;)
+    { if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&	((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
+      { uPosFound = uReadPos+i;	break;
+      }
+    }
+    if (uPosFound!=0) break;
+  }
+  if (buf) zfree(buf);
+  return uPosFound;
+}
+
+
+int unzGoToFirstFile (unzFile file);
+int unzCloseCurrentFile (unzFile file);
+
+// Open a Zip file.
+// If the zipfile cannot be opened (file don't exist or in not valid), return NULL.
+// Otherwise, the return value is a unzFile Handle, usable with other unzip functions
+unzFile unzOpenInternal(LUFILE *fin)
+{ if (fin==NULL) return NULL;
+  if (unz_copyright[0]!=' ') {lufclose(fin); return NULL;}
+
+  int err=UNZ_OK;
+  unz_s us;
+  uLong central_pos,uL;
+  central_pos = unzlocal_SearchCentralDir(fin);
+  if (central_pos==0) err=UNZ_ERRNO;
+  if (lufseek(fin,central_pos,SEEK_SET)!=0) err=UNZ_ERRNO;
+  // the signature, already checked
+  if (unzlocal_getLong(fin,&uL)!=UNZ_OK) err=UNZ_ERRNO;
+  // number of this disk
+  uLong number_disk;          // number of the current dist, used for spanning ZIP, unsupported, always 0
+  if (unzlocal_getShort(fin,&number_disk)!=UNZ_OK) err=UNZ_ERRNO;
+  // number of the disk with the start of the central directory
+  uLong number_disk_with_CD;  // number the the disk with central dir, used for spaning ZIP, unsupported, always 0
+  if (unzlocal_getShort(fin,&number_disk_with_CD)!=UNZ_OK) err=UNZ_ERRNO;
+  // total number of entries in the central dir on this disk
+  if (unzlocal_getShort(fin,&us.gi.number_entry)!=UNZ_OK) err=UNZ_ERRNO;
+  // total number of entries in the central dir
+  uLong number_entry_CD;      // total number of entries in the central dir (same than number_entry on nospan)
+  if (unzlocal_getShort(fin,&number_entry_CD)!=UNZ_OK) err=UNZ_ERRNO;
+  if ((number_entry_CD!=us.gi.number_entry) || (number_disk_with_CD!=0) || (number_disk!=0)) err=UNZ_BADZIPFILE;
+  // size of the central directory
+  if (unzlocal_getLong(fin,&us.size_central_dir)!=UNZ_OK) err=UNZ_ERRNO;
+  // offset of start of central directory with respect to the starting disk number
+  if (unzlocal_getLong(fin,&us.offset_central_dir)!=UNZ_OK) err=UNZ_ERRNO;
+  // zipfile comment length
+  if (unzlocal_getShort(fin,&us.gi.size_comment)!=UNZ_OK) err=UNZ_ERRNO;
+  if ((central_pos+fin->initial_offset<us.offset_central_dir+us.size_central_dir) && (err==UNZ_OK)) err=UNZ_BADZIPFILE;
+  if (err!=UNZ_OK) {lufclose(fin);return NULL;}
+
+  us.file=fin;
+  us.byte_before_the_zipfile = central_pos+fin->initial_offset - (us.offset_central_dir+us.size_central_dir);
+  us.central_pos = central_pos;
+  us.pfile_in_zip_read = NULL;
+  fin->initial_offset = 0; // since the zipfile itself is expected to handle this
+
+  unz_s *s = (unz_s*)zmalloc(sizeof(unz_s));
+  *s=us;
+  unzGoToFirstFile((unzFile)s);
+  return (unzFile)s;
+}
+
+
+
+//  Close a ZipFile opened with unzipOpen.
+//  If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),
+//    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
+//  return UNZ_OK if there is no problem.
+int unzClose (unzFile file)
+{
+	unz_s* s;
+	if (file==NULL)
+		return UNZ_PARAMERROR;
+	s=(unz_s*)file;
+
+    if (s->pfile_in_zip_read!=NULL)
+        unzCloseCurrentFile(file);
+
+	lufclose(s->file);
+	if (s) zfree(s); // unused s=0;
+	return UNZ_OK;
+}
+
+
+//  Write info about the ZipFile in the *pglobal_info structure.
+//  No preparation of the structure is needed
+//  return UNZ_OK if there is no problem. 
+int unzGetGlobalInfo (unzFile file,unz_global_info *pglobal_info)
+{
+	unz_s* s;
+	if (file==NULL)
+		return UNZ_PARAMERROR;
+	s=(unz_s*)file;
+	*pglobal_info=s->gi;
+	return UNZ_OK;
+}
+
+
+//   Translate date/time from Dos format to tm_unz (readable more easilty)
+void unzlocal_DosDateToTmuDate (uLong ulDosDate, tm_unz* ptm)
+{
+    uLong uDate;
+    uDate = (uLong)(ulDosDate>>16);
+    ptm->tm_mday = (uInt)(uDate&0x1f) ;
+    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;
+    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;
+
+    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);
+    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;
+    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;
+}
+
+//  Get Info about the current file in the zipfile, with internal only info
+int unzlocal_GetCurrentFileInfoInternal (unzFile file,
+                                                  unz_file_info *pfile_info,
+                                                  unz_file_info_internal
+                                                  *pfile_info_internal,
+                                                  char *szFileName,
+												  uLong fileNameBufferSize,
+                                                  void *extraField,
+												  uLong extraFieldBufferSize,
+                                                  char *szComment,
+												  uLong commentBufferSize);
+
+int unzlocal_GetCurrentFileInfoInternal (unzFile file, unz_file_info *pfile_info,
+   unz_file_info_internal *pfile_info_internal, char *szFileName,
+   uLong fileNameBufferSize, void *extraField, uLong extraFieldBufferSize,
+   char *szComment, uLong commentBufferSize)
+{
+	unz_s* s;
+	unz_file_info file_info;
+	unz_file_info_internal file_info_internal;
+	int err=UNZ_OK;
+	uLong uMagic;
+	long lSeek=0;
+
+	if (file==NULL)
+		return UNZ_PARAMERROR;
+	s=(unz_s*)file;
+	if (lufseek(s->file,s->pos_in_central_dir+s->byte_before_the_zipfile,SEEK_SET)!=0)
+		err=UNZ_ERRNO;
+
+
+	// we check the magic
+	if (err==UNZ_OK)
+		if (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)
+			err=UNZ_ERRNO;
+		else if (uMagic!=0x02014b50)
+			err=UNZ_BADZIPFILE;
+
+	if (unzlocal_getShort(s->file,&file_info.version) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getShort(s->file,&file_info.version_needed) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getShort(s->file,&file_info.flag) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getShort(s->file,&file_info.compression_method) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getLong(s->file,&file_info.dosDate) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+    unzlocal_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);
+
+	if (unzlocal_getLong(s->file,&file_info.crc) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getLong(s->file,&file_info.compressed_size) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getLong(s->file,&file_info.uncompressed_size) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getShort(s->file,&file_info.size_filename) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getShort(s->file,&file_info.size_file_extra) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getShort(s->file,&file_info.size_file_comment) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getShort(s->file,&file_info.disk_num_start) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getShort(s->file,&file_info.internal_fa) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getLong(s->file,&file_info.external_fa) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getLong(s->file,&file_info_internal.offset_curfile) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	lSeek+=file_info.size_filename;
+	if ((err==UNZ_OK) && (szFileName!=NULL))
+	{
+		uLong uSizeRead ;
+		if (file_info.size_filename<fileNameBufferSize)
+		{
+			*(szFileName+file_info.size_filename)='\0';
+			uSizeRead = file_info.size_filename;
+		}
+		else
+			uSizeRead = fileNameBufferSize;
+
+		if ((file_info.size_filename>0) && (fileNameBufferSize>0))
+			if (lufread(szFileName,(uInt)uSizeRead,1,s->file)!=1)
+				err=UNZ_ERRNO;
+		lSeek -= uSizeRead;
+	}
+
+
+	if ((err==UNZ_OK) && (extraField!=NULL))
+	{
+		uLong uSizeRead ;
+		if (file_info.size_file_extra<extraFieldBufferSize)
+			uSizeRead = file_info.size_file_extra;
+		else
+			uSizeRead = extraFieldBufferSize;
+
+		if (lSeek!=0)
+			if (lufseek(s->file,lSeek,SEEK_CUR)==0)
+				lSeek=0;
+			else
+				err=UNZ_ERRNO;
+		if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))
+			if (lufread(extraField,(uInt)uSizeRead,1,s->file)!=1)
+				err=UNZ_ERRNO;
+		lSeek += file_info.size_file_extra - uSizeRead;
+	}
+	else
+		lSeek+=file_info.size_file_extra;
+
+
+	if ((err==UNZ_OK) && (szComment!=NULL))
+	{
+		uLong uSizeRead ;
+		if (file_info.size_file_comment<commentBufferSize)
+		{
+			*(szComment+file_info.size_file_comment)='\0';
+			uSizeRead = file_info.size_file_comment;
+		}
+		else
+			uSizeRead = commentBufferSize;
+
+		if (lSeek!=0)
+			if (lufseek(s->file,lSeek,SEEK_CUR)==0)
+				{} // unused lSeek=0;
+			else
+				err=UNZ_ERRNO;
+		if ((file_info.size_file_comment>0) && (commentBufferSize>0))
+			if (lufread(szComment,(uInt)uSizeRead,1,s->file)!=1)
+				err=UNZ_ERRNO;
+		//unused lSeek+=file_info.size_file_comment - uSizeRead;
+	}
+	else {} //unused lSeek+=file_info.size_file_comment;
+
+	if ((err==UNZ_OK) && (pfile_info!=NULL))
+		*pfile_info=file_info;
+
+	if ((err==UNZ_OK) && (pfile_info_internal!=NULL))
+		*pfile_info_internal=file_info_internal;
+
+	return err;
+}
+
+
+
+//  Write info about the ZipFile in the *pglobal_info structure.
+//  No preparation of the structure is needed
+//  return UNZ_OK if there is no problem.
+int unzGetCurrentFileInfo (unzFile file, unz_file_info *pfile_info,
+  char *szFileName, uLong fileNameBufferSize, void *extraField, uLong extraFieldBufferSize,
+  char *szComment, uLong commentBufferSize)
+{ return unzlocal_GetCurrentFileInfoInternal(file,pfile_info,NULL,szFileName,fileNameBufferSize,
+      extraField,extraFieldBufferSize, szComment,commentBufferSize);
+}
+
+
+//  Set the current file of the zipfile to the first file.
+//  return UNZ_OK if there is no problem
+int unzGoToFirstFile (unzFile file)
+{
+	int err;
+	unz_s* s;
+	if (file==NULL) return UNZ_PARAMERROR;
+	s=(unz_s*)file;
+	s->pos_in_central_dir=s->offset_central_dir;
+	s->num_file=0;
+	err=unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
+											 &s->cur_file_info_internal,
+											 NULL,0,NULL,0,NULL,0);
+	s->current_file_ok = (err == UNZ_OK);
+	return err;
+}
+
+
+//  Set the current file of the zipfile to the next file.
+//  return UNZ_OK if there is no problem
+//  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
+int unzGoToNextFile (unzFile file)
+{
+	unz_s* s;
+	int err;
+
+	if (file==NULL)
+		return UNZ_PARAMERROR;
+	s=(unz_s*)file;
+	if (!s->current_file_ok)
+		return UNZ_END_OF_LIST_OF_FILE;
+	if (s->num_file+1==s->gi.number_entry)
+		return UNZ_END_OF_LIST_OF_FILE;
+
+	s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
+			s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;
+	s->num_file++;
+	err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
+											   &s->cur_file_info_internal,
+											   NULL,0,NULL,0,NULL,0);
+	s->current_file_ok = (err == UNZ_OK);
+	return err;
+}
+
+
+//  Try locate the file szFileName in the zipfile.
+//  For the iCaseSensitivity signification, see unzStringFileNameCompare
+//  return value :
+//  UNZ_OK if the file is found. It becomes the current file.
+//  UNZ_END_OF_LIST_OF_FILE if the file is not found
+int unzLocateFile (unzFile file, const TCHAR *szFileName, int iCaseSensitivity)
+{
+	unz_s* s;
+	int err;
+
+	uLong num_fileSaved;
+	uLong pos_in_central_dirSaved;
+
+	if (file==NULL)
+		return UNZ_PARAMERROR;
+
+    if (_tcslen(szFileName)>=UNZ_MAXFILENAMEINZIP)
+        return UNZ_PARAMERROR;
+
+	char szFileNameA[MAX_PATH];
+
+#ifdef _UNICODE
+	GetAnsiFileName(szFileName, szFileNameA, MAX_PATH-1);
+#else
+	strcpy(szFileNameA, szFileName);
+#endif
+
+	s=(unz_s*)file;
+	if (!s->current_file_ok)
+		return UNZ_END_OF_LIST_OF_FILE;
+
+	num_fileSaved = s->num_file;
+	pos_in_central_dirSaved = s->pos_in_central_dir;
+
+	err = unzGoToFirstFile(file);
+
+	while (err == UNZ_OK)
+	{
+		char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];
+		unzGetCurrentFileInfo(file,NULL,
+								szCurrentFileName,sizeof(szCurrentFileName)-1,
+								NULL,0,NULL,0);
+		if (unzStringFileNameCompare(szCurrentFileName,szFileNameA,iCaseSensitivity)==0)
+			return UNZ_OK;
+		err = unzGoToNextFile(file);
+	}
+
+	s->num_file = num_fileSaved ;
+	s->pos_in_central_dir = pos_in_central_dirSaved ;
+	return err;
+}
+
+
+//  Read the local header of the current zipfile
+//  Check the coherency of the local header and info in the end of central
+//        directory about this file
+//  store in *piSizeVar the size of extra info in local header
+//        (filename and size of extra field data)
+int unzlocal_CheckCurrentFileCoherencyHeader (unz_s *s,uInt *piSizeVar,
+  uLong *poffset_local_extrafield, uInt  *psize_local_extrafield)
+{
+	uLong uMagic,uData,uFlags;
+	uLong size_filename;
+	uLong size_extra_field;
+	int err=UNZ_OK;
+
+	*piSizeVar = 0;
+	*poffset_local_extrafield = 0;
+	*psize_local_extrafield = 0;
+
+	if (lufseek(s->file,s->cur_file_info_internal.offset_curfile + s->byte_before_the_zipfile,SEEK_SET)!=0)
+		return UNZ_ERRNO;
+
+
+	if (err==UNZ_OK)
+		if (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)
+			err=UNZ_ERRNO;
+		else if (uMagic!=0x04034b50)
+			err=UNZ_BADZIPFILE;
+
+	if (unzlocal_getShort(s->file,&uData) != UNZ_OK)
+		err=UNZ_ERRNO;
+//	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))
+//		err=UNZ_BADZIPFILE;
+	if (unzlocal_getShort(s->file,&uFlags) != UNZ_OK)
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getShort(s->file,&uData) != UNZ_OK)
+		err=UNZ_ERRNO;
+	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))
+		err=UNZ_BADZIPFILE;
+
+    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&
+                         (s->cur_file_info.compression_method!=Z_DEFLATED))
+        err=UNZ_BADZIPFILE;
+
+	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) // date/time
+		err=UNZ_ERRNO;
+
+	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) // crc
+		err=UNZ_ERRNO;
+	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) &&
+		                      ((uFlags & 8)==0))
+		err=UNZ_BADZIPFILE;
+
+	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) // size compr
+		err=UNZ_ERRNO;
+	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) &&
+							  ((uFlags & 8)==0))
+		err=UNZ_BADZIPFILE;
+
+	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) // size uncompr
+		err=UNZ_ERRNO;
+	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) &&
+							  ((uFlags & 8)==0))
+		err=UNZ_BADZIPFILE;
+
+
+	if (unzlocal_getShort(s->file,&size_filename) != UNZ_OK)
+		err=UNZ_ERRNO;
+	else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))
+		err=UNZ_BADZIPFILE;
+
+	*piSizeVar += (uInt)size_filename;
+
+	if (unzlocal_getShort(s->file,&size_extra_field) != UNZ_OK)
+		err=UNZ_ERRNO;
+	*poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +
+									SIZEZIPLOCALHEADER + size_filename;
+	*psize_local_extrafield = (uInt)size_extra_field;
+
+	*piSizeVar += (uInt)size_extra_field;
+
+	return err;
+}
+
+
+
+
+
+//  Open for reading data the current file in the zipfile.
+//  If there is no error and the file is opened, the return value is UNZ_OK.
+int unzOpenCurrentFile (unzFile file)
+{
+	int err;
+	int Store;
+	uInt iSizeVar;
+	unz_s* s;
+	file_in_zip_read_info_s* pfile_in_zip_read_info;
+	uLong offset_local_extrafield;  // offset of the local extra field
+	uInt  size_local_extrafield;    // size of the local extra field
+
+	if (file==NULL)
+		return UNZ_PARAMERROR;
+	s=(unz_s*)file;
+	if (!s->current_file_ok)
+		return UNZ_PARAMERROR;
+
+    if (s->pfile_in_zip_read != NULL)
+        unzCloseCurrentFile(file);
+
+	if (unzlocal_CheckCurrentFileCoherencyHeader(s,&iSizeVar,
+				&offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)
+		return UNZ_BADZIPFILE;
+
+	pfile_in_zip_read_info = (file_in_zip_read_info_s*)zmalloc(sizeof(file_in_zip_read_info_s));
+	if (pfile_in_zip_read_info==NULL)
+		return UNZ_INTERNALERROR;
+
+	pfile_in_zip_read_info->read_buffer=(char*)zmalloc(UNZ_BUFSIZE);
+	pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;
+	pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;
+	pfile_in_zip_read_info->pos_local_extrafield=0;
+
+	if (pfile_in_zip_read_info->read_buffer==NULL)
+	{
+		if (pfile_in_zip_read_info!=0) zfree(pfile_in_zip_read_info); //unused pfile_in_zip_read_info=0;
+		return UNZ_INTERNALERROR;
+	}
+
+	pfile_in_zip_read_info->stream_initialised=0;
+
+	if ((s->cur_file_info.compression_method!=0) && (s->cur_file_info.compression_method!=Z_DEFLATED))
+        { // unused err=UNZ_BADZIPFILE;
+        }
+	Store = s->cur_file_info.compression_method==0;
+
+	pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;
+	pfile_in_zip_read_info->crc32=0;
+	pfile_in_zip_read_info->compression_method =
+            s->cur_file_info.compression_method;
+	pfile_in_zip_read_info->file=s->file;
+	pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;
+
+    pfile_in_zip_read_info->stream.total_out = 0;
+
+	if (!Store)
+	{
+	  pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
+	  pfile_in_zip_read_info->stream.zfree = (free_func)0;
+	  pfile_in_zip_read_info->stream.opaque = (voidpf)0;
+
+          err=inflateInit2(&pfile_in_zip_read_info->stream);
+	  if (err == Z_OK)
+	    pfile_in_zip_read_info->stream_initialised=1;
+        // windowBits is passed < 0 to tell that there is no zlib header.
+        // Note that in this case inflate *requires* an extra "dummy" byte
+        // after the compressed stream in order to complete decompression and
+        // return Z_STREAM_END.
+        // In unzip, i don't wait absolutely Z_STREAM_END because I known the
+        // size of both compressed and uncompressed data
+	}
+	pfile_in_zip_read_info->rest_read_compressed =
+            s->cur_file_info.compressed_size ;
+	pfile_in_zip_read_info->rest_read_uncompressed =
+            s->cur_file_info.uncompressed_size ;
+
+
+	pfile_in_zip_read_info->pos_in_zipfile =
+            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +
+			  iSizeVar;
+
+	pfile_in_zip_read_info->stream.avail_in = (uInt)0;
+
+
+	s->pfile_in_zip_read = pfile_in_zip_read_info;
+    return UNZ_OK;
+}
+
+
+//  Read bytes from the current file.
+//  buf contain buffer where data must be copied
+//  len the size of buf.
+//  return the number of byte copied if somes bytes are copied
+//  return 0 if the end of file was reached
+//  return <0 with error code if there is an error
+//    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
+int unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)
+{ int err=UNZ_OK;
+  uInt iRead = 0;
+
+  unz_s *s = (unz_s*)file;
+  if (s==NULL) return UNZ_PARAMERROR;
+
+  file_in_zip_read_info_s* pfile_in_zip_read_info = s->pfile_in_zip_read;
+  if (pfile_in_zip_read_info==NULL) return UNZ_PARAMERROR;
+  if ((pfile_in_zip_read_info->read_buffer == NULL)) return UNZ_END_OF_LIST_OF_FILE;
+  if (len==0) return 0;
+
+  pfile_in_zip_read_info->stream.next_out = (Byte*)buf;
+  pfile_in_zip_read_info->stream.avail_out = (uInt)len;
+
+  if (len>pfile_in_zip_read_info->rest_read_uncompressed)
+  { pfile_in_zip_read_info->stream.avail_out = (uInt)pfile_in_zip_read_info->rest_read_uncompressed;
+  }
+
+  while (pfile_in_zip_read_info->stream.avail_out>0)
+  { if ((pfile_in_zip_read_info->stream.avail_in==0) && (pfile_in_zip_read_info->rest_read_compressed>0))
+    { uInt uReadThis = UNZ_BUFSIZE;
+      if (pfile_in_zip_read_info->rest_read_compressed<uReadThis) uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;
+      if (uReadThis == 0) return UNZ_EOF;
+      if (lufseek(pfile_in_zip_read_info->file, pfile_in_zip_read_info->pos_in_zipfile + pfile_in_zip_read_info->byte_before_the_zipfile,SEEK_SET)!=0) return UNZ_ERRNO;
+      if (lufread(pfile_in_zip_read_info->read_buffer,uReadThis,1,pfile_in_zip_read_info->file)!=1) return UNZ_ERRNO;
+      pfile_in_zip_read_info->pos_in_zipfile += uReadThis;
+      pfile_in_zip_read_info->rest_read_compressed-=uReadThis;
+      pfile_in_zip_read_info->stream.next_in = (Byte*)pfile_in_zip_read_info->read_buffer;
+      pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;
+    }
+
+    if (pfile_in_zip_read_info->compression_method==0)
+    { uInt uDoCopy,i ;
+      if (pfile_in_zip_read_info->stream.avail_out < pfile_in_zip_read_info->stream.avail_in)
+      { uDoCopy = pfile_in_zip_read_info->stream.avail_out ;
+      }
+      else
+      { uDoCopy = pfile_in_zip_read_info->stream.avail_in ;
+      }
+      for (i=0;i<uDoCopy;i++)
+      { *(pfile_in_zip_read_info->stream.next_out+i) = *(pfile_in_zip_read_info->stream.next_in+i);
+      }
+      pfile_in_zip_read_info->crc32 = ucrc32(pfile_in_zip_read_info->crc32,pfile_in_zip_read_info->stream.next_out,uDoCopy);
+      pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;
+      pfile_in_zip_read_info->stream.avail_in -= uDoCopy;
+      pfile_in_zip_read_info->stream.avail_out -= uDoCopy;
+      pfile_in_zip_read_info->stream.next_out += uDoCopy;
+      pfile_in_zip_read_info->stream.next_in += uDoCopy;
+      pfile_in_zip_read_info->stream.total_out += uDoCopy;
+      iRead += uDoCopy;
+    }
+    else
+    { uLong uTotalOutBefore,uTotalOutAfter;
+      const Byte *bufBefore;
+      uLong uOutThis;
+      int flush=Z_SYNC_FLUSH;
+      uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;
+      bufBefore = pfile_in_zip_read_info->stream.next_out;
+      err=inflate(&pfile_in_zip_read_info->stream,flush);
+      uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;
+      uOutThis = uTotalOutAfter-uTotalOutBefore;
+      pfile_in_zip_read_info->crc32 = ucrc32(pfile_in_zip_read_info->crc32,bufBefore,(uInt)(uOutThis));
+      pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;
+      iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
+      if (err==Z_STREAM_END) return (iRead==0) ? UNZ_EOF : iRead;
+      if (err!=Z_OK) break;
+    }
+  }
+
+  if (err==Z_OK) return iRead;
+  return err;
+}
+
+
+//  Give the current position in uncompressed data
+z_off_t unztell (unzFile file)
+{
+	unz_s* s;
+	file_in_zip_read_info_s* pfile_in_zip_read_info;
+	if (file==NULL)
+		return UNZ_PARAMERROR;
+	s=(unz_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+	if (pfile_in_zip_read_info==NULL)
+		return UNZ_PARAMERROR;
+
+	return (z_off_t)pfile_in_zip_read_info->stream.total_out;
+}
+
+
+//  return 1 if the end of file was reached, 0 elsewhere
+int unzeof (unzFile file)
+{
+	unz_s* s;
+	file_in_zip_read_info_s* pfile_in_zip_read_info;
+	if (file==NULL)
+		return UNZ_PARAMERROR;
+	s=(unz_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+	if (pfile_in_zip_read_info==NULL)
+		return UNZ_PARAMERROR;
+
+	if (pfile_in_zip_read_info->rest_read_uncompressed == 0)
+		return 1;
+	else
+		return 0;
+}
+
+
+
+//  Read extra field from the current file (opened by unzOpenCurrentFile)
+//  This is the local-header version of the extra field (sometimes, there is
+//    more info in the local-header version than in the central-header)
+//  if buf==NULL, it return the size of the local extra field that can be read
+//  if buf!=NULL, len is the size of the buffer, the extra header is copied in buf.
+//  the return value is the number of bytes copied in buf, or (if <0) the error code
+int unzGetLocalExtrafield (unzFile file,voidp buf,unsigned len)
+{
+	unz_s* s;
+	file_in_zip_read_info_s* pfile_in_zip_read_info;
+	uInt read_now;
+	uLong size_to_read;
+
+	if (file==NULL)
+		return UNZ_PARAMERROR;
+	s=(unz_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+	if (pfile_in_zip_read_info==NULL)
+		return UNZ_PARAMERROR;
+
+	size_to_read = (pfile_in_zip_read_info->size_local_extrafield -
+				pfile_in_zip_read_info->pos_local_extrafield);
+
+	if (buf==NULL)
+		return (int)size_to_read;
+
+	if (len>size_to_read)
+		read_now = (uInt)size_to_read;
+	else
+		read_now = (uInt)len ;
+
+	if (read_now==0)
+		return 0;
+
+	if (lufseek(pfile_in_zip_read_info->file, pfile_in_zip_read_info->offset_local_extrafield +  pfile_in_zip_read_info->pos_local_extrafield,SEEK_SET)!=0)
+		return UNZ_ERRNO;
+
+	if (lufread(buf,(uInt)size_to_read,1,pfile_in_zip_read_info->file)!=1)
+		return UNZ_ERRNO;
+
+	return (int)read_now;
+}
+
+//  Close the file in zip opened with unzipOpenCurrentFile
+//  Return UNZ_CRCERROR if all the file was read but the CRC is not good
+int unzCloseCurrentFile (unzFile file)
+{
+	int err=UNZ_OK;
+
+	unz_s* s;
+	file_in_zip_read_info_s* pfile_in_zip_read_info;
+	if (file==NULL)
+		return UNZ_PARAMERROR;
+	s=(unz_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+	if (pfile_in_zip_read_info==NULL)
+		return UNZ_PARAMERROR;
+
+
+	if (pfile_in_zip_read_info->rest_read_uncompressed == 0)
+	{
+		if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)
+			err=UNZ_CRCERROR;
+	}
+
+
+	if (pfile_in_zip_read_info->read_buffer!=0)
+        { void *buf = pfile_in_zip_read_info->read_buffer;
+          zfree(buf);
+          pfile_in_zip_read_info->read_buffer=0;
+        }
+	pfile_in_zip_read_info->read_buffer = NULL;
+	if (pfile_in_zip_read_info->stream_initialised)
+		inflateEnd(&pfile_in_zip_read_info->stream);
+
+	pfile_in_zip_read_info->stream_initialised = 0;
+        if (pfile_in_zip_read_info!=0) zfree(pfile_in_zip_read_info); // unused pfile_in_zip_read_info=0;
+
+    s->pfile_in_zip_read=NULL;
+
+	return err;
+}
+
+
+//  Get the global comment string of the ZipFile, in the szComment buffer.
+//  uSizeBuf is the size of the szComment buffer.
+//  return the number of byte copied or an error code <0
+int unzGetGlobalComment (unzFile file, char *szComment, uLong uSizeBuf)
+{ //int err=UNZ_OK;
+  unz_s* s;
+  uLong uReadThis ;
+  if (file==NULL) return UNZ_PARAMERROR;
+  s=(unz_s*)file;
+  uReadThis = uSizeBuf;
+  if (uReadThis>s->gi.size_comment) uReadThis = s->gi.size_comment;
+  if (lufseek(s->file,s->central_pos+22,SEEK_SET)!=0) return UNZ_ERRNO;
+  if (uReadThis>0)
+  { *szComment='\0';
+    if (lufread(szComment,(uInt)uReadThis,1,s->file)!=1) return UNZ_ERRNO;
+  }
+  if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment)) *(szComment+s->gi.size_comment)='\0';
+  return (int)uReadThis;
+}
+
+
+
+
+
+int unzOpenCurrentFile (unzFile file);
+int unzReadCurrentFile (unzFile file, void *buf, unsigned len);
+int unzCloseCurrentFile (unzFile file);
+
+
+FILETIME timet2filetime(const time_t timer)
+{ struct tm *tm = gmtime(&timer);
+  SYSTEMTIME st;
+  st.wYear = (WORD)(tm->tm_year+1900);
+  st.wMonth = (WORD)(tm->tm_mon+1);
+  st.wDay = (WORD)(tm->tm_mday);
+  st.wHour = (WORD)(tm->tm_hour);
+  st.wMinute = (WORD)(tm->tm_min);
+  st.wSecond = (WORD)(tm->tm_sec);
+  st.wMilliseconds=0;
+  FILETIME ft;
+  SystemTimeToFileTime(&st,&ft);
+  return ft;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+class TUnzip
+{ public:
+  TUnzip() : uf(0), currentfile(-1), czei(-1) {}
+
+  unzFile uf; int currentfile; ZIPENTRY cze; int czei;
+  TCHAR rootdir[MAX_PATH];
+
+  ZRESULT Open(void *z,unsigned int len,DWORD flags);
+  ZRESULT Get(int index,ZIPENTRY *ze);
+  ZRESULT Find(const TCHAR *name,bool ic,int *index,ZIPENTRY *ze);
+  ZRESULT Unzip(int index,void *dst,unsigned int len,DWORD flags);
+  ZRESULT Close();
+};
+
+
+ZRESULT TUnzip::Open(void *z,unsigned int len,DWORD flags)
+{ 
+	if (uf!=0 || currentfile!=-1) 
+		return ZR_NOTINITED;
+	GetCurrentDirectory(MAX_PATH,rootdir);
+	_tcscat(rootdir,_T("\\"));
+	if (flags==ZIP_HANDLE)
+	{ 
+		DWORD type = GetFileType(z);
+		if (type!=FILE_TYPE_DISK) 
+			return ZR_SEEK;
+	}
+	ZRESULT e; 
+	LUFILE *f = lufopen(z,len,flags,&e);
+	if (f==NULL) 
+		return e;
+	uf = unzOpenInternal(f);
+	return ZR_OK;
+}
+
+ZRESULT TUnzip::Get(int index,ZIPENTRY *ze)
+{ if (index<-1 || index>=(int)uf->gi.number_entry) 
+	return ZR_ARGS;
+  if (currentfile!=-1) 
+	  unzCloseCurrentFile(uf); 
+  currentfile=-1;
+  if (index==czei && index!=-1) {memcpy(ze,&cze,sizeof(ZIPENTRY)); return ZR_OK;}
+  if (index==-1)
+  { ze->index = uf->gi.number_entry;
+    ze->name[0]=0;
+    ze->attr=0;
+    ze->atime.dwLowDateTime=0; ze->atime.dwHighDateTime=0;
+    ze->ctime.dwLowDateTime=0; ze->ctime.dwHighDateTime=0;
+    ze->mtime.dwLowDateTime=0; ze->mtime.dwHighDateTime=0;
+    ze->comp_size=0;
+    ze->unc_size=0;
+    return ZR_OK;
+  }
+  if (index<(int)uf->num_file) unzGoToFirstFile(uf);
+  while ((int)uf->num_file<index) unzGoToNextFile(uf);
+  unz_file_info ufi; 
+  char fn[MAX_PATH];
+  unzGetCurrentFileInfo(uf,&ufi,fn,MAX_PATH,NULL,0,NULL,0);
+
+  // now get the extra header. We do this ourselves, instead of
+  // calling unzOpenCurrentFile &c., to avoid allocating more than necessary.
+  unsigned int extralen,iSizeVar; unsigned long offset;
+  int res = unzlocal_CheckCurrentFileCoherencyHeader(uf,&iSizeVar,&offset,&extralen);
+  if (res!=UNZ_OK) return ZR_CORRUPT;
+  if (lufseek(uf->file,offset,SEEK_SET)!=0) return ZR_READ;
+  char *extra = new char[extralen];
+  if (lufread(extra,1,(uInt)extralen,uf->file)!=extralen) {delete[] extra; return ZR_READ;}
+  //
+  ze->index=uf->num_file;
+  strcpy(ze->name,fn);
+  // zip has an 'attribute' 32bit value. Its lower half is windows stuff
+  // its upper half is standard unix attr.
+  unsigned long a = ufi.external_fa;
+  bool uisdir  =   (a&0x40000000)!=0;
+  //bool uwriteable= (a&0x08000000)!=0;
+  bool uwriteable= (a&0x00800000)!=0;	// ***hd***
+  //bool ureadable=  (a&0x01000000)!=0;
+  //bool uexecutable=(a&0x00400000)!=0;
+  bool wreadonly=  (a&0x00000001)!=0;
+  bool whidden=    (a&0x00000002)!=0;
+  bool wsystem=    (a&0x00000004)!=0;
+  bool wisdir=     (a&0x00000010)!=0;
+  bool warchive=   (a&0x00000020)!=0;
+  ze->attr=FILE_ATTRIBUTE_NORMAL;
+  if (uisdir || wisdir) ze->attr |= FILE_ATTRIBUTE_DIRECTORY;
+  if (warchive) ze->attr|=FILE_ATTRIBUTE_ARCHIVE;
+  if (whidden) ze->attr|=FILE_ATTRIBUTE_HIDDEN;
+  if (!uwriteable||wreadonly) ze->attr|=FILE_ATTRIBUTE_READONLY;
+  if (wsystem) ze->attr|=FILE_ATTRIBUTE_SYSTEM;
+  ze->comp_size = ufi.compressed_size;
+  ze->unc_size = ufi.uncompressed_size;
+  //
+  WORD dostime = (WORD)(ufi.dosDate&0xFFFF);
+  WORD dosdate = (WORD)((ufi.dosDate>>16)&0xFFFF);
+  FILETIME ft;
+  DosDateTimeToFileTime(dosdate,dostime,&ft);
+  ze->atime=ft; ze->ctime=ft; ze->mtime=ft;
+  // the zip will always have at least that dostime. But if it also has
+  // an extra header, then we'll instead get the info from that.
+  unsigned int epos=0;
+  while (epos+4<extralen)
+  { char etype[3]; etype[0]=extra[epos+0]; etype[1]=extra[epos+1]; etype[2]=0;
+    int size = extra[epos+2];
+    if (strcmp(etype,"UT")!=0) {epos += 4+size; continue;}
+    int flags = extra[epos+4];
+    bool hasmtime = (flags&1)!=0;
+    bool hasatime = (flags&2)!=0;
+    bool hasctime = (flags&4)!=0;
+    epos+=5;
+    if (hasmtime)
+    { 
+		__time32_t mtime = *(__time32_t*)(extra+epos); epos+=4;
+		ze->mtime = timet2filetime(mtime);
+    }
+    if (hasatime)
+    { 
+		__time32_t atime = *(__time32_t*)(extra+epos); epos+=4;
+		ze->atime = timet2filetime(atime);
+    }
+    if (hasctime)
+    { 
+		__time32_t ctime = *(__time32_t*)(extra+epos); 
+		ze->ctime = timet2filetime(ctime);
+    }
+    break;
+  }
+  //
+  if (extra!=0) delete[] extra;
+  memcpy(&cze,ze,sizeof(ZIPENTRY)); czei=index;
+  return ZR_OK;
+}
+
+ZRESULT TUnzip::Find(const TCHAR *name, bool ic, int *index, ZIPENTRY *ze)
+{ 
+	int res = unzLocateFile(uf,name,ic?CASE_INSENSITIVE:CASE_SENSITIVE);
+	if (res!=UNZ_OK)
+	{ 
+		if (index!=0) 
+			*index=-1;
+		if (ze!=NULL) 
+		{
+			ZeroMemory(ze,sizeof(ZIPENTRY)); ze->index=-1;
+		}
+		return ZR_NOTFOUND;
+	}
+	if (currentfile!=-1) 
+		unzCloseCurrentFile(uf); currentfile=-1;
+	int i = (int)uf->num_file;
+	if (index!=NULL) 
+		*index=i;
+	if (ze!=NULL)
+	{ 
+		ZRESULT zres = Get(i,ze);
+		if (zres!=ZR_OK) 
+			return zres;
+	}
+	return ZR_OK;
+}
+
+void EnsureDirectory(const TCHAR *rootdir, const TCHAR *dir)
+{ 
+	if (dir==NULL || dir[0] == _T('\0')) 
+		return;
+	const TCHAR *lastslash = dir, *c = lastslash;
+	while (*c != _T('\0')) 
+	{
+		if (*c==_T('/') || *c==_T('\\')) 
+		lastslash=c; 
+		c++;
+	}
+	const TCHAR *name=lastslash;
+	if (lastslash!=dir)
+	{ 
+		TCHAR tmp[MAX_PATH]; 
+		_tcsncpy(tmp, dir, lastslash-dir);
+		tmp[lastslash-dir] = _T('\0');
+		EnsureDirectory(rootdir,tmp);
+		name++;
+	}
+	TCHAR cd[MAX_PATH]; 
+	_tcscpy(cd,rootdir); 
+	_tcscat(cd,name);
+	CreateDirectory(cd,NULL);
+}
+
+ZRESULT TUnzip::Unzip(int index,void *dst,unsigned int len,DWORD flags)
+{ 
+	if (flags!=ZIP_MEMORY && flags!=ZIP_FILENAME && flags!=ZIP_HANDLE) 
+		return ZR_ARGS;
+	if (flags==ZIP_MEMORY)
+	{ 
+		if (index!=currentfile)
+		{ 
+			if (currentfile!=-1) 
+				unzCloseCurrentFile(uf); 
+			currentfile=-1;
+			if (index>=(int)uf->gi.number_entry) 
+				return ZR_ARGS;
+			if (index<(int)uf->num_file) 
+				unzGoToFirstFile(uf);
+			while ((int)uf->num_file<index) 
+				unzGoToNextFile(uf);
+			unzOpenCurrentFile(uf); 
+			currentfile=index;
+		}
+		int res = unzReadCurrentFile(uf,dst,len);
+		if (res>0) 
+			return ZR_MORE;
+		unzCloseCurrentFile(uf); 
+		currentfile=-1;
+		if (res==0) 
+			return ZR_OK;
+		else 
+			return ZR_FLATE;
+	}
+
+	// otherwise we're writing to a handle or a file
+	if (currentfile!=-1) 
+		unzCloseCurrentFile(uf); 
+	currentfile=-1;
+	if (index >= (int)uf->gi.number_entry) 
+		return ZR_ARGS;
+	if (index < (int)uf->num_file) 
+		unzGoToFirstFile(uf);
+	while ((int)uf->num_file<index) 
+		unzGoToNextFile(uf);
+	ZIPENTRY ze; 
+	Get(index,&ze);
+
+	// zipentry=directory is handled specially
+	if ((ze.attr & FILE_ATTRIBUTE_DIRECTORY) != 0)
+	{ 
+		if (flags==ZIP_HANDLE) 
+			return ZR_OK; // don't do anything
+#ifdef _UNICODE
+		TCHAR uname[MAX_PATH];
+		GetUnicodeFileName(ze.name, uname, MAX_PATH-1);
+		EnsureDirectory(rootdir, uname);
+#else
+		EnsureDirectory(rootdir, ze.name);
+#endif
+		return ZR_OK;
+	}
+
+	// otherwise, we write the zipentry to a file/handle
+	HANDLE h;
+	if (flags==ZIP_HANDLE) 
+		h=dst;
+	else
+	{ 
+		const TCHAR *name = (const TCHAR *)dst;
+		const TCHAR *c = name;
+		while (*c) 
+		{
+			if (*c == _T('/') || *c == _T('\\')) 
+				name = c + 1; 
+			c++;
+		}
+		// if it's a relative filename, ensure directories. We do this as a service  
+		// to the caller so they can just unzip straight unto ze.name.
+		if (name != (const TCHAR *)dst)
+		{ 
+			TCHAR dir[MAX_PATH]; 
+			_tcscpy(dir,(const TCHAR*)dst); 
+			dir[name-(const TCHAR*)dst-1] = _T('\0');
+			bool isabsolute = (dir[0]==_T('/') || dir[0]==_T('\\') || dir[1]==_T(':'));
+			isabsolute |= (_tcsstr(dir,_T("../"))!=0) | (_tcsstr(dir,_T("..\\"))!=0);
+			if (!isabsolute) 
+				EnsureDirectory(rootdir,dir);
+		}
+		h = ::CreateFile((const TCHAR*)dst, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
+				ze.attr, NULL);
+	}
+
+	if (h == INVALID_HANDLE_VALUE)  
+		return ZR_NOFILE;
+	
+	unzOpenCurrentFile(uf);
+	BYTE buf[16384];  
+	bool haderr=false;
+	
+	for (;;)
+	{ 
+		int res = unzReadCurrentFile(uf,buf,16384);
+		if (res<0) 
+		{
+			haderr=true; 
+			break;
+		}
+		if (res==0) 
+			break;
+		DWORD writ; 
+		BOOL bres = WriteFile(h,buf,res,&writ,NULL);
+		if (!bres) 
+		{
+			haderr=true; 
+			break;
+		}
+	}
+	bool settime=false;
+	DWORD type = GetFileType(h); 
+	if (type==FILE_TYPE_DISK && !haderr) 
+		settime=true;
+	if (settime) 
+		SetFileTime(h,&ze.ctime,&ze.atime,&ze.mtime);
+	if (flags!=ZIP_HANDLE) 
+		CloseHandle(h);
+	unzCloseCurrentFile(uf);
+	if (haderr) 
+		return ZR_WRITE;
+	return ZR_OK;
+}
+
+ZRESULT TUnzip::Close()
+{ if (currentfile!=-1) unzCloseCurrentFile(uf); currentfile=-1;
+  if (uf!=0) unzClose(uf); uf=0;
+  return ZR_OK;
+}
+
+
+
+
+
+ZRESULT lasterrorU=ZR_OK;
+
+unsigned int FormatZipMessageU(ZRESULT code, char *buf,unsigned int len)
+{ if (code==ZR_RECENT) code=lasterrorU;
+  const char *msg="unknown zip result code";
+  switch (code)
+  { case ZR_OK: msg="Success"; break;
+    case ZR_NODUPH: msg="Culdn't duplicate handle"; break;
+    case ZR_NOFILE: msg="Couldn't create/open file"; break;
+    case ZR_NOALLOC: msg="Failed to allocate memory"; break;
+    case ZR_WRITE: msg="Error writing to file"; break;
+    case ZR_NOTFOUND: msg="File not found in the zipfile"; break;
+    case ZR_MORE: msg="Still more data to unzip"; break;
+    case ZR_CORRUPT: msg="Zipfile is corrupt or not a zipfile"; break;
+    case ZR_READ: msg="Error reading file"; break;
+    case ZR_ARGS: msg="Caller: faulty arguments"; break;
+    case ZR_PARTIALUNZ: msg="Caller: the file had already been partially unzipped"; break;
+    case ZR_NOTMMAP: msg="Caller: can only get memory of a memory zipfile"; break;
+    case ZR_MEMSIZE: msg="Caller: not enough space allocated for memory zipfile"; break;
+    case ZR_FAILED: msg="Caller: there was a previous error"; break;
+    case ZR_ENDED: msg="Caller: additions to the zip have already been ended"; break;
+    case ZR_ZMODE: msg="Caller: mixing creation and opening of zip"; break;
+    case ZR_NOTINITED: msg="Zip-bug: internal initialisation not completed"; break;
+    case ZR_SEEK: msg="Zip-bug: trying to seek the unseekable"; break;
+    case ZR_MISSIZE: msg="Zip-bug: the anticipated size turned out wrong"; break;
+    case ZR_NOCHANGE: msg="Zip-bug: tried to change mind, but not allowed"; break;
+    case ZR_FLATE: msg="Zip-bug: an internal error during flation"; break;
+  }
+  unsigned int mlen=(unsigned int)strlen(msg);
+  if (buf==0 || len==0) return mlen;
+  unsigned int n=mlen; if (n+1>len) n=len-1;
+  Q_strncpy(buf,msg,n); buf[n]=0;
+  return mlen;
+}
+
+
+typedef struct
+{ DWORD flag;
+  TUnzip *unz;
+} TUnzipHandleData;
+
+HZIP OpenZipU(void *z,unsigned int len,DWORD flags)
+{ 
+	TUnzip *unz = new TUnzip();
+	lasterrorU = unz->Open(z,len,flags);
+	if (lasterrorU!=ZR_OK) 
+	{
+		delete unz; 
+		return 0;
+	}
+	TUnzipHandleData *han = new TUnzipHandleData;
+	han->flag=1; 
+	han->unz=unz; 
+	return (HZIP)han;
+}
+
+ZRESULT GetZipItemA(HZIP hz, int index, ZIPENTRY *ze)
+{ 
+	if (hz==0) 
+	{
+		lasterrorU=ZR_ARGS;
+		return ZR_ARGS;
+	}
+	TUnzipHandleData *han = (TUnzipHandleData*)hz;
+	if (han->flag!=1) 
+	{
+		lasterrorU=ZR_ZMODE;
+		return ZR_ZMODE;
+	}
+	TUnzip *unz = han->unz;
+	lasterrorU = unz->Get(index,ze);
+	return lasterrorU;
+}
+
+ZRESULT GetZipItemW(HZIP hz, int index, ZIPENTRYW *zew)
+{ 
+	if (hz==0) 
+	{
+		lasterrorU=ZR_ARGS;
+		return ZR_ARGS;
+	}
+	TUnzipHandleData *han = (TUnzipHandleData*)hz;
+	if (han->flag!=1) 
+	{
+		lasterrorU=ZR_ZMODE;
+		return ZR_ZMODE;
+	}
+	TUnzip *unz = han->unz;
+	ZIPENTRY ze;
+	lasterrorU = unz->Get(index,&ze);
+	if (lasterrorU == ZR_OK)
+	{
+		zew->index     = ze.index;
+		zew->attr      = ze.attr;
+		zew->atime     = ze.atime;
+		zew->ctime     = ze.ctime;
+		zew->mtime     = ze.mtime;
+		zew->comp_size = ze.comp_size;
+		zew->unc_size  = ze.unc_size;
+#ifdef _UNICODE
+		GetUnicodeFileName(ze.name, zew->name, MAX_PATH-1);
+#else
+		strcpy(zew->name, ze.name);
+#endif
+	}
+	return lasterrorU;
+}
+
+ZRESULT FindZipItemA(HZIP hz, const TCHAR *name, bool ic, int *index, ZIPENTRY *ze)
+{ 
+	if (hz==0) 
+	{
+		lasterrorU=ZR_ARGS;
+		return ZR_ARGS;
+	}
+	TUnzipHandleData *han = (TUnzipHandleData*)hz;
+	if (han->flag!=1) 
+	{
+		lasterrorU=ZR_ZMODE;
+		return ZR_ZMODE;
+	}
+	TUnzip *unz = han->unz;
+	lasterrorU = unz->Find(name,ic,index,ze);
+	return lasterrorU;
+}
+
+ZRESULT FindZipItemW(HZIP hz, const TCHAR *name, bool ic, int *index, ZIPENTRYW *zew)
+{ 
+	if (hz==0) 
+	{
+		lasterrorU=ZR_ARGS;
+		return ZR_ARGS;
+	}
+	TUnzipHandleData *han = (TUnzipHandleData*)hz;
+	if (han->flag!=1) 
+	{
+		lasterrorU=ZR_ZMODE;
+		return ZR_ZMODE;
+	}
+	TUnzip *unz = han->unz;
+	ZIPENTRY ze;
+	lasterrorU = unz->Find(name,ic,index,&ze);
+	if (lasterrorU == ZR_OK)
+	{
+		zew->index     = ze.index;
+		zew->attr      = ze.attr;
+		zew->atime     = ze.atime;
+		zew->ctime     = ze.ctime;
+		zew->mtime     = ze.mtime;
+		zew->comp_size = ze.comp_size;
+		zew->unc_size  = ze.unc_size;
+#ifdef _UNICODE
+		GetUnicodeFileName(ze.name, zew->name, MAX_PATH-1);
+#else
+		strcpy(zew->name, ze.name);
+#endif
+	}
+
+	return lasterrorU;
+}
+
+ZRESULT UnzipItem(HZIP hz, int index, void *dst, unsigned int len, DWORD flags)
+{ 
+	if (hz==0) 
+	{
+		lasterrorU=ZR_ARGS;
+		return ZR_ARGS;
+	}
+	TUnzipHandleData *han = (TUnzipHandleData*)hz;
+	if (han->flag!=1) 
+	{
+		lasterrorU=ZR_ZMODE;
+		return ZR_ZMODE;
+	}
+	TUnzip *unz = han->unz;
+	lasterrorU = unz->Unzip(index,dst,len,flags);
+	return lasterrorU;
+}
+
+ZRESULT CloseZipU(HZIP hz)
+{ if (hz==0) {lasterrorU=ZR_ARGS;return ZR_ARGS;}
+  TUnzipHandleData *han = (TUnzipHandleData*)hz;
+  if (han->flag!=1) {lasterrorU=ZR_ZMODE;return ZR_ZMODE;}
+  TUnzip *unz = han->unz;
+  lasterrorU = unz->Close();
+  delete unz;
+  delete han;
+  return lasterrorU;
+}
+
+bool IsZipHandleU(HZIP hz)
+{ if (hz==0) return true;
+  TUnzipHandleData *han = (TUnzipHandleData*)hz;
+  return (han->flag==1);
+}
+
+
diff --git a/src/public/cdll_int.h b/src/public/cdll_int.h
index 7e6276e..4ec6b6e 100644
--- a/src/public/cdll_int.h
+++ b/src/public/cdll_int.h
@@ -496,11 +496,6 @@ public:
 	// Methods to set/get a gamestats data container so client & server running in same process can send combined data
 	virtual void SetGamestatsData( CGamestatsData *pGamestatsData ) = 0;
 	virtual CGamestatsData *GetGamestatsData() = 0;
-
-	// Returns true if the engine is playing back a "locally recorded" demo, which includes
-	// both SourceTV and replay demos, since they're recorded locally (on servers), as opposed
-	// to a client recording a demo while connected to a remote server.
-	virtual bool IsPlayingDemoALocallyRecordedDemo() = 0;
 };
 
 
diff --git a/src/public/client_class.h b/src/public/client_class.h
index 5329cf6..691da58 100644
--- a/src/public/client_class.h
+++ b/src/public/client_class.h
@@ -93,6 +93,7 @@ public:
 // the list can be given to the engine).
 // Use this macro to expose your client class to the engine.
 // networkName must match the network name of a class registered on the server.
+#if defined ( LUA_SDK )
 #define IMPLEMENT_CLIENTCLASS(clientClassName, dataTable, serverClassName) \
 	INTERNAL_IMPLEMENT_CLIENTCLASS_PROLOGUE(clientClassName, dataTable, serverClassName) \
 	static IClientNetworkable* _##clientClassName##_CreateObject( int entnum, int serialNum ) \
@@ -101,12 +102,30 @@ public:
 		if ( !pRet ) \
 			return 0; \
 		pRet->Init( entnum, serialNum ); \
+		if ( !StringHasPrefixCaseSensitive( #clientClassName, "class " ) ) \
+			pRet->SetClassname( #clientClassName ); \
 		return pRet; \
 	} \
 	ClientClass __g_##clientClassName##ClientClass(#serverClassName, \
 													_##clientClassName##_CreateObject, \
 													NULL,\
 													&dataTable::g_RecvTable);
+#else
+#define IMPLEMENT_CLIENTCLASS(clientClassName, dataTable, serverClassName) \
+	INTERNAL_IMPLEMENT_CLIENTCLASS_PROLOGUE(clientClassName, dataTable, serverClassName) \
+	static IClientNetworkable* _##clientClassName##_CreateObject( int entnum, int serialNum ) \
+	{ \
+		clientClassName *pRet = new clientClassName; \
+		if ( !pRet ) \
+			return 0; \
+		pRet->Init( entnum, serialNum ); \
+		return pRet; \
+	} \
+	ClientClass __g_##clientClassName##ClientClass(#serverClassName, \
+													_##clientClassName##_CreateObject, \
+													NULL,\
+													&dataTable::g_RecvTable);
+#endif
 
 // Implement a client class and provide a factory so you can allocate and delete it yourself
 // (or make it a singleton).
diff --git a/src/public/engine/livdebugoverlay.cpp b/src/public/engine/livdebugoverlay.cpp
new file mode 100644
index 0000000..3aff3d1
--- /dev/null
+++ b/src/public/engine/livdebugoverlay.cpp
@@ -0,0 +1,108 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+//
+//  cdll_int.h
+//
+// 4-23-98  
+// JOHN:  client dll interface declarations
+//
+
+#define lglobalvars_base_cpp
+
+#include "cbase.h"
+#include "engine/ivdebugoverlay.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "mathlib/lvector.h"
+#include "lColor.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+
+static int debugoverlay_AddBoxOverlay (lua_State *L) {
+  debugoverlay->AddBoxOverlay(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkangle(L, 4), luaL_checkint(L, 5), luaL_checkint(L, 6), luaL_checkint(L, 7), luaL_checkint(L, 8), luaL_checknumber(L, 9));
+  return 0;
+}
+
+static int debugoverlay_AddBoxOverlay2 (lua_State *L) {
+  debugoverlay->AddBoxOverlay2(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkangle(L, 4), luaL_checkcolor(L, 5), luaL_checkcolor(L, 6), luaL_checknumber(L, 7));
+  return 0;
+}
+
+static int debugoverlay_AddGridOverlay (lua_State *L) {
+  debugoverlay->AddGridOverlay(luaL_checkvector(L, 1));
+  return 0;
+}
+
+static int debugoverlay_AddLineOverlay (lua_State *L) {
+  debugoverlay->AddLineOverlay(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkboolean(L, 6), luaL_checknumber(L, 7));
+  return 0;
+}
+
+static int debugoverlay_AddLineOverlayAlpha (lua_State *L) {
+  debugoverlay->AddLineOverlayAlpha(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkint(L, 6), luaL_checkboolean(L, 7), luaL_checknumber(L, 8));
+  return 0;
+}
+
+static int debugoverlay_AddScreenTextOverlay (lua_State *L) {
+  debugoverlay->AddScreenTextOverlay(luaL_checknumber(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkint(L, 6), luaL_checkboolean(L, 7), luaL_checkstring(L, 8));
+  return 0;
+}
+
+static int debugoverlay_AddSweptBoxOverlay (lua_State *L) {
+  debugoverlay->AddSweptBoxOverlay(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkvector(L, 4), luaL_checkangle(L, 5), luaL_checkint(L, 6), luaL_checkint(L, 7), luaL_checkint(L, 8), luaL_checkint(L, 9), luaL_checknumber(L, 10));
+  return 0;
+}
+
+static int debugoverlay_AddTriangleOverlay (lua_State *L) {
+  debugoverlay->AddTriangleOverlay(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkint(L, 6), luaL_checkint(L, 7), luaL_checkboolean(L, 8), luaL_checknumber(L, 9));
+  return 0;
+}
+
+static int debugoverlay_ClearAllOverlays (lua_State *L) {
+  debugoverlay->ClearAllOverlays();
+  return 0;
+}
+
+static int debugoverlay_ClearDeadOverlays (lua_State *L) {
+  debugoverlay->ClearDeadOverlays();
+  return 0;
+}
+
+static int debugoverlay_ScreenPosition (lua_State *L) {
+  lua_pushinteger(L, debugoverlay->ScreenPosition(luaL_checkvector(L, 1), luaL_checkvector(L, 2)));
+  return 0;
+}
+
+
+static const luaL_Reg debugoverlaylib[] = {
+  {"AddBoxOverlay",   debugoverlay_AddBoxOverlay},
+  {"AddBoxOverlay2",   debugoverlay_AddBoxOverlay2},
+  {"AddGridOverlay",   debugoverlay_AddGridOverlay},
+  {"AddLineOverlay",   debugoverlay_AddLineOverlay},
+  {"AddLineOverlayAlpha",   debugoverlay_AddLineOverlayAlpha},
+  {"AddScreenTextOverlay",   debugoverlay_AddScreenTextOverlay},
+  {"AddSweptBoxOverlay",   debugoverlay_AddSweptBoxOverlay},
+  {"AddTriangleOverlay",   debugoverlay_AddTriangleOverlay},
+  {"ClearAllOverlays",   debugoverlay_ClearAllOverlays},
+  {"ClearDeadOverlays",   debugoverlay_ClearDeadOverlays},
+  {"ScreenPosition",   debugoverlay_ScreenPosition},
+  {NULL, NULL}
+};
+
+
+/*
+** Open debugoverlay library
+*/
+LUALIB_API int luaopen_debugoverlay (lua_State *L) {
+  luaL_register(L, LUA_DEBUGOVERLAYLIBNAME, debugoverlaylib);
+  return 1;
+}
+
diff --git a/src/public/gametrace.h b/src/public/gametrace.h
index 6570fd9..05f1383 100644
--- a/src/public/gametrace.h
+++ b/src/public/gametrace.h
@@ -74,9 +74,13 @@ public:
 
 	CGameTrace() {}
 
+#if !defined ( LUA_SDK )
+	// HACKHACK: We only do this for Lua, but Lua classes which use traces will
+	// throw errors when we compile, so define this outside of the Lua SDK.
 private:
 	// No copy constructors allowed
 	CGameTrace(const CGameTrace& vOther);
+#endif
 };
 
 
diff --git a/src/public/lColor.cpp b/src/public/lColor.cpp
new file mode 100644
index 0000000..247543d
--- /dev/null
+++ b/src/public/lColor.cpp
@@ -0,0 +1,150 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define lColor_cpp
+
+#include "cbase.h"
+#include "Color.h"
+#include "fmtstr.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "lColor.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_Color &lua_tocolor (lua_State *L, int idx) {
+  lua_Color *clr = (lua_Color *)luaL_checkudata(L, idx, "Color");
+  return *clr;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushcolor (lua_State *L, lua_Color &clr) {
+  lua_Color *pColor = (lua_Color *)lua_newuserdata(L, sizeof(lua_Color));
+  *pColor = clr;
+  luaL_getmetatable(L, "Color");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_Color &luaL_checkcolor (lua_State *L, int narg) {
+  lua_Color *d = (lua_Color *)luaL_checkudata(L, narg, "Color");
+  return *d;
+}
+
+
+static int Color_a (lua_State *L) {
+  lua_pushinteger(L, luaL_checkcolor(L, 1).a());
+  return 1;
+}
+
+static int Color_b (lua_State *L) {
+  lua_pushinteger(L, luaL_checkcolor(L, 1).b());
+  return 1;
+}
+
+static int Color_g (lua_State *L) {
+  lua_pushinteger(L, luaL_checkcolor(L, 1).g());
+  return 1;
+}
+
+static int Color_GetColor (lua_State *L) {
+  int r, g, b, a;
+  luaL_checkcolor(L, 1).GetColor(r, g, b, a);
+  lua_pushinteger(L, r);
+  lua_pushinteger(L, g);
+  lua_pushinteger(L, b);
+  lua_pushinteger(L, a);
+  return 4;
+}
+
+static int Color_GetRawColor (lua_State *L) {
+  lua_pushinteger(L, luaL_checkcolor(L, 1).GetRawColor());
+  return 1;
+}
+
+static int Color_r (lua_State *L) {
+  lua_pushinteger(L, luaL_checkcolor(L, 1).r());
+  return 1;
+}
+
+static int Color_SetColor (lua_State *L) {
+  luaL_checkcolor(L, 1).SetColor(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_optint(L, 4, 255));
+  return 0;
+}
+
+static int Color_SetRawColor (lua_State *L) {
+  luaL_checkcolor(L, 1).SetRawColor(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int Color___tostring (lua_State *L) {
+  Color color = luaL_checkcolor(L, 1);
+  lua_pushfstring(L, "Color: %s", static_cast<const char *>(CFmtStr("(%i, %i, %i, %i)", color.r(), color.g(), color.b(), color.a())));
+  return 1;
+}
+
+static int Color___eq (lua_State *L) {
+  lua_pushboolean(L, luaL_checkcolor(L, 1) == luaL_checkcolor(L, 2));
+  return 1;
+}
+
+
+static const luaL_Reg Colormeta[] = {
+  {"a", Color_a},
+  {"b", Color_b},
+  {"g", Color_g},
+  {"GetColor", Color_GetColor},
+  {"GetRawColor", Color_GetRawColor},
+  {"r", Color_r},
+  {"SetColor", Color_SetColor},
+  {"SetRawColor", Color_SetRawColor},
+  {"__tostring", Color___tostring},
+  {"__eq", Color___eq},
+  {NULL, NULL}
+};
+
+
+static int luasrc_Color (lua_State *L) {
+  Color clr = Color(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_optint(L, 4, 255));
+  lua_pushcolor(L, clr);
+  return 1;
+}
+
+
+static const luaL_Reg Color_funcs[] = {
+  {"Color", luasrc_Color},
+  {NULL, NULL}
+};
+
+
+/*
+** Open Color object
+*/
+LUALIB_API int luaopen_Color (lua_State *L) {
+  luaL_newmetatable(L, LUA_COLORLIBNAME);
+  luaL_register(L, NULL, Colormeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "color");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "color" */
+  luaL_register(L, "_G", Color_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
diff --git a/src/public/lColor.h b/src/public/lColor.h
new file mode 100644
index 0000000..c3b9930
--- /dev/null
+++ b/src/public/lColor.h
@@ -0,0 +1,37 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LCOLOR_H
+#define LCOLOR_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for Color functions */
+typedef Color lua_Color;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_Color      &(lua_tocolor) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushcolor) (lua_State *L, lua_Color &clr);
+
+
+
+LUALIB_API lua_Color &(luaL_checkcolor) (lua_State *L, int narg);
+
+
+#endif // LCOLOR_H
diff --git a/src/public/lbspflags.cpp b/src/public/lbspflags.cpp
new file mode 100644
index 0000000..e94130f
--- /dev/null
+++ b/src/public/lbspflags.cpp
@@ -0,0 +1,127 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $Workfile:     $
+// $Date:         $
+// $NoKeywords: $
+//=============================================================================//
+
+#define lbspflags_cpp
+
+#include "cbase.h"
+#include "bspflags.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+
+
+/*
+** Open CONTENTS library
+*/
+LUALIB_API int luaopen_CONTENTS (lua_State *L) {
+  BEGIN_LUA_SET_ENUM_LIB(L, LUA_CONTENTSLIBNAME);
+    lua_pushenum(L, CONTENTS_EMPTY, "EMPTY");
+
+    lua_pushenum(L, CONTENTS_SOLID, "SOLID");
+    lua_pushenum(L, CONTENTS_WINDOW, "WINDOW");
+    lua_pushenum(L, CONTENTS_AUX, "AUX");
+    lua_pushenum(L, CONTENTS_GRATE, "GRATE");
+    lua_pushenum(L, CONTENTS_SLIME, "SLIME");
+    lua_pushenum(L, CONTENTS_WATER, "WATER");
+    lua_pushenum(L, CONTENTS_BLOCKLOS, "BLOCKLOS");
+    lua_pushenum(L, CONTENTS_OPAQUE, "OPAQUE");
+
+    lua_pushenum(L, CONTENTS_TESTFOGVOLUME, "TESTFOGVOLUME");
+    lua_pushenum(L, CONTENTS_UNUSED, "UNUSED");
+
+    lua_pushenum(L, CONTENTS_TEAM1, "TEAM1");
+    lua_pushenum(L, CONTENTS_TEAM2, "TEAM2");
+
+    lua_pushenum(L, CONTENTS_IGNORE_NODRAW_OPAQUE, "IGNORE_NODRAW_OPAQUE");
+
+    lua_pushenum(L, CONTENTS_MOVEABLE, "MOVEABLE");
+
+    lua_pushenum(L, CONTENTS_AREAPORTAL, "AREAPORTAL");
+
+	lua_pushenum(L, CONTENTS_PLAYERCLIP, "PLAYERCLIP");
+	lua_pushenum(L, CONTENTS_MONSTERCLIP, "MONSTERCLIP");
+
+	lua_pushenum(L, CONTENTS_CURRENT_0, "CURRENT_0");
+	lua_pushenum(L, CONTENTS_CURRENT_90, "CURRENT_90");
+	lua_pushenum(L, CONTENTS_CURRENT_180, "CURRENT_180");
+	lua_pushenum(L, CONTENTS_CURRENT_270, "CURRENT_270");
+	lua_pushenum(L, CONTENTS_CURRENT_UP, "CURRENT_UP");
+	lua_pushenum(L, CONTENTS_CURRENT_DOWN, "CURRENT_DOWN");
+
+	lua_pushenum(L, CONTENTS_ORIGIN, "ORIGIN");
+
+	lua_pushenum(L, CONTENTS_MONSTER, "MONSTER");
+	lua_pushenum(L, CONTENTS_DEBRIS, "DEBRIS");
+	lua_pushenum(L, CONTENTS_DETAIL, "DETAIL");
+	lua_pushenum(L, CONTENTS_TRANSLUCENT, "TRANSLUCENT");
+	lua_pushenum(L, CONTENTS_LADDER, "LADDER");
+	lua_pushenum(L, CONTENTS_HITBOX, "HITBOX");
+  END_LUA_SET_ENUM_LIB(L);
+  return 0;
+}
+
+
+/*
+** Open SURF library
+*/
+LUALIB_API int luaopen_SURF (lua_State *L) {
+  BEGIN_LUA_SET_ENUM_LIB(L, LUA_SURFLIBNAME);
+    lua_pushenum(L, SURF_LIGHT, "LIGHT");
+    lua_pushenum(L, SURF_SKY2D, "SKY2D");
+    lua_pushenum(L, SURF_SKY, "SKY");
+    lua_pushenum(L, SURF_WARP, "WARP");
+    lua_pushenum(L, SURF_TRANS, "TRANS");
+    lua_pushenum(L, SURF_NOPORTAL, "NOPORTAL");
+    lua_pushenum(L, SURF_TRIGGER, "TRIGGER");
+    lua_pushenum(L, SURF_NODRAW, "NODRAW");
+
+    lua_pushenum(L, SURF_HINT, "HINT");
+
+    lua_pushenum(L, SURF_SKIP, "SKIP");
+    lua_pushenum(L, SURF_NOLIGHT, "NOLIGHT");
+    lua_pushenum(L, SURF_BUMPLIGHT, "BUMPLIGHT");
+    lua_pushenum(L, SURF_NOSHADOWS, "NOSHADOWS");
+    lua_pushenum(L, SURF_NODECALS, "NODECALS");
+    lua_pushenum(L, SURF_NOCHOP, "NOCHOP");
+    lua_pushenum(L, SURF_HITBOX, "HITBOX");
+  END_LUA_SET_ENUM_LIB(L);
+  return 0;
+}
+
+
+/*
+** Open MASK library
+*/
+LUALIB_API int luaopen_MASK (lua_State *L) {
+  BEGIN_LUA_SET_ENUM_LIB(L, LUA_MASKLIBNAME);
+    lua_pushenum(L, MASK_ALL, "ALL");
+    lua_pushenum(L, MASK_SOLID, "SOLID");
+    lua_pushenum(L, MASK_PLAYERSOLID, "PLAYERSOLID");
+    lua_pushenum(L, MASK_NPCSOLID, "NPCSOLID");
+    lua_pushenum(L, MASK_WATER, "WATER");
+    lua_pushenum(L, MASK_OPAQUE, "OPAQUE");
+    lua_pushenum(L, MASK_OPAQUE_AND_NPCS, "OPAQUE_AND_NPCS");
+    lua_pushenum(L, MASK_BLOCKLOS, "BLOCKLOS");
+    lua_pushenum(L, MASK_BLOCKLOS_AND_NPCS, "BLOCKLOS_AND_NPCS");
+    lua_pushenum(L, MASK_VISIBLE, "VISIBLE");
+    lua_pushenum(L, MASK_VISIBLE_AND_NPCS, "VISIBLE_AND_NPCS");
+    lua_pushenum(L, MASK_SHOT, "SHOT");
+    lua_pushenum(L, MASK_SHOT_HULL, "SHOT_HULL");
+    lua_pushenum(L, MASK_SHOT_PORTAL, "SHOT_PORTAL");
+    lua_pushenum(L, MASK_SOLID_BRUSHONLY, "SOLID_BRUSHONLY");
+    lua_pushenum(L, MASK_PLAYERSOLID_BRUSHONLY, "PLAYERSOLID_BRUSHONLY");
+    lua_pushenum(L, MASK_NPCSOLID_BRUSHONLY, "NPCSOLID_BRUSHONLY");
+    lua_pushenum(L, MASK_NPCWORLDSTATIC, "NPCWORLDSTATIC");
+    lua_pushenum(L, MASK_SPLITAREAPORTAL, "SPLITAREAPORTAL");
+
+    lua_pushenum(L, MASK_CURRENT, "CURRENT");
+
+    lua_pushenum(L, MASK_DEADSOLID, "DEADSOLID");
+  END_LUA_SET_ENUM_LIB(L);
+  return 0;
+}
diff --git a/src/public/lcdll_int.cpp b/src/public/lcdll_int.cpp
new file mode 100644
index 0000000..5f9defa
--- /dev/null
+++ b/src/public/lcdll_int.cpp
@@ -0,0 +1,541 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: Interfaces between the client.dll and engine
+//
+//===========================================================================//
+
+#define lcdll_int_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+
+static int engine_ActivateOccluder (lua_State *L) {
+  engine->ActivateOccluder(luaL_checkint(L, 1), luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int engine_ChangeTeam (lua_State *L) {
+  engine->ChangeTeam(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int engine_CheckDoneKeyTrapping (lua_State *L) {
+  ButtonCode_t code = (ButtonCode_t)luaL_checkint(L, 1);
+  lua_pushboolean(L, engine->CheckDoneKeyTrapping(code));
+  return 1;
+}
+
+static int engine_CheckPoint (lua_State *L) {
+  engine->CheckPoint(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int engine_ClientCmd (lua_State *L) {
+  engine->ClientCmd(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int engine_ClientCmd_Unrestricted (lua_State *L) {
+  engine->ClientCmd_Unrestricted(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int engine_Con_IsVisible (lua_State *L) {
+  lua_pushboolean(L, engine->Con_IsVisible());
+  return 1;
+}
+
+static int engine_CopyFrameBufferToMaterial (lua_State *L) {
+  lua_pushboolean(L, engine->CopyFrameBufferToMaterial(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int engine_CullBox (lua_State *L) {
+  lua_pushboolean(L, engine->CullBox(luaL_checkvector(L, 1), luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int engine_DoesBoxTouchAreaFrustum (lua_State *L) {
+  lua_pushboolean(L, engine->DoesBoxTouchAreaFrustum(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkint(L, 3)));
+  return 1;
+}
+
+static int engine_DrawPortals (lua_State *L) {
+  engine->DrawPortals();
+  return 0;
+}
+
+static int engine_EngineStats_BeginFrame (lua_State *L) {
+  engine->EngineStats_BeginFrame();
+  return 0;
+}
+
+static int engine_EngineStats_EndFrame (lua_State *L) {
+  engine->EngineStats_EndFrame();
+  return 0;
+}
+
+static int engine_ExecuteClientCmd (lua_State *L) {
+  engine->ExecuteClientCmd(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int engine_FireEvents (lua_State *L) {
+  engine->FireEvents();
+  return 0;
+}
+
+static int engine_GameLumpSize (lua_State *L) {
+  engine->GameLumpSize(luaL_checkint(L, 1));
+  return 1;
+}
+
+static int engine_GameLumpVersion (lua_State *L) {
+  engine->GameLumpVersion(luaL_checkint(L, 1));
+  return 1;
+}
+
+static int engine_GetAppID (lua_State *L) {
+  lua_pushinteger(L, engine->GetAppID());
+  return 1;
+}
+
+static int engine_GetDXSupportLevel (lua_State *L) {
+  lua_pushinteger(L, engine->GetDXSupportLevel());
+  return 1;
+}
+
+static int engine_GetEngineBuildNumber (lua_State *L) {
+  lua_pushinteger(L, engine->GetEngineBuildNumber());
+  return 1;
+}
+
+static int engine_GetGameDirectory (lua_State *L) {
+  lua_pushstring(L, engine->GetGameDirectory());
+  return 1;
+}
+
+static int engine_GetLastTimeStamp (lua_State *L) {
+  lua_pushnumber(L, engine->GetLastTimeStamp());
+  return 1;
+}
+
+static int engine_GetLevelName (lua_State *L) {
+  lua_pushstring(L, engine->GetLevelName());
+  return 1;
+}
+
+static int engine_GetLightForPoint (lua_State *L) {
+  Vector v = engine->GetLightForPoint(luaL_checkvector(L, 1), luaL_checkboolean(L, 2));
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int engine_GetLightForPointFast (lua_State *L) {
+  Vector v = engine->GetLightForPointFast(luaL_checkvector(L, 1), luaL_checkboolean(L, 2));
+  lua_pushvector(L, v);
+  return 1;
+}
+
+static int engine_GetLocalPlayer (lua_State *L) {
+  lua_pushinteger(L, engine->GetLocalPlayer());
+  return 1;
+}
+
+static int engine_GetMainMenuBackgroundName (lua_State *L) {
+  char * dest = "";
+  engine->GetMainMenuBackgroundName(dest, luaL_checkint(L, 2));
+  lua_pushstring(L, dest);
+  return 1;
+}
+
+static int engine_GetMapEntitiesString (lua_State *L) {
+  lua_pushstring(L, engine->GetMapEntitiesString());
+  return 1;
+}
+
+static int engine_GetMaxClients (lua_State *L) {
+  lua_pushinteger(L, engine->GetMaxClients());
+  return 1;
+}
+
+static int engine_GetMostRecentSaveGame (lua_State *L) {
+  lua_pushstring(L, engine->GetMostRecentSaveGame());
+  return 1;
+}
+
+static int engine_GetPlayerForUserID (lua_State *L) {
+  lua_pushinteger(L, engine->GetPlayerForUserID(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int engine_GetPlayerInfo (lua_State *L) {
+  player_info_t pinfo;
+  lua_pushboolean(L, engine->GetPlayerInfo(luaL_checkint(L, 1), &pinfo));
+  lua_newtable(L);
+  lua_pushstring(L, "name");
+  lua_pushstring(L, pinfo.name);
+  lua_settable(L, -3);
+  lua_pushstring(L, "userID");
+  lua_pushinteger(L, pinfo.userID);
+  lua_settable(L, -3);
+  lua_pushstring(L, "guid");
+  lua_pushstring(L, pinfo.guid);
+  lua_settable(L, -3);
+  lua_pushstring(L, "friendsID");
+  lua_pushinteger(L, pinfo.friendsID);
+  lua_settable(L, -3);
+  lua_pushstring(L, "friendsName");
+  lua_pushstring(L, pinfo.friendsName);
+  lua_settable(L, -3);
+  lua_pushstring(L, "fakeplayer");
+  lua_pushboolean(L, pinfo.fakeplayer);
+  lua_settable(L, -3);
+  lua_pushstring(L, "ishltv");
+  lua_pushboolean(L, pinfo.ishltv);
+  lua_settable(L, -3);
+  return 2;
+}
+
+static int engine_GetProductVersionString (lua_State *L) {
+  lua_pushstring(L, engine->GetProductVersionString());
+  return 1;
+}
+
+static int engine_GetScreenAspectRatio (lua_State *L) {
+  lua_pushnumber(L, engine->GetScreenAspectRatio());
+  return 1;
+}
+
+static int engine_GetScreenSize (lua_State *L) {
+  int width, height;
+  engine->GetScreenSize(width, height);
+  lua_pushinteger(L, width);
+  lua_pushinteger(L, height);
+  return 2;
+}
+
+static int engine_GetUILanguage (lua_State *L) {
+  char * dest = "";
+  engine->GetUILanguage(dest, luaL_checkint(L, 1));
+  lua_pushstring(L, dest);
+  return 1;
+}
+
+static int engine_GrabPreColorCorrectedFrame (lua_State *L) {
+  engine->GrabPreColorCorrectedFrame(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int engine_IsBoxInViewCluster (lua_State *L) {
+  luaL_checkint(L, engine->IsBoxInViewCluster(luaL_checkvector(L, 1), luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int engine_IsBoxVisible (lua_State *L) {
+  luaL_checkint(L, engine->IsBoxVisible(luaL_checkvector(L, 1), luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int engine_IsConnected (lua_State *L) {
+  lua_pushboolean(L, engine->IsConnected());
+  return 1;
+}
+
+static int engine_IsDrawingLoadingImage (lua_State *L) {
+  lua_pushboolean(L, engine->IsDrawingLoadingImage());
+  return 1;
+}
+
+static int engine_IsHammerRunning (lua_State *L) {
+  lua_pushboolean(L, engine->IsHammerRunning());
+  return 1;
+}
+
+static int engine_IsHLTV (lua_State *L) {
+  lua_pushboolean(L, engine->IsHLTV());
+  return 1;
+}
+
+static int engine_IsInEditMode (lua_State *L) {
+  lua_pushboolean(L, engine->IsInEditMode());
+  return 1;
+}
+
+static int engine_IsInGame (lua_State *L) {
+  lua_pushboolean(L, engine->IsInGame());
+  return 1;
+}
+
+static int engine_IsLevelMainMenuBackground (lua_State *L) {
+  lua_pushboolean(L, engine->IsLevelMainMenuBackground());
+  return 1;
+}
+
+static int engine_IsLowViolence (lua_State *L) {
+  lua_pushboolean(L, engine->IsLowViolence());
+  return 1;
+}
+
+static int engine_IsOccluded (lua_State *L) {
+  luaL_checkboolean(L, engine->IsOccluded(luaL_checkvector(L, 1), luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int engine_IsPaused (lua_State *L) {
+  lua_pushboolean(L, engine->IsPaused());
+  return 1;
+}
+
+static int engine_IsPlayingDemo (lua_State *L) {
+  lua_pushboolean(L, engine->IsPlayingDemo());
+  return 1;
+}
+
+static int engine_IsPlayingTimeDemo (lua_State *L) {
+  lua_pushboolean(L, engine->IsPlayingTimeDemo());
+  return 1;
+}
+
+static int engine_IsRecordingDemo (lua_State *L) {
+  lua_pushboolean(L, engine->IsRecordingDemo());
+  return 1;
+}
+
+static int engine_IsSaveInProgress (lua_State *L) {
+  lua_pushboolean(L, engine->IsSaveInProgress());
+  return 1;
+}
+
+static int engine_IsSkyboxVisibleFromPoint (lua_State *L) {
+  lua_pushinteger(L, engine->IsSkyboxVisibleFromPoint(luaL_checkvector(L, 1)));
+  return 1;
+}
+
+static int engine_IsTakingScreenshot (lua_State *L) {
+  lua_pushboolean(L, engine->IsTakingScreenshot());
+  return 1;
+}
+
+static int engine_Key_BindingForKey (lua_State *L) {
+  ButtonCode_t code = (ButtonCode_t)luaL_checkint(L, 1);
+  lua_pushstring(L, engine->Key_BindingForKey(code));
+  return 1;
+}
+
+static int engine_Key_LookupBinding (lua_State *L) {
+  lua_pushstring(L, engine->Key_LookupBinding(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int engine_LevelLeafCount (lua_State *L) {
+  lua_pushinteger(L, engine->LevelLeafCount());
+  return 1;
+}
+
+static int engine_LightStyleValue (lua_State *L) {
+  lua_pushnumber(L, engine->LightStyleValue(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int engine_LinearToGamma (lua_State *L) {
+  float linear = luaL_checknumber(L, 1);
+  float gamma;
+  engine->LinearToGamma(&linear, &gamma);
+  lua_pushnumber(L, gamma);
+  return 1;
+}
+
+static int engine_MapHasHDRLighting (lua_State *L) {
+  lua_pushboolean(L, engine->MapHasHDRLighting());
+  return 1;
+}
+
+static int engine_MapLoadFailed (lua_State *L) {
+  lua_pushboolean(L, engine->MapLoadFailed());
+  return 1;
+}
+
+static int engine_OnStorageDeviceDetached (lua_State *L) {
+  engine->OnStorageDeviceDetached();
+  return 0;
+}
+
+static int engine_REMOVED_SteamProcessCall (lua_State *L) {
+  bool finished = luaL_checkboolean(L, 1);
+  lua_pushboolean(L, engine->REMOVED_SteamProcessCall(finished));
+  return 1;
+}
+
+static int engine_ResetDemoInterpolation (lua_State *L) {
+  engine->ResetDemoInterpolation();
+  return 0;
+}
+
+static int engine_SentenceGroupIndexFromName (lua_State *L) {
+  lua_pushinteger(L, engine->SentenceGroupIndexFromName(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int engine_SentenceGroupNameFromIndex (lua_State *L) {
+  lua_pushstring(L, engine->SentenceGroupNameFromIndex(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int engine_SentenceIndexFromName (lua_State *L) {
+  lua_pushinteger(L, engine->SentenceIndexFromName(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int engine_SentenceLength (lua_State *L) {
+  lua_pushnumber(L, engine->SentenceLength(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int engine_SentenceNameFromIndex (lua_State *L) {
+  lua_pushstring(L, engine->SentenceNameFromIndex(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int engine_ServerCmd (lua_State *L) {
+  engine->ServerCmd(luaL_checkstring(L, 1), luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int engine_SetMapLoadFailed (lua_State *L) {
+  engine->SetMapLoadFailed(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int engine_SetRestrictClientCommands (lua_State *L) {
+  engine->SetRestrictClientCommands(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int engine_SetRestrictServerCommands (lua_State *L) {
+  engine->SetRestrictServerCommands(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int engine_Sound_ExtraUpdate (lua_State *L) {
+  engine->Sound_ExtraUpdate();
+  return 0;
+}
+
+static int engine_StartKeyTrapMode (lua_State *L) {
+  engine->StartKeyTrapMode();
+  return 0;
+}
+
+static int engine_StartXboxExitingProcess (lua_State *L) {
+  engine->StartXboxExitingProcess();
+  return 0;
+}
+
+static int engine_SupportsHDR (lua_State *L) {
+  lua_pushboolean(L, engine->SupportsHDR());
+  return 1;
+}
+
+static int engine_Time (lua_State *L) {
+  lua_pushnumber(L, engine->Time());
+  return 1;
+}
+
+
+static const luaL_Reg enginelib[] = {
+  {"ActivateOccluder",   engine_ActivateOccluder},
+  {"ChangeTeam",  engine_ChangeTeam},
+  {"CheckDoneKeyTrapping",  engine_CheckDoneKeyTrapping},
+  {"CheckPoint",  engine_CheckPoint},
+  {"ClientCmd", engine_ClientCmd},
+  {"ClientCmd_Unrestricted",  engine_ClientCmd_Unrestricted},
+  {"Con_IsVisible",  engine_Con_IsVisible},
+  {"CopyFrameBufferToMaterial",   engine_CopyFrameBufferToMaterial},
+  {"CullBox",   engine_CullBox},
+  {"DoesBoxTouchAreaFrustum",   engine_DoesBoxTouchAreaFrustum},
+  {"DrawPortals",   engine_DrawPortals},
+  {"EngineStats_BeginFrame",   engine_EngineStats_BeginFrame},
+  {"EngineStats_EndFrame",   engine_EngineStats_EndFrame},
+  {"GameLumpSize",   engine_GameLumpSize},
+  {"GetAppID",   engine_GetAppID},
+  {"GetDXSupportLevel", engine_GetDXSupportLevel},
+  {"GetEngineBuildNumber",   engine_GetEngineBuildNumber},
+  {"GetGameDirectory", engine_GetGameDirectory},
+  {"GetLastTimeStamp", engine_GetLastTimeStamp},
+  {"GetLevelName",   engine_GetLevelName},
+  {"GetLightForPoint",   engine_GetLightForPoint},
+  {"GetLightForPointFast",   engine_GetLightForPointFast},
+  {"GetLocalPlayer",   engine_GetLocalPlayer},
+  {"GetMainMenuBackgroundName",   engine_GetMainMenuBackgroundName},
+  {"GetMapEntitiesString",   engine_GetMapEntitiesString},
+  {"GetMaxClients",   engine_GetMaxClients},
+  {"GetMostRecentSaveGame",   engine_GetMostRecentSaveGame},
+  {"GetPlayerForUserID",   engine_GetPlayerForUserID},
+  {"GetPlayerInfo",   engine_GetPlayerInfo},
+  {"GetProductVersionString",   engine_GetProductVersionString},
+  {"GetScreenAspectRatio",     engine_GetScreenAspectRatio},
+  {"GetScreenSize",     engine_GetScreenSize},
+  {"GetUILanguage",     engine_GetUILanguage},
+  {"GrabPreColorCorrectedFrame",     engine_GrabPreColorCorrectedFrame},
+  {"IsBoxInViewCluster",     engine_IsBoxInViewCluster},
+  {"IsBoxVisible",     engine_IsBoxVisible},
+  {"IsConnected", engine_IsConnected},
+  {"IsDrawingLoadingImage",   engine_IsDrawingLoadingImage},
+  {"IsHammerRunning",   engine_IsHammerRunning},
+  {"IsHLTV",  engine_IsHLTV},
+  {"IsInEditMode",  engine_IsInEditMode},
+  {"IsInGame",  engine_IsInGame},
+  {"IsLevelMainMenuBackground",  engine_IsLevelMainMenuBackground},
+  {"IsLowViolence",  engine_IsLowViolence},
+  {"IsOccluded",  engine_IsOccluded},
+  {"IsPaused",  engine_IsPaused},
+  {"IsPlayingDemo",  engine_IsPlayingDemo},
+  {"IsPlayingTimeDemo",  engine_IsPlayingTimeDemo},
+  {"IsRecordingDemo",  engine_IsRecordingDemo},
+  {"IsSaveInProgress",   engine_IsSaveInProgress},
+  {"IsSkyboxVisibleFromPoint",   engine_IsSkyboxVisibleFromPoint},
+  {"IsTakingScreenshot",   engine_IsTakingScreenshot},
+  {"Key_BindingForKey",   engine_Key_BindingForKey},
+  {"Key_LookupBinding",   engine_Key_LookupBinding},
+  {"LevelLeafCount",   engine_LevelLeafCount},
+  {"LightStyleValue",   engine_LightStyleValue},
+  {"LinearToGamma",   engine_LinearToGamma},
+  {"MapHasHDRLighting",   engine_MapHasHDRLighting},
+  {"MapLoadFailed",   engine_MapLoadFailed},
+  {"OnStorageDeviceDetached",   engine_OnStorageDeviceDetached},
+  {"REMOVED_SteamProcessCall",   engine_REMOVED_SteamProcessCall},
+  {"ResetDemoInterpolation",   engine_ResetDemoInterpolation},
+  {"SentenceGroupIndexFromName",   engine_SentenceGroupIndexFromName},
+  {"SentenceGroupNameFromIndex",   engine_SentenceGroupNameFromIndex},
+  {"SentenceIndexFromName",   engine_SentenceIndexFromName},
+  {"SentenceLength",   engine_SentenceLength},
+  {"SentenceNameFromIndex",   engine_SentenceNameFromIndex},
+  {"ServerCmd",   engine_ServerCmd},
+  {"SetMapLoadFailed",   engine_SetMapLoadFailed},
+  {"SetRestrictClientCommands",   engine_SetRestrictClientCommands},
+  {"SetRestrictServerCommands",   engine_SetRestrictServerCommands},
+  {"Sound_ExtraUpdate",   engine_Sound_ExtraUpdate},
+  {"StartKeyTrapMode",   engine_StartKeyTrapMode},
+  {"StartXboxExitingProcess",   engine_StartXboxExitingProcess},
+  {"SupportsHDR",   engine_SupportsHDR},
+  {"Time",   engine_Time},
+  {NULL, NULL}
+};
+
+
+/*
+** Open engine library
+*/
+LUALIB_API int luaopen_engine (lua_State *L) {
+  luaL_register(L, LUA_ENGINELIBNAME, enginelib);
+  return 1;
+}
+
diff --git a/src/public/lcmodel.h b/src/public/lcmodel.h
new file mode 100644
index 0000000..c9e214d
--- /dev/null
+++ b/src/public/lcmodel.h
@@ -0,0 +1,36 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $Workfile:     $
+// $Date:         $
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LCMODEL_H
+#define LCMODEL_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+/*
+==============================================================
+
+COLLISION DETECTION
+
+==============================================================
+*/
+
+LUA_API void lua_pushcsurface (lua_State *L, csurface_t surface) {
+  lua_newtable(L);
+  lua_pushinteger(L, surface.flags);
+  lua_setfield(L, -2, "flags");
+  lua_pushstring(L, surface.name);
+  lua_setfield(L, -2, "name");
+  lua_pushinteger(L, surface.surfaceProps);
+  lua_setfield(L, -2, "surfaceProps");
+}
+
+#endif // LCMODEL_H
+
+	
\ No newline at end of file
diff --git a/src/public/leiface.cpp b/src/public/leiface.cpp
new file mode 100644
index 0000000..8983802
--- /dev/null
+++ b/src/public/leiface.cpp
@@ -0,0 +1,347 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//===========================================================================//
+
+#define leiface_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lbaseentity_shared.h"
+#include "lbaseplayer_shared.h"
+#include "linetchannelinfo.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+// Engine interfaces.
+// IVEngineServer	*engine = NULL;
+
+static int engine_AllowImmediateEdictReuse (lua_State *L) {
+  engine->AllowImmediateEdictReuse();
+  return 0;
+}
+
+static int engine_ChangeLevel (lua_State *L) {
+  engine->ChangeLevel(luaL_checkstring(L, 1), luaL_optstring(L, 2, NULL));
+  return 0;
+}
+
+static int engine_ChangeTeam (lua_State *L) {
+  engine->ChangeTeam(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int engine_CheckAreasConnected (lua_State *L) {
+  lua_pushinteger(L, engine->CheckAreasConnected(luaL_checkinteger(L, 1), luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int engine_CopyFile (lua_State *L) {
+  lua_pushboolean(L, engine->CopyFile(luaL_checkstring(L, 1), luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int engine_CreateFakeClient (lua_State *L) {
+  edict_t *pEdict = engine->CreateFakeClient(luaL_checkstring(L, 1));
+
+  if (!pEdict)
+  {
+    Msg( "Failed to create Bot.\n");
+    return 0;
+  }
+
+  CBasePlayer *pPlayer = ((CBasePlayer*)CBaseEntity::Instance( pEdict ));
+  lua_pushplayer(L, pPlayer);
+  return 1;
+}
+
+static int engine_ForceExactFile (lua_State *L) {
+  engine->ForceExactFile(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int engine_ForceSimpleMaterial (lua_State *L) {
+  engine->ForceSimpleMaterial(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int engine_GetAppID (lua_State *L) {
+  lua_pushinteger(L, engine->GetAppID());
+  return 1;
+}
+
+static int engine_GetClientConVarValue (lua_State *L) {
+  lua_pushstring(L, engine->GetClientConVarValue(luaL_checkinteger(L, 1), luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int engine_GetEntityCount (lua_State *L) {
+  lua_pushinteger(L, engine->GetEntityCount());
+  return 1;
+}
+
+static int engine_GetGameDir (lua_State *L) {
+  char gamePath[256];
+  engine->GetGameDir( gamePath, 256 );
+  lua_pushstring(L, gamePath);
+  return 1;
+}
+
+static int engine_GetMapEntitiesString (lua_State *L) {
+  lua_pushstring(L, engine->GetMapEntitiesString());
+  return 1;
+}
+
+static int engine_GetMostRecentlyLoadedFileName (lua_State *L) {
+  lua_pushstring(L, engine->GetMostRecentlyLoadedFileName());
+  return 1;
+}
+
+static int engine_GetPlayerNetInfo (lua_State *L) {
+  lua_pushnetchannel(L, engine->GetPlayerNetInfo(luaL_checkinteger(L, 1)));
+  return 1;
+}
+
+static int engine_GetSaveFileName (lua_State *L) {
+  lua_pushstring(L, engine->GetSaveFileName());
+  return 1;
+}
+
+static int engine_IndexOfEdict (lua_State *L) {
+  lua_pushinteger(L, engine->IndexOfEdict(luaL_checkentity(L, 1)->edict()));
+  return 1;
+}
+
+static int engine_InsertServerCommand (lua_State *L) {
+  engine->InsertServerCommand(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int engine_IsDecalPrecached (lua_State *L) {
+  lua_pushboolean(L, engine->IsDecalPrecached(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int engine_IsDedicatedServer (lua_State *L) {
+  lua_pushboolean(L, engine->IsDedicatedServer());
+  return 1;
+}
+
+static int engine_IsGenericPrecached (lua_State *L) {
+  lua_pushboolean(L, engine->IsGenericPrecached(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int engine_IsInCommentaryMode (lua_State *L) {
+  lua_pushinteger(L, engine->IsInCommentaryMode());
+  return 1;
+}
+
+static int engine_IsInEditMode (lua_State *L) {
+  lua_pushinteger(L, engine->IsInEditMode());
+  return 1;
+}
+
+static int engine_IsInternalBuild (lua_State *L) {
+  lua_pushboolean(L, engine->IsInternalBuild());
+  return 1;
+}
+
+static int engine_IsLowViolence (lua_State *L) {
+  lua_pushboolean(L, engine->IsLowViolence());
+  return 1;
+}
+
+static int engine_IsMapValid (lua_State *L) {
+  lua_pushinteger(L, engine->IsMapValid(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int engine_IsModelPrecached (lua_State *L) {
+  lua_pushboolean(L, engine->IsModelPrecached(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int engine_IsPaused (lua_State *L) {
+  lua_pushboolean(L, engine->IsPaused());
+  return 1;
+}
+
+static int engine_LightStyle (lua_State *L) {
+  engine->LightStyle(luaL_checkinteger(L, 1), luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int engine_LoadAdjacentEnts (lua_State *L) {
+  engine->LoadAdjacentEnts(luaL_checkstring(L, 1), luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int engine_LoadGameState (lua_State *L) {
+  lua_pushboolean(L, engine->LoadGameState(luaL_checkstring(L, 1), luaL_checkboolean(L, 2)));
+  return 1;
+}
+
+static int engine_LockNetworkStringTables (lua_State *L) {
+  lua_pushboolean(L, engine->LockNetworkStringTables(luaL_checkboolean(L, 1)));
+  return 1;
+}
+
+static int engine_LogPrint (lua_State *L) {
+  engine->LogPrint(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int engine_MessageEnd (lua_State *L) {
+  engine->MessageEnd();
+  return 0;
+}
+
+static int engine_MultiplayerEndGame (lua_State *L) {
+  engine->MultiplayerEndGame();
+  return 0;
+}
+
+static int engine_NotifyEdictFlagsChange (lua_State *L) {
+  engine->NotifyEdictFlagsChange(luaL_checkinteger(L, 1));
+  return 0;
+}
+
+static int engine_PrecacheDecal (lua_State *L) {
+  lua_pushinteger(L, engine->PrecacheDecal(luaL_checkstring(L, 1), luaL_checkboolean(L, 2)));
+  return 1;
+}
+
+static int engine_PrecacheGeneric (lua_State *L) {
+  lua_pushinteger(L, engine->PrecacheGeneric(luaL_checkstring(L, 1), luaL_checkboolean(L, 2)));
+  return 1;
+}
+
+static int engine_PrecacheModel (lua_State *L) {
+  lua_pushinteger(L, engine->PrecacheModel(luaL_checkstring(L, 1), luaL_checkboolean(L, 2)));
+  return 1;
+}
+
+static int engine_PrecacheSentenceFile (lua_State *L) {
+  lua_pushinteger(L, engine->PrecacheSentenceFile(luaL_checkstring(L, 1), luaL_checkboolean(L, 2)));
+  return 1;
+}
+
+static int engine_SentenceGroupIndexFromName (lua_State *L) {
+  lua_pushinteger(L, engine->SentenceGroupIndexFromName(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int engine_SentenceGroupNameFromIndex (lua_State *L) {
+  lua_pushstring(L, engine->SentenceGroupNameFromIndex(luaL_checkinteger(L, 1)));
+  return 1;
+}
+
+static int engine_SentenceIndexFromName (lua_State *L) {
+  lua_pushinteger(L, engine->SentenceIndexFromName(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int engine_SentenceLength (lua_State *L) {
+  lua_pushnumber(L, engine->SentenceLength(luaL_checkinteger(L, 1)));
+  return 1;
+}
+
+static int engine_SentenceNameFromIndex (lua_State *L) {
+  lua_pushstring(L, engine->SentenceNameFromIndex(luaL_checkinteger(L, 1)));
+  return 1;
+}
+
+static int engine_ServerCommand (lua_State *L) {
+  engine->ServerCommand(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int engine_ServerExecute (lua_State *L) {
+  engine->ServerExecute();
+  return 0;
+}
+
+static int engine_SetAreaPortalState (lua_State *L) {
+  engine->SetAreaPortalState(luaL_checkinteger(L, 1), luaL_checkinteger(L, 2));
+  return 0;
+}
+
+static int engine_SetDedicatedServerBenchmarkMode (lua_State *L) {
+  engine->SetDedicatedServerBenchmarkMode(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int engine_Time (lua_State *L) {
+  lua_pushnumber(L, engine->Time());
+  return 1;
+}
+
+
+static const luaL_Reg enginelib[] = {
+  {"AllowImmediateEdictReuse",   engine_AllowImmediateEdictReuse},
+  {"ChangeLevel",  engine_ChangeLevel},
+  {"ChangeTeam",  engine_ChangeTeam},
+  {"CheckAreasConnected", engine_CheckAreasConnected},
+  {"CopyFile", engine_CopyFile},
+  {"CreateFakeClient", engine_CreateFakeClient},
+  {"ForceExactFile", engine_ForceExactFile},
+  {"ForceSimpleMaterial", engine_ForceSimpleMaterial},
+  {"GetAppID", engine_GetAppID},
+  {"GetClientConVarValue", engine_GetClientConVarValue},
+  {"GetEntityCount", engine_GetEntityCount},
+  {"GetGameDir", engine_GetGameDir},
+  {"GetMapEntitiesString", engine_GetMapEntitiesString},
+  {"GetMostRecentlyLoadedFileName", engine_GetMostRecentlyLoadedFileName},
+  {"GetPlayerNetInfo", engine_GetPlayerNetInfo},
+  {"GetSaveFileName", engine_GetSaveFileName},
+  {"IndexOfEdict", engine_IndexOfEdict},
+  {"InsertServerCommand", engine_InsertServerCommand},
+  {"IsDecalPrecached", engine_IsDecalPrecached},
+  {"IsDedicatedServer", engine_IsDedicatedServer},
+  {"IsGenericPrecached", engine_IsGenericPrecached},
+  {"IsInCommentaryMode", engine_IsInCommentaryMode},
+  {"IsInEditMode", engine_IsInEditMode},
+  {"IsInternalBuild", engine_IsInternalBuild},
+  {"IsLowViolence", engine_IsLowViolence},
+  {"IsMapValid", engine_IsMapValid},
+  {"IsModelPrecached", engine_IsModelPrecached},
+  {"IsPaused", engine_IsPaused},
+  {"LoadAdjacentEnts", engine_LoadAdjacentEnts},
+  {"LoadGameState", engine_LoadGameState},
+  {"LockNetworkStringTables", engine_LockNetworkStringTables},
+  {"LogPrint", engine_LogPrint},
+  {"MessageEnd", engine_MessageEnd},
+  {"MultiplayerEndGame", engine_MultiplayerEndGame},
+  {"NotifyEdictFlagsChange", engine_NotifyEdictFlagsChange},
+  {"PrecacheDecal", engine_PrecacheDecal},
+  {"PrecacheGeneric", engine_PrecacheGeneric},
+  {"PrecacheModel", engine_PrecacheModel},
+  {"PrecacheSentenceFile", engine_PrecacheSentenceFile},
+  {"SentenceGroupIndexFromName", engine_SentenceGroupIndexFromName},
+  {"SentenceGroupNameFromIndex", engine_SentenceGroupNameFromIndex},
+  {"SentenceIndexFromName", engine_SentenceIndexFromName},
+  {"SentenceLength", engine_SentenceLength},
+  {"SentenceNameFromIndex", engine_SentenceNameFromIndex},
+  {"ServerCommand", engine_ServerCommand},
+  {"ServerExecute", engine_ServerExecute},
+  {"SetAreaPortalState", engine_SetAreaPortalState},
+  {"SetDedicatedServerBenchmarkMode", engine_SetDedicatedServerBenchmarkMode},
+  {"Time", engine_Time},
+  {NULL, NULL}
+};
+
+
+/*
+** Open engine library
+*/
+LUALIB_API int luaopen_engine (lua_State *L) {
+  luaL_register(L, LUA_ENGINELIBNAME, enginelib);
+  return 1;
+}
+
diff --git a/src/public/lfilesystem.cpp b/src/public/lfilesystem.cpp
new file mode 100644
index 0000000..35a2bce
--- /dev/null
+++ b/src/public/lfilesystem.cpp
@@ -0,0 +1,425 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#define lfilesystem_cpp
+
+#include "cbase.h"
+#include "filesystem.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lfilesystem.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_FileHandle_t &lua_tofilehandle (lua_State *L, int idx) {
+  lua_FileHandle_t *phFile = (lua_FileHandle_t *)luaL_checkudata(L, idx, "FileHandle_t");
+  return *phFile;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushfilehandle (lua_State *L, lua_FileHandle_t hFile) {
+  lua_FileHandle_t *phFile = (lua_FileHandle_t *)lua_newuserdata(L, sizeof(lua_FileHandle_t));
+  *phFile = hFile;
+  luaL_getmetatable(L, "FileHandle_t");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_FileHandle_t &luaL_checkfilehandle (lua_State *L, int narg) {
+  lua_FileHandle_t *d = (lua_FileHandle_t *)luaL_checkudata(L, narg, "FileHandle_t");
+  if (*d == FILESYSTEM_INVALID_HANDLE)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "FileHandle_t expected, got FILESYSTEM_INVALID_HANDLE");
+  return *d;
+}
+
+
+static int filesystem_AddPackFile (lua_State *L) {
+  lua_pushboolean(L, filesystem->AddPackFile(luaL_checkstring(L, 1), luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int filesystem_AddSearchPath (lua_State *L) {
+  char fullpath[ 512 ] = { 0 };
+  bool bGetCurrentDirectory = V_GetCurrentDirectory( fullpath, sizeof( fullpath ) );
+  if ( bGetCurrentDirectory )
+  {
+#ifdef CLIENT_DLL
+    const char *gamePath = engine->GetGameDirectory();
+#else
+    char gamePath[ 256 ];
+    engine->GetGameDir( gamePath, 256 );
+#endif
+    V_SetCurrentDirectory( gamePath );
+  }
+  filesystem->AddSearchPath(luaL_checkstring(L, 1), luaL_checkstring(L, 2), (SearchPathAdd_t)luaL_optint(L, 3, PATH_ADD_TO_TAIL));
+  if ( bGetCurrentDirectory )
+	  V_SetCurrentDirectory( fullpath );
+  return 0;
+}
+
+static int filesystem_BeginMapAccess (lua_State *L) {
+  filesystem->BeginMapAccess();
+  return 0;
+}
+
+static int filesystem_CancelWaitForResources (lua_State *L) {
+  filesystem->CancelWaitForResources(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int filesystem_Close (lua_State *L) {
+  filesystem->Close(luaL_checkfilehandle(L, 1));
+  // Andrew; this isn't standard behavior or usage, but we do this for the sake
+  // of things being safe in Lua
+  luaL_checkfilehandle(L, 1) = FILESYSTEM_INVALID_HANDLE;
+  return 0;
+}
+
+static int filesystem_CreateDirHierarchy (lua_State *L) {
+  filesystem->CreateDirHierarchy(luaL_checkstring(L, 1), luaL_optstring(L, 2, 0));
+  return 0;
+}
+
+static int filesystem_DiscardPreloadData (lua_State *L) {
+  filesystem->DiscardPreloadData();
+  return 0;
+}
+
+static int filesystem_Disconnect (lua_State *L) {
+  filesystem->Disconnect();
+  return 0;
+}
+
+static int filesystem_EnableWhitelistFileTracking (lua_State *L) {
+  filesystem->EnableWhitelistFileTracking(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int filesystem_EndMapAccess (lua_State *L) {
+  filesystem->EndMapAccess();
+  return 0;
+}
+
+static int filesystem_EndOfFile (lua_State *L) {
+  lua_pushboolean(L, filesystem->EndOfFile(luaL_checkfilehandle(L, 1)));
+  return 1;
+}
+
+static int filesystem_FileExists (lua_State *L) {
+  lua_pushboolean(L, filesystem->FileExists(luaL_checkstring(L, 1), luaL_optstring(L, 2, 0)));
+  return 1;
+}
+
+static int filesystem_Flush (lua_State *L) {
+  filesystem->Flush(luaL_checkfilehandle(L, 1));
+  return 0;
+}
+
+static int filesystem_GetDVDMode (lua_State *L) {
+  lua_pushinteger(L, filesystem->GetDVDMode());
+  return 1;
+}
+
+static int filesystem_GetLocalCopy (lua_State *L) {
+  filesystem->GetLocalCopy(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int filesystem_GetWhitelistSpewFlags (lua_State *L) {
+  lua_pushinteger(L, filesystem->GetWhitelistSpewFlags());
+  return 1;
+}
+
+static int filesystem_HintResourceNeed (lua_State *L) {
+  lua_pushinteger(L, filesystem->HintResourceNeed(luaL_checkstring(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int filesystem_IsDirectory (lua_State *L) {
+  lua_pushboolean(L, filesystem->IsDirectory(luaL_checkstring(L, 1), luaL_optstring(L, 2, 0)));
+  return 1;
+}
+
+static int filesystem_IsFileImmediatelyAvailable (lua_State *L) {
+  lua_pushboolean(L, filesystem->IsFileImmediatelyAvailable(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int filesystem_IsFileWritable (lua_State *L) {
+  lua_pushboolean(L, filesystem->IsFileWritable(luaL_checkstring(L, 1), luaL_optstring(L, 2, 0)));
+  return 1;
+}
+
+static int filesystem_IsOk (lua_State *L) {
+  lua_pushboolean(L, filesystem->IsOk(luaL_checkfilehandle(L, 1)));
+  return 1;
+}
+
+static int filesystem_IsSteam (lua_State *L) {
+  lua_pushboolean(L, filesystem->IsSteam());
+  return 1;
+}
+
+static int filesystem_LoadCompiledKeyValues (lua_State *L) {
+  filesystem->LoadCompiledKeyValues((IFileSystem::KeyValuesPreloadType_t)luaL_checkint(L, 1), luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int filesystem_MarkAllCRCsUnverified (lua_State *L) {
+  filesystem->MarkAllCRCsUnverified();
+  return 0;
+}
+
+static int filesystem_MarkPathIDByRequestOnly (lua_State *L) {
+  filesystem->MarkPathIDByRequestOnly(luaL_checkstring(L, 1), luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int filesystem_MountSteamContent (lua_State *L) {
+  lua_pushinteger(L, filesystem->MountSteamContent(luaL_optint(L, 1, -1)));
+  return 1;
+}
+
+static int filesystem_Open (lua_State *L) {
+  lua_pushfilehandle(L, filesystem->Open(luaL_checkstring(L, 1), luaL_checkstring(L, 2), luaL_optstring(L, 3, 0)));
+  return 1;
+}
+
+static int filesystem_Precache (lua_State *L) {
+  lua_pushboolean(L, filesystem->Precache(luaL_checkstring(L, 1), luaL_optstring(L, 2, 0)));
+  return 1;
+}
+
+static int filesystem_PrintOpenedFiles (lua_State *L) {
+  filesystem->PrintOpenedFiles();
+  return 0;
+}
+
+static int filesystem_PrintSearchPaths (lua_State *L) {
+  filesystem->PrintSearchPaths();
+  return 0;
+}
+
+static int filesystem_Read (lua_State *L) {
+  byte *buffer;
+
+  FileHandle_t file;
+  file = luaL_checkfilehandle(L, 2);
+
+  int size = luaL_checkint(L, 1);
+  buffer = new byte[ size + 1 ];
+  if ( !buffer )
+  {
+  	Warning( "filesystem.Read:  Couldn't allocate buffer of size %i for file\n", size + 1 );
+  	lua_pushinteger(L, -1);
+  	lua_pushstring(L, NULL);
+  	return 2;
+  }
+  int bytesRead = filesystem->Read( buffer, size, file );
+
+  if ( bytesRead )
+  {
+	  // Ensure null terminator
+	  buffer[ bytesRead ] =0;
+  }
+  else
+  {
+	  *buffer = 0;
+  }
+
+  lua_pushinteger(L, size);
+  lua_pushstring(L, (const char *)buffer);
+  delete buffer;
+
+  return 2;
+}
+
+static int filesystem_RemoveAllSearchPaths (lua_State *L) {
+  filesystem->RemoveAllSearchPaths();
+  return 0;
+}
+
+static int filesystem_RemoveFile (lua_State *L) {
+  filesystem->RemoveFile(luaL_checkstring(L, 1), luaL_optstring(L, 2, 0));
+  return 0;
+}
+
+static int filesystem_RemoveSearchPath (lua_State *L) {
+  lua_pushboolean(L, filesystem->RemoveSearchPath(luaL_checkstring(L, 1), luaL_optstring(L, 2, 0)));
+  return 1;
+}
+
+static int filesystem_RemoveSearchPaths (lua_State *L) {
+  filesystem->RemoveSearchPaths(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int filesystem_RenameFile (lua_State *L) {
+  lua_pushboolean(L, filesystem->RenameFile(luaL_checkstring(L, 1), luaL_checkstring(L, 2), luaL_optstring(L, 3, 0)));
+  return 1;
+}
+
+static int filesystem_SetFileWritable (lua_State *L) {
+  lua_pushboolean(L, filesystem->SetFileWritable(luaL_checkstring(L, 1), luaL_checkboolean(L, 2), luaL_optstring(L, 3, 0)));
+  return 1;
+}
+
+static int filesystem_SetupPreloadData (lua_State *L) {
+  filesystem->SetupPreloadData();
+  return 0;
+}
+
+static int filesystem_SetWarningLevel (lua_State *L) {
+  filesystem->SetWarningLevel((FileWarningLevel_t)luaL_checkint(L, 1));
+  return 0;
+}
+
+static int filesystem_SetWhitelistSpewFlags (lua_State *L) {
+  filesystem->SetWhitelistSpewFlags(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int filesystem_Shutdown (lua_State *L) {
+  filesystem->Shutdown();
+  return 0;
+}
+
+static int filesystem_Size (lua_State *L) {
+  switch(lua_type(L, 1)) {
+    case LUA_TSTRING:
+      lua_pushinteger(L, filesystem->Size(luaL_checkstring(L, 1), luaL_optstring(L, 2, 0)));
+      break;
+    case LUA_TUSERDATA:
+    default:
+      lua_pushinteger(L, filesystem->Size(luaL_checkfilehandle(L, 1)));
+      break;
+  }
+  return 1;
+}
+
+static int filesystem_UnzipFile (lua_State *L) {
+  lua_pushboolean(L, filesystem->UnzipFile(luaL_checkstring(L, 1), luaL_checkstring(L, 2), luaL_checkstring(L, 3)));
+  return 1;
+}
+
+static int filesystem_WaitForResources (lua_State *L) {
+  lua_pushinteger(L, filesystem->WaitForResources(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int filesystem_Write (lua_State *L) {
+  size_t l;
+  const char *pInput = luaL_checklstring(L, 1, &l);
+  lua_pushinteger(L, filesystem->Write(pInput, l, luaL_checkfilehandle(L, 2)));
+  return 1;
+}
+
+
+static const luaL_Reg filesystemlib[] = {
+  {"AddPackFile",   filesystem_AddPackFile},
+  {"AddSearchPath",   filesystem_AddSearchPath},
+  {"BeginMapAccess",   filesystem_BeginMapAccess},
+  {"CancelWaitForResources",   filesystem_CancelWaitForResources},
+  {"Close",   filesystem_Close},
+  {"CreateDirHierarchy",   filesystem_CreateDirHierarchy},
+  {"DiscardPreloadData",   filesystem_DiscardPreloadData},
+  {"Disconnect",   filesystem_Disconnect},
+  {"EnableWhitelistFileTracking",   filesystem_EnableWhitelistFileTracking},
+  {"EndMapAccess",   filesystem_EndMapAccess},
+  {"EndOfFile",   filesystem_EndOfFile},
+  {"FileExists",   filesystem_FileExists},
+  {"Flush",   filesystem_Flush},
+  {"GetDVDMode",   filesystem_GetDVDMode},
+  {"GetLocalCopy",   filesystem_GetLocalCopy},
+  {"GetWhitelistSpewFlags",   filesystem_GetWhitelistSpewFlags},
+  {"HintResourceNeed",   filesystem_HintResourceNeed},
+  {"IsDirectory",   filesystem_IsDirectory},
+  {"IsFileImmediatelyAvailable",   filesystem_IsFileImmediatelyAvailable},
+  {"IsFileWritable",   filesystem_IsFileWritable},
+  {"IsOk",   filesystem_IsOk},
+  {"IsSteam",   filesystem_IsSteam},
+  {"LoadCompiledKeyValues",   filesystem_LoadCompiledKeyValues},
+  {"MarkAllCRCsUnverified",   filesystem_MarkAllCRCsUnverified},
+  {"MarkPathIDByRequestOnly",   filesystem_MarkPathIDByRequestOnly},
+  {"MountSteamContent",   filesystem_MountSteamContent},
+  {"Open",   filesystem_Open},
+  {"Precache",   filesystem_Precache},
+  {"PrintOpenedFiles",   filesystem_PrintOpenedFiles},
+  {"PrintSearchPaths",   filesystem_PrintSearchPaths},
+  {"Read",   filesystem_Read},
+  {"RemoveAllSearchPaths",   filesystem_RemoveAllSearchPaths},
+  {"RemoveFile",   filesystem_RemoveFile},
+  {"RemoveSearchPath",   filesystem_RemoveSearchPath},
+  {"RemoveSearchPaths",   filesystem_RemoveSearchPaths},
+  {"RenameFile",   filesystem_RenameFile},
+  {"SetFileWritable",   filesystem_SetFileWritable},
+  {"SetupPreloadData",   filesystem_SetupPreloadData},
+  {"SetWarningLevel",   filesystem_SetWarningLevel},
+  {"SetWhitelistSpewFlags",   filesystem_SetWhitelistSpewFlags},
+  {"Size",   filesystem_Size},
+  {"UnzipFile",   filesystem_UnzipFile},
+  {"WaitForResources",   filesystem_WaitForResources},
+  {"Write",   filesystem_Write},
+  {NULL, NULL}
+};
+
+
+static int FileHandle_t___gc (lua_State *L) {
+  FileHandle_t hFile = lua_tofilehandle(L, 1);
+  if (hFile != FILESYSTEM_INVALID_HANDLE)
+    filesystem->Close(hFile);
+  return 0;
+}
+
+static int FileHandle_t___tostring (lua_State *L) {
+  FileHandle_t hFile = lua_tofilehandle(L, 1);
+  if (hFile == FILESYSTEM_INVALID_HANDLE)
+    lua_pushstring(L, "FILESYSTEM_INVALID_HANDLE");
+  else
+    lua_pushfstring(L, "FileHandle_t: %p", lua_tofilehandle(L, 1));
+  return 1;
+}
+
+
+static const luaL_Reg FileHandle_tmeta[] = {
+  {"__gc", FileHandle_t___gc},
+  {"__tostring", FileHandle_t___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open filesystem library
+*/
+LUALIB_API int luaopen_filesystem (lua_State *L) {
+  luaL_newmetatable(L, "FileHandle_t");
+  luaL_register(L, NULL, FileHandle_tmeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "filehandle");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "filehandle" */
+  lua_pop(L, 1);
+  lua_pushfilehandle(L, FILESYSTEM_INVALID_HANDLE);
+  lua_setglobal(L, "FILESYSTEM_INVALID_HANDLE");
+  luaL_register(L, LUA_FILESYSTEMLIBNAME, filesystemlib);
+  return 1;
+}
+
diff --git a/src/public/lfilesystem.h b/src/public/lfilesystem.h
new file mode 100644
index 0000000..81e6810
--- /dev/null
+++ b/src/public/lfilesystem.h
@@ -0,0 +1,37 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#ifndef LFILESYSTEM_H
+#define LFILESYSTEM_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for FileHandle_t functions */
+typedef FileHandle_t lua_FileHandle_t;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_FileHandle_t     &(lua_tofilehandle) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushfilehandle) (lua_State *L, lua_FileHandle_t hFile);
+
+
+
+LUALIB_API lua_FileHandle_t &(luaL_checkfilehandle) (lua_State *L, int narg);
+
+
+#endif // LFILESYSTEM_H
diff --git a/src/public/lgametrace.cpp b/src/public/lgametrace.cpp
new file mode 100644
index 0000000..1631910
--- /dev/null
+++ b/src/public/lgametrace.cpp
@@ -0,0 +1,212 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+//=============================================================================//
+
+#define lgametrace_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lgametrace.h"
+#include "lcmodel.h"
+#include "lbaseentity_shared.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CGameTrace &lua_totrace (lua_State *L, int idx) {
+  lua_CGameTrace *tr = (lua_CGameTrace *)lua_touserdata(L, idx);
+  return *tr;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushtrace (lua_State *L, lua_CGameTrace &tr) {
+  lua_CGameTrace *ptr = (lua_CGameTrace *)lua_newuserdata(L, sizeof(lua_CGameTrace));
+  *ptr = tr;
+  luaL_getmetatable(L, "CGameTrace");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_CGameTrace &luaL_checktrace (lua_State *L, int narg) {
+  lua_CGameTrace *d = (lua_CGameTrace *)luaL_checkudata(L, narg, "CGameTrace");
+  return *d;
+}
+
+
+static int CGameTrace_DidHit (lua_State *L) {
+  lua_pushboolean(L, luaL_checktrace(L, 1).DidHit());
+  return 1;
+}
+
+static int CGameTrace_DidHitNonWorldEntity (lua_State *L) {
+  lua_pushboolean(L, luaL_checktrace(L, 1).DidHitNonWorldEntity());
+  return 1;
+}
+
+static int CGameTrace_DidHitWorld (lua_State *L) {
+  lua_pushboolean(L, luaL_checktrace(L, 1).DidHitWorld());
+  return 1;
+}
+
+static int CGameTrace_GetEntityIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checktrace(L, 1).GetEntityIndex());
+  return 1;
+}
+
+static int CGameTrace_IsDispSurface (lua_State *L) {
+  lua_pushboolean(L, luaL_checktrace(L, 1).IsDispSurface());
+  return 1;
+}
+
+static int CGameTrace_IsDispSurfaceBuildable (lua_State *L) {
+  lua_pushboolean(L, luaL_checktrace(L, 1).IsDispSurfaceBuildable());
+  return 1;
+}
+
+static int CGameTrace_IsDispSurfaceProp1 (lua_State *L) {
+  lua_pushboolean(L, luaL_checktrace(L, 1).IsDispSurfaceProp1());
+  return 1;
+}
+
+static int CGameTrace_IsDispSurfaceProp2 (lua_State *L) {
+  lua_pushboolean(L, luaL_checktrace(L, 1).IsDispSurfaceProp2());
+  return 1;
+}
+
+static int CGameTrace_IsDispSurfaceWalkable (lua_State *L) {
+  lua_pushboolean(L, luaL_checktrace(L, 1).IsDispSurfaceWalkable());
+  return 1;
+}
+
+static int CGameTrace___index (lua_State *L) {
+  trace_t tr = luaL_checktrace(L, 1);
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "allsolid") == 0)
+    lua_pushboolean(L, tr.allsolid);
+  else if (Q_strcmp(field, "contents") == 0)
+    lua_pushinteger(L, tr.contents);
+  else if (Q_strcmp(field, "dispFlags") == 0)
+    lua_pushinteger(L, tr.dispFlags);
+  else if (Q_strcmp(field, "endpos") == 0)
+    lua_pushvector(L, tr.endpos);
+  else if (Q_strcmp(field, "fraction") == 0)
+    lua_pushnumber(L, tr.fraction);
+  else if (Q_strcmp(field, "fractionleftsolid") == 0)
+    lua_pushnumber(L, tr.fractionleftsolid);
+  else if (Q_strcmp(field, "hitbox") == 0)
+    lua_pushinteger(L, tr.hitbox);
+  else if (Q_strcmp(field, "hitgroup") == 0)
+    lua_pushinteger(L, tr.hitgroup);
+  else if (Q_strcmp(field, "m_pEnt") == 0)
+    lua_pushentity(L, tr.m_pEnt);
+  else if (Q_strcmp(field, "physicsbone") == 0)
+    lua_pushinteger(L, tr.physicsbone);
+  else if (Q_strcmp(field, "startpos") == 0)
+    lua_pushvector(L, tr.startpos);
+  else if (Q_strcmp(field, "startsolid") == 0)
+    lua_pushboolean(L, tr.startsolid);
+  else if (Q_strcmp(field, "surface") == 0)
+    lua_pushcsurface(L, tr.surface);
+  else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+  }
+  return 1;
+}
+
+static int CGameTrace___newindex (lua_State *L) {
+  const char *field = luaL_checkstring(L, 2);
+  if (Q_strcmp(field, "allsolid") == 0)
+    luaL_checktrace(L, 1).allsolid = luaL_checkboolean(L, 3);
+  else if (Q_strcmp(field, "contents") == 0)
+    luaL_checktrace(L, 1).contents = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "dispFlags") == 0)
+    luaL_checktrace(L, 1).dispFlags = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "endpos") == 0)
+    luaL_checktrace(L, 1).endpos = luaL_checkvector(L, 3);
+  else if (Q_strcmp(field, "fraction") == 0)
+    luaL_checktrace(L, 1).fraction = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "fractionleftsolid") == 0)
+    luaL_checktrace(L, 1).fractionleftsolid = luaL_checknumber(L, 3);
+  else if (Q_strcmp(field, "hitbox") == 0)
+    luaL_checktrace(L, 1).hitbox = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "hitgroup") == 0)
+    luaL_checktrace(L, 1).hitgroup = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "m_pEnt") == 0)
+    luaL_checktrace(L, 1).m_pEnt = lua_toentity(L, 3);
+  else if (Q_strcmp(field, "physicsbone") == 0)
+    luaL_checktrace(L, 1).physicsbone = luaL_checkint(L, 3);
+  else if (Q_strcmp(field, "startpos") == 0)
+    luaL_checktrace(L, 1).startpos = luaL_checkvector(L, 3);
+  else if (Q_strcmp(field, "startsolid") == 0)
+    luaL_checktrace(L, 1).startsolid = luaL_checkboolean(L, 3);
+  return 0;
+}
+
+static int CGameTrace___tostring (lua_State *L) {
+  lua_pushfstring(L, "CGameTrace: %p", luaL_checkudata(L, 1, "CGameTrace"));
+  return 1;
+}
+
+
+static const luaL_Reg CGameTracemeta[] = {
+  {"DidHit", CGameTrace_DidHit},
+  {"DidHitNonWorldEntity", CGameTrace_DidHitNonWorldEntity},
+  {"DidHitWorld", CGameTrace_DidHitWorld},
+  {"GetEntityIndex", CGameTrace_GetEntityIndex},
+  {"IsDispSurface", CGameTrace_IsDispSurface},
+  {"IsDispSurfaceBuildable", CGameTrace_IsDispSurfaceBuildable},
+  {"IsDispSurfaceProp1", CGameTrace_IsDispSurfaceProp1},
+  {"IsDispSurfaceProp2", CGameTrace_IsDispSurfaceProp2},
+  {"IsDispSurfaceWalkable", CGameTrace_IsDispSurfaceWalkable},
+  {"__index", CGameTrace___index},
+  {"__newindex", CGameTrace___newindex},
+  {"__tostring", CGameTrace___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_trace_t (lua_State *L) {
+  trace_t tr;
+  memset( &tr, 0, sizeof( trace_t ) );
+  lua_pushtrace(L, tr);
+  return 1;
+}
+
+
+static const luaL_Reg CGameTrace_funcs[] = {
+  {"trace_t", luasrc_trace_t},
+  {NULL, NULL}
+};
+
+
+/*
+** Open CGameTrace object
+*/
+LUALIB_API int luaopen_CGameTrace (lua_State *L) {
+  luaL_newmetatable(L, LUA_GAMETRACELIBNAME);
+  luaL_register(L, NULL, CGameTracemeta);
+  lua_pushstring(L, "trace");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "trace" */
+  luaL_register(L, "_G", CGameTrace_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
diff --git a/src/public/lgametrace.h b/src/public/lgametrace.h
new file mode 100644
index 0000000..bcf829e
--- /dev/null
+++ b/src/public/lgametrace.h
@@ -0,0 +1,37 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+//=============================================================================//
+
+#ifndef LGAMETRACE_H
+#define LGAMETRACE_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+/* type for CGameTrace functions */
+typedef CGameTrace lua_CGameTrace;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CGameTrace     &(lua_totrace) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushtrace) (lua_State *L, lua_CGameTrace &tr);
+
+
+
+LUALIB_API lua_CGameTrace &(luaL_checktrace) (lua_State *L, int narg);
+
+
+#endif // LGAMETRACE_H
+
diff --git a/src/public/lglobalvars_base.cpp b/src/public/lglobalvars_base.cpp
new file mode 100644
index 0000000..9cd4639
--- /dev/null
+++ b/src/public/lglobalvars_base.cpp
@@ -0,0 +1,97 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+//=============================================================================//
+
+#define lglobalvars_base_cpp
+
+#include "cbase.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+
+static int gpGlobals_absoluteframetime (lua_State *L) {
+  lua_pushnumber(L, gpGlobals->absoluteframetime);
+  return 1;
+}
+
+static int gpGlobals_curtime (lua_State *L) {
+  lua_pushnumber(L, gpGlobals->curtime);
+  return 1;
+}
+
+static int gpGlobals_framecount (lua_State *L) {
+  lua_pushinteger(L, gpGlobals->framecount);
+  return 1;
+}
+
+static int gpGlobals_frametime (lua_State *L) {
+  lua_pushnumber(L, gpGlobals->frametime);
+  return 1;
+}
+
+static int gpGlobals_interval_per_tick (lua_State *L) {
+  lua_pushnumber(L, gpGlobals->interval_per_tick);
+  return 1;
+}
+
+static int gpGlobals_IsClient (lua_State *L) {
+  lua_pushboolean(L, gpGlobals->IsClient());
+  return 1;
+}
+
+static int gpGlobals_maxClients (lua_State *L) {
+  lua_pushinteger(L, gpGlobals->maxClients);
+  return 1;
+}
+
+static int gpGlobals_network_protocol (lua_State *L) {
+  lua_pushinteger(L, gpGlobals->network_protocol);
+  return 1;
+}
+
+static int gpGlobals_realtime (lua_State *L) {
+  lua_pushnumber(L, gpGlobals->realtime);
+  return 1;
+}
+
+static int gpGlobals_simTicksThisFrame (lua_State *L) {
+  lua_pushinteger(L, gpGlobals->simTicksThisFrame);
+  return 1;
+}
+
+static int gpGlobals_tickcount (lua_State *L) {
+  lua_pushinteger(L, gpGlobals->tickcount);
+  return 1;
+}
+
+
+static const luaL_Reg gpGlobalslib[] = {
+  {"absoluteframetime",   gpGlobals_absoluteframetime},
+  {"curtime",  gpGlobals_curtime},
+  {"framecount",  gpGlobals_framecount},
+  {"frametime", gpGlobals_frametime},
+  {"interval_per_tick",  gpGlobals_interval_per_tick},
+  {"IsClient",  gpGlobals_IsClient},
+  {"maxClients",  gpGlobals_maxClients},
+  {"network_protocol",   gpGlobals_network_protocol},
+  {"realtime",   gpGlobals_realtime},
+  {"simTicksThisFrame", gpGlobals_simTicksThisFrame},
+  {"tickcount",   gpGlobals_tickcount},
+  {NULL, NULL}
+};
+
+
+/*
+** Open gpGlobals library
+*/
+LUALIB_API int luaopen_gpGlobals (lua_State *L) {
+  luaL_register(L, LUA_GLOBALSLIBNAME, gpGlobalslib);
+  return 1;
+}
+
diff --git a/src/public/licvar.cpp b/src/public/licvar.cpp
new file mode 100644
index 0000000..ef182a4
--- /dev/null
+++ b/src/public/licvar.cpp
@@ -0,0 +1,107 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+//===========================================================================//
+
+#define leiface_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lColor.h"
+#include "lconvar.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+static int cvar_AllocateDLLIdentifier (lua_State *L) {
+  lua_pushinteger(L, cvar->AllocateDLLIdentifier());
+  return 1;
+}
+
+static int cvar_ConsoleColorPrintf (lua_State *L) {
+  cvar->ConsoleColorPrintf(luaL_checkcolor(L, 1), luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int cvar_ConsoleDPrintf (lua_State *L) {
+  cvar->ConsoleDPrintf(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int cvar_ConsolePrintf (lua_State *L) {
+  cvar->ConsolePrintf(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int cvar_FindVar (lua_State *L) {
+  lua_pushconvar(L, cvar->FindVar(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int cvar_GetCommandLineValue (lua_State *L) {
+  lua_pushstring(L, cvar->GetCommandLineValue(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int cvar_RevertFlaggedConVars (lua_State *L) {
+  cvar->RevertFlaggedConVars(luaL_checkint(L, 1));
+  return 0;
+}
+
+
+static const luaL_Reg cvarlib[] = {
+  {"AllocateDLLIdentifier",   cvar_AllocateDLLIdentifier},
+  {"ConsoleColorPrintf",   cvar_ConsoleColorPrintf},
+  {"ConsoleDPrintf",   cvar_ConsoleDPrintf},
+  {"ConsolePrintf",   cvar_ConsolePrintf},
+  {"FindVar",   cvar_FindVar},
+  {"GetCommandLineValue",   cvar_GetCommandLineValue},
+  {"RevertFlaggedConVars",   cvar_RevertFlaggedConVars},
+  {NULL, NULL}
+};
+
+
+void CV_GlobalChange_Lua( IConVar *var, const char *pOldString, float flOldValue )
+{
+  lua_getglobal(L, "cvar");
+  if (lua_istable(L, -1)) {
+	lua_getfield(L, -1, "CallGlobalChangeCallbacks");
+	if (lua_isfunction(L, -1)) {
+	  lua_remove(L, -2);
+	  lua_pushconvar(L, cvar->FindVar(var->GetName()));
+	  lua_pushstring(L, pOldString);
+	  lua_pushnumber(L, flOldValue);
+	  luasrc_pcall(L, 3, 0, 0);
+	}
+	else
+	  lua_pop(L, 2);
+  }
+  else
+    lua_pop(L, 1);
+}
+
+void InstallGlobalChangeCallbacks( void )
+{
+	// Install the global cvar callback
+	cvar->InstallGlobalChangeCallback( CV_GlobalChange_Lua );
+}
+
+void RemoveGlobalChangeCallbacks( void )
+{
+	// Remove the global cvar callback
+	cvar->RemoveGlobalChangeCallback( CV_GlobalChange_Lua );
+}
+
+
+/*
+** Open cvar library
+*/
+LUALIB_API int luaopen_cvar (lua_State *L) {
+  luaL_register(L, LUA_CVARLIBNAME, cvarlib);
+  InstallGlobalChangeCallbacks();
+  return 1;
+}
+
diff --git a/src/public/licvar.h b/src/public/licvar.h
new file mode 100644
index 0000000..fffe6f2
--- /dev/null
+++ b/src/public/licvar.h
@@ -0,0 +1,15 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+//===========================================================================//
+
+#ifndef LICVAR_H
+#define LICVAR_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+void RemoveGlobalChangeCallbacks( void );
+
+#endif // LICVAR_H
diff --git a/src/public/lienginevgui.cpp b/src/public/lienginevgui.cpp
new file mode 100644
index 0000000..ada9f19
--- /dev/null
+++ b/src/public/lienginevgui.cpp
@@ -0,0 +1,52 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $Workfile:     $
+// $Date:         $
+// $NoKeywords: $
+//=============================================================================//
+#define lienginevgui_cpp
+
+#include "cbase.h"
+#include "ienginevgui.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "vgui_controls/lPanel.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+// Forward declarations.
+namespace vgui
+{
+	class Panel;
+};
+
+
+static int enginevgui_GetPanel (lua_State *L) {
+  lua_pushpanel(L, enginevgui->GetPanel((VGuiPanel_t)luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int enginevgui_IsGameUIVisible (lua_State *L) {
+  lua_pushboolean(L, enginevgui->IsGameUIVisible());
+  return 1;
+}
+
+
+static const luaL_Reg enginevguilib[] = {
+  {"GetPanel",   enginevgui_GetPanel},
+  {"IsGameUIVisible",   enginevgui_IsGameUIVisible},
+  {NULL, NULL}
+};
+
+
+/*
+** Open enginevgui library
+*/
+LUALIB_API int luaopen_enginevgui (lua_State *L) {
+  luaL_register(L, LUA_ENGINEVGUILIBNAME, enginevguilib);
+  return 1;
+}
+
diff --git a/src/public/linetchannelinfo.cpp b/src/public/linetchannelinfo.cpp
new file mode 100644
index 0000000..1dcfa01
--- /dev/null
+++ b/src/public/linetchannelinfo.cpp
@@ -0,0 +1,249 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $Workfile:     $
+// $Date:         $
+//
+//-----------------------------------------------------------------------------
+// $Log: $
+//
+// $NoKeywords: $
+//=============================================================================//
+#define linetchannelinfo_cpp
+
+#include "cbase.h"
+#include "inetchannelinfo.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "linetchannelinfo.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_INetChannelInfo *lua_tonetchannel (lua_State *L, int idx) {
+  lua_INetChannelInfo *pNetChannel = *(lua_INetChannelInfo **)luaL_checkudata(L, idx, "INetChannelInfo");
+  return pNetChannel;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushnetchannel (lua_State *L, INetChannelInfo *netchannel) {
+  if (netchannel == NULL)
+    lua_pushnil(L);
+  else {
+    lua_INetChannelInfo **ppNetChannel = (lua_INetChannelInfo **)lua_newuserdata(L, sizeof(netchannel));
+    *ppNetChannel = netchannel;
+    luaL_getmetatable(L, "INetChannelInfo");
+    lua_setmetatable(L, -2);
+  }
+}
+
+
+LUALIB_API lua_INetChannelInfo *luaL_checknetchannel (lua_State *L, int narg) {
+  lua_INetChannelInfo *d = *(lua_INetChannelInfo **)luaL_checkudata(L, narg, "INetChannelInfo");
+  return d;
+}
+
+
+static int INetChannelInfo_GetAddress (lua_State *L) {
+  lua_pushstring(L, luaL_checknetchannel(L, 1)->GetAddress());
+  return 1;
+}
+
+static int INetChannelInfo_GetAvgChoke (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetAvgChoke(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int INetChannelInfo_GetAvgData (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetAvgData(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int INetChannelInfo_GetAvgLatency (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetAvgLatency(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int INetChannelInfo_GetAvgLoss (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetAvgLoss(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int INetChannelInfo_GetAvgPackets (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetAvgPackets(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int INetChannelInfo_GetBufferSize (lua_State *L) {
+  lua_pushinteger(L, luaL_checknetchannel(L, 1)->GetBufferSize());
+  return 1;
+}
+
+static int INetChannelInfo_GetCommandInterpolationAmount (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetCommandInterpolationAmount(luaL_checkinteger(L, 2), luaL_checkinteger(L, 3)));
+  return 1;
+}
+
+static int INetChannelInfo_GetDataRate (lua_State *L) {
+  lua_pushinteger(L, luaL_checknetchannel(L, 1)->GetDataRate());
+  return 1;
+}
+
+static int INetChannelInfo_GetLatency (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetLatency(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int INetChannelInfo_GetName (lua_State *L) {
+  lua_pushstring(L, luaL_checknetchannel(L, 1)->GetName());
+  return 1;
+}
+
+static int INetChannelInfo_GetPacketBytes (lua_State *L) {
+  lua_pushinteger(L, luaL_checknetchannel(L, 1)->GetPacketBytes(luaL_checkinteger(L, 2), luaL_checkinteger(L, 3), luaL_checkinteger(L, 4)));
+  return 1;
+}
+
+static int INetChannelInfo_GetPacketResponseLatency (lua_State *L) {
+  int pnLatencyMsecs, pnChoke;
+  luaL_checknetchannel(L, 1)->GetPacketResponseLatency(luaL_checkinteger(L, 2), luaL_checkinteger(L, 3), &pnLatencyMsecs, &pnChoke);
+  lua_pushinteger(L, pnLatencyMsecs);
+  lua_pushinteger(L, pnChoke);
+  return 2;
+}
+
+static int INetChannelInfo_GetPacketTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetPacketTime(luaL_checkinteger(L, 2), luaL_checkinteger(L, 3)));
+  return 1;
+}
+
+static int INetChannelInfo_GetRemoteFramerate (lua_State *L) {
+  float pflFrameTime, pflFrameTimeStdDeviation;
+  luaL_checknetchannel(L, 1)->GetRemoteFramerate(&pflFrameTime, &pflFrameTimeStdDeviation);
+  lua_pushnumber(L, pflFrameTime);
+  lua_pushnumber(L, pflFrameTimeStdDeviation);
+  return 2;
+}
+
+static int INetChannelInfo_GetSequenceNr (lua_State *L) {
+  lua_pushinteger(L, luaL_checknetchannel(L, 1)->GetSequenceNr(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int INetChannelInfo_GetStreamProgress (lua_State *L) {
+  int received, total;
+  lua_pushboolean(L, luaL_checknetchannel(L, 1)->GetStreamProgress(luaL_checkinteger(L, 2), &received, &total));
+  lua_pushinteger(L, received);
+  lua_pushinteger(L, total);
+  return 3;
+}
+
+static int INetChannelInfo_GetTime (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetTime());
+  return 1;
+}
+
+static int INetChannelInfo_GetTimeConnected (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetTimeConnected());
+  return 1;
+}
+
+static int INetChannelInfo_GetTimeoutSeconds (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetTimeoutSeconds());
+  return 1;
+}
+
+static int INetChannelInfo_GetTimeSinceLastReceived (lua_State *L) {
+  lua_pushnumber(L, luaL_checknetchannel(L, 1)->GetTimeSinceLastReceived());
+  return 1;
+}
+
+static int INetChannelInfo_GetTotalData (lua_State *L) {
+  lua_pushinteger(L, luaL_checknetchannel(L, 1)->GetTotalData(luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int INetChannelInfo_IsLoopback (lua_State *L) {
+  lua_pushboolean(L, luaL_checknetchannel(L, 1)->IsLoopback());
+  return 1;
+}
+
+static int INetChannelInfo_IsPlayback (lua_State *L) {
+  lua_pushboolean(L, luaL_checknetchannel(L, 1)->IsPlayback());
+  return 1;
+}
+
+static int INetChannelInfo_IsTimingOut (lua_State *L) {
+  lua_pushboolean(L, luaL_checknetchannel(L, 1)->IsTimingOut());
+  return 1;
+}
+
+static int INetChannelInfo_IsValidPacket (lua_State *L) {
+  lua_pushboolean(L, luaL_checknetchannel(L, 1)->IsValidPacket(luaL_checkinteger(L, 2), luaL_checkinteger(L, 3)));
+  return 1;
+}
+
+static int INetChannelInfo___tostring (lua_State *L) {
+  lua_pushfstring(L, "INetChannelInfo: %p", luaL_checkudata(L, 1, "INetChannelInfo"));
+  return 1;
+}
+
+
+static const luaL_Reg INetChannelInfometa[] = {
+  {"GetAddress", INetChannelInfo_GetAddress},
+  {"GetAvgChoke", INetChannelInfo_GetAvgChoke},
+  {"GetAvgData", INetChannelInfo_GetAvgData},
+  {"GetAvgLatency", INetChannelInfo_GetAvgLatency},
+  {"GetAvgLoss", INetChannelInfo_GetAvgLoss},
+  {"GetAvgPackets", INetChannelInfo_GetAvgPackets},
+  {"GetBufferSize", INetChannelInfo_GetBufferSize},
+  {"GetCommandInterpolationAmount", INetChannelInfo_GetCommandInterpolationAmount},
+  {"GetDataRate", INetChannelInfo_GetDataRate},
+  {"GetLatency", INetChannelInfo_GetLatency},
+  {"GetName", INetChannelInfo_GetName},
+  {"GetPacketBytes", INetChannelInfo_GetPacketBytes},
+  {"GetPacketResponseLatency", INetChannelInfo_GetPacketResponseLatency},
+  {"GetPacketTime", INetChannelInfo_GetPacketTime},
+  {"GetRemoteFramerate", INetChannelInfo_GetRemoteFramerate},
+  {"GetSequenceNr", INetChannelInfo_GetSequenceNr},
+  {"GetStreamProgress", INetChannelInfo_GetStreamProgress},
+  {"GetTime", INetChannelInfo_GetTime},
+  {"GetTimeConnected", INetChannelInfo_GetTimeConnected},
+  {"GetTimeoutSeconds", INetChannelInfo_GetTimeoutSeconds},
+  {"GetTimeSinceLastReceived", INetChannelInfo_GetTimeSinceLastReceived},
+  {"GetTotalData", INetChannelInfo_GetTotalData},
+  {"IsLoopback", INetChannelInfo_IsLoopback},
+  {"IsPlayback", INetChannelInfo_IsPlayback},
+  {"IsTimingOut", INetChannelInfo_IsTimingOut},
+  {"IsValidPacket", INetChannelInfo_IsValidPacket},
+  {"__tostring", INetChannelInfo___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open INetChannelInfo object
+*/
+LUALIB_API int luaopen_INetChannelInfo (lua_State *L) {
+  luaL_newmetatable(L, LUA_NETCHANNELINFOLIBNAME);
+  luaL_register(L, NULL, INetChannelInfometa);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "netchannelinfo");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "netchannelinfo" */
+  return 1;
+}
+
diff --git a/src/public/linetchannelinfo.h b/src/public/linetchannelinfo.h
new file mode 100644
index 0000000..5a578d8
--- /dev/null
+++ b/src/public/linetchannelinfo.h
@@ -0,0 +1,44 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $Workfile:     $
+// $Date:         $
+//
+//-----------------------------------------------------------------------------
+// $Log: $
+//
+// $NoKeywords: $
+//=============================================================================//
+#if !defined( LINETCHANNELINFO_H )
+#define LINETCHANNELINFO_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+#pragma warning( disable: 4189 )
+
+
+/* type for INetChannelInfo functions */
+typedef INetChannelInfo lua_INetChannelInfo;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_INetChannelInfo     *(lua_tonetchannel) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushnetchannel) (lua_State *L, lua_INetChannelInfo *netchannel);
+
+
+
+LUALIB_API lua_INetChannelInfo *(luaL_checknetchannel) (lua_State *L, int narg);
+
+
+#endif // LINETCHANNELINFO_H
\ No newline at end of file
diff --git a/src/public/lnetworkstringtabledefs.cpp b/src/public/lnetworkstringtabledefs.cpp
new file mode 100644
index 0000000..0cca60a
--- /dev/null
+++ b/src/public/lnetworkstringtabledefs.cpp
@@ -0,0 +1,206 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define lnetworkstringtabledefs_cpp
+
+#include "cbase.h"
+#include "networkstringtabledefs.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lnetworkstringtabledefs.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_INetworkStringTable *lua_tostringtable (lua_State *L, int idx) {
+  lua_INetworkStringTable **ppNetworkStringTable = (lua_INetworkStringTable **)lua_touserdata(L, idx);
+  return *ppNetworkStringTable;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushstringtable (lua_State *L, lua_INetworkStringTable *pNetworkStringTable) {
+  if (pNetworkStringTable == NULL)
+    lua_pushnil(L);
+  else {
+    lua_INetworkStringTable **ppNetworkStringTable = (lua_INetworkStringTable **)lua_newuserdata(L, sizeof(pNetworkStringTable));
+    *ppNetworkStringTable = pNetworkStringTable;
+    luaL_getmetatable(L, "INetworkStringTable");
+    lua_setmetatable(L, -2);
+  }
+}
+
+
+LUALIB_API lua_INetworkStringTable *luaL_checkstringtable (lua_State *L, int narg) {
+  lua_INetworkStringTable **d = (lua_INetworkStringTable **)luaL_checkudata(L, narg, "INetworkStringTable");
+  return *d;
+}
+
+
+static int INetworkStringTable_AddString (lua_State *L) {
+  lua_pushinteger(L, luaL_checkstringtable(L, 1)->AddString(luaL_checkboolean(L, 2), luaL_checkstring(L, 3)));
+  return 1;
+}
+
+static int INetworkStringTable_ChangedSinceTick (lua_State *L) {
+  lua_pushboolean(L, luaL_checkstringtable(L, 1)->ChangedSinceTick(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int INetworkStringTable_FindStringIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkstringtable(L, 1)->FindStringIndex(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int INetworkStringTable_GetEntryBits (lua_State *L) {
+  lua_pushinteger(L, luaL_checkstringtable(L, 1)->GetEntryBits());
+  return 1;
+}
+
+static int INetworkStringTable_GetMaxStrings (lua_State *L) {
+  lua_pushinteger(L, luaL_checkstringtable(L, 1)->GetMaxStrings());
+  return 1;
+}
+
+static int INetworkStringTable_GetNumStrings (lua_State *L) {
+  lua_pushinteger(L, luaL_checkstringtable(L, 1)->GetNumStrings());
+  return 1;
+}
+
+static int INetworkStringTable_GetString (lua_State *L) {
+  lua_pushstring(L, luaL_checkstringtable(L, 1)->GetString(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int INetworkStringTable_GetTableId (lua_State *L) {
+  lua_pushinteger(L, luaL_checkstringtable(L, 1)->GetTableId());
+  return 1;
+}
+
+static int INetworkStringTable_GetTableName (lua_State *L) {
+  lua_pushstring(L, luaL_checkstringtable(L, 1)->GetTableName());
+  return 1;
+}
+
+static int INetworkStringTable_SetStringUserData (lua_State *L) {
+  luaL_checkstringtable(L, 1)->SetStringUserData(luaL_checkint(L, 2), strlen( luaL_checkstring(L, 3) ) + 1, luaL_checkstring(L, 3));
+  return 0;
+}
+
+static int INetworkStringTable_SetTick (lua_State *L) {
+  luaL_checkstringtable(L, 1)->SetTick(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int INetworkStringTable___tostring (lua_State *L) {
+  INetworkStringTable *pNetworkStringTable = luaL_checkstringtable(L, 1);
+  lua_pushfstring(L, "INetworkStringTable: %s", pNetworkStringTable->GetTableName());
+  return 1;
+}
+
+
+static const luaL_Reg INetworkStringTablemeta[] = {
+  {"AddString", INetworkStringTable_AddString},
+  {"ChangedSinceTick", INetworkStringTable_ChangedSinceTick},
+  {"FindStringIndex", INetworkStringTable_FindStringIndex},
+  {"GetEntryBits", INetworkStringTable_GetEntryBits},
+  {"GetMaxStrings", INetworkStringTable_GetMaxStrings},
+  {"GetNumStrings", INetworkStringTable_GetNumStrings},
+  {"GetString", INetworkStringTable_GetString},
+  {"GetTableId", INetworkStringTable_GetTableId},
+  {"GetTableName", INetworkStringTable_GetTableName},
+  {"SetStringUserData", INetworkStringTable_SetStringUserData},
+  {"SetTick", INetworkStringTable_SetTick},
+  {"__tostring", INetworkStringTable___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open INetworkStringTable object
+*/
+LUALIB_API int luaopen_INetworkStringTable (lua_State *L) {
+  luaL_newmetatable(L, LUA_INETWORKSTRINGTABLELIBNAME);
+  luaL_register(L, NULL, INetworkStringTablemeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "networkstringtable");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "effect" */
+  return 1;
+}
+
+
+// Engine interfaces.
+extern INetworkStringTableContainer *networkstringtable;
+
+static int networkstringtable_CreateStringTable (lua_State *L) {
+  networkstringtable->CreateStringTable(luaL_checkstring(L, 1), luaL_checkint(L, 2), luaL_optint(L, 3, 0), luaL_optint(L, 4, 0));
+  return 0;
+}
+
+static int networkstringtable_CreateStringTableEx (lua_State *L) {
+  lua_pushstringtable(L, networkstringtable->CreateStringTableEx(luaL_checkstring(L, 1), luaL_checkint(L, 2), luaL_optint(L, 3, 0), luaL_optint(L, 4, 0), luaL_optboolean(L, 5, 0)));
+  return 1;
+}
+
+static int networkstringtable_FindTable (lua_State *L) {
+  lua_pushstringtable(L, networkstringtable->FindTable(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int networkstringtable_GetNumTables (lua_State *L) {
+  lua_pushinteger(L, networkstringtable->GetNumTables());
+  return 1;
+}
+
+static int networkstringtable_GetTable (lua_State *L) {
+  lua_pushstringtable(L, networkstringtable->GetTable(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int networkstringtable_RemoveAllTables (lua_State *L) {
+  networkstringtable->RemoveAllTables();
+  return 0;
+}
+
+static int networkstringtable_SetAllowClientSideAddString (lua_State *L) {
+  networkstringtable->SetAllowClientSideAddString(luaL_checkstringtable(L, 1), luaL_checkboolean(L, 2));
+  return 0;
+}
+
+
+static const luaL_Reg networkstringtablelib[] = {
+  {"CreateStringTable",   networkstringtable_CreateStringTable},
+  {"CreateStringTableEx",   networkstringtable_CreateStringTableEx},
+  {"FindTable",   networkstringtable_FindTable},
+  {"GetNumTables",   networkstringtable_GetNumTables},
+  {"GetTable",   networkstringtable_GetTable},
+  {"RemoveAllTables",   networkstringtable_RemoveAllTables},
+  {"SetAllowClientSideAddString",   networkstringtable_SetAllowClientSideAddString},
+  {NULL, NULL}
+};
+
+
+/*
+** Open networkstringtable library
+*/
+LUALIB_API int luaopen_networkstringtable (lua_State *L) {
+  luaL_register(L, LUA_NETWORKSTRINGTABLELIBNAME, networkstringtablelib);
+  return 1;
+}
+
diff --git a/src/public/lnetworkstringtabledefs.h b/src/public/lnetworkstringtabledefs.h
new file mode 100644
index 0000000..1d97ebc
--- /dev/null
+++ b/src/public/lnetworkstringtabledefs.h
@@ -0,0 +1,38 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LNETWORKSTRINGTABLEDEFS_H
+#define LNETWORKSTRINGTABLEDEFS_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include "networkstringtabledefs.h"
+
+/* type for INetworkStringTable functions */
+typedef INetworkStringTable lua_INetworkStringTable;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_INetworkStringTable     *(lua_tostringtable) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushstringtable) (lua_State *L, lua_INetworkStringTable *pNetworkStringTable);
+
+
+
+LUALIB_API lua_INetworkStringTable *(luaL_checkstringtable) (lua_State *L, int narg);
+
+
+#endif // LNETWORKSTRINGTABLEDEFS_H
diff --git a/src/public/lvphysics_interface.cpp b/src/public/lvphysics_interface.cpp
new file mode 100644
index 0000000..83f5083
--- /dev/null
+++ b/src/public/lvphysics_interface.cpp
@@ -0,0 +1,1204 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Public interfaces to vphysics DLL
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define lvphysics_interface_cpp
+
+#include "cbase.h"
+#include "vphysics_interface.h"
+#include "vphysics/performance.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lvphysics_interface.h"
+#include "vphysics/lperformance.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_IPhysicsObject *lua_tophysicsobject (lua_State *L, int idx) {
+  lua_IPhysicsObject **ppPhysicsObject = (lua_IPhysicsObject **)lua_touserdata(L, idx);
+  return *ppPhysicsObject;
+}
+
+
+LUA_API lua_surfacephysicsparams_t lua_tosurfacephysicsparams (lua_State *L, int idx) {
+  luaL_checktype(L, idx, LUA_TTABLE);
+  surfacephysicsparams_t physics;
+  lua_getfield(L, idx, "friction");
+  if (!lua_isnil(L, -1))
+    physics.friction = luaL_checknumber(L, -1);
+  else
+    physics.friction = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "elasticity");
+  if (!lua_isnil(L, -1))
+    physics.elasticity = luaL_checknumber(L, -1);
+  else
+    physics.elasticity = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "density");
+  if (!lua_isnil(L, -1))
+    physics.density = luaL_checknumber(L, -1);
+  else
+    physics.density = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "thickness");
+  if (!lua_isnil(L, -1))
+    physics.thickness = luaL_checknumber(L, -1);
+  else
+    physics.thickness = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "dampening");
+  if (!lua_isnil(L, -1))
+    physics.dampening = luaL_checknumber(L, -1);
+  else
+    physics.dampening = 0;
+  lua_pop(L, 1);
+  return physics;
+}
+
+
+LUA_API lua_surfaceaudioparams_t lua_tosurfaceaudioparams (lua_State *L, int idx) {
+  luaL_checktype(L, idx, LUA_TTABLE);
+  surfaceaudioparams_t audio;
+  lua_getfield(L, idx, "reflectivity");
+  if (!lua_isnil(L, -1))
+    audio.reflectivity = luaL_checknumber(L, -1);
+  else
+    audio.reflectivity = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "hardnessFactor");
+  if (!lua_isnil(L, -1))
+    audio.hardnessFactor = luaL_checknumber(L, -1);
+  else
+    audio.hardnessFactor = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "roughnessFactor");
+  if (!lua_isnil(L, -1))
+    audio.roughnessFactor = luaL_checknumber(L, -1);
+  else
+    audio.roughnessFactor = 0;
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "roughThreshold");
+  if (!lua_isnil(L, -1))
+    audio.roughThreshold = luaL_checknumber(L, -1);
+  else
+    audio.roughThreshold = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "hardThreshold");
+  if (!lua_isnil(L, -1))
+    audio.hardThreshold = luaL_checknumber(L, -1);
+  else
+    audio.hardThreshold = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "hardVelocityThreshold");
+  if (!lua_isnil(L, -1))
+    audio.hardVelocityThreshold = luaL_checknumber(L, -1);
+  else
+    audio.hardVelocityThreshold = 0;
+  lua_pop(L, 1);
+  return audio;
+}
+
+
+LUA_API lua_surfacesoundnames_t lua_tosurfacesoundnames (lua_State *L, int idx) {
+  luaL_checktype(L, idx, LUA_TTABLE);
+  surfacesoundnames_t sounds;
+  lua_getfield(L, idx, "stepleft");
+  if (!lua_isnil(L, -1))
+    sounds.stepleft = (unsigned short)luaL_checkinteger(L, -1);
+  else
+    sounds.stepleft = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "stepright");
+  if (!lua_isnil(L, -1))
+    sounds.stepright = (unsigned short)luaL_checkinteger(L, -1);
+  else
+    sounds.stepright = 0;
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "impactSoft");
+  if (!lua_isnil(L, -1))
+    sounds.impactSoft = (unsigned short)luaL_checkinteger(L, -1);
+  else
+    sounds.impactSoft = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "impactHard");
+  if (!lua_isnil(L, -1))
+    sounds.impactHard = (unsigned short)luaL_checkinteger(L, -1);
+  else
+    sounds.impactHard = 0;
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "scrapeSmooth");
+  if (!lua_isnil(L, -1))
+    sounds.scrapeSmooth = (unsigned short)luaL_checkinteger(L, -1);
+  else
+    sounds.scrapeSmooth = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "scrapeRough");
+  if (!lua_isnil(L, -1))
+    sounds.scrapeRough = (unsigned short)luaL_checkinteger(L, -1);
+  else
+    sounds.scrapeRough = 0;
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "bulletImpact");
+  if (!lua_isnil(L, -1))
+    sounds.bulletImpact = (unsigned short)luaL_checkinteger(L, -1);
+  else
+    sounds.bulletImpact = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "rolling");
+  if (!lua_isnil(L, -1))
+    sounds.rolling = (unsigned short)luaL_checkinteger(L, -1);
+  else
+    sounds.rolling = 0;
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "breakSound");
+  if (!lua_isnil(L, -1))
+    sounds.breakSound = (unsigned short)luaL_checkinteger(L, -1);
+  else
+    sounds.breakSound = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "strainSound");
+  if (!lua_isnil(L, -1))
+    sounds.strainSound = (unsigned short)luaL_checkinteger(L, -1);
+  else
+    sounds.strainSound = 0;
+  lua_pop(L, 1);
+  return sounds;
+}
+
+
+LUA_API lua_surfacesoundhandles_t lua_tosurfacesoundhandles (lua_State *L, int idx) {
+  luaL_checktype(L, idx, LUA_TTABLE);
+  surfacesoundhandles_t soundhandles;
+  lua_getfield(L, idx, "stepleft");
+  if (!lua_isnil(L, -1))
+    soundhandles.stepleft = (short)luaL_checkinteger(L, -1);
+  else
+    soundhandles.stepleft = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "stepright");
+  if (!lua_isnil(L, -1))
+    soundhandles.stepright = (short)luaL_checkinteger(L, -1);
+  else
+    soundhandles.stepright = 0;
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "impactSoft");
+  if (!lua_isnil(L, -1))
+    soundhandles.impactSoft = (short)luaL_checkinteger(L, -1);
+  else
+    soundhandles.impactSoft = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "impactHard");
+  if (!lua_isnil(L, -1))
+    soundhandles.impactHard = (short)luaL_checkinteger(L, -1);
+  else
+    soundhandles.impactHard = 0;
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "scrapeSmooth");
+  if (!lua_isnil(L, -1))
+    soundhandles.scrapeSmooth = (short)luaL_checkinteger(L, -1);
+  else
+    soundhandles.scrapeSmooth = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "scrapeRough");
+  if (!lua_isnil(L, -1))
+    soundhandles.scrapeRough = (short)luaL_checkinteger(L, -1);
+  else
+    soundhandles.scrapeRough = 0;
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "bulletImpact");
+  if (!lua_isnil(L, -1))
+    soundhandles.bulletImpact = (short)luaL_checkinteger(L, -1);
+  else
+    soundhandles.bulletImpact = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "rolling");
+  if (!lua_isnil(L, -1))
+    soundhandles.rolling = (short)luaL_checkinteger(L, -1);
+  else
+    soundhandles.rolling = 0;
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "breakSound");
+  if (!lua_isnil(L, -1))
+    soundhandles.breakSound = (short)luaL_checkinteger(L, -1);
+  else
+    soundhandles.breakSound = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "strainSound");
+  if (!lua_isnil(L, -1))
+    soundhandles.strainSound = (short)luaL_checkinteger(L, -1);
+  else
+    soundhandles.strainSound = 0;
+  lua_pop(L, 1);
+  return soundhandles;
+}
+
+
+LUA_API lua_surfacegameprops_t lua_tosurfacegameprops (lua_State *L, int idx) {
+  luaL_checktype(L, idx, LUA_TTABLE);
+  surfacegameprops_t game;
+  lua_getfield(L, idx, "maxSpeedFactor");
+  if (!lua_isnil(L, -1))
+    game.maxSpeedFactor = luaL_checknumber(L, -1);
+  else
+    game.maxSpeedFactor = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "jumpFactor");
+  if (!lua_isnil(L, -1))
+    game.jumpFactor = luaL_checknumber(L, -1);
+  else
+    game.jumpFactor = 0;
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "material");
+  if (!lua_isnil(L, -1))
+    game.material = (unsigned short)luaL_checkinteger(L, -1);
+  else
+    game.material = 0;
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "climbable");
+  if (!lua_isnil(L, -1))
+    game.climbable = (unsigned char)luaL_checkinteger(L, -1);
+  else
+    game.climbable = 0;
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "pad");
+  if (!lua_isnil(L, -1))
+    game.pad = (unsigned char)luaL_checkinteger(L, -1);
+  else
+    game.pad = 0;
+  lua_pop(L, 1);
+  return game;
+}
+
+
+#pragma warning (disable : 4701)
+
+
+LUA_API lua_surfacedata_t lua_tosurfacedata (lua_State *L, int idx) {
+  luaL_checktype(L, idx, LUA_TTABLE);
+  surfacedata_t surface;
+  lua_getfield(L, idx, "physics");
+  if (!lua_isnil(L, -1))
+    surface.physics = lua_tosurfacephysicsparams(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "audio");
+  if (!lua_isnil(L, -1))
+    surface.audio = lua_tosurfaceaudioparams(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "sounds");
+  if (!lua_isnil(L, -1))
+    surface.sounds = lua_tosurfacesoundnames(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "game");
+  if (!lua_isnil(L, -1))
+    surface.game = lua_tosurfacegameprops(L, -1);
+  lua_pop(L, 1);
+
+  lua_getfield(L, idx, "soundhandles");
+  if (!lua_isnil(L, -1))
+    surface.soundhandles = lua_tosurfacesoundhandles(L, -1);
+  lua_pop(L, 1);
+  return surface;
+}
+
+
+LUA_API lua_IPhysicsSurfaceProps *lua_tophysicssurfaceprops (lua_State *L, int idx) {
+  lua_IPhysicsSurfaceProps **ppProps = (lua_IPhysicsSurfaceProps **)lua_touserdata(L, idx);
+  return *ppProps;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+// FIXME?: So here's the deal folks; in the Source SDK storing physics objects
+// long-term is not done frequently. This is because physics objects are, for
+// the majority of the time, tied to plain physics props or other similar
+// movable entities.
+// 
+// In the Lau SDK, we want to promote the storage of the entity in variables in
+// Lua instead, which mirrors internal code storing entities in handles. There
+// are no handles for IPhysicsObjects in the Source SDK, so here we use a
+// pointer to a pointer.
+// 
+// This means this object is unsafe in Lua, since the entity which this physics
+// object is tied to could be gone when you attempt to use it.
+// 
+// Henry wrote up a handle system for this, so if we need to end up using that
+// due to unforeseen logical issues, we will.
+LUA_API void lua_pushphysicsobject (lua_State *L, lua_IPhysicsObject *pPhysicsObject) {
+  if (pPhysicsObject == NULL)
+    lua_pushnil(L);
+  else {
+    lua_IPhysicsObject **ppPhysicsObject = (lua_IPhysicsObject **)lua_newuserdata(L, sizeof(pPhysicsObject));
+    *ppPhysicsObject = pPhysicsObject;
+    luaL_getmetatable(L, "IPhysicsObject");
+    lua_setmetatable(L, -2);
+  }
+}
+
+
+LUA_API void lua_pushsurfacephysicsparams (lua_State *L, lua_surfacephysicsparams_t *pphysics) {
+  lua_newtable(L);
+  lua_pushnumber(L, pphysics->friction);
+  lua_setfield(L, -2, "friction");
+  lua_pushnumber(L, pphysics->elasticity);
+  lua_setfield(L, -2, "elasticity");
+  lua_pushnumber(L, pphysics->density);
+  lua_setfield(L, -2, "density");
+  lua_pushnumber(L, pphysics->thickness);
+  lua_setfield(L, -2, "thickness");
+  lua_pushnumber(L, pphysics->dampening);
+  lua_setfield(L, -2, "dampening");
+}
+
+
+LUA_API void lua_pushsurfaceaudioparams (lua_State *L, lua_surfaceaudioparams_t *paudio) {
+  lua_newtable(L);
+  lua_pushnumber(L, paudio->reflectivity);
+  lua_setfield(L, -2, "reflectivity");
+  lua_pushnumber(L, paudio->hardnessFactor);
+  lua_setfield(L, -2, "hardnessFactor");
+  lua_pushnumber(L, paudio->roughnessFactor);
+  lua_setfield(L, -2, "roughnessFactor");
+
+  lua_pushnumber(L, paudio->roughThreshold);
+  lua_setfield(L, -2, "roughThreshold");
+  lua_pushnumber(L, paudio->hardThreshold);
+  lua_setfield(L, -2, "hardThreshold");
+  lua_pushnumber(L, paudio->hardVelocityThreshold);
+  lua_setfield(L, -2, "hardVelocityThreshold");
+}
+
+
+LUA_API void lua_pushsurfacesoundnames (lua_State *L, lua_surfacesoundnames_t *psounds) {
+  lua_newtable(L);
+  lua_pushinteger(L, psounds->stepleft);
+  lua_setfield(L, -2, "stepleft");
+  lua_pushinteger(L, psounds->stepright);
+  lua_setfield(L, -2, "stepright");
+
+  lua_pushinteger(L, psounds->impactSoft);
+  lua_setfield(L, -2, "impactSoft");
+  lua_pushinteger(L, psounds->impactHard);
+  lua_setfield(L, -2, "impactHard");
+
+  lua_pushinteger(L, psounds->scrapeSmooth);
+  lua_setfield(L, -2, "scrapeSmooth");
+  lua_pushinteger(L, psounds->scrapeRough);
+  lua_setfield(L, -2, "scrapeRough");
+
+  lua_pushinteger(L, psounds->bulletImpact);
+  lua_setfield(L, -2, "bulletImpact");
+  lua_pushinteger(L, psounds->rolling);
+  lua_setfield(L, -2, "rolling");
+
+  lua_pushinteger(L, psounds->breakSound);
+  lua_setfield(L, -2, "breakSound");
+  lua_pushinteger(L, psounds->strainSound);
+  lua_setfield(L, -2, "strainSound");
+}
+
+
+LUA_API void lua_pushsurfacesoundhandles (lua_State *L, lua_surfacesoundhandles_t *psoundhandles) {
+  lua_newtable(L);
+  lua_pushinteger(L, psoundhandles->stepleft);
+  lua_setfield(L, -2, "stepleft");
+  lua_pushinteger(L, psoundhandles->stepright);
+  lua_setfield(L, -2, "stepright");
+
+  lua_pushinteger(L, psoundhandles->impactSoft);
+  lua_setfield(L, -2, "impactSoft");
+  lua_pushinteger(L, psoundhandles->impactHard);
+  lua_setfield(L, -2, "impactHard");
+
+  lua_pushinteger(L, psoundhandles->scrapeSmooth);
+  lua_setfield(L, -2, "scrapeSmooth");
+  lua_pushinteger(L, psoundhandles->scrapeRough);
+  lua_setfield(L, -2, "scrapeRough");
+
+  lua_pushinteger(L, psoundhandles->bulletImpact);
+  lua_setfield(L, -2, "bulletImpact");
+  lua_pushinteger(L, psoundhandles->rolling);
+  lua_setfield(L, -2, "rolling");
+
+  lua_pushinteger(L, psoundhandles->breakSound);
+  lua_setfield(L, -2, "breakSound");
+  lua_pushinteger(L, psoundhandles->strainSound);
+  lua_setfield(L, -2, "strainSound");
+}
+
+
+LUA_API void lua_pushsurfacegameprops (lua_State *L, lua_surfacegameprops_t *pgame) {
+  lua_newtable(L);
+  lua_pushnumber(L, pgame->maxSpeedFactor);
+  lua_setfield(L, -2, "maxSpeedFactor");
+  lua_pushnumber(L, pgame->jumpFactor);
+  lua_setfield(L, -2, "jumpFactor");
+
+  lua_pushinteger(L, pgame->material);
+  lua_setfield(L, -2, "material");
+
+  lua_pushinteger(L, pgame->climbable);
+  lua_setfield(L, -2, "climbable");
+  lua_pushinteger(L, pgame->pad);
+  lua_setfield(L, -2, "pad");
+}
+
+
+LUA_API void lua_pushsurfacedata (lua_State *L, lua_surfacedata_t *psurface) {
+  lua_newtable(L);
+  lua_pushsurfacephysicsparams(L, &psurface->physics);
+  lua_setfield(L, -2, "physics");
+  lua_pushsurfaceaudioparams(L, &psurface->audio);
+  lua_setfield(L, -2, "audio");
+  lua_pushsurfacesoundnames(L, &psurface->sounds);
+  lua_setfield(L, -2, "sounds");
+  lua_pushsurfacegameprops(L, &psurface->game);
+  lua_setfield(L, -2, "game");
+
+  lua_pushsurfacesoundhandles(L, &psurface->soundhandles);
+  lua_setfield(L, -2, "soundhandles");
+}
+
+
+LUA_API void lua_pushphysicssurfaceprops (lua_State *L, lua_IPhysicsSurfaceProps *pProps) {
+  if (pProps == NULL)
+    lua_pushnil(L);
+  else {
+    lua_IPhysicsSurfaceProps **ppProps = (lua_IPhysicsSurfaceProps **)lua_newuserdata(L, sizeof(pProps));
+    *ppProps = pProps;
+    luaL_getmetatable(L, "IPhysicsSurfaceProps");
+    lua_setmetatable(L, -2);
+  }
+}
+
+
+LUALIB_API lua_IPhysicsObject *luaL_checkphysicsobject (lua_State *L, int narg) {
+  lua_IPhysicsObject *d = lua_tophysicsobject(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "IPhysicsObject expected, got NULL physicsobject");
+  return d;
+}
+
+
+LUALIB_API lua_IPhysicsSurfaceProps *luaL_checkphysicssurfaceprops (lua_State *L, int narg) {
+  lua_IPhysicsSurfaceProps **d = (lua_IPhysicsSurfaceProps **)luaL_checkudata(L, narg, "IPhysicsSurfaceProps");
+  return *d;
+}
+
+
+static int physenv_CleanupDeleteList (lua_State *L) {
+  physenv->CleanupDeleteList();
+  return 0;
+}
+
+static int physenv_ClearStats (lua_State *L) {
+  physenv->ClearStats();
+  return 0;
+}
+
+static int physenv_DebugCheckContacts (lua_State *L) {
+  physenv->DebugCheckContacts();
+  return 0;
+}
+
+static int physenv_GetActiveObjectCount (lua_State *L) {
+  lua_pushnumber(L, physenv->GetActiveObjectCount());
+  return 1;
+}
+
+static int physenv_GetAirDensity (lua_State *L) {
+  lua_pushnumber(L, physenv->GetAirDensity());
+  return 1;
+}
+
+static int physenv_GetGravity (lua_State *L) {
+  Vector pGravityVector;
+  physenv->GetGravity(&pGravityVector);
+  lua_pushvector(L, pGravityVector);
+  return 1;
+}
+
+static int physenv_GetNextFrameTime (lua_State *L) {
+  lua_pushnumber(L, physenv->GetNextFrameTime());
+  return 1;
+}
+
+static int physenv_GetPerformanceSettings (lua_State *L) {
+  physics_performanceparams_t pOutput;
+  physenv->GetPerformanceSettings(&pOutput);
+  lua_pushperformanceparams(L, &pOutput);
+  return 1;
+}
+
+static int physenv_GetSimulationTime (lua_State *L) {
+  lua_pushnumber(L, physenv->GetSimulationTime());
+  return 1;
+}
+
+static int physenv_GetSimulationTimestep (lua_State *L) {
+  lua_pushnumber(L, physenv->GetSimulationTimestep());
+  return 1;
+}
+
+static int physenv_IsInSimulation (lua_State *L) {
+  lua_pushboolean(L, physenv->IsInSimulation());
+  return 1;
+}
+
+static int physenv_PostRestore (lua_State *L) {
+  physenv->PostRestore();
+  return 0;
+}
+
+static int physenv_ResetSimulationClock (lua_State *L) {
+  physenv->ResetSimulationClock();
+  return 0;
+}
+
+static int physenv_SetAirDensity (lua_State *L) {
+  physenv->SetAirDensity(luaL_checknumber(L, 1));
+  return 0;
+}
+
+static int physenv_SetGravity (lua_State *L) {
+  physenv->SetGravity(luaL_checkvector(L, 1));
+  return 0;
+}
+
+static int physenv_SetPerformanceSettings (lua_State *L) {
+  physenv->SetPerformanceSettings(&lua_toperformanceparams(L, 1));
+  return 0;
+}
+
+static int physenv_SetQuickDelete (lua_State *L) {
+  physenv->SetQuickDelete(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int physenv_SetSimulationTimestep (lua_State *L) {
+  physenv->SetSimulationTimestep(luaL_checknumber(L, 1));
+  return 0;
+}
+
+static int physenv_Simulate (lua_State *L) {
+  physenv->Simulate(luaL_checknumber(L, 1));
+  return 0;
+}
+
+
+static const luaL_Reg physenvlib[] = {
+  {"CleanupDeleteList",  physenv_CleanupDeleteList},
+  {"ClearStats",  physenv_ClearStats},
+  {"DebugCheckContacts",  physenv_DebugCheckContacts},
+  {"GetActiveObjectCount",  physenv_GetActiveObjectCount},
+  {"GetAirDensity",  physenv_GetAirDensity},
+  {"GetGravity",  physenv_GetGravity},
+  {"GetNextFrameTime",  physenv_GetNextFrameTime},
+  {"GetPerformanceSettings",  physenv_GetPerformanceSettings},
+  {"GetSimulationTime",  physenv_GetSimulationTime},
+  {"GetSimulationTimestep",  physenv_GetSimulationTimestep},
+  {"IsInSimulation",  physenv_IsInSimulation},
+  {"PostRestore",  physenv_PostRestore},
+  {"ResetSimulationClock",  physenv_ResetSimulationClock},
+  {"SetAirDensity",  physenv_SetAirDensity},
+  {"SetGravity",  physenv_SetGravity},
+  {"SetPerformanceSettings",  physenv_SetPerformanceSettings},
+  {"SetQuickDelete",  physenv_SetQuickDelete},
+  {"SetSimulationTimestep",  physenv_SetSimulationTimestep},
+  {"Simulate",  physenv_Simulate},
+  {NULL, NULL}
+};
+
+
+/*
+** Open physenv library
+*/
+LUALIB_API int luaopen_physenv (lua_State *L) {
+  luaL_register(L, LUA_PHYSENVLIBNAME, physenvlib);
+  return 1;
+}
+
+
+static int IPhysicsObject_AddVelocity (lua_State *L) {
+  Vector velocity = luaL_checkvector(L, 2);
+  AngularImpulse angularVelocity = luaL_checkvector(L, 3);
+  luaL_checkphysicsobject(L, 1)->AddVelocity(&velocity, &angularVelocity);
+  return 0;
+}
+
+static int IPhysicsObject_ApplyForceCenter (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->ApplyForceCenter(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_ApplyForceOffset (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->ApplyForceOffset(luaL_checkvector(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int IPhysicsObject_ApplyTorqueCenter (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->ApplyTorqueCenter(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_BecomeHinged (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->BecomeHinged(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_BecomeTrigger (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->BecomeTrigger();
+  return 0;
+}
+
+static int IPhysicsObject_CalculateAngularDrag (lua_State *L) {
+  lua_pushnumber(L, luaL_checkphysicsobject(L, 1)->CalculateAngularDrag(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int IPhysicsObject_CalculateForceOffset (lua_State *L) {
+  Vector centerForce, centerTorque;
+  luaL_checkphysicsobject(L, 1)->CalculateForceOffset(luaL_checkvector(L, 2), luaL_checkvector(L, 3), &centerForce, &centerTorque);
+  lua_pushvector(L, centerForce);
+  lua_pushvector(L, centerTorque);
+  return 2;
+}
+
+static int IPhysicsObject_CalculateLinearDrag (lua_State *L) {
+  lua_pushnumber(L, luaL_checkphysicsobject(L, 1)->CalculateLinearDrag(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int IPhysicsObject_CalculateVelocityOffset (lua_State *L) {
+  Vector centerVelocity, centerAngularVelocity;
+  luaL_checkphysicsobject(L, 1)->CalculateVelocityOffset(luaL_checkvector(L, 2), luaL_checkvector(L, 3), &centerVelocity, &centerAngularVelocity);
+  lua_pushvector(L, centerVelocity);
+  lua_pushvector(L, centerAngularVelocity);
+  return 2;
+}
+
+static int IPhysicsObject_EnableCollisions (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->EnableCollisions(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_EnableDrag (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->EnableDrag(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_EnableGravity (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->EnableGravity(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_EnableMotion (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->EnableMotion(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_GetCallbackFlags (lua_State *L) {
+  lua_pushinteger(L, luaL_checkphysicsobject(L, 1)->GetCallbackFlags());
+  return 1;
+}
+
+static int IPhysicsObject_GetContactPoint (lua_State *L) {
+  Vector contactPoint;
+  IPhysicsObject *contactObject;
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->GetContactPoint(&contactPoint, &contactObject));
+  lua_pushvector(L, contactPoint);
+  lua_pushphysicsobject(L, contactObject);
+  return 3;
+}
+
+static int IPhysicsObject_GetContents (lua_State *L) {
+  lua_pushinteger(L, luaL_checkphysicsobject(L, 1)->GetContents());
+  return 1;
+}
+
+static int IPhysicsObject_GetDamping (lua_State *L) {
+  float speed, rot;
+  luaL_checkphysicsobject(L, 1)->GetDamping(&speed, &rot);
+  lua_pushnumber(L, speed);
+  lua_pushnumber(L, rot);
+  return 2;
+}
+
+static int IPhysicsObject_GetEnergy (lua_State *L) {
+  lua_pushnumber(L, luaL_checkphysicsobject(L, 1)->GetEnergy());
+  return 1;
+}
+
+static int IPhysicsObject_GetGameFlags (lua_State *L) {
+  lua_pushinteger(L, luaL_checkphysicsobject(L, 1)->GetGameFlags());
+  return 1;
+}
+
+static int IPhysicsObject_GetGameIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkphysicsobject(L, 1)->GetGameIndex());
+  return 1;
+}
+
+static int IPhysicsObject_GetImplicitVelocity (lua_State *L) {
+  Vector velocity, angularVelocity;
+  luaL_checkphysicsobject(L, 1)->GetImplicitVelocity(&velocity, &angularVelocity);
+  lua_pushvector(L, velocity);
+  lua_pushvector(L, angularVelocity);
+  return 2;
+}
+
+static int IPhysicsObject_GetInertia (lua_State *L) {
+  lua_pushvector(L, luaL_checkphysicsobject(L, 1)->GetInertia());
+  return 1;
+}
+
+static int IPhysicsObject_GetInvInertia (lua_State *L) {
+  lua_pushvector(L, luaL_checkphysicsobject(L, 1)->GetInvInertia());
+  return 1;
+}
+
+static int IPhysicsObject_GetInvMass (lua_State *L) {
+  lua_pushnumber(L, luaL_checkphysicsobject(L, 1)->GetInvMass());
+  return 1;
+}
+
+static int IPhysicsObject_GetMass (lua_State *L) {
+  lua_pushnumber(L, luaL_checkphysicsobject(L, 1)->GetMass());
+  return 1;
+}
+
+static int IPhysicsObject_GetMassCenterLocalSpace (lua_State *L) {
+  lua_pushvector(L, luaL_checkphysicsobject(L, 1)->GetMassCenterLocalSpace());
+  return 1;
+}
+
+static int IPhysicsObject_GetMaterialIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkphysicsobject(L, 1)->GetMaterialIndex());
+  return 1;
+}
+
+static int IPhysicsObject_GetName (lua_State *L) {
+  lua_pushstring(L, luaL_checkphysicsobject(L, 1)->GetName());
+  return 1;
+}
+
+static int IPhysicsObject_GetPosition (lua_State *L) {
+  Vector worldPosition;
+  QAngle angles;
+  luaL_checkphysicsobject(L, 1)->GetPosition(&worldPosition, &angles);
+  lua_pushvector(L, worldPosition);
+  lua_pushangle(L, angles);
+  return 2;
+}
+
+static int IPhysicsObject_GetShadowPosition (lua_State *L) {
+  Vector position;
+  QAngle angles;
+  lua_pushinteger(L, luaL_checkphysicsobject(L, 1)->GetShadowPosition(&position, &angles));
+  lua_pushvector(L, position);
+  lua_pushangle(L, angles);
+  return 3;
+}
+
+static int IPhysicsObject_GetSphereRadius (lua_State *L) {
+  lua_pushnumber(L, luaL_checkphysicsobject(L, 1)->GetSphereRadius());
+  return 1;
+}
+
+static int IPhysicsObject_GetVelocity (lua_State *L) {
+  Vector velocity, angularVelocity;
+  luaL_checkphysicsobject(L, 1)->GetVelocity(&velocity, &angularVelocity);
+  lua_pushvector(L, velocity);
+  lua_pushvector(L, angularVelocity);
+  return 2;
+}
+
+static int IPhysicsObject_GetVelocityAtPoint (lua_State *L) {
+  Vector pVelocity;
+  luaL_checkphysicsobject(L, 1)->GetVelocityAtPoint(luaL_checkvector(L, 2), &pVelocity);
+  lua_pushvector(L, pVelocity);
+  return 1;
+}
+
+static int IPhysicsObject_IsAsleep (lua_State *L) {
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->IsAsleep());
+  return 1;
+}
+
+static int IPhysicsObject_IsAttachedToConstraint (lua_State *L) {
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->IsAttachedToConstraint(luaL_checkboolean(L, 2)));
+  return 1;
+}
+
+static int IPhysicsObject_IsCollisionEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->IsCollisionEnabled());
+  return 1;
+}
+
+static int IPhysicsObject_IsDragEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->IsDragEnabled());
+  return 1;
+}
+
+static int IPhysicsObject_IsFluid (lua_State *L) {
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->IsFluid());
+  return 1;
+}
+
+static int IPhysicsObject_IsGravityEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->IsGravityEnabled());
+  return 1;
+}
+
+static int IPhysicsObject_IsHinged (lua_State *L) {
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->IsHinged());
+  return 1;
+}
+
+static int IPhysicsObject_IsMotionEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->IsMotionEnabled());
+  return 1;
+}
+
+static int IPhysicsObject_IsMoveable (lua_State *L) {
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->IsMoveable());
+  return 1;
+}
+
+static int IPhysicsObject_IsStatic (lua_State *L) {
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->IsStatic());
+  return 1;
+}
+
+static int IPhysicsObject_IsTrigger (lua_State *L) {
+  lua_pushboolean(L, luaL_checkphysicsobject(L, 1)->IsTrigger());
+  return 1;
+}
+
+static int IPhysicsObject_LocalToWorld (lua_State *L) {
+  Vector worldPosition;
+  luaL_checkphysicsobject(L, 1)->LocalToWorld(&worldPosition, luaL_checkvector(L, 2));
+  lua_pushvector(L, worldPosition);
+  return 1;
+}
+
+static int IPhysicsObject_LocalToWorldVector (lua_State *L) {
+  Vector worldVector;
+  luaL_checkphysicsobject(L, 1)->LocalToWorldVector(&worldVector, luaL_checkvector(L, 2));
+  lua_pushvector(L, worldVector);
+  return 1;
+}
+
+static int IPhysicsObject_OutputDebugInfo (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->OutputDebugInfo();
+  return 0;
+}
+
+static int IPhysicsObject_RecheckCollisionFilter (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->RecheckCollisionFilter();
+  return 0;
+}
+
+static int IPhysicsObject_RecheckContactPoints (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->RecheckContactPoints();
+  return 0;
+}
+
+static int IPhysicsObject_RemoveHinged (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->RemoveHinged();
+  return 0;
+}
+
+static int IPhysicsObject_RemoveShadowController (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->RemoveShadowController();
+  return 0;
+}
+
+static int IPhysicsObject_RemoveTrigger (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->RemoveTrigger();
+  return 0;
+}
+
+static int IPhysicsObject_SetBuoyancyRatio (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->SetBuoyancyRatio(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_SetCallbackFlags (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->SetCallbackFlags(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_SetContents (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->SetContents(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_SetDragCoefficient (lua_State *L) {
+  float pDrag = luaL_checknumber(L, 2);
+  float pAngularDrag = luaL_checknumber(L, 3);
+  luaL_checkphysicsobject(L, 1)->SetDragCoefficient(&pDrag, &pAngularDrag);
+  return 0;
+}
+
+static int IPhysicsObject_SetGameFlags (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->SetGameFlags(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_SetGameIndex (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->SetGameIndex(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_SetMass (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->SetMass(luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_SetMaterialIndex (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->SetMaterialIndex(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int IPhysicsObject_SetShadow (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->SetShadow(luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checkboolean(L, 4), luaL_checkboolean(L, 5));
+  return 0;
+}
+
+static int IPhysicsObject_SetVelocity (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->SetVelocity(&luaL_checkvector(L, 2), &luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int IPhysicsObject_SetVelocityInstantaneous (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->SetVelocityInstantaneous(&luaL_checkvector(L, 2), &luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int IPhysicsObject_Sleep (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->Sleep();
+  return 0;
+}
+
+static int IPhysicsObject_Wake (lua_State *L) {
+  luaL_checkphysicsobject(L, 1)->Wake();
+  return 0;
+}
+
+static int IPhysicsObject_WorldToLocal (lua_State *L) {
+  Vector localPosition;
+  luaL_checkphysicsobject(L, 1)->WorldToLocal(&localPosition, luaL_checkvector(L, 2));
+  lua_pushvector(L, localPosition);
+  return 1;
+}
+
+static int IPhysicsObject_WorldToLocalVector (lua_State *L) {
+  Vector localVector;
+  luaL_checkphysicsobject(L, 1)->WorldToLocalVector(&localVector, luaL_checkvector(L, 2));
+  lua_pushvector(L, localVector);
+  return 1;
+}
+
+static int IPhysicsObject___tostring (lua_State *L) {
+  lua_pushfstring(L, "IPhysicsObject: %p", luaL_checkudata(L, 1, "IPhysicsObject"));
+  return 1;
+}
+
+
+static const luaL_Reg IPhysicsObjectmeta[] = {
+  {"AddVelocity", IPhysicsObject_AddVelocity},
+  {"ApplyForceCenter", IPhysicsObject_ApplyForceCenter},
+  {"ApplyForceOffset", IPhysicsObject_ApplyForceOffset},
+  {"ApplyTorqueCenter", IPhysicsObject_ApplyTorqueCenter},
+  {"BecomeHinged", IPhysicsObject_BecomeHinged},
+  {"BecomeTrigger", IPhysicsObject_BecomeTrigger},
+  {"CalculateAngularDrag", IPhysicsObject_CalculateAngularDrag},
+  {"CalculateForceOffset", IPhysicsObject_CalculateForceOffset},
+  {"CalculateLinearDrag", IPhysicsObject_CalculateLinearDrag},
+  {"CalculateVelocityOffset", IPhysicsObject_CalculateVelocityOffset},
+  {"EnableCollisions", IPhysicsObject_EnableCollisions},
+  {"EnableDrag", IPhysicsObject_EnableDrag},
+  {"EnableGravity", IPhysicsObject_EnableGravity},
+  {"EnableMotion", IPhysicsObject_EnableMotion},
+  {"GetCallbackFlags", IPhysicsObject_GetCallbackFlags},
+  {"GetContactPoint", IPhysicsObject_GetContactPoint},
+  {"GetContents", IPhysicsObject_GetContents},
+  {"GetDamping", IPhysicsObject_GetDamping},
+  {"GetEnergy", IPhysicsObject_GetEnergy},
+  {"GetGameFlags", IPhysicsObject_GetGameFlags},
+  {"GetGameIndex", IPhysicsObject_GetGameIndex},
+  {"GetImplicitVelocity", IPhysicsObject_GetImplicitVelocity},
+  {"GetInertia", IPhysicsObject_GetInertia},
+  {"GetInvInertia", IPhysicsObject_GetInvInertia},
+  {"GetInvMass", IPhysicsObject_GetInvMass},
+  {"GetMass", IPhysicsObject_GetMass},
+  {"GetMassCenterLocalSpace", IPhysicsObject_GetMassCenterLocalSpace},
+  {"GetMaterialIndex", IPhysicsObject_GetMaterialIndex},
+  {"GetName", IPhysicsObject_GetName},
+  {"GetPosition", IPhysicsObject_GetPosition},
+  {"GetShadowPosition", IPhysicsObject_GetShadowPosition},
+  {"GetSphereRadius", IPhysicsObject_GetSphereRadius},
+  {"GetVelocity", IPhysicsObject_GetVelocity},
+  {"GetVelocityAtPoint", IPhysicsObject_GetVelocityAtPoint},
+  {"IsAsleep", IPhysicsObject_IsAsleep},
+  {"IsAttachedToConstraint", IPhysicsObject_IsAttachedToConstraint},
+  {"IsCollisionEnabled", IPhysicsObject_IsCollisionEnabled},
+  {"IsDragEnabled", IPhysicsObject_IsDragEnabled},
+  {"IsFluid", IPhysicsObject_IsFluid},
+  {"IsGravityEnabled", IPhysicsObject_IsGravityEnabled},
+  {"IsHinged", IPhysicsObject_IsHinged},
+  {"IsMotionEnabled", IPhysicsObject_IsMotionEnabled},
+  {"IsMoveable", IPhysicsObject_IsMoveable},
+  {"IsStatic", IPhysicsObject_IsStatic},
+  {"IsTrigger", IPhysicsObject_IsTrigger},
+  {"LocalToWorld", IPhysicsObject_LocalToWorld},
+  {"LocalToWorldVector", IPhysicsObject_LocalToWorldVector},
+  {"OutputDebugInfo", IPhysicsObject_OutputDebugInfo},
+  {"RecheckCollisionFilter", IPhysicsObject_RecheckCollisionFilter},
+  {"RecheckContactPoints", IPhysicsObject_RecheckContactPoints},
+  {"RemoveHinged", IPhysicsObject_RemoveHinged},
+  {"RemoveShadowController", IPhysicsObject_RemoveShadowController},
+  {"RemoveTrigger", IPhysicsObject_RemoveTrigger},
+  {"SetBuoyancyRatio", IPhysicsObject_SetBuoyancyRatio},
+  {"SetCallbackFlags", IPhysicsObject_SetCallbackFlags},
+  {"SetContents", IPhysicsObject_SetContents},
+  {"SetDragCoefficient", IPhysicsObject_SetDragCoefficient},
+  {"SetGameFlags", IPhysicsObject_SetGameFlags},
+  {"SetGameIndex", IPhysicsObject_SetGameIndex},
+  {"SetMass", IPhysicsObject_SetMass},
+  {"SetMaterialIndex", IPhysicsObject_SetMaterialIndex},
+  {"SetShadow", IPhysicsObject_SetShadow},
+  {"SetVelocity", IPhysicsObject_SetVelocity},
+  {"SetVelocityInstantaneous", IPhysicsObject_SetVelocityInstantaneous},
+  {"Sleep", IPhysicsObject_Sleep},
+  {"Wake", IPhysicsObject_Wake},
+  {"WorldToLocal", IPhysicsObject_WorldToLocal},
+  {"WorldToLocalVector", IPhysicsObject_WorldToLocalVector},
+  {"__tostring", IPhysicsObject___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open IPhysicsObject object
+*/
+LUALIB_API int luaopen_IPhysicsObject (lua_State *L) {
+  luaL_newmetatable(L, LUA_PHYSICSOBJECTLIBNAME);
+  luaL_register(L, NULL, IPhysicsObjectmeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "physicsobject");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "physicsobject" */
+  return 1;
+}
+
+
+static int IPhysicsSurfaceProps_GetPhysicsParameters (lua_State *L) {
+  surfacephysicsparams_t pParamsOut;
+  luaL_checkphysicssurfaceprops(L, 1)->GetPhysicsParameters(luaL_checkint(L, 2), &pParamsOut);
+  lua_pushsurfacephysicsparams(L, &pParamsOut);
+  return 1;
+}
+
+static int IPhysicsSurfaceProps_GetPhysicsProperties (lua_State *L) {
+  float density, thickness, friction, elasticity;
+  luaL_checkphysicssurfaceprops(L, 1)->GetPhysicsProperties(luaL_checkint(L, 2), &density, &thickness, &friction, &elasticity);
+  lua_pushnumber(L, density);
+  lua_pushnumber(L, thickness);
+  lua_pushnumber(L, friction);
+  lua_pushnumber(L, elasticity);
+  return 4;
+}
+
+static int IPhysicsSurfaceProps_GetPropName (lua_State *L) {
+  lua_pushstring(L, luaL_checkphysicssurfaceprops(L, 1)->GetPropName(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int IPhysicsSurfaceProps_GetString (lua_State *L) {
+  lua_pushstring(L, luaL_checkphysicssurfaceprops(L, 1)->GetString((unsigned short)luaL_checkinteger(L, 2)));
+  return 1;
+}
+
+static int IPhysicsSurfaceProps_GetSurfaceData (lua_State *L) {
+  lua_pushsurfacedata(L, luaL_checkphysicssurfaceprops(L, 1)->GetSurfaceData(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int IPhysicsSurfaceProps_GetSurfaceIndex (lua_State *L) {
+  lua_pushinteger(L, luaL_checkphysicssurfaceprops(L, 1)->GetSurfaceIndex(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int IPhysicsSurfaceProps_ParseSurfaceData (lua_State *L) {
+  lua_pushinteger(L, luaL_checkphysicssurfaceprops(L, 1)->ParseSurfaceData(luaL_checkstring(L, 2), luaL_checkstring(L, 3)));
+  return 1;
+}
+
+static int IPhysicsSurfaceProps_SurfacePropCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkphysicssurfaceprops(L, 1)->SurfacePropCount());
+  return 1;
+}
+
+static int IPhysicsSurfaceProps___tostring (lua_State *L) {
+  lua_pushfstring(L, "IPhysicsSurfaceProps: %p", luaL_checkudata(L, 1, "IPhysicsSurfaceProps"));
+  return 1;
+}
+
+
+static const luaL_Reg IPhysicsSurfacePropsmeta[] = {
+  {"GetPhysicsParameters", IPhysicsSurfaceProps_GetPhysicsParameters},
+  {"GetPhysicsProperties", IPhysicsSurfaceProps_GetPhysicsProperties},
+  {"GetPropName", IPhysicsSurfaceProps_GetPropName},
+  {"GetString", IPhysicsSurfaceProps_GetString},
+  {"GetSurfaceData", IPhysicsSurfaceProps_GetSurfaceData},
+  {"GetSurfaceIndex", IPhysicsSurfaceProps_GetSurfaceIndex},
+  {"ParseSurfaceData", IPhysicsSurfaceProps_ParseSurfaceData},
+  {"SurfacePropCount", IPhysicsSurfaceProps_SurfacePropCount},
+  {"__tostring", IPhysicsSurfaceProps___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open IPhysicsSurfaceProps object
+*/
+LUALIB_API int luaopen_IPhysicsSurfaceProps (lua_State *L) {
+  luaL_newmetatable(L, LUA_PHYSICSSURFACEPROPSLIBNAME);
+  luaL_register(L, NULL, IPhysicsSurfacePropsmeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "physicssurfaceprops");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "physicssurfaceprops" */
+  lua_pushphysicssurfaceprops(L, physprops);
+  lua_setglobal(L, "physprops");  /* set global physprops */
+  return 1;
+}
+
diff --git a/src/public/lvphysics_interface.h b/src/public/lvphysics_interface.h
new file mode 100644
index 0000000..94e7521
--- /dev/null
+++ b/src/public/lvphysics_interface.h
@@ -0,0 +1,61 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Public interfaces to vphysics DLL
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LVPHYSICS_INTERFACE_H
+#define LVPHYSICS_INTERFACE_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+#pragma warning (disable : 4238)
+
+
+/* type for IPhysicsObject functions */
+typedef IPhysicsObject lua_IPhysicsObject;
+typedef surfacephysicsparams_t lua_surfacephysicsparams_t;
+typedef surfaceaudioparams_t lua_surfaceaudioparams_t;
+typedef surfacesoundnames_t lua_surfacesoundnames_t;
+typedef surfacesoundhandles_t lua_surfacesoundhandles_t;
+typedef surfacegameprops_t lua_surfacegameprops_t;
+typedef surfacedata_t lua_surfacedata_t;
+typedef IPhysicsSurfaceProps lua_IPhysicsSurfaceProps;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_IPhysicsObject             *(lua_tophysicsobject) (lua_State *L, int idx);
+LUA_API lua_surfacephysicsparams_t     (lua_tosurfacephysicsparams) (lua_State *L, int idx);
+LUA_API lua_surfaceaudioparams_t       (lua_tosurfaceaudioparams) (lua_State *L, int idx);
+LUA_API lua_surfacesoundnames_t        (lua_tosurfacesoundnames) (lua_State *L, int idx);
+LUA_API lua_surfacesoundhandles_t      (lua_tosurfacesoundhandles) (lua_State *L, int idx);
+LUA_API lua_surfacegameprops_t         (lua_tosurfacegameprops) (lua_State *L, int idx);
+LUA_API lua_surfacedata_t              (lua_tosurfacedata) (lua_State *L, int idx);
+LUA_API lua_IPhysicsSurfaceProps       *(lua_tophysicssurfaceprops) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushphysicsobject) (lua_State *L, lua_IPhysicsObject *pPhysicsObject);
+LUA_API void  (lua_pushsurfacephysicsparams) (lua_State *L, lua_surfacephysicsparams_t *pphysics);
+LUA_API void  (lua_pushsurfaceaudioparams) (lua_State *L, lua_surfaceaudioparams_t *paudio);
+LUA_API void  (lua_pushsurfacesoundnames) (lua_State *L, lua_surfacesoundnames_t *psounds);
+LUA_API void  (lua_pushsurfacesoundhandles) (lua_State *L, lua_surfacesoundhandles_t *psoundhandles);
+LUA_API void  (lua_pushsurfacegameprops) (lua_State *L, lua_surfacegameprops_t *pgame);
+LUA_API void  (lua_pushsurfacedata) (lua_State *L, lua_surfacedata_t *psurface);
+LUA_API void  (lua_pushphysicssurfaceprops) (lua_State *L, lua_IPhysicsSurfaceProps *pProps);
+
+
+
+LUALIB_API lua_IPhysicsObject *(luaL_checkphysicsobject) (lua_State *L, int narg);
+LUALIB_API lua_IPhysicsSurfaceProps *(luaL_checkphysicssurfaceprops) (lua_State *L, int narg);
+
+
+#endif // LVPHYSICS_INTERFACE_H
diff --git a/src/public/materialsystem/limaterial.cpp b/src/public/materialsystem/limaterial.cpp
new file mode 100644
index 0000000..9974c52
--- /dev/null
+++ b/src/public/materialsystem/limaterial.cpp
@@ -0,0 +1,360 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//===========================================================================//
+
+#define limaterial_cpp
+
+#include "cbase.h"
+#include "imaterial.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "limaterial.h"
+#include "mathlib/lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_IMaterial *lua_tomaterial (lua_State *L, int idx) {
+  lua_IMaterial **ppMaterial = (lua_IMaterial **)lua_touserdata(L, idx);
+  return *ppMaterial;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushmaterial (lua_State *L, lua_IMaterial *pMaterial) {
+  if (pMaterial == NULL)
+    lua_pushnil(L);
+  else {
+    lua_IMaterial **ppMaterial = (lua_IMaterial **)lua_newuserdata(L, sizeof(pMaterial));
+    *ppMaterial = pMaterial;
+    luaL_getmetatable(L, "IMaterial");
+    lua_setmetatable(L, -2);
+  }
+}
+
+
+LUALIB_API lua_IMaterial *luaL_checkmaterial (lua_State *L, int narg) {
+  lua_IMaterial **d = (lua_IMaterial **)luaL_checkudata(L, narg, "IMaterial");
+  return *d;
+}
+
+
+static int IMaterial_AddRef (lua_State *L) {
+  luaL_checkmaterial(L, 1)->AddRef();
+  return 0;
+}
+
+static int IMaterial_AlphaModulate (lua_State *L) {
+  luaL_checkmaterial(L, 1)->AlphaModulate(luaL_checknumber(L, 1));
+  return 0;
+}
+
+static int IMaterial_ColorModulate (lua_State *L) {
+  luaL_checkmaterial(L, 1)->ColorModulate(luaL_checknumber(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3));
+  return 0;
+}
+
+static int IMaterial_DecrementReferenceCount (lua_State *L) {
+  luaL_checkmaterial(L, 1)->DecrementReferenceCount();
+  return 0;
+}
+
+static int IMaterial_DeleteIfUnreferenced (lua_State *L) {
+  luaL_checkmaterial(L, 1)->DeleteIfUnreferenced();
+  return 0;
+}
+
+static int IMaterial_GetAlphaModulation (lua_State *L) {
+  lua_pushnumber(L, luaL_checkmaterial(L, 1)->GetAlphaModulation());
+  return 1;
+}
+
+static int IMaterial_GetColorModulation (lua_State *L) {
+  float r, g, b;
+  luaL_checkmaterial(L, 1)->GetColorModulation(&r, &g, &b);
+  lua_pushnumber(L, r);
+  lua_pushnumber(L, g);
+  lua_pushnumber(L, b);
+  return 3;
+}
+
+static int IMaterial_GetEnumerationID (lua_State *L) {
+  lua_pushinteger(L, luaL_checkmaterial(L, 1)->GetEnumerationID());
+  return 1;
+}
+
+static int IMaterial_GetMappingHeight (lua_State *L) {
+  lua_pushinteger(L, luaL_checkmaterial(L, 1)->GetMappingHeight());
+  return 1;
+}
+
+static int IMaterial_GetMappingWidth (lua_State *L) {
+  lua_pushinteger(L, luaL_checkmaterial(L, 1)->GetMappingWidth());
+  return 1;
+}
+
+static int IMaterial_GetMaterialPage (lua_State *L) {
+  lua_pushmaterial(L, luaL_checkmaterial(L, 1)->GetMaterialPage());
+  return 1;
+}
+
+static int IMaterial_GetMaterialVarFlag (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->GetMaterialVarFlag((MaterialVarFlags_t)luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int IMaterial_GetMorphFormat (lua_State *L) {
+  lua_pushinteger(L, luaL_checkmaterial(L, 1)->GetMorphFormat());
+  return 1;
+}
+
+static int IMaterial_GetName (lua_State *L) {
+  lua_pushstring(L, luaL_checkmaterial(L, 1)->GetName());
+  return 1;
+}
+
+static int IMaterial_GetNumAnimationFrames (lua_State *L) {
+  lua_pushinteger(L, luaL_checkmaterial(L, 1)->GetNumAnimationFrames());
+  return 1;
+}
+
+static int IMaterial_GetNumPasses (lua_State *L) {
+  lua_pushinteger(L, luaL_checkmaterial(L, 1)->GetNumPasses());
+  return 1;
+}
+
+static int IMaterial_GetPropertyFlag (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->GetPropertyFlag((MaterialPropertyTypes_t)luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int IMaterial_GetReflectivity (lua_State *L) {
+  luaL_checkmaterial(L, 1)->GetReflectivity(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int IMaterial_GetShaderName (lua_State *L) {
+  lua_pushstring(L, luaL_checkmaterial(L, 1)->GetShaderName());
+  return 1;
+}
+
+static int IMaterial_GetTextureGroupName (lua_State *L) {
+  lua_pushstring(L, luaL_checkmaterial(L, 1)->GetTextureGroupName());
+  return 1;
+}
+
+static int IMaterial_GetTextureMemoryBytes (lua_State *L) {
+  lua_pushinteger(L, luaL_checkmaterial(L, 1)->GetTextureMemoryBytes());
+  return 1;
+}
+
+static int IMaterial_HasProxy (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->HasProxy());
+  return 1;
+}
+
+static int IMaterial_IncrementReferenceCount (lua_State *L) {
+  luaL_checkmaterial(L, 1)->IncrementReferenceCount();
+  return 0;
+}
+
+static int IMaterial_InMaterialPage (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->InMaterialPage());
+  return 1;
+}
+
+static int IMaterial_IsAlphaTested (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->IsAlphaTested());
+  return 1;
+}
+
+static int IMaterial_IsErrorMaterial (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->IsErrorMaterial());
+  return 1;
+}
+
+static int IMaterial_IsSpriteCard (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->IsSpriteCard());
+  return 1;
+}
+
+static int IMaterial_IsTranslucent (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->IsTranslucent());
+  return 1;
+}
+
+static int IMaterial_IsTwoSided (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->IsTwoSided());
+  return 1;
+}
+
+static int IMaterial_IsVertexLit (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->IsVertexLit());
+  return 1;
+}
+
+static int IMaterial_NeedsFullFrameBufferTexture (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->NeedsFullFrameBufferTexture(luaL_optboolean(L, 1, 1)));
+  return 1;
+}
+
+static int IMaterial_NeedsLightmapBlendAlpha (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->NeedsLightmapBlendAlpha());
+  return 1;
+}
+
+static int IMaterial_NeedsPowerOfTwoFrameBufferTexture (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->NeedsPowerOfTwoFrameBufferTexture(luaL_optboolean(L, 1, 1)));
+  return 1;
+}
+
+static int IMaterial_NeedsSoftwareLighting (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->NeedsSoftwareLighting());
+  return 1;
+}
+
+static int IMaterial_NeedsSoftwareSkinning (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->NeedsSoftwareSkinning());
+  return 1;
+}
+
+static int IMaterial_NeedsTangentSpace (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->NeedsTangentSpace());
+  return 1;
+}
+
+static int IMaterial_RecomputeStateSnapshots (lua_State *L) {
+  luaL_checkmaterial(L, 1)->RecomputeStateSnapshots();
+  return 0;
+}
+
+static int IMaterial_Refresh (lua_State *L) {
+  luaL_checkmaterial(L, 1)->Refresh();
+  return 0;
+}
+
+static int IMaterial_RefreshPreservingMaterialVars (lua_State *L) {
+  luaL_checkmaterial(L, 1)->RefreshPreservingMaterialVars();
+  return 0;
+}
+
+static int IMaterial_Release (lua_State *L) {
+  luaL_checkmaterial(L, 1)->Release();
+  return 0;
+}
+
+static int IMaterial_SetMaterialVarFlag (lua_State *L) {
+  luaL_checkmaterial(L, 1)->SetMaterialVarFlag((MaterialVarFlags_t)luaL_checkint(L, 1), luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int IMaterial_SetShader (lua_State *L) {
+  luaL_checkmaterial(L, 1)->SetShader(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int IMaterial_SetUseFixedFunctionBakedLighting (lua_State *L) {
+  luaL_checkmaterial(L, 1)->SetUseFixedFunctionBakedLighting(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int IMaterial_ShaderParamCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkmaterial(L, 1)->ShaderParamCount());
+  return 1;
+}
+
+static int IMaterial_UsesEnvCubemap (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->UsesEnvCubemap());
+  return 1;
+}
+
+static int IMaterial_WasReloadedFromWhitelist (lua_State *L) {
+  lua_pushboolean(L, luaL_checkmaterial(L, 1)->WasReloadedFromWhitelist());
+  return 1;
+}
+
+static int IMaterial___tostring (lua_State *L) {
+  lua_pushfstring(L, "IMaterial: %s", luaL_checkmaterial(L, 1)->GetName());
+  return 1;
+}
+
+
+static const luaL_Reg IMaterialmeta[] = {
+  {"AddRef", IMaterial_AddRef},
+  {"AlphaModulate", IMaterial_AlphaModulate},
+  {"ColorModulate", IMaterial_ColorModulate},
+  {"DecrementReferenceCount", IMaterial_DecrementReferenceCount},
+  {"DeleteIfUnreferenced", IMaterial_DeleteIfUnreferenced},
+  {"GetAlphaModulation", IMaterial_GetAlphaModulation},
+  {"GetColorModulation", IMaterial_GetColorModulation},
+  {"GetEnumerationID", IMaterial_GetEnumerationID},
+  {"GetMappingHeight", IMaterial_GetMappingHeight},
+  {"GetMappingWidth", IMaterial_GetMappingWidth},
+  {"GetMaterialPage", IMaterial_GetMaterialPage},
+  {"GetMaterialVarFlag", IMaterial_GetMaterialVarFlag},
+  {"GetMorphFormat", IMaterial_GetMorphFormat},
+  {"GetName", IMaterial_GetName},
+  {"GetNumAnimationFrames", IMaterial_GetNumAnimationFrames},
+  {"GetNumPasses", IMaterial_GetNumPasses},
+  {"GetPropertyFlag", IMaterial_GetPropertyFlag},
+  {"GetReflectivity", IMaterial_GetReflectivity},
+  {"GetShaderName", IMaterial_GetShaderName},
+  {"GetTextureGroupName", IMaterial_GetTextureGroupName},
+  {"GetTextureMemoryBytes", IMaterial_GetTextureMemoryBytes},
+  {"IncrementReferenceCount", IMaterial_IncrementReferenceCount},
+  {"InMaterialPage", IMaterial_InMaterialPage},
+  {"IsAlphaTested", IMaterial_IsAlphaTested},
+  {"IsErrorMaterial", IMaterial_IsErrorMaterial},
+  {"IsSpriteCard", IMaterial_IsSpriteCard},
+  {"IsTranslucent", IMaterial_IsTranslucent},
+  {"IsTwoSided", IMaterial_IsTwoSided},
+  {"IsVertexLit", IMaterial_IsVertexLit},
+  {"NeedsFullFrameBufferTexture", IMaterial_NeedsFullFrameBufferTexture},
+  {"NeedsLightmapBlendAlpha", IMaterial_NeedsLightmapBlendAlpha},
+  {"NeedsPowerOfTwoFrameBufferTexture", IMaterial_NeedsPowerOfTwoFrameBufferTexture},
+  {"NeedsSoftwareLighting", IMaterial_NeedsSoftwareLighting},
+  {"NeedsSoftwareSkinning", IMaterial_NeedsSoftwareSkinning},
+  {"NeedsTangentSpace", IMaterial_NeedsTangentSpace},
+  {"RecomputeStateSnapshots", IMaterial_RecomputeStateSnapshots},
+  {"Refresh", IMaterial_Refresh},
+  {"RefreshPreservingMaterialVars", IMaterial_RefreshPreservingMaterialVars},
+  {"Release", IMaterial_Release},
+  {"SetMaterialVarFlag", IMaterial_SetMaterialVarFlag},
+  {"SetShader", IMaterial_SetShader},
+  {"SetUseFixedFunctionBakedLighting", IMaterial_SetUseFixedFunctionBakedLighting},
+  {"ShaderParamCount", IMaterial_ShaderParamCount},
+  {"UsesEnvCubemap", IMaterial_UsesEnvCubemap},
+  {"WasReloadedFromWhitelist", IMaterial_WasReloadedFromWhitelist},
+  {"__tostring", IMaterial___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open IMaterial object
+*/
+LUALIB_API int luaopen_IMaterial (lua_State *L) {
+  luaL_newmetatable(L, LUA_MATERIALLIBNAME);
+  luaL_register(L, NULL, IMaterialmeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "material");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "material" */
+  return 1;
+}
+
diff --git a/src/public/materialsystem/limaterial.h b/src/public/materialsystem/limaterial.h
new file mode 100644
index 0000000..a5dfd57
--- /dev/null
+++ b/src/public/materialsystem/limaterial.h
@@ -0,0 +1,38 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//===========================================================================//
+
+#ifndef LIMATERIAL_H
+#define LIMATERIAL_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for IMaterial functions */
+typedef IMaterial lua_IMaterial;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_IMaterial      *(lua_tomaterial) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushmaterial) (lua_State *L, lua_IMaterial *pMaterial);
+
+
+
+LUALIB_API lua_IMaterial *(luaL_checkmaterial) (lua_State *L, int narg);
+
+
+#endif // LIMATERIAL_H
diff --git a/src/public/mathlib/lmathlib.cpp b/src/public/mathlib/lmathlib.cpp
new file mode 100644
index 0000000..67bddf0
--- /dev/null
+++ b/src/public/mathlib/lmathlib.cpp
@@ -0,0 +1,200 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+//===========================================================================//
+
+#define lmathlib_cpp
+
+#include "cbase.h"
+#include "mathlib.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "lmathlib.h"
+#include "lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_matrix3x4_t &lua_tomatrix (lua_State *L, int idx) {
+  lua_matrix3x4_t *matrix = (lua_matrix3x4_t *)luaL_checkudata(L, idx, "matrix3x4_t");
+  return *matrix;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushmatrix (lua_State *L, lua_matrix3x4_t &matrix) {
+  lua_matrix3x4_t *pMat = (lua_matrix3x4_t *)lua_newuserdata(L, sizeof(lua_matrix3x4_t));
+  *pMat = matrix;
+  luaL_getmetatable(L, "matrix3x4_t");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_matrix3x4_t &luaL_checkmatrix (lua_State *L, int narg) {
+  lua_matrix3x4_t *d = (lua_matrix3x4_t *)luaL_checkudata(L, narg, "matrix3x4_t");
+  return *d;
+}
+
+
+static int matrix3x4_t_Base (lua_State *L) {
+  lua_pushnumber(L, *luaL_checkmatrix(L, 1).Base());
+  return 1;
+}
+
+static int matrix3x4_t_Init (lua_State *L) {
+  luaL_checkmatrix(L, 1).Init(luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkvector(L, 4), luaL_checkvector(L, 5));
+  return 0;
+}
+
+static int matrix3x4_t_Invalidate (lua_State *L) {
+  luaL_checkmatrix(L, 1).Invalidate();
+  return 0;
+}
+
+static int matrix3x4_t___index (lua_State *L) {
+  matrix3x4_t matrix = luaL_checkmatrix(L, 1);
+  const char *field = luaL_checkstring(L, 2);
+  if (strcmp(field, "0") == 0) {
+    lua_newtable(L);
+	for (int j = 0; j < 4; j++)
+	{
+		lua_pushinteger(L, j);
+		lua_pushnumber(L, matrix[0][j]);
+		lua_settable(L, -3);
+	}
+  } else if (strcmp(field, "1") == 0) {
+    lua_newtable(L);
+	for (int j = 0; j < 4; j++)
+	{
+		lua_pushinteger(L, j);
+		lua_pushnumber(L, matrix[1][j]);
+		lua_settable(L, -3);
+	}
+  } else if (strcmp(field, "2") == 0) {
+    lua_newtable(L);
+	for (int j = 0; j < 4; j++)
+	{
+		lua_pushinteger(L, j);
+		lua_pushnumber(L, matrix[2][j]);
+		lua_settable(L, -3);
+	}
+  } else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+  }
+  return 1;
+}
+
+static int matrix3x4_t___newindex (lua_State *L) {
+  // TODO
+  return 0;
+}
+
+static int matrix3x4_t___tostring (lua_State *L) {
+  matrix3x4_t matrix = luaL_checkmatrix(L, 1);
+  lua_pushfstring(L, "matrix3x4_t: %f, %f, %f, %f\n             %f, %f, %f, %f\n             %f, %f, %f, %f",
+    matrix[0][0],	matrix[0][1], matrix[0][2], matrix[0][3],
+    matrix[1][0],	matrix[1][1], matrix[1][2], matrix[1][3],
+    matrix[2][0],	matrix[2][1], matrix[2][2], matrix[2][3]
+  );
+  return 1;
+}
+
+
+static const luaL_Reg matrix3x4_tmeta[] = {
+  {"Base", matrix3x4_t_Base},
+  {"Init", matrix3x4_t_Init},
+  {"Invalidate", matrix3x4_t_Invalidate},
+  {"__index", matrix3x4_t___index},
+  {"__newindex", matrix3x4_t___newindex},
+  {"__tostring", matrix3x4_t___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_matrix3x4_t (lua_State *L) {
+  if (lua_gettop(L) < 4) {
+    matrix3x4_t matrix;
+    memset( &matrix, 0, sizeof( matrix3x4_t ) );
+    lua_pushmatrix(L, matrix);
+  } else if (lua_gettop(L) < 12) {
+    matrix3x4_t matrix = matrix3x4_t(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkvector(L, 4));
+    lua_pushmatrix(L, matrix);
+  } else {
+    matrix3x4_t matrix = matrix3x4_t(luaL_checknumber(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checknumber(L, 4), luaL_checknumber(L, 5), luaL_checknumber(L, 6), luaL_checknumber(L, 7), luaL_checknumber(L, 8), luaL_checknumber(L, 9), luaL_checknumber(L, 10), luaL_checknumber(L, 11), luaL_checknumber(L, 12));
+    lua_pushmatrix(L, matrix);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg matrix3x4_t_funcs[] = {
+  {"matrix3x4_t", luasrc_matrix3x4_t},
+  {NULL, NULL}
+};
+
+
+/*
+** Open matrix3x4_t object
+*/
+LUALIB_API int luaopen_matrix3x4_t (lua_State *L) {
+  luaL_newmetatable(L, LUA_MATRIXLIBNAME);
+  luaL_register(L, NULL, matrix3x4_tmeta);
+  lua_pushstring(L, "matrix");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "matrix" */
+  luaL_register(L, "_G", matrix3x4_t_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
+
+static int mathlib_clamp (lua_State *L) {
+  lua_pushnumber(L, clamp(luaL_checknumber(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3)));
+  return 1;
+}
+
+static int mathlib_AngleVectors (lua_State *L) {
+  if (lua_gettop(L) > 2)
+    AngleVectors(luaL_checkangle(L, 1), &luaL_checkvector(L, 2), &luaL_checkvector(L, 3), &luaL_checkvector(L, 4));
+  else
+    AngleVectors(luaL_checkangle(L, 1), &luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int mathlib_VectorAngles (lua_State *L) {
+  if (lua_gettop(L) > 2)
+    VectorAngles(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkangle(L, 3));
+  else
+    VectorAngles(luaL_checkvector(L, 1), luaL_checkangle(L, 2));
+  return 0;
+}
+
+
+static const luaL_Reg mathliblib[] = {
+  {"clamp",   mathlib_clamp},
+  {"AngleVectors",   mathlib_AngleVectors},
+  {"VectorAngles",   mathlib_VectorAngles},
+  {NULL, NULL}
+};
+
+
+/*
+** Open mathlib library
+*/
+LUALIB_API int luaopen_mathlib (lua_State *L) {
+  luaL_register(L, LUA_MATHLIBLIBNAME, mathliblib);
+  return 1;
+}
+
diff --git a/src/public/mathlib/lmathlib.h b/src/public/mathlib/lmathlib.h
new file mode 100644
index 0000000..725af66
--- /dev/null
+++ b/src/public/mathlib/lmathlib.h
@@ -0,0 +1,37 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+//===========================================================================//
+
+#ifndef LMATHLIB_H
+#define LMATHLIB_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for matrix3x4_t functions */
+typedef matrix3x4_t lua_matrix3x4_t;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_matrix3x4_t     &(lua_tomatrix) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushmatrix) (lua_State *L, lua_matrix3x4_t &v);
+
+
+
+LUALIB_API lua_matrix3x4_t &(luaL_checkmatrix) (lua_State *L, int narg);
+
+
+#endif
+
diff --git a/src/public/mathlib/lvector.cpp b/src/public/mathlib/lvector.cpp
new file mode 100644
index 0000000..6778dea
--- /dev/null
+++ b/src/public/mathlib/lvector.cpp
@@ -0,0 +1,463 @@
+//====== Copyright  1996-2005, Valve Corporation, All rights reserved. =======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+
+#define lvector_cpp
+
+#include "cbase.h"
+#include "vector.h"
+#include "fmtstr.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "lvector.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_Vector &lua_tovector (lua_State *L, int idx) {
+  lua_Vector *v = (lua_Vector *)luaL_checkudata(L, idx, "Vector");
+  return *v;
+}
+
+
+LUA_API lua_QAngle &lua_toangle (lua_State *L, int idx) {
+  lua_QAngle *v = (lua_QAngle *)luaL_checkudata(L, idx, "QAngle");
+  return *v;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushvector (lua_State *L, lua_Vector &v) {
+  lua_Vector *pVec = (lua_Vector *)lua_newuserdata(L, sizeof(lua_Vector));
+  *pVec = v;
+  luaL_getmetatable(L, "Vector");
+  lua_setmetatable(L, -2);
+}
+
+
+LUA_API void lua_pushangle (lua_State *L, lua_QAngle &v) {
+  lua_QAngle *pVec = (lua_QAngle *)lua_newuserdata(L, sizeof(lua_QAngle));
+  *pVec = v;
+  luaL_getmetatable(L, "QAngle");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_Vector &luaL_checkvector (lua_State *L, int narg) {
+  lua_Vector *d = (lua_Vector *)luaL_checkudata(L, narg, "Vector");
+  return *d;
+}
+
+
+LUALIB_API lua_QAngle &luaL_checkangle (lua_State *L, int narg) {
+  lua_QAngle *d = (lua_QAngle *)luaL_checkudata(L, narg, "QAngle");
+  return *d;
+}
+
+
+LUALIB_API lua_Vector &luaL_optvector (lua_State *L, int narg,
+                                                     Vector *def) {
+  return luaL_opt(L, luaL_checkvector, narg, *def);
+}
+
+
+LUALIB_API lua_QAngle &luaL_optangle (lua_State *L, int narg,
+                                                     QAngle *def) {
+  return luaL_opt(L, luaL_checkangle, narg, *def);
+}
+
+
+static int Vector_Cross (lua_State *L) {
+  lua_pushvector(L, luaL_checkvector(L, 1).Cross(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int Vector_DistTo (lua_State *L) {
+  lua_pushnumber(L, luaL_checkvector(L, 1).DistTo(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int Vector_DistToSqr (lua_State *L) {
+  lua_pushnumber(L, luaL_checkvector(L, 1).DistToSqr(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int Vector_Dot (lua_State *L) {
+  lua_pushnumber(L, luaL_checkvector(L, 1).Dot(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int Vector_Init (lua_State *L) {
+  luaL_checkvector(L, 1).Init(luaL_optnumber(L, 2, 0.0f), luaL_optnumber(L, 3, 0.0f), luaL_optnumber(L, 4, 0.0f));
+  return 0;
+}
+
+static int Vector_Invalidate (lua_State *L) {
+  luaL_checkvector(L, 1).Invalidate();
+  return 0;
+}
+
+static int Vector_IsLengthGreaterThan (lua_State *L) {
+  lua_pushboolean(L, luaL_checkvector(L, 1).IsLengthGreaterThan(luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int Vector_IsLengthLessThan (lua_State *L) {
+  lua_pushboolean(L, luaL_checkvector(L, 1).IsLengthLessThan(luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int Vector_IsValid (lua_State *L) {
+  lua_pushboolean(L, luaL_checkvector(L, 1).IsValid());
+  return 1;
+}
+
+static int Vector_Length (lua_State *L) {
+  lua_pushnumber(L, luaL_checkvector(L, 1).Length());
+  return 1;
+}
+
+static int Vector_Length2D (lua_State *L) {
+  lua_pushnumber(L, luaL_checkvector(L, 1).Length2D());
+  return 1;
+}
+
+static int Vector_Length2DSqr (lua_State *L) {
+  lua_pushnumber(L, luaL_checkvector(L, 1).Length2DSqr());
+  return 1;
+}
+
+static int Vector_LengthSqr (lua_State *L) {
+  lua_pushnumber(L, luaL_checkvector(L, 1).LengthSqr());
+  return 1;
+}
+
+static int Vector_Max (lua_State *L) {
+  lua_pushvector(L, luaL_checkvector(L, 1).Max(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int Vector_Min (lua_State *L) {
+  lua_pushvector(L, luaL_checkvector(L, 1).Min(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int Vector_MulAdd (lua_State *L) {
+  luaL_checkvector(L, 1).MulAdd(luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checknumber(L, 4));
+  return 0;
+}
+
+static int Vector_Negate (lua_State *L) {
+  luaL_checkvector(L, 1).Negate();
+  return 0;
+}
+
+static int Vector_NormalizeInPlace (lua_State *L) {
+  lua_pushnumber(L, luaL_checkvector(L, 1).NormalizeInPlace());
+  return 1;
+}
+
+static int Vector_Random (lua_State *L) {
+  luaL_checkvector(L, 1).Random(luaL_checknumber(L, 2), luaL_checknumber(L, 3));
+  return 0;
+}
+
+static int Vector_WithinAABox (lua_State *L) {
+  lua_pushboolean(L, luaL_checkvector(L, 1).WithinAABox(luaL_checkvector(L, 2), luaL_checkvector(L, 3)));
+  return 1;
+}
+
+static int Vector_Zero (lua_State *L) {
+  luaL_checkvector(L, 1).Zero();
+  return 0;
+}
+
+static int Vector___index (lua_State *L) {
+  Vector v = luaL_checkvector(L, 1);
+  const char *field = luaL_checkstring(L, 2);
+  if (strcmp(field, "x") == 0)
+    lua_pushnumber(L, v.x);
+  else if (strcmp(field, "y") == 0)
+    lua_pushnumber(L, v.y);
+  else if (strcmp(field, "z") == 0)
+    lua_pushnumber(L, v.z);
+  else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+  }
+  return 1;
+}
+
+static int Vector___newindex (lua_State *L) {
+  const char *field = luaL_checkstring(L, 2);
+  if (strcmp(field, "x") == 0)
+    luaL_checkvector(L, 1).x = (vec_t)luaL_checknumber(L, 3);
+  else if (strcmp(field, "y") == 0)
+    luaL_checkvector(L, 1).y = (vec_t)luaL_checknumber(L, 3);
+  else if (strcmp(field, "z") == 0)
+    luaL_checkvector(L, 1).z = (vec_t)luaL_checknumber(L, 3);
+  return 0;
+}
+
+static int Vector___tostring (lua_State *L) {
+  lua_pushfstring(L, "Vector: %s", VecToString( luaL_checkvector(L, 1) ));
+  return 1;
+}
+
+static int Vector___eq (lua_State *L) {
+  lua_pushboolean(L, luaL_checkvector(L, 1) == luaL_checkvector(L, 2));
+  return 1;
+}
+
+static int Vector___add (lua_State *L) {
+  lua_pushvector(L, luaL_checkvector(L, 1) + luaL_checkvector(L, 2));
+  return 1;
+}
+
+static int Vector___sub (lua_State *L) {
+  lua_pushvector(L, luaL_checkvector(L, 1) - luaL_checkvector(L, 2));
+  return 1;
+}
+
+static int Vector___mul (lua_State *L) {
+  switch(lua_type(L, 1)) {
+	case LUA_TNUMBER:
+      lua_pushvector(L, luaL_checknumber(L, 1) * luaL_checkvector(L, 2));
+	  break;
+	case LUA_TUSERDATA:
+	default:
+      lua_pushvector(L, luaL_checkvector(L, 1) * luaL_checknumber(L, 2));
+	  break;
+  }
+  return 1;
+}
+
+static int Vector___div (lua_State *L) {
+  lua_pushvector(L, luaL_checkvector(L, 1) / luaL_checknumber(L, 2));
+  return 1;
+}
+
+static int Vector___unm (lua_State *L) {
+  lua_pushvector(L, -luaL_checkvector(L, 1));
+  return 1;
+}
+
+
+static const luaL_Reg Vectormeta[] = {
+  {"Cross", Vector_Cross},
+  {"DistTo", Vector_DistTo},
+  {"DistToSqr", Vector_DistToSqr},
+  {"Dot", Vector_Dot},
+  {"Init", Vector_Init},
+  {"Invalidate", Vector_Invalidate},
+  {"IsLengthGreaterThan", Vector_IsLengthGreaterThan},
+  {"IsLengthLessThan", Vector_IsLengthLessThan},
+  {"IsValid", Vector_IsValid},
+  {"Length", Vector_Length},
+  {"Length2D", Vector_Length2D},
+  {"Length2DSqr", Vector_Length2DSqr},
+  {"LengthSqr", Vector_LengthSqr},
+  {"Max", Vector_Max},
+  {"Min", Vector_Min},
+  {"MulAdd", Vector_MulAdd},
+  {"Negate", Vector_Negate},
+  {"NormalizeInPlace", Vector_NormalizeInPlace},
+  {"Random", Vector_Random},
+  {"WithinAABox", Vector_WithinAABox},
+  {"Zero", Vector_Zero},
+  {"__index", Vector___index},
+  {"__newindex", Vector___newindex},
+  {"__tostring", Vector___tostring},
+  {"__eq", Vector___eq},
+  {"__add", Vector___add},
+  {"__sub", Vector___sub},
+  {"__mul", Vector___mul},
+  {"__div", Vector___div},
+  {"__unm", Vector___unm},
+  {NULL, NULL}
+};
+
+
+static int luasrc_Vector (lua_State *L) {
+  lua_pushvector(L, Vector((vec_t)luaL_optnumber(L, 1, 0.0f), (vec_t)luaL_optnumber(L, 2, 0.0f), (vec_t)luaL_optnumber(L, 3, 0.0f)));
+  return 1;
+}
+
+
+static const luaL_Reg Vector_funcs[] = {
+  {"Vector", luasrc_Vector},
+  {NULL, NULL}
+};
+
+
+/*
+** Open Vector object
+*/
+LUALIB_API int luaopen_Vector (lua_State *L) {
+  luaL_newmetatable(L, LUA_VECTORLIBNAME);
+  luaL_register(L, NULL, Vectormeta);
+  lua_pushstring(L, "vector");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "vector" */
+  luaL_register(L, "_G", Vector_funcs);
+  lua_pop(L, 1);
+  Vector origin = vec3_origin;
+  lua_pushvector(L, origin);
+  lua_setglobal(L, "vec3_origin");  /* set global vec3_origin */
+  Vector invalid = vec3_invalid;
+  lua_pushvector(L, invalid);
+  lua_setglobal(L, "vec3_invalid");  /* set global vec3_invalid */
+  return 1;
+}
+
+
+static int QAngle_Init (lua_State *L) {
+  luaL_checkangle(L, 1).Init(luaL_optnumber(L, 1, 0.0f), luaL_optnumber(L, 1, 0.0f), luaL_optnumber(L, 1, 0.0f));
+  return 0;
+}
+
+static int QAngle_Invalidate (lua_State *L) {
+  luaL_checkangle(L, 1).Invalidate();
+  return 0;
+}
+
+static int QAngle_IsValid (lua_State *L) {
+  lua_pushboolean(L, luaL_checkangle(L, 1).IsValid());
+  return 1;
+}
+
+static int QAngle_Length (lua_State *L) {
+  lua_pushnumber(L, luaL_checkangle(L, 1).Length());
+  return 1;
+}
+
+static int QAngle_LengthSqr (lua_State *L) {
+  lua_pushnumber(L, luaL_checkangle(L, 1).LengthSqr());
+  return 1;
+}
+
+static int QAngle___index (lua_State *L) {
+  QAngle v = luaL_checkangle(L, 1);
+  const char *field = luaL_checkstring(L, 2);
+  if (strcmp(field, "x") == 0)
+    lua_pushnumber(L, v.x);
+  else if (strcmp(field, "y") == 0)
+    lua_pushnumber(L, v.y);
+  else if (strcmp(field, "z") == 0)
+    lua_pushnumber(L, v.z);
+  else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+  }
+  return 1;
+}
+
+static int QAngle___newindex (lua_State *L) {
+  const char *field = luaL_checkstring(L, 2);
+  if (strcmp(field, "x") == 0)
+    luaL_checkangle(L, 1).x = (vec_t)luaL_checknumber(L, 3);
+  else if (strcmp(field, "y") == 0)
+    luaL_checkangle(L, 1).y = (vec_t)luaL_checknumber(L, 3);
+  else if (strcmp(field, "z") == 0)
+    luaL_checkangle(L, 1).z = (vec_t)luaL_checknumber(L, 3);
+  return 0;
+}
+
+static int QAngle___tostring (lua_State *L) {
+  lua_pushfstring(L, VecToString( luaL_checkangle(L, 1) ));
+  return 1;
+}
+
+static int QAngle___eq (lua_State *L) {
+  lua_pushboolean(L, luaL_checkangle(L, 1) == luaL_checkangle(L, 2));
+  return 1;
+}
+
+static int QAngle___add (lua_State *L) {
+  lua_pushangle(L, luaL_checkangle(L, 1) + luaL_checkangle(L, 2));
+  return 1;
+}
+
+static int QAngle___sub (lua_State *L) {
+  lua_pushangle(L, luaL_checkangle(L, 1) - luaL_checkangle(L, 2));
+  return 1;
+}
+
+static int QAngle___mul (lua_State *L) {
+  lua_pushangle(L, luaL_checkangle(L, 1) * luaL_checknumber(L, 2));
+  return 1;
+}
+
+static int QAngle___div (lua_State *L) {
+  lua_pushangle(L, luaL_checkangle(L, 1) / luaL_checknumber(L, 2));
+  return 1;
+}
+
+static int QAngle___unm (lua_State *L) {
+  lua_pushangle(L, -luaL_checkangle(L, 1));
+  return 1;
+}
+
+
+static const luaL_Reg QAnglemeta[] = {
+  {"Init", QAngle_Init},
+  {"Invalidate", QAngle_Invalidate},
+  {"IsValid", QAngle_IsValid},
+  {"Length", QAngle_Length},
+  {"LengthSqr", QAngle_LengthSqr},
+  {"__index", QAngle___index},
+  {"__newindex", QAngle___newindex},
+  {"__tostring", QAngle___tostring},
+  {"__eq", QAngle___eq},
+  {"__add", QAngle___add},
+  {"__sub", QAngle___sub},
+  {"__mul", QAngle___mul},
+  {"__div", QAngle___div},
+  {"__unm", QAngle___unm},
+  {NULL, NULL}
+};
+
+
+static int luasrc_QAngle (lua_State *L) {
+  lua_pushangle(L, QAngle((vec_t)luaL_optnumber(L, 1, 0.0f), (vec_t)luaL_optnumber(L, 2, 0.0f), (vec_t)luaL_optnumber(L, 3, 0.0f)));
+  return 1;
+}
+
+
+static const luaL_Reg QAngle_funcs[] = {
+  {"QAngle", luasrc_QAngle},
+  {NULL, NULL}
+};
+
+
+/*
+** Open QAngle object
+*/
+LUALIB_API int luaopen_QAngle (lua_State *L) {
+  luaL_newmetatable(L, LUA_QANGLELIBNAME);
+  luaL_register(L, NULL, QAnglemeta);
+  lua_pushstring(L, "angle");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "angle" */
+  luaL_register(L, "_G", QAngle_funcs);
+  lua_pop(L, 1);
+  QAngle v = vec3_angle;
+  lua_pushangle(L, v);
+  lua_setglobal(L, "vec3_angle");  /* set global vec3_angle */
+  return 1;
+}
+
diff --git a/src/public/mathlib/lvector.h b/src/public/mathlib/lvector.h
new file mode 100644
index 0000000..2eb1b8b
--- /dev/null
+++ b/src/public/mathlib/lvector.h
@@ -0,0 +1,50 @@
+//====== Copyright  1996-2005, Valve Corporation, All rights reserved. =======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+
+#ifndef LVECTOR_H
+#define LVECTOR_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for Vector functions */
+typedef Vector lua_Vector;
+
+
+/* type for QAngle functions */
+typedef QAngle lua_QAngle;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_Vector     &(lua_tovector) (lua_State *L, int idx);
+LUA_API lua_QAngle     &(lua_toangle) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushvector) (lua_State *L, lua_Vector &v);
+LUA_API void  (lua_pushangle) (lua_State *L, lua_QAngle &v);
+
+
+
+LUALIB_API lua_Vector &(luaL_checkvector) (lua_State *L, int narg);
+LUALIB_API lua_QAngle &(luaL_checkangle) (lua_State *L, int narg);
+LUALIB_API lua_Vector &(luaL_optvector) (lua_State *L, int narg,
+                                                       lua_Vector *def);
+LUALIB_API lua_QAngle &(luaL_optangle) (lua_State *L, int narg,
+                                                      lua_QAngle *def);
+
+
+#endif
+
diff --git a/src/public/mathlib/lvmatrix.cpp b/src/public/mathlib/lvmatrix.cpp
new file mode 100644
index 0000000..1ff68ec
--- /dev/null
+++ b/src/public/mathlib/lvmatrix.cpp
@@ -0,0 +1,645 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+//
+// VMatrix always postmultiply vectors as in Ax = b.
+// Given a set of basis vectors ((F)orward, (L)eft, (U)p), and a (T)ranslation, 
+// a matrix to transform a vector into that space looks like this:
+// Fx Lx Ux Tx
+// Fy Ly Uy Ty
+// Fz Lz Uz Tz
+// 0   0  0  1
+
+// Note that concatenating matrices needs to multiply them in reverse order.
+// ie: if I want to apply matrix A, B, then C, the equation needs to look like this:
+// C * B * A * v
+// ie:
+// v = A * v;
+// v = B * v;
+// v = C * v;
+//=============================================================================
+
+#define lvmatrix_cpp
+
+#include "cbase.h"
+#include <string.h>
+#include "mathlib/vmatrix.h"
+#include "mathlib/vector.h"
+#include "mathlib/mathlib.h"
+#include "fmtstr.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "lvmatrix.h"
+#include "lvector.h"
+#include "lmathlib.h"
+
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_VMatrix &lua_tovmatrix (lua_State *L, int idx) {
+  lua_VMatrix *matrix = (lua_VMatrix *)luaL_checkudata(L, idx, "VMatrix");
+  return *matrix;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushvmatrix (lua_State *L, lua_VMatrix &matrix) {
+  lua_VMatrix *pMat = (lua_VMatrix *)lua_newuserdata(L, sizeof(lua_VMatrix));
+  *pMat = matrix;
+  luaL_getmetatable(L, "VMatrix");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_VMatrix &luaL_checkvmatrix (lua_State *L, int narg) {
+  lua_VMatrix *d = (lua_VMatrix *)luaL_checkudata(L, narg, "VMatrix");
+  return *d;
+}
+
+
+static int VMatrix_ApplyRotation (lua_State *L) {
+  lua_pushvector(L, luaL_checkvmatrix(L, 1).ApplyRotation(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int VMatrix_As3x4 (lua_State *L) {
+  lua_pushmatrix(L, luaL_checkvmatrix(L, 1).As3x4());
+  return 1;
+}
+
+static int VMatrix_Base (lua_State *L) {
+  lua_pushnumber(L, *luaL_checkvmatrix(L, 1).Base());
+  return 1;
+}
+
+static int VMatrix_CopyFrom3x4 (lua_State *L) {
+  luaL_checkvmatrix(L, 1).CopyFrom3x4(luaL_checkmatrix(L, 2));
+  return 0;
+}
+
+static int VMatrix_GetBasisVectors (lua_State *L) {
+  luaL_checkvmatrix(L, 1).GetBasisVectors(luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkvector(L, 4));
+  return 0;
+}
+
+static int VMatrix_GetForward (lua_State *L) {
+  lua_pushvector(L, luaL_checkvmatrix(L, 1).GetForward());
+  return 1;
+}
+
+static int VMatrix_GetLeft (lua_State *L) {
+  lua_pushvector(L, luaL_checkvmatrix(L, 1).GetLeft());
+  return 1;
+}
+
+static int VMatrix_GetScale (lua_State *L) {
+  lua_pushvector(L, luaL_checkvmatrix(L, 1).GetScale());
+  return 1;
+}
+
+static int VMatrix_GetTranslation (lua_State *L) {
+  lua_pushvector(L, luaL_checkvmatrix(L, 1).GetTranslation());
+  return 1;
+}
+
+static int VMatrix_GetUp (lua_State *L) {
+  lua_pushvector(L, luaL_checkvmatrix(L, 1).GetUp());
+  return 1;
+}
+
+static int VMatrix_Identity (lua_State *L) {
+  luaL_checkvmatrix(L, 1).Identity();
+  return 0;
+}
+
+static int VMatrix_Init (lua_State *L) {
+  if (lua_gettop(L) < 17)
+    luaL_checkvmatrix(L, 1).Init(luaL_checkmatrix(L, 2));
+  else
+    luaL_checkvmatrix(L, 1).Init(luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checknumber(L, 4), luaL_checknumber(L, 5), luaL_checknumber(L, 6), luaL_checknumber(L, 7), luaL_checknumber(L, 8), luaL_checknumber(L, 9), luaL_checknumber(L, 10), luaL_checknumber(L, 11), luaL_checknumber(L, 12), luaL_checknumber(L, 13), luaL_checknumber(L, 14), luaL_checknumber(L, 15), luaL_checknumber(L, 16), luaL_checknumber(L, 17));
+  return 0;
+}
+
+static int VMatrix_InverseGeneral (lua_State *L) {
+  lua_pushboolean(L, luaL_checkvmatrix(L, 1).InverseGeneral(luaL_checkvmatrix(L, 2)));
+  return 1;
+}
+
+static int VMatrix_InverseTR (lua_State *L) {
+  lua_pushvmatrix(L, luaL_checkvmatrix(L, 1).InverseTR());
+  return 1;
+}
+
+static int VMatrix_IsIdentity (lua_State *L) {
+  lua_pushboolean(L, luaL_checkvmatrix(L, 1).IsIdentity());
+  return 1;
+}
+
+static int VMatrix_IsRotationMatrix (lua_State *L) {
+  lua_pushboolean(L, luaL_checkvmatrix(L, 1).IsRotationMatrix());
+  return 1;
+}
+
+static int VMatrix_MatrixMul (lua_State *L) {
+  luaL_checkvmatrix(L, 1).MatrixMul(luaL_checkvmatrix(L, 2), luaL_checkvmatrix(L, 3));
+  return 0;
+}
+
+static int VMatrix_NormalizeBasisVectors (lua_State *L) {
+  lua_pushvmatrix(L, luaL_checkvmatrix(L, 1).NormalizeBasisVectors());
+  return 1;
+}
+
+static int VMatrix_PostTranslate (lua_State *L) {
+  luaL_checkvmatrix(L, 1).PostTranslate(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int VMatrix_PreTranslate (lua_State *L) {
+  luaL_checkvmatrix(L, 1).PreTranslate(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int VMatrix_Scale (lua_State *L) {
+  lua_pushvmatrix(L, luaL_checkvmatrix(L, 1).Scale(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int VMatrix_Set3x4 (lua_State *L) {
+  luaL_checkvmatrix(L, 1).Set3x4(luaL_checkmatrix(L, 2));
+  return 0;
+}
+
+static int VMatrix_SetBasisVectors (lua_State *L) {
+  luaL_checkvmatrix(L, 1).SetBasisVectors(luaL_checkvector(L, 2), luaL_checkvector(L, 3), luaL_checkvector(L, 4));
+  return 0;
+}
+
+static int VMatrix_SetForward (lua_State *L) {
+  luaL_checkvmatrix(L, 1).SetForward(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int VMatrix_SetLeft (lua_State *L) {
+  luaL_checkvmatrix(L, 1).SetLeft(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int VMatrix_SetTranslation (lua_State *L) {
+  luaL_checkvmatrix(L, 1).SetTranslation(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int VMatrix_SetUp (lua_State *L) {
+  luaL_checkvmatrix(L, 1).SetUp(luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int VMatrix_SetupMatrixOrgAngles (lua_State *L) {
+  luaL_checkvmatrix(L, 1).SetupMatrixOrgAngles(luaL_checkvector(L, 2), luaL_checkangle(L, 3));
+  return 0;
+}
+
+static int VMatrix_Transpose (lua_State *L) {
+  lua_pushvmatrix(L, luaL_checkvmatrix(L, 1).Transpose());
+  return 1;
+}
+
+static int VMatrix_Transpose3x3 (lua_State *L) {
+  lua_pushvmatrix(L, luaL_checkvmatrix(L, 1).Transpose3x3());
+  return 1;
+}
+
+static int VMatrix_V3Mul (lua_State *L) {
+  luaL_checkvmatrix(L, 1).V3Mul(luaL_checkvector(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int VMatrix_VMul3x3 (lua_State *L) {
+  lua_pushvector(L, luaL_checkvmatrix(L, 1).VMul3x3(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int VMatrix_VMul3x3Transpose (lua_State *L) {
+  lua_pushvector(L, luaL_checkvmatrix(L, 1).VMul3x3Transpose(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int VMatrix_VMul4x3 (lua_State *L) {
+  lua_pushvector(L, luaL_checkvmatrix(L, 1).VMul4x3(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int VMatrix_VMul4x3Transpose (lua_State *L) {
+  lua_pushvector(L, luaL_checkvmatrix(L, 1).VMul4x3Transpose(luaL_checkvector(L, 2)));
+  return 1;
+}
+
+static int VMatrix___index (lua_State *L) {
+  VMatrix matrix = luaL_checkvmatrix(L, 1);
+  const char *field = luaL_checkstring(L, 2);
+  if (strcmp(field, "0") == 0) {
+    lua_newtable(L);
+	for (int j = 0; j < 4; j++)
+	{
+		lua_pushinteger(L, j);
+		lua_pushnumber(L, matrix[0][j]);
+		lua_settable(L, -3);
+	}
+  } else if (strcmp(field, "1") == 0) {
+    lua_newtable(L);
+	for (int j = 0; j < 4; j++)
+	{
+		lua_pushinteger(L, j);
+		lua_pushnumber(L, matrix[1][j]);
+		lua_settable(L, -3);
+	}
+  } else if (strcmp(field, "2") == 0) {
+    lua_newtable(L);
+	for (int j = 0; j < 4; j++)
+	{
+		lua_pushinteger(L, j);
+		lua_pushnumber(L, matrix[2][j]);
+		lua_settable(L, -3);
+	}
+  } else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+  }
+  return 1;
+}
+
+static int VMatrix___newindex (lua_State *L) {
+  // TODO
+  return 0;
+}
+
+static int VMatrix___tostring (lua_State *L) {
+  lua_pushfstring(L, "VMatrix: %s", VMatToString( luaL_checkvmatrix(L, 1) ));
+  return 1;
+}
+
+static int VMatrix___eq (lua_State *L) {
+  lua_pushboolean(L, luaL_checkvmatrix(L, 1) == luaL_checkvmatrix(L, 2));
+  return 1;
+}
+
+static int VMatrix___add (lua_State *L) {
+  lua_pushvmatrix(L, luaL_checkvmatrix(L, 1) + luaL_checkvmatrix(L, 2));
+  return 1;
+}
+
+static int VMatrix___sub (lua_State *L) {
+  lua_pushvmatrix(L, luaL_checkvmatrix(L, 1) - luaL_checkvmatrix(L, 2));
+  return 1;
+}
+
+static int VMatrix___mul (lua_State *L) {
+  lua_pushvmatrix(L, luaL_checkvmatrix(L, 1) * luaL_checkvmatrix(L, 2));
+  return 1;
+}
+
+static int VMatrix___unm (lua_State *L) {
+  lua_pushvmatrix(L, -luaL_checkvmatrix(L, 1));
+  return 1;
+}
+
+
+static const luaL_Reg VMatrixmeta[] = {
+  {"ApplyRotation", VMatrix_ApplyRotation},
+  {"As3x4", VMatrix_As3x4},
+  {"Base", VMatrix_Base},
+  {"CopyFrom3x4", VMatrix_CopyFrom3x4},
+  {"GetBasisVectors", VMatrix_GetBasisVectors},
+  {"GetForward", VMatrix_GetForward},
+  {"GetLeft", VMatrix_GetLeft},
+  {"GetScale", VMatrix_GetScale},
+  {"GetTranslation", VMatrix_GetTranslation},
+  {"GetUp", VMatrix_GetUp},
+  {"Identity", VMatrix_Identity},
+  {"Init", VMatrix_Init},
+  {"InverseGeneral", VMatrix_InverseGeneral},
+  {"InverseTR", VMatrix_InverseTR},
+  {"IsIdentity", VMatrix_IsIdentity},
+  {"IsRotationMatrix", VMatrix_IsRotationMatrix},
+  {"MatrixMul", VMatrix_MatrixMul},
+  {"NormalizeBasisVectors", VMatrix_NormalizeBasisVectors},
+  {"PostTranslate", VMatrix_PostTranslate},
+  {"PreTranslate", VMatrix_PreTranslate},
+  {"Scale", VMatrix_Scale},
+  {"Set3x4", VMatrix_Set3x4},
+  {"SetBasisVectors", VMatrix_SetBasisVectors},
+  {"SetForward", VMatrix_SetForward},
+  {"SetLeft", VMatrix_SetLeft},
+  {"SetTranslation", VMatrix_SetTranslation},
+  {"SetUp", VMatrix_SetUp},
+  {"SetupMatrixOrgAngles", VMatrix_SetupMatrixOrgAngles},
+  {"Transpose", VMatrix_Transpose},
+  {"Transpose3x3", VMatrix_Transpose3x3},
+  {"V3Mul", VMatrix_V3Mul},
+  {"VMul3x3", VMatrix_VMul3x3},
+  {"VMul3x3Transpose", VMatrix_VMul3x3Transpose},
+  {"VMul4x3", VMatrix_VMul4x3},
+  {"VMul4x3Transpose", VMatrix_VMul4x3Transpose},
+  {"__index", VMatrix___index},
+  {"__newindex", VMatrix___newindex},
+  {"__tostring", VMatrix___tostring},
+  {"__eq", VMatrix___eq},
+  {"__add", VMatrix___add},
+  {"__sub", VMatrix___sub},
+  {"__mul", VMatrix___mul},
+  {"__unm", VMatrix___unm},
+  {NULL, NULL}
+};
+
+
+static int luasrc_VMatrix (lua_State *L) {
+  if (lua_gettop(L) < 1) {
+    VMatrix matrix = VMatrix();
+    memset( &matrix, 0, sizeof( VMatrix ) );
+    lua_pushvmatrix(L, matrix);
+  } else if (lua_gettop(L) < 3) {
+    VMatrix matrix = VMatrix(luaL_checkmatrix(L, 1));
+    lua_pushvmatrix(L, matrix);
+  } else if (lua_gettop(L) < 16) {
+    VMatrix matrix = VMatrix(luaL_checkvector(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3));
+    lua_pushvmatrix(L, matrix);
+  } else {
+    VMatrix matrix = VMatrix(luaL_checknumber(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checknumber(L, 4), luaL_checknumber(L, 5), luaL_checknumber(L, 6), luaL_checknumber(L, 7), luaL_checknumber(L, 8), luaL_checknumber(L, 9), luaL_checknumber(L, 10), luaL_checknumber(L, 11), luaL_checknumber(L, 12), luaL_checknumber(L, 13), luaL_checknumber(L, 14), luaL_checknumber(L, 15), luaL_checknumber(L, 16));
+    lua_pushvmatrix(L, matrix);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg _G_funcs[] = {
+  {"VMatrix", luasrc_VMatrix},
+  {NULL, NULL}
+};
+
+
+static int vmatrix_SetupMatrixIdentity (lua_State *L) {
+  lua_pushvmatrix(L, SetupMatrixIdentity());
+  return 1;
+}
+
+static int vmatrix_SetupMatrixScale (lua_State *L) {
+  lua_pushvmatrix(L, SetupMatrixScale(luaL_checkvector(L, 1)));
+  return 1;
+}
+
+static int vmatrix_SetupMatrixTranslation (lua_State *L) {
+  lua_pushvmatrix(L, SetupMatrixTranslation(luaL_checkvector(L, 1)));
+  return 1;
+}
+
+static int vmatrix_SetupMatrixAxisRot (lua_State *L) {
+  lua_pushvmatrix(L, SetupMatrixAxisRot(luaL_checkvector(L, 1), luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int vmatrix_SetupMatrixAngles (lua_State *L) {
+  lua_pushvmatrix(L, SetupMatrixAngles(luaL_checkangle(L, 1)));
+  return 1;
+}
+
+static int vmatrix_SetupMatrixOrgAngles (lua_State *L) {
+  lua_pushvmatrix(L, SetupMatrixOrgAngles(luaL_checkvector(L, 1), luaL_checkangle(L, 2)));
+  return 1;
+}
+
+static int vmatrix_VMatToString (lua_State *L) {
+  lua_pushstring(L, VMatToString(luaL_checkvmatrix(L, 1)));
+  return 1;
+}
+
+static int vmatrix_MatrixSetIdentity (lua_State *L) {
+  MatrixSetIdentity(luaL_checkvmatrix(L, 1));
+  return 0;
+}
+
+static int vmatrix_MatrixTranspose (lua_State *L) {
+  MatrixTranspose(luaL_checkvmatrix(L, 1), luaL_checkvmatrix(L, 2));
+  return 0;
+}
+
+static int vmatrix_MatrixCopy (lua_State *L) {
+  MatrixCopy(luaL_checkvmatrix(L, 1), luaL_checkvmatrix(L, 2));
+  return 0;
+}
+
+static int vmatrix_MatrixMultiply (lua_State *L) {
+  MatrixMultiply(luaL_checkvmatrix(L, 1), luaL_checkvmatrix(L, 2), luaL_checkvmatrix(L, 3));
+  return 0;
+}
+
+static int vmatrix_MatrixGetColumn (lua_State *L) {
+  MatrixGetColumn(luaL_checkvmatrix(L, 1), luaL_checkint(L, 2), &luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int vmatrix_MatrixSetColumn (lua_State *L) {
+  MatrixSetColumn(luaL_checkvmatrix(L, 1), luaL_checkint(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int vmatrix_MatrixGetRow (lua_State *L) {
+  MatrixGetRow(luaL_checkvmatrix(L, 1), luaL_checkint(L, 2), &luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int vmatrix_MatrixSetRow (lua_State *L) {
+  MatrixSetRow(luaL_checkvmatrix(L, 1), luaL_checkint(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int vmatrix_Vector3DMultiply (lua_State *L) {
+  Vector3DMultiply(luaL_checkvmatrix(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int vmatrix_Vector3DMultiplyPositionProjective (lua_State *L) {
+  Vector3DMultiplyPositionProjective(luaL_checkvmatrix(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int vmatrix_Vector3DMultiplyProjective (lua_State *L) {
+  Vector3DMultiplyProjective(luaL_checkvmatrix(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int vmatrix_Vector3DMultiplyTranspose (lua_State *L) {
+  Vector3DMultiplyTranspose(luaL_checkvmatrix(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int vmatrix_MatrixBuildTranslation (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+	default:
+	  MatrixBuildTranslation(luaL_checkvmatrix(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checknumber(L, 4));
+	  break;
+	case LUA_TUSERDATA:
+      if (luaL_checkudata(L, 2, "Vector"))
+	    MatrixBuildTranslation(luaL_checkvmatrix(L, 1), luaL_checkvector(L, 2));
+	  else
+	    luaL_typerror(L, 2, "Vector");
+	  break;
+  }
+  return 0;
+}
+
+static int vmatrix_MatrixTranslate (lua_State *L) {
+  MatrixTranslate(luaL_checkvmatrix(L, 1), luaL_checkvector(L, 2));
+  return 0;
+}
+
+static int vmatrix_MatrixBuildRotationAboutAxis (lua_State *L) {
+  MatrixBuildRotationAboutAxis(luaL_checkvmatrix(L, 1), luaL_checkvector(L, 2), luaL_checknumber(L, 3));
+  return 0;
+}
+
+static int vmatrix_MatrixBuildRotateZ (lua_State *L) {
+  MatrixBuildRotateZ(luaL_checkvmatrix(L, 1), luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int vmatrix_MatrixRotate (lua_State *L) {
+  MatrixRotate(luaL_checkvmatrix(L, 1), luaL_checkvector(L, 2), luaL_checknumber(L, 3));
+  return 0;
+}
+
+static int vmatrix_MatrixBuildRotation (lua_State *L) {
+  MatrixBuildRotation(luaL_checkvmatrix(L, 1), luaL_checkvector(L, 2), luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int vmatrix_MatrixBuildScale (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+	default:
+	  MatrixBuildScale(luaL_checkvmatrix(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checknumber(L, 4));
+	  break;
+	case LUA_TUSERDATA:
+      if (luaL_checkudata(L, 2, "Vector"))
+	    MatrixBuildScale(luaL_checkvmatrix(L, 1), luaL_checkvector(L, 2));
+	  else
+	    luaL_typerror(L, 2, "Vector");
+	  break;
+  }
+  return 0;
+}
+
+static int vmatrix_MatrixBuildPerspective (lua_State *L) {
+  MatrixBuildPerspective(luaL_checkvmatrix(L, 1), luaL_checknumber(L, 2), luaL_checknumber(L, 3), luaL_checknumber(L, 4), luaL_checknumber(L, 5));
+  return 0;
+}
+
+static int vmatrix_CalculateAABBFromProjectionMatrix (lua_State *L) {
+  CalculateAABBFromProjectionMatrix(luaL_checkvmatrix(L, 1), &luaL_checkvector(L, 2), &luaL_checkvector(L, 3));
+  return 0;
+}
+
+static int vmatrix_CalculateSphereFromProjectionMatrix (lua_State *L) {
+  float flRadius = 0;
+  CalculateSphereFromProjectionMatrix(luaL_checkvmatrix(L, 1), &luaL_checkvector(L, 2), &flRadius);
+  lua_pushnumber(L, flRadius);
+  return 1;
+}
+
+static int vmatrix_MatrixFromAngles (lua_State *L) {
+  MatrixFromAngles(luaL_checkangle(L, 1), luaL_checkvmatrix(L, 2));
+  return 0;
+}
+
+static int vmatrix_MatrixToAngles (lua_State *L) {
+  MatrixToAngles(luaL_checkvmatrix(L, 1), luaL_checkangle(L, 2));
+  return 0;
+}
+
+static int vmatrix_MatrixInverseTR (lua_State *L) {
+  MatrixInverseTR(luaL_checkvmatrix(L, 1), luaL_checkvmatrix(L, 2));
+  return 0;
+}
+
+static int vmatrix_MatrixInverseGeneral (lua_State *L) {
+  MatrixInverseGeneral(luaL_checkvmatrix(L, 1), luaL_checkvmatrix(L, 2));
+  return 0;
+}
+
+static int vmatrix_MatrixInverseTranspose (lua_State *L) {
+  MatrixInverseTranspose(luaL_checkvmatrix(L, 1), luaL_checkvmatrix(L, 2));
+  return 0;
+}
+
+
+static const luaL_Reg VMatrix_funcs[] = {
+  {"SetupMatrixIdentity", vmatrix_SetupMatrixIdentity},
+  {"SetupMatrixScale", vmatrix_SetupMatrixScale},
+  {"SetupMatrixTranslation", vmatrix_SetupMatrixTranslation},
+  {"SetupMatrixAxisRot", vmatrix_SetupMatrixAxisRot},
+  {"SetupMatrixAngles", vmatrix_SetupMatrixAngles},
+  {"SetupMatrixOrgAngles", vmatrix_SetupMatrixOrgAngles},
+  {"VMatToString", vmatrix_VMatToString},
+  {"MatrixSetIdentity", vmatrix_MatrixSetIdentity},
+  {"MatrixTranspose", vmatrix_MatrixTranspose},
+  {"MatrixCopy", vmatrix_MatrixCopy},
+  {"MatrixMultiply", vmatrix_MatrixMultiply},
+  {"MatrixGetColumn", vmatrix_MatrixGetColumn},
+  {"MatrixSetColumn", vmatrix_MatrixSetColumn},
+  {"MatrixGetRow", vmatrix_MatrixGetRow},
+  {"MatrixSetRow", vmatrix_MatrixSetRow},
+  {"Vector3DMultiply", vmatrix_Vector3DMultiply},
+  {"Vector3DMultiplyPositionProjective", vmatrix_Vector3DMultiplyPositionProjective},
+  {"Vector3DMultiplyProjective", vmatrix_Vector3DMultiplyProjective},
+  {"Vector3DMultiplyTranspose", vmatrix_Vector3DMultiplyTranspose},
+  {"MatrixBuildTranslation", vmatrix_MatrixBuildTranslation},
+  {"MatrixTranslate", vmatrix_MatrixTranslate},
+  {"MatrixBuildRotationAboutAxis", vmatrix_MatrixBuildRotationAboutAxis},
+  {"MatrixBuildRotateZ", vmatrix_MatrixBuildRotateZ},
+  {"MatrixRotate", vmatrix_MatrixRotate},
+  {"MatrixBuildRotation", vmatrix_MatrixBuildRotation},
+  {"MatrixBuildScale", vmatrix_MatrixBuildScale},
+  {"MatrixBuildPerspective", vmatrix_MatrixBuildPerspective},
+  {"CalculateAABBFromProjectionMatrix", vmatrix_CalculateAABBFromProjectionMatrix},
+  {"CalculateSphereFromProjectionMatrix", vmatrix_CalculateSphereFromProjectionMatrix},
+  {"MatrixFromAngles", vmatrix_MatrixFromAngles},
+  {"MatrixToAngles", vmatrix_MatrixToAngles},
+  {"MatrixInverseTR", vmatrix_MatrixInverseTR},
+  {"MatrixInverseGeneral", vmatrix_MatrixInverseGeneral},
+  {"MatrixInverseTranspose", vmatrix_MatrixInverseTranspose},
+  {NULL, NULL}
+};
+
+
+/*
+** Open VMatrix object
+*/
+LUALIB_API int luaopen_VMatrix (lua_State *L) {
+  luaL_newmetatable(L, "VMatrix");
+  luaL_register(L, NULL, VMatrixmeta);
+  lua_pushstring(L, "vmatrix");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "vmatrix" */
+  luaL_register(L, "_G", _G_funcs);
+  lua_pop(L, 2);
+  luaL_register(L, LUA_VMATRIXLIBNAME, VMatrix_funcs);
+  return 1;
+}
+
+
diff --git a/src/public/mathlib/lvmatrix.h b/src/public/mathlib/lvmatrix.h
new file mode 100644
index 0000000..ed65fb1
--- /dev/null
+++ b/src/public/mathlib/lvmatrix.h
@@ -0,0 +1,56 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+//
+// VMatrix always postmultiply vectors as in Ax = b.
+// Given a set of basis vectors ((F)orward, (L)eft, (U)p), and a (T)ranslation, 
+// a matrix to transform a vector into that space looks like this:
+// Fx Lx Ux Tx
+// Fy Ly Uy Ty
+// Fz Lz Uz Tz
+// 0   0  0  1
+
+// Note that concatenating matrices needs to multiply them in reverse order.
+// ie: if I want to apply matrix A, B, then C, the equation needs to look like this:
+// C * B * A * v
+// ie:
+// v = A * v;
+// v = B * v;
+// v = C * v;
+//=============================================================================
+
+#ifndef LVMATRIX_H
+#define LVMATRIX_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for VMatrix functions */
+typedef VMatrix lua_VMatrix;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_VMatrix     &(lua_tovmatrix) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushvmatrix) (lua_State *L, lua_VMatrix &matrix);
+
+
+
+LUALIB_API lua_VMatrix &(luaL_checkvmatrix) (lua_State *L, int narg);
+
+#endif
+
+
diff --git a/src/public/soundemittersystem/lisoundemittersystembase.cpp b/src/public/soundemittersystem/lisoundemittersystembase.cpp
new file mode 100644
index 0000000..bedf64f
--- /dev/null
+++ b/src/public/soundemittersystem/lisoundemittersystembase.cpp
@@ -0,0 +1,100 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#define lisoundemittersystembase_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "lisoundemittersystembase.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_CSoundParameters lua_tosoundparameters (lua_State *L, int idx) {
+  luaL_checktype(L, idx, LUA_TTABLE);
+  CSoundParameters SoundParameters = CSoundParameters();
+  lua_getfield(L, idx, "channel");
+  if (!lua_isnil(L, -1))
+    SoundParameters.channel = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "volume");
+  if (!lua_isnil(L, -1))
+    SoundParameters.volume = luaL_checknumber(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "pitch");
+  if (!lua_isnil(L, -1))
+    SoundParameters.pitch = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "pitchlow");
+  if (!lua_isnil(L, -1))
+    SoundParameters.pitchlow = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "pitchhigh");
+  if (!lua_isnil(L, -1))
+    SoundParameters.pitchhigh = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "soundlevel");
+  if (!lua_isnil(L, -1))
+    SoundParameters.soundlevel = (soundlevel_t)luaL_checkinteger(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "play_to_owner_only");
+  if (!lua_isnil(L, -1))
+    SoundParameters.play_to_owner_only = luaL_checkboolean(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "count");
+  if (!lua_isnil(L, -1))
+    SoundParameters.count = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "soundname");
+  if (!lua_isnil(L, -1)) {
+	Q_strncpy(SoundParameters.soundname, luaL_checkstring(L, -1), 128);
+	SoundParameters.soundname[ 128 ] = '\0';
+  }
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "delay_msec");
+  if (!lua_isnil(L, -1))
+    SoundParameters.delay_msec = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  return SoundParameters;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushsoundparameters (lua_State *L, lua_CSoundParameters &params) {
+  lua_newtable(L);
+  lua_pushinteger(L, params.channel);
+  lua_setfield(L, -2, "channel");
+  lua_pushnumber(L, params.volume);
+  lua_setfield(L, -2, "volume");
+  lua_pushinteger(L, params.pitch);
+  lua_setfield(L, -2, "pitch");
+  lua_pushinteger(L, params.pitchlow);
+  lua_setfield(L, -2, "pitchlow");
+  lua_pushinteger(L, params.pitchhigh);
+  lua_setfield(L, -2, "pitchhigh");
+  lua_pushinteger(L, params.soundlevel);
+  lua_setfield(L, -2, "soundlevel");
+  lua_pushboolean(L, params.play_to_owner_only);
+  lua_setfield(L, -2, "play_to_owner_only");
+  lua_pushinteger(L, params.count);
+  lua_setfield(L, -2, "count");
+  lua_pushstring(L, params.soundname);
+  lua_setfield(L, -2, "soundname");
+  lua_pushinteger(L, params.delay_msec);
+  lua_setfield(L, -2, "delay_msec");
+}
diff --git a/src/public/soundemittersystem/lisoundemittersystembase.h b/src/public/soundemittersystem/lisoundemittersystembase.h
new file mode 100644
index 0000000..85dba9d
--- /dev/null
+++ b/src/public/soundemittersystem/lisoundemittersystembase.h
@@ -0,0 +1,32 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#ifndef LISOUNDEMITTERSYSTEMBASE_H
+#define LISOUNDEMITTERSYSTEMBASE_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+/* type for CSoundParameters in Lua */
+typedef CSoundParameters lua_CSoundParameters;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_CSoundParameters      (lua_tosoundparameters) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushsoundparameters) (lua_State *L, lua_CSoundParameters &params);
+
+#endif // LISOUNDEMITTERSYSTEMBASE_H
diff --git a/src/public/steam/listeamfriends.cpp b/src/public/steam/listeamfriends.cpp
new file mode 100644
index 0000000..360227e
--- /dev/null
+++ b/src/public/steam/listeamfriends.cpp
@@ -0,0 +1,115 @@
+
+//====== Copyright  1996-2004, Valve Corporation, All rights reserved. =======
+//
+// Purpose: interface to friends data in Steam
+//
+//=============================================================================
+
+#define listeamfriends_cpp
+
+#include "cbase.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "listeamfriends.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_ISteamFriends *lua_tosteamfriends (lua_State *L, int idx) {
+  lua_ISteamFriends **ppSteamFriends = (lua_ISteamFriends **)lua_touserdata(L, idx);
+  return *ppSteamFriends;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushsteamfriends (lua_State *L, ISteamFriends *pSteamFriends) {
+  if (pSteamFriends == NULL)
+    lua_pushnil(L);
+  else {
+    lua_ISteamFriends **ppSteamFriends = (lua_ISteamFriends **)lua_newuserdata(L, sizeof(pSteamFriends));
+    *ppSteamFriends = pSteamFriends;
+    luaL_getmetatable(L, "ISteamFriends");
+    lua_setmetatable(L, -2);
+  }
+}
+
+
+LUALIB_API lua_ISteamFriends *luaL_checksteamfriends (lua_State *L, int narg) {
+  lua_ISteamFriends *d = (lua_ISteamFriends *)luaL_checkudata(L, narg, "ISteamFriends");
+  return d;
+}
+
+
+static int ISteamFriends_ActivateGameOverlay (lua_State *L) {
+  luaL_checksteamfriends(L, 1)->ActivateGameOverlay(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int ISteamFriends_GetClanCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checksteamfriends(L, 1)->GetClanCount());
+  return 1;
+}
+
+static int ISteamFriends_GetFriendCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checksteamfriends(L, 1)->GetFriendCount(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int ISteamFriends_GetPersonaName (lua_State *L) {
+  lua_pushstring(L, luaL_checksteamfriends(L, 1)->GetPersonaName());
+  return 1;
+}
+
+static int ISteamFriends_GetPersonaState (lua_State *L) {
+  lua_pushinteger(L, luaL_checksteamfriends(L, 1)->GetPersonaState());
+  return 1;
+}
+
+static int ISteamFriends_SetPersonaName (lua_State *L) {
+  luaL_checksteamfriends(L, 1)->SetPersonaName(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int ISteamFriends___tostring (lua_State *L) {
+  ISteamFriends *pSteamFriends = luaL_checksteamfriends(L, 1);
+  lua_pushfstring(L, "ISteamFriends: %s", pSteamFriends->GetPersonaName());
+  return 1;
+}
+
+
+static const luaL_Reg ISteamFriendsmeta[] = {
+  {"ActivateGameOverlay", ISteamFriends_ActivateGameOverlay},
+  {"GetClanCount", ISteamFriends_GetClanCount},
+  {"GetFriendCount", ISteamFriends_GetFriendCount},
+  {"GetPersonaName", ISteamFriends_GetPersonaName},
+  {"GetPersonaState", ISteamFriends_GetPersonaState},
+  {"SetPersonaName", ISteamFriends_SetPersonaName},
+  {"__tostring", ISteamFriends___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open ISteamFriends object
+*/
+LUALIB_API int luaopen_ISteamFriends (lua_State *L) {
+  luaL_newmetatable(L, LUA_STEAMFRIENDSLIBNAME);
+  luaL_register(L, NULL, ISteamFriendsmeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "steamfriends");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "steamfriends" */
+  return 1;
+}
+
diff --git a/src/public/steam/listeamfriends.h b/src/public/steam/listeamfriends.h
new file mode 100644
index 0000000..3cb4f1d
--- /dev/null
+++ b/src/public/steam/listeamfriends.h
@@ -0,0 +1,38 @@
+
+//====== Copyright  1996-2004, Valve Corporation, All rights reserved. =======
+//
+// Purpose: interface to friends data in Steam
+//
+//=============================================================================
+
+#ifndef LISTEAMFRIENDS_H
+#define LISTEAMFRIENDS_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include "isteamfriends.h"
+
+/* type for ISteamFriends functions */
+typedef ISteamFriends lua_ISteamFriends;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_ISteamFriends     *(lua_tosteamfriends) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushsteamfriends) (lua_State *L, lua_ISteamFriends *pSteamFriends);
+
+
+
+LUALIB_API lua_ISteamFriends *(luaL_checksteamfriends) (lua_State *L, int narg);
+
+
+#endif // LISTEAMFRIENDS_H
diff --git a/src/public/steam/lsteam_api.cpp b/src/public/steam/lsteam_api.cpp
new file mode 100644
index 0000000..c0174a7
--- /dev/null
+++ b/src/public/steam/lsteam_api.cpp
@@ -0,0 +1,37 @@
+//====== Copyright  1996-2004, Valve Corporation, All rights reserved. =======
+//
+// Purpose: 
+//
+//=============================================================================
+
+#define lsteam_api_cpp
+
+#include "cbase.h"
+#include "steam_api.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "listeamfriends.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+static int steamapicontext_SteamFriends (lua_State *L) {
+  lua_pushsteamfriends(L, steamapicontext->SteamFriends());
+  return 1;
+}
+
+
+static const luaL_Reg steamapicontextlib[] = {
+  {"SteamFriends",   steamapicontext_SteamFriends},
+  {NULL, NULL}
+};
+
+
+/*
+** Open steamapicontext library
+*/
+LUALIB_API int luaopen_steamapicontext (lua_State *L) {
+  luaL_register(L, LUA_STEAMAPICONTEXTLIBNAME, steamapicontextlib);
+  return 1;
+}
+
diff --git a/src/public/tier0/ldbg.cpp b/src/public/tier0/ldbg.cpp
new file mode 100644
index 0000000..0329cbb
--- /dev/null
+++ b/src/public/tier0/ldbg.cpp
@@ -0,0 +1,168 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ========//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//
+//=============================================================================//
+#define ldbg_cpp
+
+#include "cbase.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "lColor.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+
+static int luasrc_SpewActivate (lua_State *L) {
+  SpewActivate(luaL_checkstring(L, 1), luaL_checkint(L, 2));
+  return 0;
+}
+
+static int luasrc_IsSpewActive (lua_State *L) {
+  lua_pushboolean(L, IsSpewActive(luaL_checkstring(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int luasrc_Msg (lua_State *L) {
+  Msg(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_DMsg (lua_State *L) {
+  DMsg(luaL_checkstring(L, 1), luaL_checkint(L, 2), luaL_checkstring(L, 3));
+  return 0;
+}
+
+static int luasrc_Warning (lua_State *L) {
+  Warning(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_DWarning (lua_State *L) {
+  DWarning(luaL_checkstring(L, 1), luaL_checkint(L, 2), luaL_checkstring(L, 3));
+  return 0;
+}
+
+static int luasrc_Log (lua_State *L) {
+  Log(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_DLog (lua_State *L) {
+  DLog(luaL_checkstring(L, 1), luaL_checkint(L, 2), luaL_checkstring(L, 3));
+  return 0;
+}
+
+static int luasrc_Error (lua_State *L) {
+  Error(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_DevMsg (lua_State *L) {
+  DevMsg(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_DevWarning (lua_State *L) {
+  DevWarning(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_DevLog (lua_State *L) {
+  DevLog(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_ConColorMsg (lua_State *L) {
+  ConColorMsg(luaL_checkcolor(L, 1), luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int luasrc_ConMsg (lua_State *L) {
+  ConMsg(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_ConWarning (lua_State *L) {
+  ConWarning(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_ConLog (lua_State *L) {
+  ConLog(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_ConDColorMsg (lua_State *L) {
+  ConDColorMsg(luaL_checkcolor(L, 1), luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int luasrc_ConDMsg (lua_State *L) {
+  ConDMsg(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_ConDWarning (lua_State *L) {
+  ConDWarning(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_ConDLog (lua_State *L) {
+  ConDLog(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int luasrc_NetMsg (lua_State *L) {
+  NetMsg(luaL_checkint(L, 1), luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int luasrc_NetWarning (lua_State *L) {
+  NetWarning(luaL_checkint(L, 1), luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int luasrc_NetLog (lua_State *L) {
+  NetLog(luaL_checkint(L, 1), luaL_checkstring(L, 2));
+  return 0;
+}
+
+
+static const luaL_Reg dbg_funcs[] = {
+  {"SpewActivate",  luasrc_SpewActivate},
+  {"IsSpewActive",  luasrc_IsSpewActive},
+  {"Msg",  luasrc_Msg},
+  {"DMsg",  luasrc_DMsg},
+  {"Warning",  luasrc_Warning},
+  {"DWarning",  luasrc_DWarning},
+  {"Log",  luasrc_Log},
+  {"DLog",  luasrc_DLog},
+  {"Error",  luasrc_Error},
+  {"DevMsg",  luasrc_DevMsg},
+  {"DevWarning",  luasrc_DevWarning},
+  {"DevLog",  luasrc_DevLog},
+  {"ConColorMsg",  luasrc_ConColorMsg},
+  {"ConMsg",  luasrc_ConMsg},
+  {"ConWarning",  luasrc_ConWarning},
+  {"ConLog",  luasrc_ConLog},
+  {"ConDColorMsg",  luasrc_ConDColorMsg},
+  {"ConDMsg",  luasrc_ConDMsg},
+  {"ConDWarning",  luasrc_ConDWarning},
+  {"ConDLog",  luasrc_ConDLog},
+  {"NetMsg",  luasrc_NetMsg},
+  {"NetWarning",  luasrc_NetWarning},
+  {"NetLog",  luasrc_NetLog},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_dbg (lua_State *L) {
+  luaL_register(L, LUA_DBGLIBNAME, dbg_funcs);
+  return 1;
+}
+
diff --git a/src/public/tier1/LKeyValues.cpp b/src/public/tier1/LKeyValues.cpp
new file mode 100644
index 0000000..905afad
--- /dev/null
+++ b/src/public/tier1/LKeyValues.cpp
@@ -0,0 +1,399 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#include "cbase.h"
+#include "KeyValues.h"
+#include "filesystem.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "LKeyValues.h"
+#include "lColor.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_KeyValues *lua_tokeyvalues (lua_State *L, int idx) {
+  lua_KeyValues *kv = *(lua_KeyValues **)lua_touserdata(L, idx);
+  return kv;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushkeyvalues (lua_State *L, lua_KeyValues *pKV) {
+  lua_KeyValues **ppKV = (lua_KeyValues **)lua_newuserdata(L, sizeof(lua_KeyValues *));
+  *ppKV = pKV;
+  luaL_getmetatable(L, "KeyValues");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_KeyValues *luaL_checkkeyvalues (lua_State *L, int narg) {
+  lua_KeyValues **d = (lua_KeyValues **)luaL_checkudata(L, narg, "KeyValues");
+  if (*d == 0)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "KeyValues expected, got NULL keyvalues");
+  return *d;
+}
+
+
+LUALIB_API lua_KeyValues *luaL_optkeyvalues (lua_State *L, int narg,
+                                                           KeyValues *def) {
+  return luaL_opt(L, luaL_checkkeyvalues, narg, def);
+}
+
+
+static int KeyValues_AddSubKey (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->AddSubKey(luaL_checkkeyvalues(L, 2));
+  return 0;
+}
+
+static int KeyValues_ChainKeyValue (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->ChainKeyValue(luaL_checkkeyvalues(L, 2));
+  return 0;
+}
+
+static int KeyValues_Clear (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->Clear();
+  return 0;
+}
+
+static int KeyValues_CopySubkeys (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->CopySubkeys(luaL_checkkeyvalues(L, 2));
+  return 0;
+}
+
+static int KeyValues_CreateNewKey (lua_State *L) {
+  lua_pushkeyvalues(L, luaL_checkkeyvalues(L, 1)->CreateNewKey());
+  return 1;
+}
+
+static int KeyValues_deleteThis (lua_State *L) {
+  KeyValues *pKV = luaL_checkkeyvalues(L, 1);
+  pKV->deleteThis();
+  // Andrew; this isn't standard behavior or usage, but we do this for the sake
+  // of things being safe in Lua
+  *(void **)lua_touserdata(L, 1) = (void **)NULL;
+  return 0;
+}
+
+static int KeyValues_FindKey (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+	  lua_pushkeyvalues(L, luaL_checkkeyvalues(L, 1)->FindKey(luaL_checkint(L, 2)));
+	  break;
+	case LUA_TSTRING:
+	default:
+	  lua_pushkeyvalues(L, luaL_checkkeyvalues(L, 1)->FindKey(luaL_checkstring(L, 2), luaL_optboolean(L, 3, false)));
+	  break;
+  }
+  return 1;
+}
+
+static int KeyValues_GetColor (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+	  lua_pushcolor(L, luaL_checkkeyvalues(L, 1)->GetColor(luaL_checkint(L, 2)));
+	  break;
+	case LUA_TNONE:
+	case LUA_TSTRING:
+	default:
+	  lua_pushcolor(L, luaL_checkkeyvalues(L, 1)->GetColor(luaL_optstring(L, 2, 0)));
+	  break;
+  }
+  return 1;
+}
+
+static int KeyValues_GetDataType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkkeyvalues(L, 1)->GetDataType(luaL_optstring(L, 2, 0)));
+  return 1;
+}
+
+static int KeyValues_GetFirstSubKey (lua_State *L) {
+  lua_pushkeyvalues(L, luaL_checkkeyvalues(L, 1)->GetFirstSubKey());
+  return 1;
+}
+
+static int KeyValues_GetFirstTrueSubKey (lua_State *L) {
+  lua_pushkeyvalues(L, luaL_checkkeyvalues(L, 1)->GetFirstTrueSubKey());
+  return 1;
+}
+
+static int KeyValues_GetFirstValue (lua_State *L) {
+  lua_pushkeyvalues(L, luaL_checkkeyvalues(L, 1)->GetFirstValue());
+  return 1;
+}
+
+static int KeyValues_GetFloat (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+	  lua_pushnumber(L, luaL_checkkeyvalues(L, 1)->GetFloat(luaL_checkint(L, 2), luaL_optnumber(L, 3, 0.0f)));
+	  break;
+	case LUA_TNONE:
+	case LUA_TSTRING:
+	default:
+	  lua_pushnumber(L, luaL_checkkeyvalues(L, 1)->GetFloat(luaL_optstring(L, 2, 0), luaL_optnumber(L, 3, 0.0f)));
+	  break;
+  }
+  return 1;
+}
+
+static int KeyValues_GetInt (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+	  lua_pushinteger(L, luaL_checkkeyvalues(L, 1)->GetInt(luaL_checkint(L, 2), luaL_optint(L, 3, 0)));
+	  break;
+	case LUA_TNONE:
+	case LUA_TSTRING:
+	default:
+	  lua_pushinteger(L, luaL_checkkeyvalues(L, 1)->GetInt(luaL_optstring(L, 2, 0), luaL_optint(L, 3, 0)));
+	  break;
+  }
+  return 1;
+}
+
+static int KeyValues_GetName (lua_State *L) {
+  lua_pushstring(L, luaL_checkkeyvalues(L, 1)->GetName());
+  return 1;
+}
+
+static int KeyValues_GetNameSymbol (lua_State *L) {
+  lua_pushinteger(L, luaL_checkkeyvalues(L, 1)->GetNameSymbol());
+  return 1;
+}
+
+static int KeyValues_GetNextKey (lua_State *L) {
+  lua_pushkeyvalues(L, luaL_checkkeyvalues(L, 1)->GetNextKey());
+  return 1;
+}
+
+static int KeyValues_GetNextTrueSubKey (lua_State *L) {
+  lua_pushkeyvalues(L, luaL_checkkeyvalues(L, 1)->GetNextTrueSubKey());
+  return 1;
+}
+
+static int KeyValues_GetNextValue (lua_State *L) {
+  lua_pushkeyvalues(L, luaL_checkkeyvalues(L, 1)->GetNextValue());
+  return 1;
+}
+
+static int KeyValues_GetString (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+	  lua_pushstring(L, luaL_checkkeyvalues(L, 1)->GetString(luaL_checkint(L, 2), luaL_optstring(L, 3, "")));
+	  break;
+	case LUA_TNONE:
+	case LUA_TSTRING:
+	default:
+	  lua_pushstring(L, luaL_checkkeyvalues(L, 1)->GetString(luaL_optstring(L, 2, 0), luaL_optstring(L, 3, "")));
+	  break;
+  }
+  return 1;
+}
+
+static int KeyValues_IsEmpty (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+	  lua_pushboolean(L, luaL_checkkeyvalues(L, 1)->IsEmpty(luaL_checkint(L, 2)));
+	  break;
+	case LUA_TNONE:
+	case LUA_TSTRING:
+	default:
+	  lua_pushboolean(L, luaL_checkkeyvalues(L, 1)->IsEmpty(luaL_optstring(L, 2, 0)));
+	  break;
+  }
+  return 1;
+}
+
+static int KeyValues_LoadFromFile (lua_State *L) {
+  lua_pushboolean(L, luaL_checkkeyvalues(L, 1)->LoadFromFile(filesystem, luaL_checkstring(L, 2), luaL_optstring(L, 3, 0)));
+  return 1;
+}
+
+static int KeyValues_MakeCopy (lua_State *L) {
+  lua_pushkeyvalues(L, luaL_checkkeyvalues(L, 1)->MakeCopy());
+  return 1;
+}
+
+static int KeyValues_ProcessResolutionKeys (lua_State *L) {
+  lua_pushboolean(L, luaL_checkkeyvalues(L, 1)->ProcessResolutionKeys(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int KeyValues_RemoveSubKey (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->RemoveSubKey(luaL_checkkeyvalues(L, 2));
+  return 0;
+}
+
+static int KeyValues_SaveToFile (lua_State *L) {
+  lua_pushboolean(L, luaL_checkkeyvalues(L, 1)->SaveToFile(filesystem, luaL_checkstring(L, 2), luaL_optstring(L, 3, 0)));
+  return 1;
+}
+
+static int KeyValues_SetColor (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->SetColor(luaL_checkstring(L, 2), luaL_checkcolor(L, 3));
+  return 0;
+}
+
+static int KeyValues_SetFloat (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->SetFloat(luaL_checkstring(L, 2), luaL_checknumber(L, 3));
+  return 0;
+}
+
+static int KeyValues_SetInt (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->SetInt(luaL_checkstring(L, 2), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int KeyValues_SetName (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->SetName(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int KeyValues_SetNextKey (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->SetNextKey(luaL_checkkeyvalues(L, 2));
+  return 0;
+}
+
+static int KeyValues_SetString (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->SetString(luaL_checkstring(L, 2), luaL_checkstring(L, 3));
+  return 0;
+}
+
+static int KeyValues_SetStringValue (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->SetStringValue(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int KeyValues_UsesEscapeSequences (lua_State *L) {
+  luaL_checkkeyvalues(L, 1)->UsesEscapeSequences(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int KeyValues___eq (lua_State *L) {
+  lua_pushboolean(L, lua_tokeyvalues(L, 1) == lua_tokeyvalues(L, 2));
+  return 1;
+}
+
+static int KeyValues___tostring (lua_State *L) {
+  KeyValues *pKV = lua_tokeyvalues(L, 1);
+  if (pKV == NULL)
+    lua_pushstring(L, "NULL_KEYVALUES");
+  else
+    lua_pushfstring(L, "KeyValues: %p", pKV);
+  return 1;
+}
+
+
+static const luaL_Reg KeyValuesmeta[] = {
+  {"AddSubKey", KeyValues_AddSubKey},
+  {"ChainKeyValue", KeyValues_ChainKeyValue},
+  {"Clear", KeyValues_Clear},
+  {"CopySubkeys", KeyValues_CopySubkeys},
+  {"CreateNewKey", KeyValues_CreateNewKey},
+  {"deleteThis", KeyValues_deleteThis},
+  {"FindKey", KeyValues_FindKey},
+  {"GetColor", KeyValues_GetColor},
+  {"GetDataType", KeyValues_GetDataType},
+  {"GetFirstSubKey", KeyValues_GetFirstSubKey},
+  {"GetFirstTrueSubKey", KeyValues_GetFirstTrueSubKey},
+  {"GetFirstValue", KeyValues_GetFirstValue},
+  {"GetFloat", KeyValues_GetFloat},
+  {"GetInt", KeyValues_GetInt},
+  {"GetName", KeyValues_GetName},
+  {"GetNameSymbol", KeyValues_GetNameSymbol},
+  {"GetNextKey", KeyValues_GetNextKey},
+  {"GetNextTrueSubKey", KeyValues_GetNextTrueSubKey},
+  {"GetNextValue", KeyValues_GetNextValue},
+  {"GetString", KeyValues_GetString},
+  {"IsEmpty", KeyValues_IsEmpty},
+  {"LoadFromFile", KeyValues_LoadFromFile},
+  {"MakeCopy", KeyValues_MakeCopy},
+  {"ProcessResolutionKeys", KeyValues_ProcessResolutionKeys},
+  {"RemoveSubKey", KeyValues_RemoveSubKey},
+  {"SaveToFile", KeyValues_SaveToFile},
+  {"SetColor", KeyValues_SetColor},
+  {"SetFloat", KeyValues_SetFloat},
+  {"SetInt", KeyValues_SetInt},
+  {"SetName", KeyValues_SetName},
+  {"SetNextKey", KeyValues_SetNextKey},
+  {"SetString", KeyValues_SetString},
+  {"SetStringValue", KeyValues_SetStringValue},
+  {"UsesEscapeSequences", KeyValues_UsesEscapeSequences},
+  {"__eq", KeyValues___eq},
+  {"__tostring", KeyValues___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_KeyValues (lua_State *L) {
+  KeyValues *pKV = NULL;
+  if (lua_gettop(L) <= 1)
+	pKV = new KeyValues(luaL_checkstring(L, 1));
+  else if (lua_gettop(L) <= 3) {
+    switch(lua_type(L, 3)) {
+      case LUA_TNUMBER:
+	    pKV = new KeyValues(luaL_checkstring(L, 1), luaL_checkstring(L, 2), luaL_checkint(L, 3));
+        break;
+      case LUA_TSTRING:
+	    pKV = new KeyValues(luaL_checkstring(L, 1), luaL_checkstring(L, 2), luaL_checkstring(L, 3));
+        break;
+      default:
+        luaL_typerror(L, 3, "string or number");
+        break;
+    }
+  }
+  else if (lua_gettop(L) <= 5) {
+    switch(lua_type(L, 3)) {
+      case LUA_TNUMBER:
+	    pKV = new KeyValues(luaL_checkstring(L, 1), luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkstring(L, 4), luaL_checkint(L, 5));
+        break;
+      case LUA_TSTRING:
+	    pKV = new KeyValues(luaL_checkstring(L, 1), luaL_checkstring(L, 2), luaL_checkstring(L, 3), luaL_checkstring(L, 4), luaL_checkstring(L, 5));
+        break;
+      default:
+        luaL_typerror(L, 3, "string or number");
+        break;
+    }
+  }
+  lua_pushkeyvalues(L, pKV);
+  return 1;
+}
+
+
+static const luaL_Reg KeyValues_funcs[] = {
+  {"KeyValues", luasrc_KeyValues},
+  {NULL, NULL}
+};
+
+
+/*
+** Open KeyValues object
+*/
+LUALIB_API int luaopen_KeyValues (lua_State *L) {
+  luaL_newmetatable(L, LUA_KEYVALUESLIBNAME);
+  luaL_register(L, NULL, KeyValuesmeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "keyvalues");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "keyvalues" */
+  luaL_register(L, "_G", KeyValues_funcs);
+  lua_pop(L, 1);
+  // Andrew; This is nasty, but we can't really repurpose the NULL global
+  // entity.
+  lua_pushkeyvalues(L, NULL);
+  lua_setglobal(L, "NULL_KEYVALUES");  /* set global NULL_KEYVALUES */
+  return 1;
+}
diff --git a/src/public/tier1/LKeyValues.h b/src/public/tier1/LKeyValues.h
new file mode 100644
index 0000000..22c13b7
--- /dev/null
+++ b/src/public/tier1/LKeyValues.h
@@ -0,0 +1,39 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LKEYVALUES_H
+#define LKEYVALUES_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+/* type for KeyValues functions */
+typedef KeyValues lua_KeyValues;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_KeyValues     *(lua_tokeyvalues) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushkeyvalues) (lua_State *L, lua_KeyValues *pKV);
+
+
+
+LUALIB_API lua_KeyValues *(luaL_checkkeyvalues) (lua_State *L, int narg);
+LUALIB_API lua_KeyValues *(luaL_optkeyvalues) (lua_State *L, int narg,
+                                                             lua_KeyValues *def);
+
+
+#endif // LKEYVALUES_H
diff --git a/src/public/tier1/lconvar.cpp b/src/public/tier1/lconvar.cpp
new file mode 100644
index 0000000..acacd02
--- /dev/null
+++ b/src/public/tier1/lconvar.cpp
@@ -0,0 +1,489 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $Workfile:     $
+// $Date:         $
+//
+//-----------------------------------------------------------------------------
+// $NoKeywords: $
+//===========================================================================//
+
+#define lconvar_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "lconvar.h"
+#include "lbaseplayer_shared.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_ConCommand *lua_toconcommand (lua_State *L, int idx) {
+  lua_ConCommand **ppConCommand = (lua_ConCommand **)lua_touserdata(L, idx);
+  return *ppConCommand;
+}
+
+
+LUA_API lua_ConVar *lua_toconvar (lua_State *L, int idx) {
+  lua_ConVar **ppConVar = (lua_ConVar **)lua_touserdata(L, idx);
+  return *ppConVar;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushconcommand (lua_State *L, lua_ConCommand *pConCommand) {
+  if (pConCommand == NULL)
+    lua_pushnil(L);
+  else {
+    lua_ConCommand **ppConCommand = (lua_ConCommand **)lua_newuserdata(L, sizeof(pConCommand));
+    *ppConCommand = pConCommand;
+    luaL_getmetatable(L, "ConCommand");
+    lua_setmetatable(L, -2);
+  }
+}
+
+
+LUA_API void lua_pushconvar (lua_State *L, lua_ConVar *pConVar) {
+  if (pConVar == NULL)
+    lua_pushnil(L);
+  else {
+    lua_ConVar **ppConVar = (lua_ConVar **)lua_newuserdata(L, sizeof(pConVar));
+    *ppConVar = pConVar;
+    luaL_getmetatable(L, "ConVar");
+    lua_setmetatable(L, -2);
+  }
+}
+
+
+LUALIB_API lua_ConCommand *luaL_checkconcommand (lua_State *L, int narg) {
+  lua_ConCommand **d = (lua_ConCommand **)luaL_checkudata(L, narg, "ConCommand");
+  return *d;
+}
+
+
+LUALIB_API lua_ConVar *luaL_checkconvar (lua_State *L, int narg) {
+  lua_ConVar **d = (lua_ConVar **)luaL_checkudata(L, narg, "ConVar");
+  return *d;
+}
+
+
+static int ConCommand_CanAutoComplete (lua_State *L) {
+  lua_pushboolean(L, luaL_checkconcommand(L, 1)->CanAutoComplete());
+  return 1;
+}
+
+static int ConCommand_IsCommand (lua_State *L) {
+  lua_pushboolean(L, luaL_checkconcommand(L, 1)->IsCommand());
+  return 1;
+}
+
+static int ConCommand___tostring (lua_State *L) {
+  lua_pushfstring(L, "ConCommand: \"%s\"", luaL_checkconcommand(L, 1)->GetName());
+  return 1;
+}
+
+
+static const luaL_Reg ConCommandmeta[] = {
+  {"CanAutoComplete", ConCommand_CanAutoComplete},
+  {"IsCommand", ConCommand_IsCommand},
+  {"__tostring", ConCommand___tostring},
+  {NULL, NULL}
+};
+
+
+#ifdef CLIENT_DLL
+static CUtlDict< ConCommand*, unsigned short > m_GameUIConCommandDatabase;
+#endif
+static CUtlDict< ConCommand*, unsigned short > m_ConCommandDatabase;
+
+#ifdef CLIENT_DLL
+// Andrew; ugh.
+void CC_GameUIConCommand( const CCommand& args )
+{
+	C_BasePlayer *pPlayer = C_BasePlayer::GetLocalPlayer();
+	const char *pCmd = args[0];
+
+	// Is the client spawned yet?
+	// if ( !pPlayer )
+	// 	return;
+
+	MDLCACHE_CRITICAL_SECTION();
+
+	lua_getglobal( LGameUI, "concommand" );
+	if ( lua_istable( LGameUI, -1 ) )
+	{
+		lua_getfield( LGameUI, -1, "Dispatch" );
+		if ( lua_isfunction( LGameUI, -1 ) )
+		{
+			lua_remove( LGameUI, -2 );
+			lua_pushplayer( LGameUI, pPlayer );
+			lua_pushstring( LGameUI, pCmd );
+			lua_pushstring( LGameUI, args.ArgS() );
+			luasrc_pcall( LGameUI, 3, 1, 0 );
+			if ( lua_isboolean( LGameUI, -1 ) )
+			{
+				bool res = (bool)luaL_checkboolean( LGameUI, -1 );
+				lua_pop( LGameUI, 1 );
+				if ( !res )
+				{
+				}
+			}
+			else
+			{
+				lua_pop( LGameUI, 1 );
+			}
+		}
+		else
+			lua_pop( LGameUI, 2 );
+	}
+	else
+		lua_pop( LGameUI, 1 );
+}
+#endif
+
+void CC_ConCommand( const CCommand& args )
+{
+#ifdef CLIENT_DLL
+	C_BasePlayer *pPlayer = C_BasePlayer::GetLocalPlayer();
+#else
+	CBasePlayer* pPlayer = UTIL_GetCommandClient();
+#endif
+	const char *pCmd = args[0];
+
+	// Is the client spawned yet?
+	// if ( !pPlayer )
+	// 	return;
+
+	MDLCACHE_CRITICAL_SECTION();
+
+	lua_getglobal( L, "concommand" );
+	if ( lua_istable( L, -1 ) )
+	{
+		lua_getfield( L, -1, "Dispatch" );
+		if ( lua_isfunction( L, -1 ) )
+		{
+			lua_remove( L, -2 );
+			lua_pushplayer( L, pPlayer );
+			lua_pushstring( L, pCmd );
+			lua_pushstring( L, args.ArgS() );
+			luasrc_pcall( L, 3, 1, 0 );
+			if ( lua_isboolean( L, -1 ) )
+			{
+				bool res = (bool)luaL_checkboolean( L, -1 );
+				lua_pop( L, 1 );
+				if ( !res )
+				{
+#ifndef CLIENT_DLL
+					if ( Q_strlen( pCmd ) > 128 )
+					{
+						ClientPrint( pPlayer, HUD_PRINTCONSOLE, "Console command too long.\n" );
+					}
+					else
+					{
+						// tell the user they entered an unknown command
+						ClientPrint( pPlayer, HUD_PRINTCONSOLE, UTIL_VarArgs( "Unknown command: %s\n", pCmd ) );
+					}
+#endif
+				}
+			}
+			else
+			{
+				lua_pop( L, 1 );
+			}
+		}
+		else
+			lua_pop( L, 2 );
+	}
+	else
+		lua_pop( L, 1 );
+}
+
+static int luasrc_ConCommand (lua_State *L) {
+  const char *pName = luaL_checkstring(L, 1);
+#ifdef CLIENT_DLL
+  bool bIsGameUI = false;
+  unsigned short lookup;
+  lua_getglobal(L, "_GAMEUI");
+  if (!lua_isnoneornil(L, -1) && lua_toboolean(L, -1)) {
+    bIsGameUI = true;
+
+    // Complain about duplicately defined ConCommand names...
+    lookup = m_GameUIConCommandDatabase.Find( pName );
+    if ( lookup != m_GameUIConCommandDatabase.InvalidIndex() || cvar->FindCommand(pName) )
+    {
+      lua_pushconcommand(L, cvar->FindCommand(pName));
+      return 1;
+    }
+  } else {
+#endif
+    // Complain about duplicately defined ConCommand names...
+    unsigned short lookup = m_ConCommandDatabase.Find( pName );
+    if ( lookup != m_ConCommandDatabase.InvalidIndex() || cvar->FindCommand(pName) )
+    {
+      lua_pushconcommand(L, cvar->FindCommand(pName));
+      return 1;
+    }
+#ifdef CLIENT_DLL
+  }
+#endif
+  lua_pop(L, 1);
+
+  ConCommand *pConCommand;
+#ifdef CLIENT_DLL
+  if (bIsGameUI)
+#if 0
+    pConCommand = new ConCommand(strdup(pName), CC_GameUIConCommand, strdup(luaL_optstring(L, 2, 0)), luaL_optint(L, 3, 0), NULL);
+#else
+    pConCommand = new ConCommand(strdup(pName), CC_GameUIConCommand, strdup(luaL_optstring(L, 2, 0)), 0, NULL);
+#endif
+  else
+    pConCommand = new ConCommand(strdup(pName), CC_ConCommand, strdup(luaL_optstring(L, 2, 0)), FCVAR_CLIENTDLL | FCVAR_CLIENTCMD_CAN_EXECUTE | FCVAR_SERVER_CAN_EXECUTE, NULL);
+#else
+#if 0
+    pConCommand = new ConCommand(strdup(pName), CC_ConCommand, strdup(luaL_optstring(L, 2, 0)), luaL_optint(L, 3, 0), NULL);
+#else
+    pConCommand = new ConCommand(strdup(pName), CC_ConCommand, strdup(luaL_optstring(L, 2, 0)), FCVAR_GAMEDLL | FCVAR_CLIENTCMD_CAN_EXECUTE, NULL);
+#endif
+#endif
+
+#ifdef CLIENT_DLL
+  if (bIsGameUI) {
+    lookup = m_GameUIConCommandDatabase.Insert( pName, pConCommand );
+    Assert( lookup != m_GameUIConCommandDatabase.InvalidIndex() );
+  } else {
+#endif
+    lookup = m_ConCommandDatabase.Insert( pName, pConCommand );
+    Assert( lookup != m_ConCommandDatabase.InvalidIndex() );
+#ifdef CLIENT_DLL
+  }
+#endif
+  lua_pushconcommand(L, pConCommand);
+  return 1;
+}
+
+#ifdef CLIENT_DLL
+void ResetGameUIConCommandDatabase( void )
+{
+	for ( int i=m_GameUIConCommandDatabase.First(); i != m_GameUIConCommandDatabase.InvalidIndex(); i=m_GameUIConCommandDatabase.Next( i ) )
+	{
+		ConCommand *pConCommand = m_GameUIConCommandDatabase[ i ];
+		cvar->UnregisterConCommand(pConCommand);
+		delete pConCommand;
+	}
+	m_GameUIConCommandDatabase.RemoveAll();
+}
+#endif
+
+void ResetConCommandDatabase( void )
+{
+	for ( int i=m_ConCommandDatabase.First(); i != m_ConCommandDatabase.InvalidIndex(); i=m_ConCommandDatabase.Next( i ) )
+	{
+		ConCommand *pConCommand = m_ConCommandDatabase[ i ];
+		cvar->UnregisterConCommand(pConCommand);
+		delete pConCommand;
+	}
+	m_ConCommandDatabase.RemoveAll();
+}
+
+
+static const luaL_Reg ConCommand_funcs[] = {
+  {"ConCommand", luasrc_ConCommand},
+  {NULL, NULL}
+};
+
+
+/*
+** Open ConCommand object
+*/
+LUALIB_API int luaopen_ConCommand (lua_State *L) {
+  luaL_newmetatable(L, LUA_CONCOMMANDLIBNAME);
+  luaL_register(L, NULL, ConCommandmeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "concommand");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "concommand" */
+  luaL_register(L, "_G", ConCommand_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
+
+static int ConVar_AddFlags (lua_State *L) {
+  luaL_checkconvar(L, 1)->AddFlags(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int ConVar_GetBool (lua_State *L) {
+  lua_pushboolean(L, luaL_checkconvar(L, 1)->GetBool());
+  return 1;
+}
+
+static int ConVar_GetDefault (lua_State *L) {
+  lua_pushstring(L, luaL_checkconvar(L, 1)->GetDefault());
+  return 1;
+}
+
+static int ConVar_GetFloat (lua_State *L) {
+  lua_pushnumber(L, luaL_checkconvar(L, 1)->GetFloat());
+  return 1;
+}
+
+static int ConVar_GetHelpText (lua_State *L) {
+  lua_pushstring(L, luaL_checkconvar(L, 1)->GetHelpText());
+  return 1;
+}
+
+static int ConVar_GetInt (lua_State *L) {
+  lua_pushinteger(L, luaL_checkconvar(L, 1)->GetInt());
+  return 1;
+}
+
+static int ConVar_GetMax (lua_State *L) {
+  float maxVal;
+  lua_pushboolean(L, luaL_checkconvar(L, 1)->GetMax(maxVal));
+  lua_pushnumber(L, maxVal);
+  return 2;
+}
+
+static int ConVar_GetMin (lua_State *L) {
+  float minVal;
+  lua_pushboolean(L, luaL_checkconvar(L, 1)->GetMin(minVal));
+  lua_pushnumber(L, minVal);
+  return 2;
+}
+
+static int ConVar_GetName (lua_State *L) {
+  lua_pushstring(L, luaL_checkconvar(L, 1)->GetName());
+  return 1;
+}
+
+static int ConVar_GetString (lua_State *L) {
+  lua_pushstring(L, luaL_checkconvar(L, 1)->GetString());
+  return 1;
+}
+
+static int ConVar_IsCommand (lua_State *L) {
+  lua_pushboolean(L, luaL_checkconvar(L, 1)->IsCommand());
+  return 1;
+}
+
+static int ConVar_IsFlagSet (lua_State *L) {
+  lua_pushboolean(L, luaL_checkconvar(L, 1)->IsFlagSet(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int ConVar_IsRegistered (lua_State *L) {
+  lua_pushboolean(L, luaL_checkconvar(L, 1)->IsRegistered());
+  return 1;
+}
+
+static int ConVar_Revert (lua_State *L) {
+  luaL_checkconvar(L, 1)->Revert();
+  return 0;
+}
+
+static int ConVar_SetValue (lua_State *L) {
+  switch(lua_type(L, 2)) {
+	case LUA_TNUMBER:
+	  luaL_checkconvar(L, 1)->SetValue((float)luaL_checknumber(L, 2));
+	  break;
+	case LUA_TSTRING:
+	default:
+	  luaL_checkconvar(L, 1)->SetValue(luaL_checkstring(L, 2));
+	  break;
+  }
+  return 0;
+}
+
+static int ConVar___tostring (lua_State *L) {
+  lua_pushfstring(L, "ConVar: \"%s\" = \"%s\"", luaL_checkconvar(L, 1)->GetName(), luaL_checkconvar(L, 1)->GetString());
+  return 1;
+}
+
+
+static const luaL_Reg ConVarmeta[] = {
+  {"AddFlags", ConVar_AddFlags},
+  {"GetBool", ConVar_GetBool},
+  {"GetDefault", ConVar_GetDefault},
+  {"GetFloat", ConVar_GetFloat},
+  {"GetHelpText", ConVar_GetHelpText},
+  {"GetInt", ConVar_GetInt},
+  {"GetMax", ConVar_GetMax},
+  {"GetMin", ConVar_GetMin},
+  {"GetName", ConVar_GetName},
+  {"GetString", ConVar_GetString},
+  {"IsCommand", ConVar_IsCommand},
+  {"IsFlagSet", ConVar_IsFlagSet},
+  {"IsRegistered", ConVar_IsRegistered},
+  {"Revert", ConVar_Revert},
+  {"SetValue", ConVar_SetValue},
+  {"__tostring", ConVar___tostring},
+  {NULL, NULL}
+};
+
+
+static CUtlDict< ConVar*, unsigned short > m_ConVarDatabase;
+
+static int luasrc_ConVar (lua_State *L) {
+  const char *pName = luaL_checkstring(L, 1);
+  // Complain about duplicately defined ConVar names...
+  unsigned short lookup = m_ConVarDatabase.Find( pName );
+  if ( lookup != m_ConVarDatabase.InvalidIndex() || cvar->FindVar(pName) )
+  {
+    lua_pushconvar(L, cvar->FindVar(pName));
+    return 1;
+  }
+
+  ConVar *pConVar = new ConVar(strdup(pName), luaL_checkstring(L, 2), luaL_optint(L, 3, 0), strdup(luaL_optstring(L, 4, 0)), luaL_optboolean(L, 5, 0), luaL_optnumber(L, 6, 0.0), luaL_optboolean(L, 7, 0), luaL_optnumber(L, 8, 0));
+
+  lookup = m_ConVarDatabase.Insert( pName, pConVar );
+  Assert( lookup != m_ConVarDatabase.InvalidIndex() );
+  lua_pushconvar(L, pConVar);
+  return 1;
+}
+
+void ResetConVarDatabase( void )
+{
+	for ( int i=m_ConVarDatabase.First(); i != m_ConVarDatabase.InvalidIndex(); i=m_ConVarDatabase.Next( i ) )
+	{
+		ConVar *pConVar = m_ConVarDatabase[ i ];
+		cvar->UnregisterConCommand(pConVar);
+		delete pConVar;
+	}
+	m_ConVarDatabase.RemoveAll();
+}
+
+
+static const luaL_Reg ConVar_funcs[] = {
+  {"ConVar", luasrc_ConVar},
+  {NULL, NULL}
+};
+
+
+/*
+** Open ConVar object
+*/
+LUALIB_API int luaopen_ConVar (lua_State *L) {
+  luaL_newmetatable(L, LUA_CONVARLIBNAME);
+  luaL_register(L, NULL, ConVarmeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "convar");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "convar" */
+  luaL_register(L, "_G", ConVar_funcs);
+  lua_pop(L, 1);
+  return 1;
+}
+
diff --git a/src/public/tier1/lconvar.h b/src/public/tier1/lconvar.h
new file mode 100644
index 0000000..ceeb366
--- /dev/null
+++ b/src/public/tier1/lconvar.h
@@ -0,0 +1,54 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $Workfile:     $
+// $Date:         $
+//
+//-----------------------------------------------------------------------------
+// $NoKeywords: $
+//===========================================================================//
+
+#ifndef LCONVAR_H
+#define LCONVAR_H
+
+#if _WIN32
+#pragma once
+#endif
+
+/* type for ConCommand functions */
+typedef ConCommand lua_ConCommand;
+
+
+/* type for ConVar functions */
+typedef ConVar lua_ConVar;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_ConCommand     *(lua_toconcommand) (lua_State *L, int idx);
+LUA_API lua_ConVar     *(lua_toconvar) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushconcommand) (lua_State *L, lua_ConCommand *pConCommand);
+LUA_API void  (lua_pushconvar) (lua_State *L, lua_ConVar *pConVar);
+
+
+
+LUALIB_API lua_ConCommand *(luaL_checkconcommand) (lua_State *L, int narg);
+LUALIB_API lua_ConVar *(luaL_checkconvar) (lua_State *L, int narg);
+
+
+#ifdef CLIENT_DLL
+void ResetGameUIConCommandDatabase( void );
+#endif
+void ResetConCommandDatabase( void );
+void ResetConVarDatabase( void );
+
+#endif // LCONVAR_H
diff --git a/src/public/tier1/liconvar.cpp b/src/public/tier1/liconvar.cpp
new file mode 100644
index 0000000..80dbef5
--- /dev/null
+++ b/src/public/tier1/liconvar.cpp
@@ -0,0 +1,55 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $Workfile:     $
+// $Date:         $
+//
+//-----------------------------------------------------------------------------
+// $NoKeywords: $
+//===========================================================================//
+
+#define liconvar_cpp
+
+#include "cbase.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+
+
+/*
+** Open FCVAR library
+*/
+LUALIB_API int luaopen_FCVAR (lua_State *L) {
+  BEGIN_LUA_SET_ENUM_LIB(L, LUA_FCVARLIBNAME);
+    lua_pushenum(L, FCVAR_NONE, "NONE");
+
+    lua_pushenum(L, FCVAR_UNREGISTERED, "UNREGISTERED");
+    lua_pushenum(L, FCVAR_DEVELOPMENTONLY, "DEVELOPMENTONLY");
+    lua_pushenum(L, FCVAR_GAMEDLL, "GAMEDLL");
+    lua_pushenum(L, FCVAR_CLIENTDLL, "CLIENTDLL");
+    lua_pushenum(L, FCVAR_HIDDEN, "HIDDEN");
+
+    lua_pushenum(L, FCVAR_PROTECTED, "PROTECTED");
+    lua_pushenum(L, FCVAR_SPONLY, "SPONLY");
+    lua_pushenum(L, FCVAR_ARCHIVE, "ARCHIVE");
+    lua_pushenum(L, FCVAR_NOTIFY, "NOTIFY");
+    lua_pushenum(L, FCVAR_USERINFO, "USERINFO");
+    lua_pushenum(L, FCVAR_CHEAT, "CHEAT");
+
+    lua_pushenum(L, FCVAR_PRINTABLEONLY, "PRINTABLEONLY");
+    lua_pushenum(L, FCVAR_UNLOGGED, "UNLOGGED");
+    lua_pushenum(L, FCVAR_NEVER_AS_STRING, "NEVER_AS_STRING");
+
+	lua_pushenum(L, FCVAR_REPLICATED, "REPLICATED");
+	lua_pushenum(L, FCVAR_DEMO, "DEMO");
+	lua_pushenum(L, FCVAR_DONTRECORD, "DONTRECORD");
+
+	lua_pushenum(L, FCVAR_NOT_CONNECTED, "NOT_CONNECTED");
+
+	lua_pushenum(L, FCVAR_ARCHIVE_XBOX, "ARCHIVE_XBOX");
+	lua_pushenum(L, FCVAR_SERVER_CAN_EXECUTE, "SERVER_CAN_EXECUTE");
+	lua_pushenum(L, FCVAR_SERVER_CANNOT_QUERY, "SERVER_CANNOT_QUERY");
+	lua_pushenum(L, FCVAR_CLIENTCMD_CAN_EXECUTE, "CLIENTCMD_CAN_EXECUTE");
+  END_LUA_SET_ENUM_LIB(L);
+  return 0;
+}
diff --git a/src/public/trace.h b/src/public/trace.h
index 3e2646d..53d5e66 100644
--- a/src/public/trace.h
+++ b/src/public/trace.h
@@ -61,9 +61,13 @@ public:
 
 	CBaseTrace() {}
 
+#if !defined ( LUA_SDK )
+	// HACKHACK: We only do this for Lua, but Lua classes which use traces will
+	// throw errors when we compile, so define this outside of the Lua SDK.
 private:
 	// No copy constructors allowed
 	CBaseTrace(const CBaseTrace& vOther);
+#endif
 };
 
 #endif // TRACE_H
\ No newline at end of file
diff --git a/src/public/vgui/LIInput.cpp b/src/public/vgui/LIInput.cpp
new file mode 100644
index 0000000..bd1bffe
--- /dev/null
+++ b/src/public/vgui/LIInput.cpp
@@ -0,0 +1,342 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#define LIInput_cpp
+
+#include <cbase.h>
+#include "vgui/iinput.h"
+#include "vgui_controls/Controls.h"
+#include <luamanager.h>
+#include "luasrclib.h"
+#include "vgui_controls/lPanel.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+using namespace vgui;
+
+
+static int input_CandidateListStartsAtOne (lua_State *L) {
+  lua_pushboolean(L, input()->CandidateListStartsAtOne());
+  return 1;
+}
+
+static int input_GetAppModalSurface (lua_State *L) {
+  lua_pushpanel(L, input()->GetAppModalSurface());
+  return 1;
+}
+
+static int input_GetCandidateListCount (lua_State *L) {
+  lua_pushinteger(L, input()->GetCandidateListCount());
+  return 1;
+}
+
+static int input_GetCandidateListPageSize (lua_State *L) {
+  lua_pushinteger(L, input()->GetCandidateListPageSize());
+  return 1;
+}
+
+static int input_GetCandidateListPageStart (lua_State *L) {
+  lua_pushinteger(L, input()->GetCandidateListPageStart());
+  return 1;
+}
+
+static int input_GetCandidateListSelectedItem (lua_State *L) {
+  lua_pushinteger(L, input()->GetCandidateListSelectedItem());
+  return 1;
+}
+
+static int input_GetCurrentIMEHandle (lua_State *L) {
+  lua_pushinteger(L, input()->GetCurrentIMEHandle());
+  return 1;
+}
+
+static int input_GetCursorPos__USE_VCR_MODE (lua_State *L) {
+  int x, y;
+  input()->GetCursorPos__USE_VCR_MODE(x, y);
+  lua_pushinteger(L, x);
+  lua_pushinteger(L, y);
+  return 2;
+}
+
+static int input_GetCursorPosition (lua_State *L) {
+  int x, y;
+  input()->GetCursorPosition(x, y);
+  lua_pushinteger(L, x);
+  lua_pushinteger(L, y);
+  return 2;
+}
+
+static int input_GetEnglishIMEHandle (lua_State *L) {
+  lua_pushinteger(L, input()->GetEnglishIMEHandle());
+  return 1;
+}
+
+static int input_GetFocus (lua_State *L) {
+  lua_pushpanel(L, input()->GetFocus());
+  return 1;
+}
+
+static int input_GetModalSubTree (lua_State *L) {
+  lua_pushpanel(L, input()->GetModalSubTree());
+  return 1;
+}
+
+static int input_GetMouseCapture (lua_State *L) {
+  lua_pushpanel(L, input()->GetMouseCapture());
+  return 1;
+}
+
+static int input_GetMouseOver (lua_State *L) {
+  lua_pushpanel(L, input()->GetMouseOver());
+  return 1;
+}
+
+static int input_GetShouldInvertCompositionString (lua_State *L) {
+  lua_pushboolean(L, input()->GetShouldInvertCompositionString());
+  return 1;
+}
+
+static int input_IsKeyDown (lua_State *L) {
+  lua_pushboolean(L, input()->IsKeyDown((KeyCode)luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int input_IsMouseDown (lua_State *L) {
+  lua_pushboolean(L, input()->IsMouseDown((KeyCode)luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int input_OnChangeIME (lua_State *L) {
+  input()->OnChangeIME(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int input_OnChangeIMEByHandle (lua_State *L) {
+  input()->OnChangeIMEByHandle(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int input_OnChangeIMEConversionModeByHandle (lua_State *L) {
+  input()->OnChangeIMEConversionModeByHandle(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int input_OnChangeIMESentenceModeByHandle (lua_State *L) {
+  input()->OnChangeIMESentenceModeByHandle(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int input_OnIMEChangeCandidates (lua_State *L) {
+  input()->OnIMEChangeCandidates();
+  return 0;
+}
+
+static int input_OnIMECloseCandidates (lua_State *L) {
+  input()->OnIMECloseCandidates();
+  return 0;
+}
+
+static int input_OnIMEComposition (lua_State *L) {
+  input()->OnIMEComposition(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int input_OnIMEEndComposition (lua_State *L) {
+  input()->OnIMEEndComposition();
+  return 0;
+}
+
+static int input_OnIMERecomputeModes (lua_State *L) {
+  input()->OnIMERecomputeModes();
+  return 0;
+}
+
+static int input_OnIMEShowCandidates (lua_State *L) {
+  input()->OnIMEShowCandidates();
+  return 0;
+}
+
+static int input_OnIMEStartComposition (lua_State *L) {
+  input()->OnIMEStartComposition();
+  return 0;
+}
+
+static int input_OnInputLanguageChanged (lua_State *L) {
+  input()->OnInputLanguageChanged();
+  return 0;
+}
+
+static int input_OnKeyCodeUnhandled (lua_State *L) {
+  input()->OnKeyCodeUnhandled(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int input_RegisterKeyCodeUnhandledListener (lua_State *L) {
+  input()->RegisterKeyCodeUnhandledListener(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int input_ReleaseAppModalSurface (lua_State *L) {
+  input()->ReleaseAppModalSurface();
+  return 0;
+}
+
+static int input_ReleaseModalSubTree (lua_State *L) {
+  input()->ReleaseModalSubTree();
+  return 0;
+}
+
+static int input_SetAppModalSurface (lua_State *L) {
+  input()->SetAppModalSurface(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int input_SetCandidateListPageStart (lua_State *L) {
+  input()->SetCandidateListPageStart(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int input_SetCandidateWindowPos (lua_State *L) {
+  input()->SetCandidateWindowPos(luaL_checkint(L, 1), luaL_checkint(L, 2));
+  return 0;
+}
+
+static int input_SetCursorPos (lua_State *L) {
+  input()->SetCursorPos(luaL_checkint(L, 1), luaL_checkint(L, 2));
+  return 0;
+}
+
+static int input_SetModalSubTree (lua_State *L) {
+  input()->SetModalSubTree(luaL_checkvpanel(L, 1), luaL_checkvpanel(L, 2), luaL_optboolean(L, 3, true));
+  return 0;
+}
+
+static int input_SetModalSubTreeReceiveMessages (lua_State *L) {
+  input()->SetModalSubTreeReceiveMessages(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int input_SetMouseCapture (lua_State *L) {
+  input()->SetMouseCapture(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int input_SetMouseCaptureEx (lua_State *L) {
+  input()->SetMouseCaptureEx(luaL_checkvpanel(L, 1), (MouseCode)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int input_SetMouseFocus (lua_State *L) {
+  input()->SetMouseFocus(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int input_ShouldModalSubTreeReceiveMessages (lua_State *L) {
+  lua_pushboolean(L, input()->ShouldModalSubTreeReceiveMessages());
+  return 1;
+}
+
+static int input_UnregisterKeyCodeUnhandledListener (lua_State *L) {
+  input()->UnregisterKeyCodeUnhandledListener(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int input_WasKeyPressed (lua_State *L) {
+  lua_pushboolean(L, input()->WasKeyPressed((KeyCode)luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int input_WasKeyReleased (lua_State *L) {
+  lua_pushboolean(L, input()->WasKeyReleased((KeyCode)luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int input_WasKeyTyped (lua_State *L) {
+  lua_pushboolean(L, input()->WasKeyTyped((KeyCode)luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int input_WasMouseDoublePressed (lua_State *L) {
+  lua_pushboolean(L, input()->WasMouseDoublePressed((MouseCode)luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int input_WasMousePressed (lua_State *L) {
+  lua_pushboolean(L, input()->WasMousePressed((MouseCode)luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int input_WasMouseReleased (lua_State *L) {
+  lua_pushboolean(L, input()->WasMouseReleased((MouseCode)luaL_checkint(L, 1)));
+  return 1;
+}
+
+
+static const luaL_Reg inputlib[] = {
+  {"CandidateListStartsAtOne",   input_CandidateListStartsAtOne},
+  {"GetAppModalSurface",   input_GetAppModalSurface},
+  {"GetCandidateListCount",   input_GetCandidateListCount},
+  {"GetCandidateListPageSize",   input_GetCandidateListPageSize},
+  {"GetCandidateListPageStart",   input_GetCandidateListPageStart},
+  {"GetCandidateListSelectedItem",   input_GetCandidateListSelectedItem},
+  {"GetCurrentIMEHandle",   input_GetCurrentIMEHandle},
+  {"GetCursorPos__USE_VCR_MODE",   input_GetCursorPos__USE_VCR_MODE},
+  {"GetCursorPos",   input_GetCursorPos__USE_VCR_MODE},
+  {"GetCursorPosition",   input_GetCursorPosition},
+  {"GetEnglishIMEHandle",   input_GetEnglishIMEHandle},
+  {"GetFocus",   input_GetFocus},
+  {"GetModalSubTree",   input_GetModalSubTree},
+  {"GetMouseCapture",   input_GetMouseCapture},
+  {"GetMouseOver",   input_GetMouseOver},
+  {"GetShouldInvertCompositionString",   input_GetShouldInvertCompositionString},
+  {"IsKeyDown",   input_IsKeyDown},
+  {"IsMouseDown",   input_IsMouseDown},
+  {"OnChangeIME",   input_OnChangeIME},
+  {"OnChangeIMEByHandle",   input_OnChangeIMEByHandle},
+  {"OnChangeIMEConversionModeByHandle",   input_OnChangeIMEConversionModeByHandle},
+  {"OnChangeIMESentenceModeByHandle",   input_OnChangeIMESentenceModeByHandle},
+  {"OnIMEChangeCandidates",   input_OnIMEChangeCandidates},
+  {"OnIMECloseCandidates",   input_OnIMECloseCandidates},
+  {"OnIMEComposition",   input_OnIMEComposition},
+  {"OnIMEEndComposition",   input_OnIMEEndComposition},
+  {"OnIMERecomputeModes",   input_OnIMERecomputeModes},
+  {"OnIMEShowCandidates",   input_OnIMEShowCandidates},
+  {"OnIMEStartComposition",   input_OnIMEStartComposition},
+  {"OnInputLanguageChanged",   input_OnInputLanguageChanged},
+  {"OnKeyCodeUnhandled",   input_OnKeyCodeUnhandled},
+  {"RegisterKeyCodeUnhandledListener",   input_RegisterKeyCodeUnhandledListener},
+  {"ReleaseAppModalSurface",   input_ReleaseAppModalSurface},
+  {"ReleaseModalSubTree",   input_ReleaseModalSubTree},
+  {"SetAppModalSurface",   input_SetAppModalSurface},
+  {"SetCandidateListPageStart",   input_SetCandidateListPageStart},
+  {"SetCandidateWindowPos",   input_SetCandidateWindowPos},
+  {"SetCursorPos",   input_SetCursorPos},
+  {"SetModalSubTree",   input_SetModalSubTree},
+  {"SetModalSubTreeReceiveMessages",   input_SetModalSubTreeReceiveMessages},
+  {"SetMouseCapture",   input_SetMouseCapture},
+  {"SetMouseCaptureEx",   input_SetMouseCaptureEx},
+  {"SetMouseFocus",   input_SetMouseFocus},
+  {"ShouldModalSubTreeReceiveMessages",   input_ShouldModalSubTreeReceiveMessages},
+  {"UnregisterKeyCodeUnhandledListener",   input_UnregisterKeyCodeUnhandledListener},
+  {"WasKeyPressed",   input_WasKeyPressed},
+  {"WasKeyReleased",   input_WasKeyReleased},
+  {"WasKeyTyped",   input_WasKeyTyped},
+  {"WasMouseDoublePressed",   input_WasMouseDoublePressed},
+  {"WasMousePressed",   input_WasMousePressed},
+  {"WasMouseReleased",   input_WasMouseReleased},
+  {NULL, NULL}
+};
+
+
+/*
+** Open input library
+*/
+LUALIB_API int luaopen_input (lua_State *L) {
+  luaL_register(L, LUA_INPUTLIBNAME, inputlib);
+  return 1;
+}
diff --git a/src/public/vgui/LIScheme.cpp b/src/public/vgui/LIScheme.cpp
new file mode 100644
index 0000000..7136dc6
--- /dev/null
+++ b/src/public/vgui/LIScheme.cpp
@@ -0,0 +1,191 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define LIScheme_cpp
+
+#include "cbase.h"
+#include "vgui/ischeme.h"
+#include "vgui_controls/Controls.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "vgui/lischeme.h"
+#include "vgui/lvgui.h"
+#include "vgui_controls/lPanel.h"
+#include "lColor.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+using namespace vgui;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_IScheme *lua_toischeme (lua_State *L, int idx) {
+  lua_IScheme **ppScheme = (lua_IScheme **)lua_touserdata(L, idx);
+  return *ppScheme;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushischeme (lua_State *L, lua_IScheme *pScheme) {
+  if (pScheme == NULL)
+    lua_pushnil(L);
+  else {
+    lua_IScheme **ppScheme = (lua_IScheme **)lua_newuserdata(L, sizeof(lua_IScheme));
+    *ppScheme = pScheme;
+    luaL_getmetatable(L, "IScheme");
+    lua_setmetatable(L, -2);
+  }
+}
+
+
+LUALIB_API lua_IScheme *luaL_checkischeme (lua_State *L, int narg) {
+  lua_IScheme **d = (lua_IScheme **)luaL_checkudata(L, narg, "IScheme");
+  return *d;
+}
+
+
+static int IScheme_GetColor (lua_State *L) {
+  lua_pushcolor(L, luaL_checkischeme(L, 1)->GetColor(luaL_checkstring(L, 2), luaL_checkcolor(L, 3)));
+  return 1;
+}
+
+static int IScheme_GetFont (lua_State *L) {
+  lua_pushfont(L, luaL_checkischeme(L, 1)->GetFont(luaL_checkstring(L, 2), luaL_optboolean(L, 3, false)));
+  return 1;
+}
+
+static int IScheme_GetFontName (lua_State *L) {
+  lua_pushstring(L, luaL_checkischeme(L, 1)->GetFontName(luaL_checkfont(L, 2)));
+  return 1;
+}
+
+static int IScheme_GetResourceString (lua_State *L) {
+  lua_pushstring(L, luaL_checkischeme(L, 1)->GetResourceString(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int IScheme___tostring (lua_State *L) {
+  lua_pushfstring(L, "IScheme: %p", luaL_checkudata(L, 1, "IScheme"));
+  return 1;
+}
+
+
+static const luaL_Reg ISchememeta[] = {
+  {"GetColor", IScheme_GetColor},
+  {"GetFont", IScheme_GetFont},
+  {"GetFontName", IScheme_GetFontName},
+  {"GetResourceString", IScheme_GetResourceString},
+  {"__tostring", IScheme___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open IScheme object
+*/
+LUALIB_API int luaopen_IScheme (lua_State *L) {
+  luaL_newmetatable(L, LUA_ISCHEMELIBNAME);
+  luaL_register(L, NULL, ISchememeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "ischeme");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "ischeme" */
+  return 1;
+}
+
+
+static int scheme_GetDefaultScheme (lua_State *L) {
+  lua_pushscheme(L, scheme()->GetDefaultScheme());
+  return 1;
+}
+
+static int scheme_GetIScheme (lua_State *L) {
+  lua_pushischeme(L, scheme()->GetIScheme(luaL_checkscheme(L, 1)));
+  return 1;
+}
+
+static int scheme_GetProportionalNormalizedValue (lua_State *L) {
+  lua_pushinteger(L, scheme()->GetProportionalNormalizedValue(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int scheme_GetProportionalNormalizedValueEx (lua_State *L) {
+  lua_pushinteger(L, scheme()->GetProportionalNormalizedValueEx(luaL_checkscheme(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int scheme_GetProportionalScaledValue (lua_State *L) {
+  lua_pushinteger(L, scheme()->GetProportionalScaledValue(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int scheme_GetProportionalScaledValueEx (lua_State *L) {
+  lua_pushinteger(L, scheme()->GetProportionalScaledValueEx(luaL_checkscheme(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int scheme_GetScheme (lua_State *L) {
+  lua_pushscheme(L, scheme()->GetScheme(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int scheme_LoadSchemeFromFile (lua_State *L) {
+  lua_pushscheme(L, scheme()->LoadSchemeFromFile(luaL_checkstring(L, 1), luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int scheme_LoadSchemeFromFileEx (lua_State *L) {
+  lua_pushscheme(L, scheme()->LoadSchemeFromFileEx(luaL_checkvpanel(L, 1), luaL_checkstring(L, 2), luaL_checkstring(L, 3)));
+  return 1;
+}
+
+static int scheme_ReloadFonts (lua_State *L) {
+  scheme()->ReloadFonts();
+  return 0;
+}
+
+static int scheme_ReloadSchemes (lua_State *L) {
+  scheme()->ReloadSchemes();
+  return 0;
+}
+
+
+static const luaL_Reg schemelib[] = {
+  {"GetDefaultScheme",   scheme_GetDefaultScheme},
+  {"GetIScheme",   scheme_GetIScheme},
+  {"GetProportionalNormalizedValue",   scheme_GetProportionalNormalizedValue},
+  {"GetProportionalNormalizedValueEx",   scheme_GetProportionalNormalizedValueEx},
+  {"GetProportionalScaledValue",   scheme_GetProportionalScaledValue},
+  {"GetProportionalScaledValueEx",   scheme_GetProportionalScaledValueEx},
+  {"GetScheme",   scheme_GetScheme},
+  {"LoadSchemeFromFile",   scheme_LoadSchemeFromFile},
+  {"LoadSchemeFromFileEx",   scheme_LoadSchemeFromFileEx},
+  {"ReloadFonts",   scheme_ReloadFonts},
+  {"ReloadSchemes",   scheme_ReloadSchemes},
+  {NULL, NULL}
+};
+
+
+/*
+** Open scheme library
+*/
+LUALIB_API int luaopen_scheme (lua_State *L) {
+  luaL_register(L, LUA_SCHEMELIBNAME, schemelib);
+  return 1;
+}
+
diff --git a/src/public/vgui/LIScheme.h b/src/public/vgui/LIScheme.h
new file mode 100644
index 0000000..b9baef4
--- /dev/null
+++ b/src/public/vgui/LIScheme.h
@@ -0,0 +1,38 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LISCHEME_H
+#define LISCHEME_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+/* type for IScheme functions */
+typedef vgui::IScheme lua_IScheme;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_IScheme             *(lua_toischeme) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushischeme) (lua_State *L, lua_IScheme *pScheme);
+
+
+
+LUALIB_API lua_IScheme *(luaL_checkischeme) (lua_State *L, int narg);
+
+
+#endif // LISCHEME_H
diff --git a/src/public/vgui/LISurface.cpp b/src/public/vgui/LISurface.cpp
new file mode 100644
index 0000000..6e6d20c
--- /dev/null
+++ b/src/public/vgui/LISurface.cpp
@@ -0,0 +1,607 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#define LISurface_cpp
+
+#include "cbase.h"
+#include "vgui/isurface.h"
+#include "vgui/ILocalize.h"
+#include "vgui_controls/Controls.h"
+#include "luamanager.h"
+#include "luasrclib.h"
+#include "vgui/lvgui.h"
+#include "vgui_controls/lPanel.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+using namespace vgui;
+
+
+
+static int surface_AddBitmapFontFile (lua_State *L) {
+  lua_pushboolean(L, surface()->AddBitmapFontFile(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int surface_AddCustomFontFile (lua_State *L) {
+  lua_pushboolean(L, surface()->AddCustomFontFile(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int surface_AddPanel (lua_State *L) {
+  surface()->AddPanel(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int surface_ApplyChanges (lua_State *L) {
+  surface()->ApplyChanges();
+  return 0;
+}
+
+static int surface_BringToFront (lua_State *L) {
+  surface()->BringToFront(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int surface_CalculateMouseVisible (lua_State *L) {
+  surface()->CalculateMouseVisible();
+  return 0;
+}
+
+static int surface_ClearTemporaryFontCache (lua_State *L) {
+  surface()->ClearTemporaryFontCache();
+  return 0;
+}
+
+static int surface_CreateFont (lua_State *L) {
+  lua_pushfont(L, surface()->CreateFont());
+  return 1;
+}
+
+static int surface_CreateNewTextureID (lua_State *L) {
+  lua_pushinteger(L, surface()->CreateNewTextureID(luaL_optboolean(L, 1, false)));
+  return 1;
+}
+
+static int surface_CreatePopup (lua_State *L) {
+  surface()->CreatePopup(luaL_checkvpanel(L, 1), luaL_checkboolean(L, 2), luaL_optboolean(L, 3, true), luaL_optboolean(L, 4, false), luaL_optboolean(L, 5, true), luaL_optboolean(L, 6, true));
+  return 0;
+}
+
+static int surface_DrawFilledRect (lua_State *L) {
+  surface()->DrawFilledRect(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int surface_DrawFilledRectFade (lua_State *L) {
+  surface()->DrawFilledRectFade(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkint(L, 6), luaL_checkboolean(L, 7));
+  return 0;
+}
+
+static int surface_DrawFlushText (lua_State *L) {
+  surface()->DrawFlushText();
+  return 0;
+}
+
+static int surface_DrawGetAlphaMultiplier (lua_State *L) {
+  lua_pushnumber(L, surface()->DrawGetAlphaMultiplier());
+  return 1;
+}
+
+static int surface_DrawGetTextPos (lua_State *L) {
+  int x, y;
+  surface()->DrawGetTextPos(x, y);
+  lua_pushinteger(L, x);
+  lua_pushinteger(L, y);
+  return 2;
+}
+
+static int surface_DrawGetTextureFile (lua_State *L) {
+  char * filename = "";
+  lua_pushboolean(L, surface()->DrawGetTextureFile(luaL_checkint(L, 1), filename, luaL_checkint(L, 2)));
+  lua_pushstring(L, filename);
+  return 2;
+}
+
+static int surface_DrawGetTextureId (lua_State *L) {
+  lua_pushinteger(L, surface()->DrawGetTextureId(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int surface_DrawGetTextureSize (lua_State *L) {
+  int wide, tall;
+  surface()->DrawGetTextureSize(luaL_checkint(L, 1), wide, tall);
+  lua_pushinteger(L, wide);
+  lua_pushinteger(L, tall);
+  return 2;
+}
+
+static int surface_DrawLine (lua_State *L) {
+  surface()->DrawLine(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int surface_DrawOutlinedCircle (lua_State *L) {
+  surface()->DrawOutlinedCircle(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int surface_DrawOutlinedRect (lua_State *L) {
+  surface()->DrawOutlinedRect(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int surface_DrawPrintText (lua_State *L) {
+  const char *sz = luaL_checkstring(L, 1);
+  int bufSize = (strlen( sz ) + 1 ) * sizeof(wchar_t);
+  wchar_t *wbuf = static_cast<wchar_t *>( _alloca( bufSize ) );
+  if ( wbuf )
+  {
+	  g_pVGuiLocalize->ConvertANSIToUnicode( sz, wbuf, bufSize);
+	  surface()->DrawPrintText( wbuf, wcslen( wbuf ), (FontDrawType_t)luaL_optint(L, 3, FONT_DRAW_DEFAULT));
+  }
+  return 0;
+}
+
+static int surface_DrawSetAlphaMultiplier (lua_State *L) {
+  surface()->DrawSetAlphaMultiplier(luaL_checknumber(L, 1));
+  return 0;
+}
+
+static int surface_DrawSetColor (lua_State *L) {
+  surface()->DrawSetColor(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int surface_DrawSetTextColor (lua_State *L) {
+  surface()->DrawSetTextColor(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int surface_DrawSetTextFont (lua_State *L) {
+  surface()->DrawSetTextFont(luaL_checkfont(L, 1));
+  return 0;
+}
+
+static int surface_DrawSetTextPos (lua_State *L) {
+  surface()->DrawSetTextPos(luaL_checkint(L, 1), luaL_checkint(L, 2));
+  return 0;
+}
+
+static int surface_DrawSetTextScale (lua_State *L) {
+  surface()->DrawSetTextScale(luaL_checknumber(L, 1), luaL_checknumber(L, 2));
+  return 0;
+}
+
+static int surface_DrawSetTexture (lua_State *L) {
+  surface()->DrawSetTexture(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int surface_DrawSetTextureFile (lua_State *L) {
+  surface()->DrawSetTextureFile(luaL_checkint(L, 1), luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkboolean(L, 4));
+  return 0;
+}
+
+static int surface_DrawTexturedRect (lua_State *L) {
+  surface()->DrawTexturedRect(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int surface_DrawTexturedSubRect (lua_State *L) {
+  surface()->DrawTexturedSubRect(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checknumber(L, 5), luaL_checknumber(L, 6), luaL_checknumber(L, 7), luaL_checknumber(L, 8));
+  return 0;
+}
+
+static int surface_EnableMouseCapture (lua_State *L) {
+  surface()->EnableMouseCapture(luaL_checkvpanel(L, 1), luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int surface_FlashWindow (lua_State *L) {
+  surface()->FlashWindow(luaL_checkvpanel(L, 1), luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int surface_GetAbsoluteWindowBounds (lua_State *L) {
+  int x, y, wide, tall;
+  surface()->GetAbsoluteWindowBounds(x, y, wide, tall);
+  lua_pushinteger(L, x);
+  lua_pushinteger(L, y);
+  lua_pushinteger(L, wide);
+  lua_pushinteger(L, tall);
+  return 4;
+}
+
+static int surface_GetBitmapFontName (lua_State *L) {
+  lua_pushstring(L, surface()->GetBitmapFontName(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int surface_GetCharABCwide (lua_State *L) {
+  int a, b, c;
+  surface()->GetCharABCwide(luaL_checkfont(L, 1), luaL_checkint(L, 2), a, b, c);
+  lua_pushinteger(L, a);
+  lua_pushinteger(L, b);
+  lua_pushinteger(L, c);
+  return 3;
+}
+
+static int surface_GetCharacterWidth (lua_State *L) {
+  lua_pushinteger(L, surface()->GetCharacterWidth(luaL_checkfont(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int surface_GetEmbeddedPanel (lua_State *L) {
+  lua_pushpanel(L, surface()->GetEmbeddedPanel());
+  return 1;
+}
+
+static int surface_GetFontAscent (lua_State *L) {
+  wchar_t wch[1];
+  g_pVGuiLocalize->ConvertANSIToUnicode(luaL_checkstring(L, 2), wch, sizeof(wch));
+  lua_pushinteger(L, surface()->GetFontAscent(luaL_checkfont(L, 1), wch[1]));
+  return 1;
+}
+
+static int surface_GetFontTall (lua_State *L) {
+  lua_pushinteger(L, surface()->GetFontTall(luaL_checkfont(L, 1)));
+  return 1;
+}
+
+static int surface_GetModalPanel (lua_State *L) {
+  lua_pushpanel(L, surface()->GetModalPanel());
+  return 1;
+}
+
+static int surface_GetNotifyPanel (lua_State *L) {
+  lua_pushpanel(L, surface()->GetNotifyPanel());
+  return 1;
+}
+
+static int surface_GetPopup (lua_State *L) {
+  lua_pushpanel(L, surface()->GetPopup(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int surface_GetPopupCount (lua_State *L) {
+  lua_pushinteger(L, surface()->GetPopupCount());
+  return 1;
+}
+
+static int surface_GetProportionalBase (lua_State *L) {
+  int width, height;
+  surface()->GetProportionalBase(width, height);
+  lua_pushinteger(L, width);
+  lua_pushinteger(L, height);
+  return 2;
+}
+
+static int surface_GetResolutionKey (lua_State *L) {
+  lua_pushstring(L, surface()->GetResolutionKey());
+  return 1;
+}
+
+static int surface_GetScreenSize (lua_State *L) {
+  int wide, tall;
+  surface()->GetScreenSize(wide, tall);
+  lua_pushinteger(L, wide);
+  lua_pushinteger(L, tall);
+  return 2;
+}
+
+static int surface_GetTextSize (lua_State *L) {
+  const char *sz = luaL_checkstring(L, 2);
+  int wide = 0;
+  int tall = 0;
+  int bufSize = (strlen( sz ) + 1 ) * sizeof(wchar_t);
+  wchar_t *wbuf = static_cast<wchar_t *>( _alloca( bufSize ) );
+  if ( wbuf )
+  {
+	  surface()->GetTextSize(luaL_checkfont(L, 1), wbuf, wide, tall);
+  }
+  lua_pushinteger(L, wide);
+  lua_pushinteger(L, tall);
+  return 2;
+}
+
+static int surface_GetTitle (lua_State *L) {
+  char szTitle[256];
+  const wchar_t *wszTitle = surface()->GetTitle(luaL_checkvpanel(L, 1));
+  g_pVGuiLocalize->ConvertUnicodeToANSI( wszTitle, szTitle, sizeof( szTitle ) );
+  lua_pushstring(L, szTitle);
+  return 1;
+}
+
+static int surface_GetTopmostPopup (lua_State *L) {
+  lua_pushpanel(L, surface()->GetTopmostPopup());
+  return 1;
+}
+
+static int surface_GetWorkspaceBounds (lua_State *L) {
+  int x, y, wide, tall;
+  surface()->GetWorkspaceBounds(x, y, wide, tall);
+  lua_pushinteger(L, x);
+  lua_pushinteger(L, y);
+  lua_pushinteger(L, wide);
+  lua_pushinteger(L, tall);
+  return 4;
+}
+
+static int surface_GetZPos (lua_State *L) {
+  lua_pushnumber(L, surface()->GetZPos());
+  return 1;
+}
+
+static int surface_HasCursorPosFunctions (lua_State *L) {
+  lua_pushboolean(L, surface()->HasCursorPosFunctions());
+  return 1;
+}
+
+static int surface_HasFocus (lua_State *L) {
+  lua_pushboolean(L, surface()->HasFocus());
+  return 1;
+}
+
+static int surface_Invalidate (lua_State *L) {
+  surface()->Invalidate(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int surface_IsCursorLocked (lua_State *L) {
+  lua_pushboolean(L, surface()->IsCursorLocked());
+  return 1;
+}
+
+static int surface_IsCursorVisible (lua_State *L) {
+  lua_pushboolean(L, surface()->IsCursorVisible());
+  return 1;
+}
+
+static int surface_IsFontAdditive (lua_State *L) {
+  lua_pushboolean(L, surface()->IsFontAdditive(luaL_checkfont(L, 1)));
+  return 1;
+}
+
+static int surface_IsMinimized (lua_State *L) {
+  lua_pushboolean(L, surface()->IsMinimized(luaL_checkvpanel(L, 1)));
+  return 1;
+}
+
+static int surface_IsTextureIDValid (lua_State *L) {
+  lua_pushboolean(L, surface()->IsTextureIDValid(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int surface_IsWithin (lua_State *L) {
+  lua_pushboolean(L, surface()->IsWithin(luaL_checkint(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int surface_LockCursor (lua_State *L) {
+  surface()->LockCursor();
+  return 0;
+}
+
+static int surface_MovePopupToBack (lua_State *L) {
+  surface()->MovePopupToBack(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int surface_MovePopupToFront (lua_State *L) {
+  surface()->MovePopupToFront(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int surface_NeedKBInput (lua_State *L) {
+  lua_pushboolean(L, surface()->NeedKBInput());
+  return 1;
+}
+
+static int surface_OnScreenSizeChanged (lua_State *L) {
+  surface()->OnScreenSizeChanged(luaL_checkint(L, 1), luaL_checkint(L, 2));
+  return 0;
+}
+
+static int surface_PaintTraverse (lua_State *L) {
+  surface()->PaintTraverse(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int surface_PaintTraverseEx (lua_State *L) {
+  surface()->PaintTraverseEx(luaL_checkvpanel(L, 1), luaL_optboolean(L, 2, false));
+  return 0;
+}
+
+static int surface_PlaySound (lua_State *L) {
+  surface()->PlaySound(luaL_checkstring(L, 1));
+  return 0;
+}
+
+static int surface_PopMakeCurrent (lua_State *L) {
+  surface()->PopMakeCurrent(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int surface_RunFrame (lua_State *L) {
+  surface()->RunFrame();
+  return 0;
+}
+
+static int surface_SetAllowHTMLJavaScript (lua_State *L) {
+  surface()->SetAllowHTMLJavaScript(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int surface_SetBitmapFontName (lua_State *L) {
+  surface()->SetBitmapFontName(luaL_checkstring(L, 1), luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int surface_SetEmbeddedPanel (lua_State *L) {
+  surface()->SetEmbeddedPanel(luaL_checkvpanel(L, 1));
+  return 0;
+}
+
+static int surface_SetFontGlyphSet (lua_State *L) {
+  lua_pushboolean(L, surface()->SetFontGlyphSet(luaL_checkfont(L, 1), luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkint(L, 6), luaL_checkint(L, 7), luaL_optint(L, 8, 0), luaL_optint(L, 9, 0)));
+  return 1;
+}
+
+static int surface_SetTranslateExtendedKeys (lua_State *L) {
+  surface()->SetTranslateExtendedKeys(luaL_checkboolean(L, 1));
+  return 0;
+}
+
+static int surface_SetWorkspaceInsets (lua_State *L) {
+  surface()->SetWorkspaceInsets(luaL_checkint(L, 1), luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int surface_SupportsFeature (lua_State *L) {
+  surface()->SupportsFeature((ISurface::SurfaceFeature_e)luaL_checkint(L, 1));
+  return 0;
+}
+
+static int surface_SurfaceGetCursorPos (lua_State *L) {
+  int x, y;
+  surface()->SurfaceGetCursorPos(x, y);
+  lua_pushinteger(L, x);
+  lua_pushinteger(L, y);
+  return 2;
+}
+
+static int surface_SurfaceSetCursorPos (lua_State *L) {
+  surface()->SurfaceSetCursorPos(luaL_checkint(L, 1), luaL_checkint(L, 2));
+  return 0;
+}
+
+static int surface_UnlockCursor (lua_State *L) {
+  surface()->UnlockCursor();
+  return 0;
+}
+
+
+static const luaL_Reg surfacelib[] = {
+  {"AddBitmapFontFile",   surface_AddBitmapFontFile},
+  {"AddCustomFontFile",   surface_AddCustomFontFile},
+  {"AddPanel",   surface_AddPanel},
+  {"ApplyChanges",   surface_ApplyChanges},
+  {"BringToFront",   surface_BringToFront},
+  {"CalculateMouseVisible",   surface_CalculateMouseVisible},
+  {"ClearTemporaryFontCache",   surface_ClearTemporaryFontCache},
+  {"CreateFont",   surface_CreateFont},
+  {"CreateNewTextureID",   surface_CreateNewTextureID},
+  {"CreatePopup",   surface_CreatePopup},
+  {"DrawFilledRect",   surface_DrawFilledRect},
+  {"DrawFilledRectFade",   surface_DrawFilledRectFade},
+  {"DrawFlushText",   surface_DrawFlushText},
+  {"DrawGetAlphaMultiplier",   surface_DrawGetAlphaMultiplier},
+  {"DrawGetTextPos",   surface_DrawGetTextPos},
+  {"DrawGetTextureFile",   surface_DrawGetTextureFile},
+  {"DrawGetTextureId",   surface_DrawGetTextureId},
+  {"DrawGetTextureSize",   surface_DrawGetTextureSize},
+  {"DrawLine",   surface_DrawLine},
+  {"DrawOutlinedCircle",   surface_DrawOutlinedCircle},
+  {"DrawOutlinedRect",   surface_DrawOutlinedRect},
+  {"DrawPrintText",   surface_DrawPrintText},
+  {"DrawSetAlphaMultiplier",   surface_DrawSetAlphaMultiplier},
+  {"DrawSetColor",   surface_DrawSetColor},
+  {"DrawSetTextColor",   surface_DrawSetTextColor},
+  {"DrawSetTextFont",   surface_DrawSetTextFont},
+  {"DrawSetTextPos",   surface_DrawSetTextPos},
+  {"DrawSetTextScale",   surface_DrawSetTextScale},
+  {"DrawSetTexture",   surface_DrawSetTexture},
+  {"DrawSetTextureFile",   surface_DrawSetTextureFile},
+  {"DrawTexturedRect",   surface_DrawTexturedRect},
+  {"DrawTexturedSubRect",   surface_DrawTexturedSubRect},
+  {"EnableMouseCapture",   surface_EnableMouseCapture},
+  {"FlashWindow",   surface_FlashWindow},
+  {"GetAbsoluteWindowBounds",   surface_GetAbsoluteWindowBounds},
+  {"GetBitmapFontName",   surface_GetBitmapFontName},
+  {"GetCharABCwide",   surface_GetCharABCwide},
+  {"GetCharacterWidth",   surface_GetCharacterWidth},
+  {"GetEmbeddedPanel",   surface_GetEmbeddedPanel},
+  {"GetFontAscent",   surface_GetFontAscent},
+  {"GetFontTall",   surface_GetFontTall},
+  {"GetModalPanel",   surface_GetModalPanel},
+  {"GetNotifyPanel",   surface_GetNotifyPanel},
+  {"GetPopup",   surface_GetPopup},
+  {"GetPopupCount",   surface_GetPopupCount},
+  {"GetProportionalBase",   surface_GetProportionalBase},
+  {"GetResolutionKey",   surface_GetResolutionKey},
+  {"GetScreenSize",   surface_GetScreenSize},
+  {"GetTextSize",   surface_GetTextSize},
+  {"GetTitle",   surface_GetTitle},
+  {"GetTopmostPopup",   surface_GetTopmostPopup},
+  {"GetWorkspaceBounds",   surface_GetWorkspaceBounds},
+  {"GetZPos",   surface_GetZPos},
+  {"HasCursorPosFunctions",   surface_HasCursorPosFunctions},
+  {"HasFocus",   surface_HasFocus},
+  {"Invalidate",   surface_Invalidate},
+  {"IsCursorLocked",   surface_IsCursorLocked},
+  {"IsCursorVisible",   surface_IsCursorVisible},
+  {"IsFontAdditive",   surface_IsFontAdditive},
+  {"IsMinimized",   surface_IsMinimized},
+  {"IsTextureIDValid",   surface_IsTextureIDValid},
+  {"IsWithin",   surface_IsWithin},
+  {"LockCursor",   surface_LockCursor},
+  {"MovePopupToBack",   surface_MovePopupToBack},
+  {"MovePopupToFront",   surface_MovePopupToFront},
+  {"NeedKBInput",   surface_NeedKBInput},
+  {"OnScreenSizeChanged",   surface_OnScreenSizeChanged},
+  {"PaintTraverse",   surface_PaintTraverse},
+  {"PaintTraverseEx",   surface_PaintTraverseEx},
+  {"PlaySound",   surface_PlaySound},
+  {"PopMakeCurrent",   surface_PopMakeCurrent},
+  {"RunFrame",   surface_RunFrame},
+  {"SetAllowHTMLJavaScript",   surface_SetAllowHTMLJavaScript},
+  {"SetBitmapFontName",   surface_SetBitmapFontName},
+  {"SetEmbeddedPanel",   surface_SetEmbeddedPanel},
+  {"SetFontGlyphSet",   surface_SetFontGlyphSet},
+  {"SetTranslateExtendedKeys",   surface_SetTranslateExtendedKeys},
+  {"SetWorkspaceInsets",   surface_SetWorkspaceInsets},
+  {"SupportsFeature",   surface_SupportsFeature},
+  {"SurfaceGetCursorPos",   surface_SurfaceGetCursorPos},
+  {"SurfaceSetCursorPos",   surface_SurfaceSetCursorPos},
+  {"UnlockCursor",   surface_UnlockCursor},
+  {NULL, NULL}
+};
+
+
+/*
+** Open surface library
+*/
+LUALIB_API int luaopen_surface (lua_State *L) {
+  luaL_register(L, LUA_SURFACELIBNAME, surfacelib);
+  return 1;
+}
+
+
+/*
+** Open FONTFLAG library
+*/
+LUALIB_API int luaopen_FONTFLAG (lua_State *L) {
+  BEGIN_LUA_SET_ENUM_LIB(L, LUA_FONTFLAGLIBNAME);
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_NONE, "NONE");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_ITALIC, "ITALIC");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_UNDERLINE, "UNDERLINE");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_STRIKEOUT, "STRIKEOUT");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_SYMBOL, "SYMBOL");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_ANTIALIAS, "ANTIALIAS");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_GAUSSIANBLUR, "GAUSSIANBLUR");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_ROTARY, "ROTARY");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_DROPSHADOW, "DROPSHADOW");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_ADDITIVE, "ADDITIVE");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_OUTLINE, "OUTLINE");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_CUSTOM, "CUSTOM");
+    lua_pushenum(L, vgui::ISurface::FONTFLAG_BITMAP, "BITMAP");
+  END_LUA_SET_ENUM_LIB(L);
+  return 0;
+}
+
diff --git a/src/public/vgui/LVGUI.cpp b/src/public/vgui/LVGUI.cpp
new file mode 100644
index 0000000..e1efc72
--- /dev/null
+++ b/src/public/vgui/LVGUI.cpp
@@ -0,0 +1,129 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Basic header for using vgui
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define lvgui_cpp
+
+#include "cbase.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+#include "lvgui.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+using namespace vgui;
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_HScheme lua_toscheme (lua_State *L, int idx) {
+  lua_HScheme hScheme = *(lua_HScheme *)lua_touserdata(L, idx);
+  return hScheme;
+}
+
+
+LUA_API lua_HFont lua_tofont (lua_State *L, int idx) {
+  lua_HFont hFont = *(lua_HFont *)lua_touserdata(L, idx);
+  return hFont;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushscheme (lua_State *L, HScheme hScheme) {
+  lua_HScheme *phScheme = (lua_HFont *)lua_newuserdata(L, sizeof(hScheme));
+  *phScheme = hScheme;
+  luaL_getmetatable(L, "HScheme");
+  lua_setmetatable(L, -2);
+}
+
+
+LUA_API void lua_pushfont (lua_State *L, HFont hFont) {
+  lua_HFont *phFont = (lua_HFont *)lua_newuserdata(L, sizeof(hFont));
+  *phFont = hFont;
+  luaL_getmetatable(L, "HFont");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_HScheme luaL_checkscheme (lua_State *L, int narg) {
+  lua_HScheme *d = (lua_HScheme *)luaL_checkudata(L, narg, "HScheme");
+  return *d;
+}
+
+
+LUALIB_API lua_HFont luaL_checkfont (lua_State *L, int narg) {
+  lua_HFont *d = (lua_HFont *)luaL_checkudata(L, narg, "HFont");
+  return *d;
+}
+
+
+static int HScheme___tostring (lua_State *L) {
+  HScheme hScheme = luaL_checkscheme(L, 1);
+  lua_pushfstring(L, "HScheme: %d", hScheme);
+  return 1;
+}
+
+
+static const luaL_Reg HSchememeta[] = {
+  {"__tostring", HScheme___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open HScheme object
+*/
+LUALIB_API int luaopen_HScheme (lua_State *L) {
+  luaL_newmetatable(L, LUA_HSCHEMELIBNAME);
+  luaL_register(L, NULL, HSchememeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "scheme");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "scheme" */
+  return 1;
+}
+
+
+static int HFont___tostring (lua_State *L) {
+  HFont hFont = luaL_checkfont(L, 1);
+  if (hFont == INVALID_FONT)
+    lua_pushstring(L, "INVALID_FONT");
+  else
+    lua_pushfstring(L, "HFont: %d", hFont);
+  return 1;
+}
+
+
+static const luaL_Reg HFontmeta[] = {
+  {"__tostring", HFont___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open HFont object
+*/
+LUALIB_API int luaopen_HFont (lua_State *L) {
+  luaL_newmetatable(L, LUA_FONTLIBNAME);
+  luaL_register(L, NULL, HFontmeta);
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  lua_pushstring(L, "font");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "font" */
+  lua_pushfont(L, INVALID_FONT);
+  lua_setglobal(L, "INVALID_FONT");  /* set global INVALID_FONT */
+  return 1;
+}
diff --git a/src/public/vgui/LVGUI.h b/src/public/vgui/LVGUI.h
new file mode 100644
index 0000000..34b218b
--- /dev/null
+++ b/src/public/vgui/LVGUI.h
@@ -0,0 +1,44 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: Basic header for using vgui
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LVGUI_H
+#define LVGUI_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+/* type for HScheme functions */
+typedef vgui::HScheme lua_HScheme;
+
+
+/* type for HFont functions */
+typedef vgui::HFont lua_HFont;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_HScheme     (lua_toscheme) (lua_State *L, int idx);
+LUA_API lua_HFont     (lua_tofont) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushscheme) (lua_State *L, lua_HScheme hScheme);
+LUA_API void  (lua_pushfont) (lua_State *L, lua_HFont hFont);
+
+
+
+LUALIB_API lua_HScheme (luaL_checkscheme) (lua_State *L, int narg);
+LUALIB_API lua_HFont (luaL_checkfont) (lua_State *L, int narg);
+
+
+#endif // LVGUI_H
diff --git a/src/public/vgui_controls/lControls.h b/src/public/vgui_controls/lControls.h
new file mode 100644
index 0000000..ca0ea2f
--- /dev/null
+++ b/src/public/vgui_controls/lControls.h
@@ -0,0 +1,66 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#ifndef LCONTROLS_H
+#define LCONTROLS_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+
+// predeclare all the vgui control class names
+LUALIB_API int luaopen_vgui_AnalogBar(lua_State *L);
+LUALIB_API int luaopen_vgui_AnimatingImagePanel(lua_State *L);
+LUALIB_API int luaopen_vgui_AnimationController(lua_State *L);
+LUALIB_API int luaopen_vgui_BuildModeDialog(lua_State *L);
+LUALIB_API int luaopen_vgui_Button(lua_State *L);
+LUALIB_API int luaopen_vgui_CheckButton(lua_State *L);
+LUALIB_API int luaopen_vgui_CheckButtonList(lua_State *L);
+LUALIB_API int luaopen_vgui_ComboBox(lua_State *L);
+LUALIB_API int luaopen_vgui_DirectorySelectDialog(lua_State *L);
+LUALIB_API int luaopen_vgui_Divider(lua_State *L);
+LUALIB_API int luaopen_vgui_EditablePanel(lua_State *L);
+LUALIB_API int luaopen_vgui_FileOpenDialog(lua_State *L);
+LUALIB_API int luaopen_vgui_Frame(lua_State *L);
+LUALIB_API int luaopen_vgui_GraphPanel(lua_State *L);
+LUALIB_API int luaopen_vgui_HTML(lua_State *L);
+LUALIB_API int luaopen_vgui_ImagePanel(lua_State *L);
+LUALIB_API int luaopen_vgui_Label(lua_State *L);
+LUALIB_API int luaopen_vgui_ListPanel(lua_State *L);
+LUALIB_API int luaopen_vgui_ListViewPanel(lua_State *L);
+LUALIB_API int luaopen_vgui_Menu(lua_State *L);
+LUALIB_API int luaopen_vgui_MenuBar(lua_State *L);
+LUALIB_API int luaopen_vgui_MenuButton(lua_State *L);
+LUALIB_API int luaopen_vgui_MenuItem(lua_State *L);
+LUALIB_API int luaopen_vgui_MessageBox(lua_State *L);
+LUALIB_API int luaopen_vgui_Panel(lua_State *L);
+LUALIB_API int luaopen_vgui_PanelListPanel(lua_State *L);
+LUALIB_API int luaopen_vgui_ProgressBar(lua_State *L);
+LUALIB_API int luaopen_vgui_ProgressBox(lua_State *L);
+LUALIB_API int luaopen_vgui_PropertyDialog(lua_State *L);
+LUALIB_API int luaopen_vgui_PropertyPage(lua_State *L);
+LUALIB_API int luaopen_vgui_PropertySheet(lua_State *L);
+LUALIB_API int luaopen_vgui_QueryBox(lua_State *L);
+LUALIB_API int luaopen_vgui_RadioButton(lua_State *L);
+LUALIB_API int luaopen_vgui_RichText(lua_State *L);
+LUALIB_API int luaopen_vgui_ScalableImagePanel(lua_State *L);
+LUALIB_API int luaopen_vgui_ScrollBar(lua_State *L);
+LUALIB_API int luaopen_vgui_ScrollBarSlider(lua_State *L);
+LUALIB_API int luaopen_vgui_SectionedListPanel(lua_State *L);
+LUALIB_API int luaopen_vgui_Slider(lua_State *L);
+LUALIB_API int luaopen_vgui_Splitter(lua_State *L);
+LUALIB_API int luaopen_vgui_TextEntry(lua_State *L);
+LUALIB_API int luaopen_vgui_ToggleButton(lua_State *L);
+LUALIB_API int luaopen_vgui_Tooltip(lua_State *L);
+LUALIB_API int luaopen_vgui_TreeView(lua_State *L);
+LUALIB_API int luaopen_vgui_CTreeViewListControl(lua_State *L);
+LUALIB_API int luaopen_vgui_URLLabel(lua_State *L);
+LUALIB_API int luaopen_vgui_WizardPanel(lua_State *L);
+LUALIB_API int luaopen_vgui_WizardSubPanel(lua_State *L);
+
+#endif // LCONTROLS_H
diff --git a/src/public/vgui_controls/lEditablePanel.cpp b/src/public/vgui_controls/lEditablePanel.cpp
new file mode 100644
index 0000000..07dab06
--- /dev/null
+++ b/src/public/vgui_controls/lEditablePanel.cpp
@@ -0,0 +1,321 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#define leditablepanel_cpp
+
+#include "cbase.h"
+#include <vgui_controls/PHandle.h>
+#include "luamanager.h"
+#include <vgui_controls/lEditablePanel.h>
+#include <LKeyValues.h>
+#include <vgui_controls/lPanel.h>
+
+using namespace vgui;
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_EditablePanel *lua_toeditablepanel (lua_State *L, int idx) {
+  PHandle *phPanel = dynamic_cast<PHandle *>((PHandle *)lua_touserdata(L, idx));
+  if (phPanel == NULL)
+    return NULL;
+  return dynamic_cast<lua_EditablePanel *>(phPanel->Get());
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pusheditablepanel (lua_State *L, EditablePanel *pPanel) {
+  PHandle *phPanel = (PHandle *)lua_newuserdata(L, sizeof(PHandle));
+  phPanel->Set(pPanel);
+  luaL_getmetatable(L, "EditablePanel");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_EditablePanel *luaL_checkeditablepanel (lua_State *L, int narg) {
+  lua_EditablePanel *d = lua_toeditablepanel(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "EditablePanel expected, got INVALID_PANEL");
+  return d;
+}
+
+
+static int EditablePanel_ActivateBuildMode (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->ActivateBuildMode();
+  return 0;
+}
+
+static int EditablePanel_ApplySettings (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->ApplySettings(luaL_checkkeyvalues(L, 2));
+  return 0;
+}
+
+static int EditablePanel_ChainToAnimationMap (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->ChainToAnimationMap();
+  return 0;
+}
+
+static int EditablePanel_ChainToMap (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->ChainToMap();
+  return 0;
+}
+
+static int EditablePanel_CreateControlByName (lua_State *L) {
+  lua_pushpanel(L, luaL_checkeditablepanel(L, 1)->CreateControlByName(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int EditablePanel_GetControlInt (lua_State *L) {
+  lua_pushinteger(L, luaL_checkeditablepanel(L, 1)->GetControlInt(luaL_checkstring(L, 2), luaL_checkint(L, 3)));
+  return 1;
+}
+
+static int EditablePanel_GetControlString (lua_State *L) {
+  lua_pushstring(L, luaL_checkeditablepanel(L, 1)->GetControlString(luaL_checkstring(L, 2), luaL_optstring(L, 3, "")));
+  return 1;
+}
+
+static int EditablePanel_GetCurrentKeyFocus (lua_State *L) {
+  lua_pushpanel(L, luaL_checkeditablepanel(L, 1)->GetCurrentKeyFocus());
+  return 1;
+}
+
+static int EditablePanel_GetDialogVariables (lua_State *L) {
+  lua_pushkeyvalues(L, luaL_checkeditablepanel(L, 1)->GetDialogVariables());
+  return 1;
+}
+
+static int EditablePanel_GetPanelBaseClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkeditablepanel(L, 1)->GetPanelBaseClassName());
+  return 1;
+}
+
+static int EditablePanel_GetPanelClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkeditablepanel(L, 1)->GetPanelClassName());
+  return 1;
+}
+
+static int EditablePanel_HasHotkey (lua_State *L) {
+  size_t l;
+  lua_pushpanel(L, luaL_checkeditablepanel(L, 1)->HasHotkey((wchar_t)luaL_checklstring(L, 2, &l)));
+  return 1;
+}
+
+static int EditablePanel_KB_AddBoundKey (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->KB_AddBoundKey(luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int EditablePanel_KB_ChainToMap (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->KB_ChainToMap();
+  return 0;
+}
+
+static int EditablePanel_KeyCodeToString (lua_State *L) {
+  lua_pushstring(L, luaL_checkeditablepanel(L, 1)->KeyCodeToString((KeyCode)luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int EditablePanel_LoadControlSettings (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->LoadControlSettings(luaL_checkstring(L, 2), luaL_optstring(L, 3, NULL), luaL_optkeyvalues(L, 4, NULL));
+  return 0;
+}
+
+static int EditablePanel_LoadControlSettingsAndUserConfig (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->LoadControlSettingsAndUserConfig(luaL_checkstring(L, 2), luaL_optint(L, 3, 0));
+  return 0;
+}
+
+static int EditablePanel_LoadUserConfig (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->LoadUserConfig(luaL_checkstring(L, 2), luaL_optint(L, 3, 0));
+  return 0;
+}
+
+static int EditablePanel_OnKeyCodeTyped (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->OnKeyCodeTyped((KeyCode)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int EditablePanel_OnRequestFocus (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->OnRequestFocus(luaL_checkvpanel(L, 2), luaL_checkvpanel(L, 3));
+  return 0;
+}
+
+static int EditablePanel_OnSetFocus (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->OnSetFocus();
+  return 0;
+}
+
+static int EditablePanel_RegisterControlSettingsFile (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->RegisterControlSettingsFile(luaL_checkstring(L, 2), luaL_optstring(L, 3, NULL));
+  return 0;
+}
+
+static int EditablePanel_RequestFocus (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->RequestFocus(luaL_optint(L, 2, 0));
+  return 0;
+}
+
+static int EditablePanel_RequestFocusNext (lua_State *L) {
+  lua_pushboolean(L, luaL_checkeditablepanel(L, 1)->RequestFocusNext(luaL_checkvpanel(L, 2)));
+  return 1;
+}
+
+static int EditablePanel_RequestFocusPrev (lua_State *L) {
+  lua_pushboolean(L, luaL_checkeditablepanel(L, 1)->RequestFocusPrev(luaL_checkvpanel(L, 2)));
+  return 1;
+}
+
+static int EditablePanel_RequestInfo (lua_State *L) {
+  lua_pushboolean(L, luaL_checkeditablepanel(L, 1)->RequestInfo(luaL_checkkeyvalues(L, 2)));
+  return 1;
+}
+
+static int EditablePanel_RequestInfoFromChild (lua_State *L) {
+  lua_pushboolean(L, luaL_checkeditablepanel(L, 1)->RequestInfoFromChild(luaL_checkstring(L, 2), luaL_checkkeyvalues(L, 3)));
+  return 1;
+}
+
+static int EditablePanel_SaveUserConfig (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->SaveUserConfig();
+  return 0;
+}
+
+static int EditablePanel_SetControlEnabled (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->SetControlEnabled(luaL_checkstring(L, 2), luaL_checkboolean(L, 3));
+  return 0;
+}
+
+static int EditablePanel_SetControlInt (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->SetControlInt(luaL_checkstring(L, 2), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int EditablePanel_SetControlString (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->SetControlString(luaL_checkstring(L, 2), luaL_checkstring(L, 3));
+  return 0;
+}
+
+static int EditablePanel_SetControlVisible (lua_State *L) {
+  luaL_checkeditablepanel(L, 1)->SetControlVisible(luaL_checkstring(L, 2), luaL_checkboolean(L, 3));
+  return 0;
+}
+
+static int EditablePanel_SetDialogVariable (lua_State *L) {
+  switch(lua_type(L, 3)) {
+	case LUA_TNUMBER:
+	  luaL_checkeditablepanel(L, 1)->SetDialogVariable(luaL_checkstring(L, 2), (float)luaL_checknumber(L, 3));
+	  break;
+	case LUA_TSTRING:
+	default:
+	  luaL_checkeditablepanel(L, 1)->SetDialogVariable(luaL_checkstring(L, 2), luaL_checkstring(L, 3));
+	  break;
+  }
+  return 0;
+}
+
+static int EditablePanel___index (lua_State *L) {
+  EditablePanel *pPanel = lua_toeditablepanel(L, 1);
+  if (pPanel == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  lua_getmetatable(L, 1);
+  lua_pushvalue(L, 2);
+  lua_gettable(L, -2);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 2);
+    luaL_getmetatable(L, "Panel");
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+  }
+  return 1;
+}
+
+static int EditablePanel___eq (lua_State *L) {
+  lua_pushboolean(L, lua_toeditablepanel(L, 1) == lua_toeditablepanel(L, 2));
+  return 1;
+}
+
+static int EditablePanel___tostring (lua_State *L) {
+  EditablePanel *pPanel = lua_toeditablepanel(L, 1);
+  if (pPanel == NULL)
+    lua_pushstring(L, "INVALID_PANEL");
+  else {
+    const char *pName = pPanel->GetName();
+    if (Q_strcmp(pName, "") == 0)
+      pName = "(no name)";
+    lua_pushfstring(L, "EditablePanel: \"%s\"", pName);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg EditablePanelmeta[] = {
+  {"ActivateBuildMode", EditablePanel_ActivateBuildMode},
+  {"ApplySettings", EditablePanel_ApplySettings},
+  {"ChainToAnimationMap", EditablePanel_ChainToAnimationMap},
+  {"ChainToMap", EditablePanel_ChainToMap},
+  {"CreateControlByName", EditablePanel_CreateControlByName},
+  {"GetControlInt", EditablePanel_GetControlInt},
+  {"GetControlString", EditablePanel_GetControlString},
+  {"GetCurrentKeyFocus", EditablePanel_GetCurrentKeyFocus},
+  {"GetDialogVariables", EditablePanel_GetDialogVariables},
+  {"GetPanelBaseClassName", EditablePanel_GetPanelBaseClassName},
+  {"GetPanelClassName", EditablePanel_GetPanelClassName},
+  {"HasHotkey", EditablePanel_HasHotkey},
+  {"KB_AddBoundKey", EditablePanel_KB_AddBoundKey},
+  {"KB_ChainToMap", EditablePanel_KB_ChainToMap},
+  {"KeyCodeToString", EditablePanel_KeyCodeToString},
+  {"LoadControlSettings", EditablePanel_LoadControlSettings},
+  {"LoadControlSettingsAndUserConfig", EditablePanel_LoadControlSettingsAndUserConfig},
+  {"LoadUserConfig", EditablePanel_LoadUserConfig},
+  {"OnKeyCodeTyped", EditablePanel_OnKeyCodeTyped},
+  {"OnRequestFocus", EditablePanel_OnRequestFocus},
+  {"OnSetFocus", EditablePanel_OnSetFocus},
+  {"RegisterControlSettingsFile", EditablePanel_RegisterControlSettingsFile},
+  {"RequestFocus", EditablePanel_RequestFocus},
+  {"RequestFocusNext", EditablePanel_RequestFocusNext},
+  {"RequestFocusPrev", EditablePanel_RequestFocusPrev},
+  {"RequestInfo", EditablePanel_RequestInfo},
+  {"RequestInfoFromChild", EditablePanel_RequestInfoFromChild},
+  {"SaveUserConfig", EditablePanel_SaveUserConfig},
+  {"SetControlEnabled", EditablePanel_SetControlEnabled},
+  {"SetControlInt", EditablePanel_SetControlInt},
+  {"SetControlString", EditablePanel_SetControlString},
+  {"SetControlVisible", EditablePanel_SetControlVisible},
+  {"SetDialogVariable", EditablePanel_SetDialogVariable},
+  {"__index", EditablePanel___index},
+  {"__eq", EditablePanel___eq},
+  {"__tostring", EditablePanel___tostring},
+  {NULL, NULL}
+};
+
+
+/*
+** Open EditablePanel object
+*/
+LUALIB_API int luaopen_vgui_EditablePanel (lua_State *L) {
+  luaL_newmetatable(L, "EditablePanel");
+  luaL_register(L, NULL, EditablePanelmeta);
+  lua_pushstring(L, "panel");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "panel" */
+  return 1;
+}
diff --git a/src/public/vgui_controls/lEditablePanel.h b/src/public/vgui_controls/lEditablePanel.h
new file mode 100644
index 0000000..343a45e
--- /dev/null
+++ b/src/public/vgui_controls/lEditablePanel.h
@@ -0,0 +1,41 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//=============================================================================//
+
+#ifndef LEDITABLEPANEL_H
+#define LEDITABLEPANEL_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include <vgui_controls/EditablePanel.h>
+
+using namespace vgui;
+
+/* type for EditablePanel functions */
+typedef EditablePanel lua_EditablePanel;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_EditablePanel     *(lua_toeditablepanel) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pusheditablepanel) (lua_State *L, lua_EditablePanel *pPanel);
+
+
+
+LUALIB_API lua_EditablePanel *(luaL_checkeditablepanel) (lua_State *L, int narg);
+
+
+#endif // LEDITABLEPANEL_H
diff --git a/src/public/vgui_controls/lPanel.cpp b/src/public/vgui_controls/lPanel.cpp
new file mode 100644
index 0000000..7dabedc
--- /dev/null
+++ b/src/public/vgui_controls/lPanel.cpp
@@ -0,0 +1,1325 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#define lpanel_cpp
+
+#include "cbase.h"
+#include <vgui_controls/Panel.h>
+#include "c_vguiscreen.h"
+#include "iclientmode.h"
+#include "ienginevgui.h"
+#include <vgui/IVGui.h>
+#include "panelmetaclassmgr.h"
+#include <vgui_controls/PHandle.h>
+#include "luamanager.h"
+#include "vgui_int.h"
+#include "lPanel.h"
+#include <scripted_controls/lPanel.h>
+#include "lColor.h"
+
+using namespace vgui;
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_Panel *lua_topanel (lua_State *L, int idx) {
+  PHandle *phPanel = dynamic_cast<PHandle *>((PHandle *)lua_touserdata(L, idx));
+  if (phPanel == NULL)
+    return NULL;
+  return (lua_Panel *)phPanel->Get();
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushpanel (lua_State *L, Panel *pPanel) {
+  LPanel *plPanel = dynamic_cast<LPanel *>(pPanel);
+  if (plPanel)
+    ++plPanel->m_nRefCount;
+  PHandle *phPanel = (PHandle *)lua_newuserdata(L, sizeof(PHandle));
+  phPanel->Set(pPanel);
+  luaL_getmetatable(L, "Panel");
+  lua_setmetatable(L, -2);
+}
+
+
+LUA_API void lua_pushpanel (lua_State *L, VPANEL panel) {
+  PHandle *phPanel = (PHandle *)lua_newuserdata(L, sizeof(PHandle));
+  phPanel->Set(ivgui()->PanelToHandle(panel));
+  luaL_getmetatable(L, "Panel");
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API lua_Panel *luaL_checkpanel (lua_State *L, int narg) {
+  lua_Panel *d = lua_topanel(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "Panel expected, got INVALID_PANEL");
+  return d;
+}
+
+
+LUALIB_API VPANEL luaL_checkvpanel (lua_State *L, int narg) {
+  lua_Panel *d = lua_topanel(L, narg);
+  if (d == NULL)  /* avoid extra test when d is not 0 */
+    luaL_argerror(L, narg, "Panel expected, got INVALID_PANEL");
+  PHandle hPanel;
+  hPanel.Set(d);
+  return ivgui()->HandleToPanel(hPanel.m_iPanelID);
+}
+
+
+LUALIB_API lua_Panel *luaL_optpanel (lua_State *L, int narg,
+                                                   Panel *def) {
+  return luaL_opt(L, luaL_checkpanel, narg, def);
+}
+
+
+static int Panel_AddKeyBinding (lua_State *L) {
+  luaL_checkpanel(L, 1)->AddKeyBinding(luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int Panel_AddActionSignalTarget (lua_State *L) {
+  luaL_checkpanel(L, 1)->AddActionSignalTarget(luaL_checkpanel(L, 2));
+  return 0;
+}
+
+static int Panel_CanStartDragging (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->CanStartDragging(luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5)));
+  return 1;
+}
+
+static int Panel_ChainToAnimationMap (lua_State *L) {
+  luaL_checkpanel(L, 1)->ChainToAnimationMap();
+  return 0;
+}
+
+static int Panel_ChainToMap (lua_State *L) {
+  luaL_checkpanel(L, 1)->ChainToMap();
+  return 0;
+}
+
+static int Panel_DeletePanel (lua_State *L) {
+  luaL_checkpanel(L, 1)->DeletePanel();
+  return 0;
+}
+
+static int Panel_DisableMouseInputForThisPanel (lua_State *L) {
+  luaL_checkpanel(L, 1)->DisableMouseInputForThisPanel(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_DrawBox (lua_State *L) {
+  luaL_checkpanel(L, 1)->DrawBox(luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkcolor(L, 6), luaL_checknumber(L, 7), luaL_optboolean(L, 8, 0));
+  return 0;
+}
+
+static int Panel_DrawBoxFade (lua_State *L) {
+  luaL_checkpanel(L, 1)->DrawBoxFade(luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkcolor(L, 6), luaL_checknumber(L, 7), luaL_checkint(L, 8), luaL_checkint(L, 9), luaL_checkboolean(L, 10), luaL_optboolean(L, 11, 0));
+  return 0;
+}
+
+static int Panel_DrawHollowBox (lua_State *L) {
+  luaL_checkpanel(L, 1)->DrawHollowBox(luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkcolor(L, 6), luaL_checknumber(L, 7));
+  return 0;
+}
+
+static int Panel_DrawTexturedBox (lua_State *L) {
+  luaL_checkpanel(L, 1)->DrawTexturedBox(luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkcolor(L, 6), luaL_checknumber(L, 7));
+  return 0;
+}
+
+static int Panel_EditKeyBindings (lua_State *L) {
+  luaL_checkpanel(L, 1)->EditKeyBindings();
+  return 0;
+}
+
+static int Panel_FillRectSkippingPanel (lua_State *L) {
+  luaL_checkpanel(L, 1)->FillRectSkippingPanel(luaL_checkcolor(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkint(L, 6), luaL_checkpanel(L, 7));
+  return 0;
+}
+
+static int Panel_FindChildByName (lua_State *L) {
+  lua_pushpanel(L, luaL_checkpanel(L, 1)->FindChildByName(luaL_checkstring(L, 2), luaL_optboolean(L, 3, 0)));
+  return 1;
+}
+
+static int Panel_FindChildIndexByName (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->FindChildIndexByName(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int Panel_FindSiblingByName (lua_State *L) {
+  lua_pushpanel(L, luaL_checkpanel(L, 1)->FindSiblingByName(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int Panel_GetAlpha (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->GetAlpha());
+  return 1;
+}
+
+static int Panel_GetBgColor (lua_State *L) {
+  lua_pushcolor(L, luaL_checkpanel(L, 1)->GetBgColor());
+  return 1;
+}
+
+static int Panel_GetBounds (lua_State *L) {
+  int x, y, wide, tall;
+  luaL_checkpanel(L, 1)->GetBounds(x, y, wide, tall);
+  lua_pushinteger(L, x);
+  lua_pushinteger(L, y);
+  lua_pushinteger(L, wide);
+  lua_pushinteger(L, tall);
+  return 4;
+}
+
+static int Panel_GetChild (lua_State *L) {
+  lua_pushpanel(L, luaL_checkpanel(L, 1)->GetChild(luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int Panel_GetChildCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->GetChildCount());
+  return 1;
+}
+
+static int Panel_GetClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkpanel(L, 1)->GetClassName());
+  return 1;
+}
+
+static int Panel_GetClipRect (lua_State *L) {
+  int x0, y0, x1, y1;
+  luaL_checkpanel(L, 1)->GetClipRect(x0, y0, x1, y1);
+  lua_pushinteger(L, x0);
+  lua_pushinteger(L, y0);
+  lua_pushinteger(L, x1);
+  lua_pushinteger(L, y1);
+  return 4;
+}
+
+static int Panel_GetCornerTextureSize (lua_State *L) {
+  int w, h;
+  luaL_checkpanel(L, 1)->GetCornerTextureSize(w, h);
+  lua_pushinteger(L, w);
+  lua_pushinteger(L, h);
+  return 2;
+}
+
+static int Panel_GetDescription (lua_State *L) {
+  lua_pushstring(L, luaL_checkpanel(L, 1)->GetDescription());
+  return 1;
+}
+
+static int Panel_GetDragFrameColor (lua_State *L) {
+  lua_pushcolor(L, luaL_checkpanel(L, 1)->GetDragFrameColor());
+  return 1;
+}
+
+static int Panel_GetDragPanel (lua_State *L) {
+  lua_pushpanel(L, luaL_checkpanel(L, 1)->GetDragPanel());
+  return 1;
+}
+
+static int Panel_GetDragStartTolerance (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->GetDragStartTolerance());
+  return 1;
+}
+
+static int Panel_GetDropFrameColor (lua_State *L) {
+  lua_pushcolor(L, luaL_checkpanel(L, 1)->GetDropFrameColor());
+  return 1;
+}
+
+static int Panel_GetFgColor (lua_State *L) {
+  lua_pushcolor(L, luaL_checkpanel(L, 1)->GetFgColor());
+  return 1;
+}
+
+static int Panel_GetInset (lua_State *L) {
+  int left, top, right, bottom;
+  luaL_checkpanel(L, 1)->GetInset(left, top, right, bottom);
+  lua_pushinteger(L, left);
+  lua_pushinteger(L, top);
+  lua_pushinteger(L, right);
+  lua_pushinteger(L, bottom);
+  return 4;
+}
+
+static int Panel_GetKeyBindingsFile (lua_State *L) {
+  lua_pushstring(L, luaL_checkpanel(L, 1)->GetKeyBindingsFile());
+  return 1;
+}
+
+static int Panel_GetKeyBindingsFilePathID (lua_State *L) {
+  lua_pushstring(L, luaL_checkpanel(L, 1)->GetKeyBindingsFilePathID());
+  return 1;
+}
+
+static int Panel_GetKeyMappingCount (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->GetKeyMappingCount());
+  return 1;
+}
+
+static int Panel_GetMinimumSize (lua_State *L) {
+  int wide, tall;
+  luaL_checkpanel(L, 1)->GetMinimumSize(wide, tall);
+  lua_pushinteger(L, wide);
+  lua_pushinteger(L, tall);
+  return 2;
+}
+
+static int Panel_GetModuleName (lua_State *L) {
+  lua_pushstring(L, luaL_checkpanel(L, 1)->GetModuleName());
+  return 1;
+}
+
+static int Panel_GetName (lua_State *L) {
+  lua_pushstring(L, luaL_checkpanel(L, 1)->GetName());
+  return 1;
+}
+
+static int Panel_GetPaintBackgroundType (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->GetPaintBackgroundType());
+  return 1;
+}
+
+static int Panel_GetPaintSize (lua_State *L) {
+  int wide, tall;
+  luaL_checkpanel(L, 1)->GetPaintSize(wide, tall);
+  lua_pushinteger(L, wide);
+  lua_pushinteger(L, tall);
+  return 2;
+}
+
+static int Panel_GetPanelBaseClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkpanel(L, 1)->GetPanelBaseClassName());
+  return 1;
+}
+
+static int Panel_GetPanelClassName (lua_State *L) {
+  lua_pushstring(L, luaL_checkpanel(L, 1)->GetPanelClassName());
+  return 1;
+}
+
+static int Panel_GetParent (lua_State *L) {
+  lua_pushpanel(L, luaL_checkpanel(L, 1)->GetParent());
+  return 1;
+}
+
+static int Panel_GetPinCorner (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->GetPinCorner());
+  return 1;
+}
+
+static int Panel_GetPinOffset (lua_State *L) {
+  int dx, dy;
+  luaL_checkpanel(L, 1)->GetPinOffset(dx, dy);
+  lua_pushinteger(L, dx);
+  lua_pushinteger(L, dy);
+  return 2;
+}
+
+static int Panel_GetPos (lua_State *L) {
+  int x, y;
+  luaL_checkpanel(L, 1)->GetPos(x, y);
+  lua_pushinteger(L, x);
+  lua_pushinteger(L, y);
+  return 2;
+}
+
+static int Panel_GetRefTable (lua_State *L) {
+  LPanel *plPanel = dynamic_cast<LPanel *>(luaL_checkpanel(L, 1));
+  if (plPanel) {
+    if (plPanel->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plPanel->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plPanel->m_nTableReference);
+  }
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+static int Panel_GetResizeOffset (lua_State *L) {
+  int dx, dy;
+  luaL_checkpanel(L, 1)->GetResizeOffset(dx, dy);
+  lua_pushinteger(L, dx);
+  lua_pushinteger(L, dy);
+  return 2;
+}
+
+static int Panel_GetSize (lua_State *L) {
+  int wide, tall;
+  luaL_checkpanel(L, 1)->GetSize(wide, tall);
+  lua_pushinteger(L, wide);
+  lua_pushinteger(L, tall);
+  return 2;
+}
+
+static int Panel_GetTabPosition (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->GetTabPosition());
+  return 1;
+}
+
+static int Panel_GetTall (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->GetTall());
+  return 1;
+}
+
+static int Panel_GetVPanel (lua_State *L) {
+  lua_pushpanel(L, luaL_checkpanel(L, 1)->GetVPanel());
+  return 1;
+}
+
+static int Panel_GetVParent (lua_State *L) {
+  lua_pushpanel(L, luaL_checkpanel(L, 1)->GetVParent());
+  return 1;
+}
+
+static int Panel_GetWide (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->GetWide());
+  return 1;
+}
+
+static int Panel_GetZPos (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->GetZPos());
+  return 1;
+}
+
+static int Panel_HasFocus (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->HasFocus());
+  return 1;
+}
+
+static int Panel_HasUserConfigSettings (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->HasUserConfigSettings());
+  return 1;
+}
+
+static int Panel_InitPropertyConverters (lua_State *L) {
+  luaL_checkpanel(L, 1)->InitPropertyConverters();
+  return 0;
+}
+
+static int Panel_InvalidateLayout (lua_State *L) {
+  luaL_checkpanel(L, 1)->InvalidateLayout(luaL_optboolean(L, 2, 0), luaL_optboolean(L, 3, 0));
+  return 0;
+}
+
+static int Panel_IsAutoDeleteSet (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsAutoDeleteSet());
+  return 1;
+}
+
+static int Panel_IsBeingDragged (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsBeingDragged());
+  return 1;
+}
+
+static int Panel_IsBlockingDragChaining (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsBlockingDragChaining());
+  return 1;
+}
+
+static int Panel_IsBottomAligned (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsBottomAligned());
+  return 1;
+}
+
+static int Panel_IsBuildGroupEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsBuildGroupEnabled());
+  return 1;
+}
+
+static int Panel_IsBuildModeActive (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsBuildModeActive());
+  return 1;
+}
+
+static int Panel_IsBuildModeDeletable (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsBuildModeDeletable());
+  return 1;
+}
+
+static int Panel_IsBuildModeEditable (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsBuildModeEditable());
+  return 1;
+}
+
+static int Panel_IsChildOfModalSubTree (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsChildOfModalSubTree());
+  return 1;
+}
+
+static int Panel_IsChildOfSurfaceModalPanel (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsChildOfSurfaceModalPanel());
+  return 1;
+}
+
+static int Panel_IsCursorNone (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsCursorNone());
+  return 1;
+}
+
+static int Panel_IsCursorOver (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsCursorOver());
+  return 1;
+}
+
+static int Panel_IsDragEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsDragEnabled());
+  return 1;
+}
+
+static int Panel_IsDropEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsDropEnabled());
+  return 1;
+}
+
+static int Panel_IsEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsEnabled());
+  return 1;
+}
+
+static int Panel_IsKeyBindingChainToParentAllowed (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsKeyBindingChainToParentAllowed());
+  return 1;
+}
+
+static int Panel_IsKeyBoardInputEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsKeyBoardInputEnabled());
+  return 1;
+}
+
+static int Panel_IsKeyOverridden (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsKeyOverridden((KeyCode)luaL_checkint(L, 2), luaL_checkint(L, 3)));
+  return 1;
+}
+
+static int Panel_IsKeyRebound (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsKeyRebound((KeyCode)luaL_checkint(L, 2), luaL_checkint(L, 3)));
+  return 1;
+}
+
+static int Panel_IsLayoutInvalid (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsLayoutInvalid());
+  return 1;
+}
+
+static int Panel_IsMouseInputDisabledForThisPanel (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsMouseInputDisabledForThisPanel());
+  return 1;
+}
+
+static int Panel_IsMouseInputEnabled (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsMouseInputEnabled());
+  return 1;
+}
+
+static int Panel_IsOpaque (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsOpaque());
+  return 1;
+}
+
+static int Panel_IsPopup (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsPopup());
+  return 1;
+}
+
+static int Panel_IsProportional (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsProportional());
+  return 1;
+}
+
+static int Panel_IsRightAligned (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsRightAligned());
+  return 1;
+}
+
+static int Panel_IsStartDragWhenMouseExitsPanel (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsStartDragWhenMouseExitsPanel());
+  return 1;
+}
+
+static int Panel_IsTriplePressAllowed (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsTriplePressAllowed());
+  return 1;
+}
+
+static int Panel_IsValidKeyBindingsContext (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsValidKeyBindingsContext());
+  return 1;
+}
+
+static int Panel_IsVisible (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsVisible());
+  return 1;
+}
+
+static int Panel_IsWithin (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsWithin(luaL_checkint(L, 2), luaL_checkint(L, 3)));
+  return 1;
+}
+
+static int Panel_IsWithinTraverse (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->IsWithinTraverse(luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkboolean(L, 4)));
+  return 1;
+}
+
+static int Panel_KB_AddBoundKey (lua_State *L) {
+  luaL_checkpanel(L, 1)->KB_AddBoundKey(luaL_checkstring(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int Panel_KB_ChainToMap (lua_State *L) {
+  luaL_checkpanel(L, 1)->KB_ChainToMap();
+  return 0;
+}
+
+static int Panel_KeyCodeToString (lua_State *L) {
+  lua_pushstring(L, luaL_checkpanel(L, 1)->KeyCodeToString((KeyCode)luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int Panel_LocalToScreen (lua_State *L) {
+  int x, y;
+  luaL_checkpanel(L, 1)->LocalToScreen(x, y);
+  lua_pushinteger(L, x);
+  lua_pushinteger(L, y);
+  return 2;
+}
+
+static int Panel_MakePopup (lua_State *L) {
+  luaL_checkpanel(L, 1)->MakePopup(luaL_optboolean(L, 2, 1), luaL_optboolean(L, 3, 0));
+  return 0;
+}
+
+static int Panel_MakeReadyForUse (lua_State *L) {
+  luaL_checkpanel(L, 1)->MakeReadyForUse();
+  return 0;
+}
+
+static int Panel_MarkForDeletion (lua_State *L) {
+  luaL_checkpanel(L, 1)->MarkForDeletion();
+  return 0;
+}
+
+static int Panel_MoveToFront (lua_State *L) {
+  luaL_checkpanel(L, 1)->MoveToFront();
+  return 0;
+}
+
+static int Panel_OnCommand (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnCommand(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int Panel_OnCursorEntered (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnCursorEntered();
+  return 0;
+}
+
+static int Panel_OnCursorExited (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnCursorExited();
+  return 0;
+}
+
+static int Panel_OnCursorMoved (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnCursorMoved(luaL_checkint(L, 2), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int Panel_OnDelete (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnDelete();
+  return 0;
+}
+
+static int Panel_OnDraggablePanelPaint (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnDraggablePanelPaint();
+  return 0;
+}
+
+static int Panel_OnKeyCodePressed (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnKeyCodePressed((KeyCode)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_OnKeyCodeTyped (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnKeyCodeTyped((KeyCode)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_OnKeyFocusTicked (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnKeyFocusTicked();
+  return 0;
+}
+
+static int Panel_OnKillFocus (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnKillFocus();
+  return 0;
+}
+
+static int Panel_OnMouseCaptureLost (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnMouseCaptureLost();
+  return 0;
+}
+
+static int Panel_OnMouseDoublePressed (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnMouseDoublePressed((MouseCode)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_OnMouseFocusTicked (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnMouseFocusTicked();
+  return 0;
+}
+
+static int Panel_OnMousePressed (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnMousePressed((MouseCode)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_OnMouseReleased (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnMouseReleased((MouseCode)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_OnMouseTriplePressed (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnMouseTriplePressed((MouseCode)luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_OnMouseWheeled (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnMouseWheeled(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_OnMove (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnMove();
+  return 0;
+}
+
+static int Panel_OnSetFocus (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnSetFocus();
+  return 0;
+}
+
+static int Panel_OnSizeChanged (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnSizeChanged(luaL_checkint(L, 2), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int Panel_OnThink (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnThink();
+  return 0;
+}
+
+static int Panel_OnTick (lua_State *L) {
+  luaL_checkpanel(L, 1)->OnTick();
+  return 0;
+}
+
+static int Panel_Paint (lua_State *L) {
+  luaL_checkpanel(L, 1)->Paint();
+  return 0;
+}
+
+static int Panel_PaintBackground (lua_State *L) {
+  luaL_checkpanel(L, 1)->PaintBackground();
+  return 0;
+}
+
+static int Panel_PaintBorder (lua_State *L) {
+  luaL_checkpanel(L, 1)->PaintBorder();
+  return 0;
+}
+
+static int Panel_PaintBuildOverlay (lua_State *L) {
+  luaL_checkpanel(L, 1)->PaintBuildOverlay();
+  return 0;
+}
+
+static int Panel_ParentLocalToScreen (lua_State *L) {
+  int x, y;
+  luaL_checkpanel(L, 1)->ParentLocalToScreen(x, y);
+  lua_pushinteger(L, x);
+  lua_pushinteger(L, y);
+  return 2;
+}
+
+static int Panel_PerformLayout (lua_State *L) {
+  luaL_checkpanel(L, 1)->PerformLayout();
+  return 0;
+}
+
+static int Panel_PostChildPaint (lua_State *L) {
+  luaL_checkpanel(L, 1)->PostChildPaint();
+  return 0;
+}
+
+static int Panel_ReloadKeyBindings (lua_State *L) {
+  luaL_checkpanel(L, 1)->ReloadKeyBindings();
+  return 0;
+}
+
+static int Panel_RemoveActionSignalTarget (lua_State *L) {
+  luaL_checkpanel(L, 1)->RemoveActionSignalTarget(luaL_checkpanel(L, 2));
+  return 0;
+}
+
+static int Panel_RemoveAllKeyBindings (lua_State *L) {
+  luaL_checkpanel(L, 1)->RemoveAllKeyBindings();
+  return 0;
+}
+
+static int Panel_Repaint (lua_State *L) {
+  luaL_checkpanel(L, 1)->Repaint();
+  return 0;
+}
+
+static int Panel_RequestFocus (lua_State *L) {
+  luaL_checkpanel(L, 1)->RequestFocus(luaL_optint(L, 2, 0));
+  return 0;
+}
+
+static int Panel_RevertKeyBindingsToDefault (lua_State *L) {
+  luaL_checkpanel(L, 1)->RevertKeyBindingsToDefault();
+  return 0;
+}
+
+static int Panel_ScreenToLocal (lua_State *L) {
+  int x, y;
+  luaL_checkpanel(L, 1)->ScreenToLocal(x, y);
+  lua_pushinteger(L, x);
+  lua_pushinteger(L, y);
+  return 2;
+}
+
+static int Panel_SetAllowKeyBindingChainToParent (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetAllowKeyBindingChainToParent(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetAlpha (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetAlpha(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_SetAutoDelete (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetAutoDelete(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetAutoResize (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetAutoResize((Panel::PinCorner_e)luaL_checkint(L, 2), (Panel::AutoResize_e)luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5), luaL_checkint(L, 6), luaL_checkint(L, 7));
+  return 0;
+}
+
+static int Panel_SetBgColor (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetBgColor(luaL_checkcolor(L, 2));
+  return 0;
+}
+
+static int Panel_SetBlockDragChaining (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetBlockDragChaining(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetBounds (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetBounds(luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4), luaL_checkint(L, 5));
+  return 0;
+}
+
+static int Panel_SetBuildModeDeletable (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetBuildModeDeletable(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetBuildModeEditable (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetBuildModeEditable(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetDragEnabled (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetDragEnabled(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetDragSTartTolerance (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetDragSTartTolerance(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_SetDropEnabled (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetDropEnabled(luaL_checkboolean(L, 2), luaL_optnumber(L, 3, 0.0f));
+  return 0;
+}
+
+static int Panel_SetEnabled (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetEnabled(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetFgColor (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetFgColor(luaL_checkcolor(L, 2));
+  return 0;
+}
+
+static int Panel_SetKeyBoardInputEnabled (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetKeyBoardInputEnabled(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetMinimumSize (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetMinimumSize(luaL_checkint(L, 2), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int Panel_SetMouseInputEnabled (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetMouseInputEnabled(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetName (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetName(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int Panel_SetPaintBackgroundEnabled (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetPaintBackgroundEnabled(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetPaintBackgroundType (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetPaintBackgroundType(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_SetPaintBorderEnabled (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetPaintBorderEnabled(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetPaintEnabled (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetPaintEnabled(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetParent (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetParent(luaL_checkpanel(L, 2));
+  return 0;
+}
+
+static int Panel_SetPinCorner (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetPinCorner((Panel::PinCorner_e)luaL_checkint(L, 2), luaL_checkint(L, 3), luaL_checkint(L, 4));
+  return 0;
+}
+
+static int Panel_SetPos (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetPos(luaL_checkint(L, 2), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int Panel_SetPostChildPaintEnabled (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetPostChildPaintEnabled(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetProportional (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetProportional(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetScheme (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetScheme(luaL_checkstring(L, 2));
+  return 0;
+}
+
+static int Panel_SetSilentMode (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetSilentMode(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetSize (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetSize(luaL_checkint(L, 2), luaL_checkint(L, 3));
+  return 0;
+}
+
+static int Panel_SetSkipChildDuringPainting (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetSkipChildDuringPainting(luaL_checkpanel(L, 2));
+  return 0;
+}
+
+static int Panel_SetStartDragWhenMouseExitsPanel (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetStartDragWhenMouseExitsPanel(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetTabPosition (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetTabPosition(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_SetTall (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetTall(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_SetTriplePressAllowed (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetTriplePressAllowed(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetVisible (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetVisible(luaL_checkboolean(L, 2));
+  return 0;
+}
+
+static int Panel_SetWide (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetWide(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_SetZPos (lua_State *L) {
+  luaL_checkpanel(L, 1)->SetZPos(luaL_checkint(L, 2));
+  return 0;
+}
+
+static int Panel_ShouldHandleInputMessage (lua_State *L) {
+  lua_pushboolean(L, luaL_checkpanel(L, 1)->ShouldHandleInputMessage());
+  return 1;
+}
+
+static int Panel_StringToKeyCode (lua_State *L) {
+  lua_pushinteger(L, luaL_checkpanel(L, 1)->StringToKeyCode(luaL_checkstring(L, 2)));
+  return 1;
+}
+
+static int Panel___index (lua_State *L) {
+  Panel *pPanel = lua_topanel(L, 1);
+  if (pPanel == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+	lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+	return lua_error(L);
+  }
+  LPanel *plPanel = dynamic_cast<LPanel *>(pPanel);
+  if (plPanel && plPanel->m_nTableReference != LUA_NOREF) {
+    lua_getref(L, plPanel->m_nTableReference);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 2);
+      lua_getmetatable(L, 1);
+      lua_pushvalue(L, 2);
+      lua_gettable(L, -2);
+    }
+  } else {
+    lua_getmetatable(L, 1);
+    lua_pushvalue(L, 2);
+    lua_gettable(L, -2);
+  }
+  return 1;
+}
+
+static int Panel___newindex (lua_State *L) {
+  Panel *pPanel = lua_topanel(L, 1);
+  if (pPanel == NULL) {  /* avoid extra test when d is not 0 */
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index an INVALID_PANEL", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+  LPanel *plPanel = dynamic_cast<LPanel *>(pPanel);
+  if (plPanel) {
+    if (plPanel->m_nTableReference == LUA_NOREF) {
+      lua_newtable(L);
+      plPanel->m_nTableReference = luaL_ref(L, LUA_REGISTRYINDEX);
+    }
+    lua_getref(L, plPanel->m_nTableReference);
+    lua_pushvalue(L, 3);
+    lua_setfield(L, -2, luaL_checkstring(L, 2));
+	lua_pop(L, 1);
+    return 0;
+  } else {
+    lua_Debug ar1;
+    lua_getstack(L, 1, &ar1);
+    lua_getinfo(L, "fl", &ar1);
+    lua_Debug ar2;
+    lua_getinfo(L, ">S", &ar2);
+    lua_pushfstring(L, "%s:%d: attempt to index a non-scripted panel", ar2.short_src, ar1.currentline);
+    return lua_error(L);
+  }
+}
+
+static int Panel___gc (lua_State *L) {
+  LPanel *plPanel = dynamic_cast<LPanel *>(lua_topanel(L, 1));
+  if (plPanel) {
+    --plPanel->m_nRefCount;
+	if (plPanel->m_nRefCount <= 0) {
+      delete plPanel;
+    }
+  }
+  return 0;
+}
+
+static int Panel___eq (lua_State *L) {
+  lua_pushboolean(L, lua_topanel(L, 1) == lua_topanel(L, 2));
+  return 1;
+}
+
+static int Panel___tostring (lua_State *L) {
+  Panel *pPanel = lua_topanel(L, 1);
+  if (pPanel == NULL)
+    lua_pushstring(L, "INVALID_PANEL");
+  else {
+    const char *pName = pPanel->GetName();
+    if (Q_strcmp(pName, "") == 0)
+      pName = "(no name)";
+    lua_pushfstring(L, "Panel: \"%s\"", pName);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg Panelmeta[] = {
+  {"AddKeyBinding", Panel_AddKeyBinding},
+  {"AddActionSignalTarget", Panel_AddActionSignalTarget},
+  {"CanStartDragging", Panel_CanStartDragging},
+  {"ChainToAnimationMap", Panel_ChainToAnimationMap},
+  {"ChainToMap", Panel_ChainToMap},
+  {"DeletePanel", Panel_DeletePanel},
+  {"DisableMouseInputForThisPanel", Panel_DisableMouseInputForThisPanel},
+  {"DrawBox", Panel_DrawBox},
+  {"DrawBoxFade", Panel_DrawBoxFade},
+  {"DrawHollowBox", Panel_DrawHollowBox},
+  {"DrawTexturedBox", Panel_DrawTexturedBox},
+  {"EditKeyBindings", Panel_EditKeyBindings},
+  {"FillRectSkippingPanel", Panel_FillRectSkippingPanel},
+  {"FindChildByName", Panel_FindChildByName},
+  {"FindChildIndexByName", Panel_FindChildIndexByName},
+  {"FindSiblingByName", Panel_FindSiblingByName},
+  {"GetAlpha", Panel_GetAlpha},
+  {"GetBgColor", Panel_GetBgColor},
+  {"GetBounds", Panel_GetBounds},
+  {"GetChild", Panel_GetChild},
+  {"GetChildCount", Panel_GetChildCount},
+  {"GetClassName", Panel_GetClassName},
+  {"GetClipRect", Panel_GetClipRect},
+  {"GetCornerTextureSize", Panel_GetCornerTextureSize},
+  {"GetDescription", Panel_GetDescription},
+  {"GetDragFrameColor", Panel_GetDragFrameColor},
+  {"GetDragPanel", Panel_GetDragPanel},
+  {"GetDragStartTolerance", Panel_GetDragStartTolerance},
+  {"GetDropFrameColor", Panel_GetDropFrameColor},
+  {"GetFgColor", Panel_GetFgColor},
+  {"GetInset", Panel_GetInset},
+  {"GetKeyBindingsFile", Panel_GetKeyBindingsFile},
+  {"GetKeyBindingsFilePathID", Panel_GetKeyBindingsFilePathID},
+  {"GetKeyMappingCount", Panel_GetKeyMappingCount},
+  {"GetMinimumSize", Panel_GetMinimumSize},
+  {"GetModuleName", Panel_GetModuleName},
+  {"GetName", Panel_GetName},
+  {"GetPaintBackgroundType", Panel_GetPaintBackgroundType},
+  {"GetPaintSize", Panel_GetPaintSize},
+  {"GetPanelBaseClassName", Panel_GetPanelBaseClassName},
+  {"GetPanelClassName", Panel_GetPanelClassName},
+  {"GetParent", Panel_GetParent},
+  {"GetPinCorner", Panel_GetPinCorner},
+  {"GetPinOffset", Panel_GetPinOffset},
+  {"GetPos", Panel_GetPos},
+  {"GetRefTable", Panel_GetRefTable},
+  {"GetResizeOffset", Panel_GetResizeOffset},
+  {"GetSize", Panel_GetSize},
+  {"GetTabPosition", Panel_GetTabPosition},
+  {"GetTall", Panel_GetTall},
+  {"GetVPanel", Panel_GetVPanel},
+  {"GetVParent", Panel_GetVParent},
+  {"GetWide", Panel_GetWide},
+  {"GetZPos", Panel_GetZPos},
+  {"HasFocus", Panel_HasFocus},
+  {"HasUserConfigSettings", Panel_HasUserConfigSettings},
+  {"InitPropertyConverters", Panel_InitPropertyConverters},
+  {"InvalidateLayout", Panel_InvalidateLayout},
+  {"IsAutoDeleteSet", Panel_IsAutoDeleteSet},
+  {"IsBeingDragged", Panel_IsBeingDragged},
+  {"IsBlockingDragChaining", Panel_IsBlockingDragChaining},
+  {"IsBottomAligned", Panel_IsBottomAligned},
+  {"IsBuildGroupEnabled", Panel_IsBuildGroupEnabled},
+  {"IsBuildModeActive", Panel_IsBuildModeActive},
+  {"IsBuildModeDeletable", Panel_IsBuildModeDeletable},
+  {"IsBuildModeEditable", Panel_IsBuildModeEditable},
+  {"IsChildOfModalSubTree", Panel_IsChildOfModalSubTree},
+  {"IsChildOfSurfaceModalPanel", Panel_IsChildOfSurfaceModalPanel},
+  {"IsCursorNone", Panel_IsCursorNone},
+  {"IsCursorOver", Panel_IsCursorOver},
+  {"IsDragEnabled", Panel_IsDragEnabled},
+  {"IsDropEnabled", Panel_IsDropEnabled},
+  {"IsEnabled", Panel_IsEnabled},
+  {"IsKeyBindingChainToParentAllowed", Panel_IsKeyBindingChainToParentAllowed},
+  {"IsKeyBoardInputEnabled", Panel_IsKeyBoardInputEnabled},
+  {"IsKeyOverridden", Panel_IsKeyOverridden},
+  {"IsKeyRebound", Panel_IsKeyRebound},
+  {"IsLayoutInvalid", Panel_IsLayoutInvalid},
+  {"IsMouseInputDisabledForThisPanel", Panel_IsMouseInputDisabledForThisPanel},
+  {"IsMouseInputEnabled", Panel_IsMouseInputEnabled},
+  {"IsOpaque", Panel_IsOpaque},
+  {"IsPopup", Panel_IsPopup},
+  {"IsProportional", Panel_IsProportional},
+  {"IsRightAligned", Panel_IsRightAligned},
+  {"IsStartDragWhenMouseExitsPanel", Panel_IsStartDragWhenMouseExitsPanel},
+  {"IsTriplePressAllowed", Panel_IsTriplePressAllowed},
+  {"IsValidKeyBindingsContext", Panel_IsValidKeyBindingsContext},
+  {"IsVisible", Panel_IsVisible},
+  {"IsWithin", Panel_IsWithin},
+  {"IsWithinTraverse", Panel_IsWithinTraverse},
+  {"KB_AddBoundKey", Panel_KB_AddBoundKey},
+  {"KB_ChainToMap", Panel_KB_ChainToMap},
+  {"KeyCodeToString", Panel_KeyCodeToString},
+  {"LocalToScreen", Panel_LocalToScreen},
+  {"MakePopup", Panel_MakePopup},
+  {"MakeReadyForUse", Panel_MakeReadyForUse},
+  {"MarkForDeletion", Panel_MarkForDeletion},
+  {"MoveToFront", Panel_MoveToFront},
+  {"OnCommand", Panel_OnCommand},
+  {"OnCursorEntered", Panel_OnCursorEntered},
+  {"OnCursorExited", Panel_OnCursorExited},
+  {"OnCursorMoved", Panel_OnCursorMoved},
+  {"OnDelete", Panel_OnDelete},
+  {"OnDraggablePanelPaint", Panel_OnDraggablePanelPaint},
+  {"OnKeyCodePressed", Panel_OnKeyCodePressed},
+  {"OnKeyCodeTyped", Panel_OnKeyCodeTyped},
+  {"OnKeyFocusTicked", Panel_OnKeyFocusTicked},
+  {"OnKillFocus", Panel_OnKillFocus},
+  {"OnMouseCaptureLost", Panel_OnMouseCaptureLost},
+  {"OnMouseDoublePressed", Panel_OnMouseDoublePressed},
+  {"OnMouseFocusTicked", Panel_OnMouseFocusTicked},
+  {"OnMousePressed", Panel_OnMousePressed},
+  {"OnMouseReleased", Panel_OnMouseReleased},
+  {"OnMouseTriplePressed", Panel_OnMouseTriplePressed},
+  {"OnMouseWheeled", Panel_OnMouseWheeled},
+  {"OnMove", Panel_OnMove},
+  {"OnSetFocus", Panel_OnSetFocus},
+  {"OnSizeChanged", Panel_OnSizeChanged},
+  {"OnThink", Panel_OnThink},
+  {"OnTick", Panel_OnTick},
+  {"Paint", Panel_Paint},
+  {"PaintBackground", Panel_PaintBackground},
+  {"PaintBorder", Panel_PaintBorder},
+  {"PaintBuildOverlay", Panel_PaintBuildOverlay},
+  {"ParentLocalToScreen", Panel_ParentLocalToScreen},
+  {"PerformLayout", Panel_PerformLayout},
+  {"PostChildPaint", Panel_PostChildPaint},
+  {"ReloadKeyBindings", Panel_ReloadKeyBindings},
+  {"RemoveActionSignalTarget", Panel_RemoveActionSignalTarget},
+  {"RemoveAllKeyBindings", Panel_RemoveAllKeyBindings},
+  {"Repaint", Panel_Repaint},
+  {"RequestFocus", Panel_RequestFocus},
+  {"RevertKeyBindingsToDefault", Panel_RevertKeyBindingsToDefault},
+  {"ScreenToLocal", Panel_ScreenToLocal},
+  {"SetAllowKeyBindingChainToParent", Panel_SetAllowKeyBindingChainToParent},
+  {"SetAlpha", Panel_SetAlpha},
+  {"SetAutoDelete", Panel_SetAutoDelete},
+  {"SetAutoResize", Panel_SetAutoResize},
+  {"SetBgColor", Panel_SetBgColor},
+  {"SetBlockDragChaining", Panel_SetBlockDragChaining},
+  {"SetBounds", Panel_SetBounds},
+  {"SetBuildModeDeletable", Panel_SetBuildModeDeletable},
+  {"SetBuildModeEditable", Panel_SetBuildModeEditable},
+  {"SetDragEnabled", Panel_SetDragEnabled},
+  {"SetDragSTartTolerance", Panel_SetDragSTartTolerance},
+  {"SetDropEnabled", Panel_SetDropEnabled},
+  {"SetEnabled", Panel_SetEnabled},
+  {"SetFgColor", Panel_SetFgColor},
+  {"SetKeyBoardInputEnabled", Panel_SetKeyBoardInputEnabled},
+  {"SetMinimumSize", Panel_SetMinimumSize},
+  {"SetMouseInputEnabled", Panel_SetMouseInputEnabled},
+  {"SetName", Panel_SetName},
+  {"SetPaintBackgroundEnabled", Panel_SetPaintBackgroundEnabled},
+  {"SetPaintBackgroundType", Panel_SetPaintBackgroundType},
+  {"SetPaintBorderEnabled", Panel_SetPaintBorderEnabled},
+  {"SetPaintEnabled", Panel_SetPaintEnabled},
+  {"SetParent", Panel_SetParent},
+  {"SetPinCorner", Panel_SetPinCorner},
+  {"SetPos", Panel_SetPos},
+  {"SetPostChildPaintEnabled", Panel_SetPostChildPaintEnabled},
+  {"SetProportional", Panel_SetProportional},
+  {"SetScheme", Panel_SetScheme},
+  {"SetSilentMode", Panel_SetSilentMode},
+  {"SetSize", Panel_SetSize},
+  {"SetSkipChildDuringPainting", Panel_SetSkipChildDuringPainting},
+  {"SetStartDragWhenMouseExitsPanel", Panel_SetStartDragWhenMouseExitsPanel},
+  {"SetTabPosition", Panel_SetTabPosition},
+  {"SetTall", Panel_SetTall},
+  {"SetTriplePressAllowed", Panel_SetTriplePressAllowed},
+  {"SetVisible", Panel_SetVisible},
+  {"SetWide", Panel_SetWide},
+  {"SetZPos", Panel_SetZPos},
+  {"ShouldHandleInputMessage", Panel_ShouldHandleInputMessage},
+  {"StringToKeyCode", Panel_StringToKeyCode},
+  {"__index", Panel___index},
+  {"__newindex", Panel___newindex},
+  {"__gc", Panel___gc},
+  {"__eq", Panel___eq},
+  {"__tostring", Panel___tostring},
+  {NULL, NULL}
+};
+
+
+static int luasrc_VGui_GetGameUIPanel (lua_State *L) {
+  lua_pushpanel(L, VGui_GetGameUIPanel());
+  return 1;
+}
+
+static int luasrc_VGui_GetClientLuaRootPanel (lua_State *L) {
+  lua_pushpanel(L, VGui_GetClientLuaRootPanel());
+  return 1;
+}
+
+
+static const luaL_Reg Panel_funcs[] = {
+  {"VGui_GetGameUIPanel", luasrc_VGui_GetGameUIPanel},
+  {"VGui_GetClientLuaRootPanel", luasrc_VGui_GetClientLuaRootPanel},
+  {NULL, NULL}
+};
+
+
+/*
+** Open Panel object
+*/
+LUALIB_API int luaopen_Panel (lua_State *L) {
+  luaL_newmetatable(L, "Panel");
+  luaL_register(L, NULL, Panelmeta);
+  lua_pushstring(L, "panel");
+  lua_setfield(L, -2, "__type");  /* metatable.__type = "panel" */
+  luaL_register(L, "_G", Panel_funcs);
+  lua_pop(L, 1);
+  // Andrew; Don't be mislead, INVALID_PANEL is not NULL internally, but we
+  // need a name other than NULL, because NULL has already been assigned as an
+  // entity.
+  lua_pushpanel(L, (Panel *)0);
+  lua_setglobal(L, "INVALID_PANEL");  /* set global INVALID_PANEL */
+  return 1;
+}
+
diff --git a/src/public/vgui_controls/lPanel.h b/src/public/vgui_controls/lPanel.h
new file mode 100644
index 0000000..d727d9e
--- /dev/null
+++ b/src/public/vgui_controls/lPanel.h
@@ -0,0 +1,45 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: 
+//
+// $NoKeywords: $
+//===========================================================================//
+
+#ifndef LPANEL_H
+#define LPANEL_H
+
+#ifdef _WIN32
+#pragma once
+#endif
+
+#include <vgui_controls/Panel.h>
+
+using namespace vgui;
+
+/* type for Panel functions */
+typedef Panel lua_Panel;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_Panel     *(lua_topanel) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushpanel) (lua_State *L, lua_Panel *pPanel);
+LUA_API void  (lua_pushpanel) (lua_State *L, VPANEL panel);
+
+
+
+LUALIB_API lua_Panel *(luaL_checkpanel) (lua_State *L, int narg);
+LUALIB_API VPANEL     (luaL_checkvpanel) (lua_State *L, int narg);
+LUALIB_API lua_Panel *(luaL_optpanel) (lua_State *L, int narg,
+                                                     lua_Panel *def);
+
+
+#endif // LPANEL_H
diff --git a/src/public/vgui_controls/lvgui_controls.cpp b/src/public/vgui_controls/lvgui_controls.cpp
new file mode 100644
index 0000000..8fb3b6f
--- /dev/null
+++ b/src/public/vgui_controls/lvgui_controls.cpp
@@ -0,0 +1,29 @@
+//====== Copyright  1996-2005, Valve Corporation, All rights reserved. =======
+//
+// Purpose: 
+//
+//=============================================================================
+#define lvgui_controls_cpp
+
+#include "cbase.h"
+#include "lua.hpp"
+#include "lControls.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** Open vgui library
+*/
+LUALIB_API int luaopen_vgui (lua_State *L) {
+  luaopen_vgui_Button(L);
+  luaopen_vgui_EditablePanel(L);
+  luaopen_vgui_Panel(L);
+  luaopen_vgui_CheckButton(L);
+  luaopen_vgui_Frame(L);
+  luaopen_vgui_PropertyDialog(L);
+  luaopen_vgui_PropertyPage(L);
+  return 0;
+}
+
diff --git a/src/public/vgui_controls/phandle.h b/src/public/vgui_controls/phandle.h
index 18d7302..712f778 100644
--- a/src/public/vgui_controls/phandle.h
+++ b/src/public/vgui_controls/phandle.h
@@ -38,7 +38,9 @@ public:
 	bool operator == (Panel *pPanel)		{ return (Get() == pPanel); }
 	operator bool ()						{ return Get() != 0; }
 
+#ifndef LUA_SDK
 private:
+#endif
 	HPanel m_iPanelID;
 };
 
diff --git a/src/public/vgui_controls/propertydialog.h b/src/public/vgui_controls/propertydialog.h
index 2c3d144..c586567 100644
--- a/src/public/vgui_controls/propertydialog.h
+++ b/src/public/vgui_controls/propertydialog.h
@@ -70,7 +70,11 @@ protected:
 	MESSAGE_FUNC( OnApplyButtonEnable, "ApplyButtonEnable" );
 	void EnableApplyButton(bool bEnable);
 	
+#ifndef LUA_SDK
 private:
+#else
+protected:
+#endif
 	PropertySheet *_propertySheet;
 	Button *_okButton;
 	Button *_cancelButton;
diff --git a/src/public/vphysics/lperformance.cpp b/src/public/vphysics/lperformance.cpp
new file mode 100644
index 0000000..16a5fe3
--- /dev/null
+++ b/src/public/vphysics/lperformance.cpp
@@ -0,0 +1,88 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+//=============================================================================//
+
+#define lperformance_cpp
+
+#include "cbase.h"
+#include "performance.h"
+#include "lua.hpp"
+#include "lperformance.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API lua_Physics_performanceparams_t lua_toperformanceparams (lua_State *L, int idx) {
+  luaL_checktype(L, idx, LUA_TTABLE);
+  physics_performanceparams_t params;
+  params.Defaults();
+  lua_getfield(L, idx, "maxCollisionsPerObjectPerTimestep");
+  if (!lua_isnil(L, -1))
+    params.maxCollisionsPerObjectPerTimestep = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "maxCollisionChecksPerTimestep");
+  if (!lua_isnil(L, -1))
+    params.maxCollisionChecksPerTimestep = luaL_checkint(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "maxVelocity");
+  if (!lua_isnil(L, -1))
+    params.maxVelocity = luaL_checknumber(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "maxAngularVelocity");
+  if (!lua_isnil(L, -1))
+    params.maxAngularVelocity = luaL_checknumber(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "lookAheadTimeObjectsVsWorld");
+  if (!lua_isnil(L, -1))
+    params.lookAheadTimeObjectsVsWorld = luaL_checknumber(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "lookAheadTimeObjectsVsObject");
+  if (!lua_isnil(L, -1))
+    params.lookAheadTimeObjectsVsObject = luaL_checknumber(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "minFrictionMass");
+  if (!lua_isnil(L, -1))
+    params.minFrictionMass = luaL_checknumber(L, -1);
+  lua_pop(L, 1);
+  lua_getfield(L, idx, "maxFrictionMass");
+  if (!lua_isnil(L, -1))
+    params.maxFrictionMass = luaL_checknumber(L, -1);
+  lua_pop(L, 1);
+  return params;
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushperformanceparams (lua_State *L, lua_Physics_performanceparams_t *pOutput) {
+  lua_newtable(L);
+  lua_pushinteger(L, pOutput->maxCollisionChecksPerTimestep);
+  lua_setfield(L, -2, "maxCollisionsPerObjectPerTimestep");
+  lua_pushinteger(L, pOutput->maxCollisionChecksPerTimestep);
+  lua_setfield(L, -2, "maxCollisionChecksPerTimestep");
+  lua_pushnumber(L, pOutput->maxVelocity);
+  lua_setfield(L, -2, "maxVelocity");
+  lua_pushnumber(L, pOutput->maxAngularVelocity);
+  lua_setfield(L, -2, "maxAngularVelocity");
+  lua_pushnumber(L, pOutput->lookAheadTimeObjectsVsWorld);
+  lua_setfield(L, -2, "lookAheadTimeObjectsVsWorld");
+  lua_pushnumber(L, pOutput->lookAheadTimeObjectsVsObject);
+  lua_setfield(L, -2, "lookAheadTimeObjectsVsObject");
+  lua_pushnumber(L, pOutput->minFrictionMass);
+  lua_setfield(L, -2, "minFrictionMass");
+  lua_pushnumber(L, pOutput->maxFrictionMass);
+  lua_setfield(L, -2, "maxFrictionMass");
+}
+
diff --git a/src/public/vphysics/lperformance.h b/src/public/vphysics/lperformance.h
new file mode 100644
index 0000000..2179d30
--- /dev/null
+++ b/src/public/vphysics/lperformance.h
@@ -0,0 +1,34 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+//=============================================================================//
+
+#ifndef LPERFORMANCE_H
+#define LPERFORMANCE_H
+#ifdef _WIN32
+#pragma once
+#endif
+
+#pragma warning (disable : 4238)
+
+
+/* type for physics_performanceparams_t in Lua */
+typedef physics_performanceparams_t lua_Physics_performanceparams_t;
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API lua_Physics_performanceparams_t      (lua_toperformanceparams) (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  (lua_pushperformanceparams) (lua_State *L, lua_Physics_performanceparams_t *pOutput);
+
+
+#endif // LPERFORMANCE_H
diff --git a/src/public/vstdlib/lrandom.cpp b/src/public/vstdlib/lrandom.cpp
new file mode 100644
index 0000000..5b0787d
--- /dev/null
+++ b/src/public/vstdlib/lrandom.cpp
@@ -0,0 +1,97 @@
+//===== Copyright  1996-2005, Valve Corporation, All rights reserved. ======//
+//
+// Purpose: Random number generator
+//
+// $Workfile: $
+// $NoKeywords: $
+//===========================================================================//
+
+#define lrandom_cpp
+
+#include "cbase.h"
+#include "lua.hpp"
+#include "luasrclib.h"
+
+// memdbgon must be the last include file in a .cpp file!!!
+#include "tier0/memdbgon.h"
+
+
+
+static int random_RandomFloat (lua_State *L) {
+  lua_pushnumber(L, random->RandomFloat(luaL_optnumber(L, 1, 0.0f), luaL_optnumber(L, 2, 0.0f)));
+  return 1;
+}
+
+static int random_RandomFloatExp (lua_State *L) {
+  lua_pushnumber(L, random->RandomFloatExp(luaL_optnumber(L, 1, 0.0f), luaL_optnumber(L, 2, 0.0f), luaL_optnumber(L, 3, 1.0f)));
+  return 1;
+}
+
+static int random_RandomInt (lua_State *L) {
+  lua_pushinteger(L, random->RandomInt(luaL_checkint(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int random_SetSeed (lua_State *L) {
+  random->SetSeed(luaL_checkint(L, 1));
+  return 0;
+}
+
+
+static const luaL_Reg randomlib[] = {
+  {"RandomFloat",   random_RandomFloat},
+  {"RandomFloatExp",   random_RandomFloatExp},
+  {"RandomInt",   random_RandomInt},
+  {"SetSeed",   random_SetSeed},
+  {NULL, NULL}
+};
+
+
+#if 0
+static int luasrc_RandomSeed (lua_State *L) {
+  RandomSeed(luaL_checkint(L, 1));
+  return 0;
+}
+
+static int luasrc_RandomFloat (lua_State *L) {
+  lua_pushnumber(L, RandomFloat(luaL_optnumber(L, 1, 0.0f), luaL_optnumber(L, 2, 0.0f)));
+  return 1;
+}
+
+static int luasrc_RandomFloatExp (lua_State *L) {
+  lua_pushnumber(L, RandomFloatExp(luaL_optnumber(L, 1, 0.0f), luaL_optnumber(L, 2, 1.0f), luaL_optnumber(L, 3, 1.0f)));
+  return 1;
+}
+
+static int luasrc_RandomInt (lua_State *L) {
+  lua_pushinteger(L, RandomInt(luaL_checkint(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+static int luasrc_RandomGaussianFloat (lua_State *L) {
+  lua_pushnumber(L, RandomGaussianFloat(luaL_optnumber(L, 1, 0.0f), luaL_optnumber(L, 2, 1.0f)));
+  return 1;
+}
+
+
+static const luaL_Reg random_funcs[] = {
+  {"RandomSeed",  luasrc_RandomSeed},
+  {"RandomFloat",  luasrc_RandomFloat},
+  {"RandomFloatExp",  luasrc_RandomFloatExp},
+  {"RandomInt",  luasrc_RandomInt},
+  {"RandomGaussianFloat",  luasrc_RandomGaussianFloat},
+  {NULL, NULL}
+};
+#endif
+
+
+/*
+** Open random library
+*/
+LUALIB_API int luaopen_random (lua_State *L) {
+  luaL_register(L, LUA_RANDOMLIBNAME, randomlib);
+  // UNDONE: this has always been redundant.
+  // luaL_register(L, "_G", random_funcs);
+  return 1;
+}
+
diff --git a/src/public/zip_utils_src.cpp b/src/public/zip_utils_src.cpp
new file mode 100644
index 0000000..f8727e3
--- /dev/null
+++ b/src/public/zip_utils_src.cpp
@@ -0,0 +1,1663 @@
+//========= Copyright  1996-2005, Valve Corporation, All rights reserved. ============//
+//
+// Purpose: 
+//
+//=============================================================================//
+
+#include <cbase.h>
+#include <tier0/platform.h>
+#ifdef IS_WINDOWS_PC
+#ifndef LUA_SDK
+#include <windows.h>
+#else
+#include <winlite.h>
+#endif
+#endif
+#include "utlbuffer.h"
+#include "utllinkedlist.h"
+#include "zip_utils.h"
+#include "zip_uncompressed.h"
+#include "checksum_crc.h"
+#include "byteswap.h"
+#include "utlstring.h"
+#ifdef LUA_SDK
+#include "filesystem.h"
+#endif
+
+// Data descriptions for byte swapping - only needed
+// for structures that are written to file for use by the game.
+BEGIN_BYTESWAP_DATADESC( ZIP_EndOfCentralDirRecord )
+	DEFINE_FIELD( signature, FIELD_INTEGER ),
+	DEFINE_FIELD( numberOfThisDisk, FIELD_SHORT ),
+	DEFINE_FIELD( numberOfTheDiskWithStartOfCentralDirectory, FIELD_SHORT ),
+	DEFINE_FIELD( nCentralDirectoryEntries_ThisDisk, FIELD_SHORT ),
+	DEFINE_FIELD( nCentralDirectoryEntries_Total, FIELD_SHORT ),
+	DEFINE_FIELD( centralDirectorySize, FIELD_INTEGER ),
+	DEFINE_FIELD( startOfCentralDirOffset, FIELD_INTEGER ),
+	DEFINE_FIELD( commentLength, FIELD_SHORT ),
+END_BYTESWAP_DATADESC()
+
+BEGIN_BYTESWAP_DATADESC( ZIP_FileHeader )
+	DEFINE_FIELD( signature, FIELD_INTEGER ),
+	DEFINE_FIELD( versionMadeBy, FIELD_SHORT ),
+	DEFINE_FIELD( versionNeededToExtract, FIELD_SHORT ),
+	DEFINE_FIELD( flags, FIELD_SHORT ),
+	DEFINE_FIELD( compressionMethod, FIELD_SHORT ),
+	DEFINE_FIELD( lastModifiedTime, FIELD_SHORT ),
+	DEFINE_FIELD( lastModifiedDate, FIELD_SHORT ),
+	DEFINE_FIELD( crc32, FIELD_INTEGER ),
+	DEFINE_FIELD( compressedSize, FIELD_INTEGER ),
+	DEFINE_FIELD( uncompressedSize, FIELD_INTEGER ),
+	DEFINE_FIELD( fileNameLength, FIELD_SHORT ),
+	DEFINE_FIELD( extraFieldLength, FIELD_SHORT ),
+	DEFINE_FIELD( fileCommentLength, FIELD_SHORT ),
+	DEFINE_FIELD( diskNumberStart, FIELD_SHORT ),
+	DEFINE_FIELD( internalFileAttribs, FIELD_SHORT ),
+	DEFINE_FIELD( externalFileAttribs, FIELD_INTEGER ),
+	DEFINE_FIELD( relativeOffsetOfLocalHeader, FIELD_INTEGER ),
+END_BYTESWAP_DATADESC()
+
+#if !defined( SWDS )
+
+BEGIN_BYTESWAP_DATADESC( ZIP_LocalFileHeader )
+	DEFINE_FIELD( signature, FIELD_INTEGER ),
+	DEFINE_FIELD( versionNeededToExtract, FIELD_SHORT ),
+	DEFINE_FIELD( flags, FIELD_SHORT ),
+	DEFINE_FIELD( compressionMethod, FIELD_SHORT ),
+	DEFINE_FIELD( lastModifiedTime, FIELD_SHORT ),
+	DEFINE_FIELD( lastModifiedDate, FIELD_SHORT ),
+	DEFINE_FIELD( crc32, FIELD_INTEGER ),
+	DEFINE_FIELD( compressedSize, FIELD_INTEGER ),
+	DEFINE_FIELD( uncompressedSize, FIELD_INTEGER ),
+	DEFINE_FIELD( fileNameLength, FIELD_SHORT ),
+	DEFINE_FIELD( extraFieldLength, FIELD_SHORT ),
+END_BYTESWAP_DATADESC()
+
+BEGIN_BYTESWAP_DATADESC( ZIP_PreloadHeader )
+	DEFINE_FIELD( Version, FIELD_INTEGER ),
+	DEFINE_FIELD( DirectoryEntries, FIELD_INTEGER ),
+	DEFINE_FIELD( PreloadDirectoryEntries, FIELD_INTEGER ),
+	DEFINE_FIELD( Alignment, FIELD_INTEGER ),
+END_BYTESWAP_DATADESC()
+
+BEGIN_BYTESWAP_DATADESC( ZIP_PreloadDirectoryEntry )
+	DEFINE_FIELD( Length, FIELD_INTEGER ),
+	DEFINE_FIELD( DataOffset, FIELD_INTEGER ),
+END_BYTESWAP_DATADESC()
+
+//-----------------------------------------------------------------------------
+// For >2 GB File Support
+//-----------------------------------------------------------------------------
+class CWin32File
+{
+public:
+	static HANDLE CreateTempFile( CUtlString &WritePath, CUtlString &FileName )
+	{
+		char tempFileName[MAX_PATH];
+		if ( WritePath.IsEmpty() )
+		{
+			// use a safe name in the cwd
+			char *pBuffer = tmpnam( NULL );
+			if ( !pBuffer )
+			{
+				return INVALID_HANDLE_VALUE;
+			}
+			if ( pBuffer[0] == '\\' )
+			{
+				pBuffer++;
+			}
+			if ( pBuffer[strlen( pBuffer )-1] == '.' )
+			{
+				pBuffer[strlen( pBuffer )-1] = '\0';
+			}
+			V_snprintf( tempFileName, sizeof( tempFileName ), "_%s.tmp", pBuffer );
+		}
+		else
+		{
+			// generate safe name at the desired prefix
+			char uniqueFilename[MAX_PATH];
+			SYSTEMTIME sysTime;                                                       \
+			GetLocalTime( &sysTime );   
+			V_snprintf( uniqueFilename, sizeof( uniqueFilename ), "%d_%d_%d_%d_%d.tmp", sysTime.wDay, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds );                                                \
+			V_ComposeFileName( WritePath.String(), uniqueFilename, tempFileName, sizeof( tempFileName ) );
+		}
+
+		FileName = tempFileName;
+		HANDLE hFile = CreateFile( tempFileName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
+		
+		return hFile;
+	}
+
+	static unsigned int FileSeek( HANDLE hFile, unsigned int distance, DWORD MoveMethod )
+	{
+		LARGE_INTEGER li;
+
+		li.QuadPart = distance;
+		li.LowPart = SetFilePointer( hFile, li.LowPart, &li.HighPart, MoveMethod);
+		if ( li.LowPart == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR )
+		{
+			li.QuadPart = -1;
+		}
+
+		return ( unsigned int )li.QuadPart;
+	}
+
+	static unsigned int FileTell( HANDLE hFile )
+	{
+		return FileSeek( hFile, 0, FILE_CURRENT );
+	}
+
+	static bool FileRead( HANDLE hFile, void *pBuffer, unsigned int size )
+	{
+		DWORD numBytesRead;
+		BOOL bSuccess = ::ReadFile( hFile, pBuffer, size, &numBytesRead, NULL );
+		return bSuccess && ( numBytesRead == size );
+	}
+
+	static bool FileWrite( HANDLE hFile, void *pBuffer, unsigned int size )
+	{
+		DWORD numBytesWritten;
+		BOOL bSuccess = WriteFile( hFile, pBuffer, size, &numBytesWritten, NULL );
+		return bSuccess && ( numBytesWritten == size );
+	}
+};
+
+//-----------------------------------------------------------------------------
+// Purpose: Interface to allow abstraction of zip file output methods, and
+// avoid duplication of code. Files may be written to a CUtlBuffer or a filestream
+//-----------------------------------------------------------------------------
+abstract_class IWriteStream
+{
+public:
+	virtual void Put( const void* pMem, int size ) = 0;
+	virtual unsigned int Tell( void ) = 0;
+};
+
+//-----------------------------------------------------------------------------
+// Purpose: Wrapper for CUtlBuffer methods
+//-----------------------------------------------------------------------------
+class CBufferStream : public IWriteStream
+{
+public:
+	CBufferStream( CUtlBuffer& buff ) : IWriteStream(), m_buff( &buff ) {}
+
+	// Implementing IWriteStream method
+	virtual void Put( const void* pMem, int size ) { m_buff->Put( pMem, size ); }
+
+	// Implementing IWriteStream method
+	virtual unsigned int Tell( void ) { return m_buff->TellPut(); }
+
+private:
+	CUtlBuffer *m_buff;
+};
+
+//-----------------------------------------------------------------------------
+// Purpose: Wrapper for file I/O methods
+//-----------------------------------------------------------------------------
+class CFileStream : public IWriteStream
+{
+public:
+#ifndef LUA_SDK
+	CFileStream( FILE *fout ) : IWriteStream(), m_file( fout ), m_hFile( INVALID_HANDLE_VALUE ) {}
+	CFileStream( HANDLE hOutFile ) : IWriteStream(), m_file( NULL ), m_hFile( hOutFile ) {}
+#else
+	CFileStream( FILE *fout ) : IWriteStream(), m_file( fout ), m_hFile( FILESYSTEM_INVALID_HANDLE ) {}
+	CFileStream( FileHandle_t hOutFile ) : IWriteStream(), m_file( NULL ), m_hFile( hOutFile ) {}
+#endif
+
+	// Implementing IWriteStream method
+	virtual void Put( const void* pMem, int size ) 
+	{ 
+		if ( m_file )
+		{
+			fwrite( pMem, size, 1, m_file ); 
+		}
+#ifndef LUA_SDK
+		else
+		{
+			DWORD numBytesWritten;
+			WriteFile( m_hFile, pMem, size, &numBytesWritten, NULL );
+		}
+#else
+		else
+		{
+			filesystem->Write( pMem, size, m_hFile );
+		}
+#endif
+	}
+
+	// Implementing IWriteStream method
+	virtual unsigned int Tell( void ) 
+	{ 
+		if ( m_file )
+		{
+			return ftell( m_file );
+		}
+#ifndef LUA_SDK
+		else
+		{
+			return CWin32File::FileTell( m_hFile );
+		} 
+#else
+		else
+		{
+			return filesystem->Tell( m_hFile );
+		} 
+#endif
+	}
+
+private:
+	FILE	*m_file;
+	HANDLE	m_hFile;
+#ifdef LUA_SDK
+	FileHandle_t	m_fhFile;
+#endif
+};
+
+//-----------------------------------------------------------------------------
+// Purpose: Container for modifiable pak file which is embedded inside the .bsp file
+//  itself.  It's used to allow one-off files to be stored local to the map and it is
+//  hooked into the file system as an override for searching for named files.
+//-----------------------------------------------------------------------------
+class CZipFile
+{
+public:
+	// Construction
+					CZipFile( const char *pDiskCacheWritePath, bool bSortByName );
+					~CZipFile( void );
+
+	// Public API
+	// Clear all existing data
+	void			Reset( void );
+
+	// Add file to zip under relative name
+	void			AddFileToZip( const char *relativename, const char *fullpath );
+
+	// Delete file from zip
+	void			RemoveFileFromZip( const char *relativename );
+
+	// Add buffer to zip as a file with given name
+	void			AddBufferToZip( const char *relativename, void *data, int length, bool bTextMode );
+
+	// Check if a file already exists in the zip.
+	bool			FileExistsInZip( const char *relativename );
+
+	// Reads a file from a zip file
+	bool			ReadFileFromZip( const char *relativename, bool bTextMode, CUtlBuffer &buf );
+	bool			ReadFileFromZip( HANDLE hZipFile, const char *relativename, bool bTextMode, CUtlBuffer &buf );
+
+	// Initialize the zip file from a buffer
+	void			ParseFromBuffer( void *buffer, int bufferlength );
+	HANDLE			ParseFromDisk( const char *pFilename );
+
+	// Estimate the size of the zip file (including header, padding, etc.)
+	unsigned int	EstimateSize();
+
+	// Print out a directory of files in the zip.
+	void			PrintDirectory( void );
+
+	// Use to iterate directory, pass 0 for first element
+	// returns nonzero element id with filled buffer, or -1 at list conclusion
+	int				GetNextFilename( int id, char *pBuffer, int bufferSize, int &fileSize );
+
+	// Write the zip to a buffer
+	void			SaveToBuffer( CUtlBuffer& buffer );
+	// Write the zip to a filestream
+	void			SaveToDisk( FILE *fout );
+#ifndef LUA_SDK
+	void			SaveToDisk( HANDLE hOutFile );
+#else
+	void			SaveToDisk( FileHandle_t fhOutFile );
+#endif
+
+	unsigned int	CalculateSize( void );
+
+	void			ForceAlignment( bool aligned, bool bCompatibleFormat, unsigned int alignmentSize );
+
+	unsigned int	GetAlignment();
+
+	void			SetBigEndian( bool bigEndian );
+	void			ActivateByteSwapping( bool bActivate );
+
+private:
+	enum
+	{
+		MAX_FILES_IN_ZIP = 32768,
+	};
+
+	typedef struct
+	{
+		CUtlSymbol			m_Name;
+		unsigned int		filepos;
+		int					filelen;
+	} TmpFileInfo_t;
+
+	CByteswap		m_Swap;
+	unsigned int	m_AlignmentSize;
+	bool			m_bForceAlignment;
+	bool			m_bCompatibleFormat;
+
+	unsigned short	CalculatePadding( unsigned int filenameLen, unsigned int pos );
+	void			SaveDirectory( IWriteStream& stream );
+	int				MakeXZipCommentString( char *pComment );
+	void			ParseXZipCommentString( const char *pComment );
+	
+	// Internal entry for faster searching, etc.
+	class CZipEntry
+	{
+	public:
+					CZipEntry( void );
+					~CZipEntry( void );
+
+					CZipEntry( const CZipEntry& src );
+
+		// RB tree compare function
+		static bool ZipFileLessFunc( CZipEntry const& src1, CZipEntry const& src2 );
+		static bool ZipFileLessFunc_CaselessSort( CZipEntry const& src1, CZipEntry const& src2 );
+
+		// Name of entry
+		CUtlSymbol		m_Name;
+
+		// Lenth of data element
+		int				m_Length;
+		// Raw data, could be null and data may be in disk write cache
+		void			*m_pData;
+
+		// Offset in Zip ( set and valid during final write )
+		unsigned int	m_ZipOffset;
+		// CRC of blob ( set and valid during final write )
+		CRC32_t			m_ZipCRC;
+
+		// Location of data in disk cache
+		unsigned int	m_DiskCacheOffset;
+		unsigned int	m_SourceDiskOffset;
+	};
+
+	// For fast name lookup and sorting
+	CUtlRBTree< CZipEntry, int > m_Files;
+
+	// Used to buffer zip data, instead of ram
+	bool				m_bUseDiskCacheForWrites;
+	HANDLE				m_hDiskCacheWriteFile;
+	CUtlString			m_DiskCacheName;
+	CUtlString			m_DiskCacheWritePath;
+};
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+//-----------------------------------------------------------------------------
+CZipFile::CZipEntry::CZipEntry( void )
+{
+	m_Name = "";
+	m_Length = 0;
+	m_pData = NULL;
+	m_ZipOffset = 0;
+	m_ZipCRC = 0;
+	m_DiskCacheOffset = 0;
+	m_SourceDiskOffset = 0;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : src - 
+//-----------------------------------------------------------------------------
+CZipFile::CZipEntry::CZipEntry( const CZipFile::CZipEntry& src )
+{
+	m_Name = src.m_Name;
+	m_Length = src.m_Length;
+
+	if ( src.m_Length > 0 && src.m_pData )
+	{
+		m_pData = malloc( src.m_Length );
+		memcpy( m_pData, src.m_pData, src.m_Length );
+	}
+	else
+	{
+		m_pData = NULL;
+	}
+
+	m_ZipOffset = src.m_ZipOffset;
+	m_ZipCRC = src.m_ZipCRC;
+	m_DiskCacheOffset = src.m_DiskCacheOffset;
+	m_SourceDiskOffset = src.m_SourceDiskOffset;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Clear any leftover data
+//-----------------------------------------------------------------------------
+CZipFile::CZipEntry::~CZipEntry( void )
+{
+	if ( m_pData )
+	{
+		free( m_pData );
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Construction
+//-----------------------------------------------------------------------------
+CZipFile::CZipFile( const char *pDiskCacheWritePath, bool bSortByName )
+: m_Files( 0, 32 )
+{
+	m_AlignmentSize = 0;
+	m_bForceAlignment = false;
+	m_bCompatibleFormat = true;
+
+	m_bUseDiskCacheForWrites = ( pDiskCacheWritePath != NULL );
+	m_DiskCacheWritePath = pDiskCacheWritePath;
+	m_hDiskCacheWriteFile = INVALID_HANDLE_VALUE;
+
+	if ( bSortByName )
+	{
+		m_Files.SetLessFunc( CZipEntry::ZipFileLessFunc_CaselessSort );
+	}
+	else
+	{
+		m_Files.SetLessFunc( CZipEntry::ZipFileLessFunc );
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Destroy zip data
+//-----------------------------------------------------------------------------
+CZipFile::~CZipFile( void )
+{
+	m_bUseDiskCacheForWrites = false;
+	Reset();
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Delete all current data
+//-----------------------------------------------------------------------------
+void CZipFile::Reset( void )
+{
+	m_Files.RemoveAll();
+
+	if ( m_hDiskCacheWriteFile != INVALID_HANDLE_VALUE )
+	{
+		CloseHandle( m_hDiskCacheWriteFile );
+		DeleteFile( m_DiskCacheName.String() );
+		m_hDiskCacheWriteFile = INVALID_HANDLE_VALUE;
+	}
+
+	if ( m_bUseDiskCacheForWrites )
+	{
+		m_hDiskCacheWriteFile = CWin32File::CreateTempFile( m_DiskCacheWritePath, m_DiskCacheName );
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Comparison for sorting entries
+// Input  : src1 - 
+//			src2 - 
+// Output : Returns true on success, false on failure.
+//-----------------------------------------------------------------------------
+bool CZipFile::CZipEntry::ZipFileLessFunc( CZipEntry const& src1, CZipEntry const& src2 )
+{
+	return ( src1.m_Name < src2.m_Name );
+}
+
+bool CZipFile::CZipEntry::ZipFileLessFunc_CaselessSort( CZipEntry const& src1, CZipEntry const& src2 )
+{
+	return ( V_stricmp( src1.m_Name.String(), src2.m_Name.String() ) < 0 );
+}
+
+void CZipFile::ForceAlignment( bool bAligned, bool bCompatibleFormat, unsigned int alignment )
+{
+	m_bForceAlignment = bAligned;
+	m_AlignmentSize = alignment;
+	m_bCompatibleFormat = bCompatibleFormat;
+
+	if ( !bAligned )
+	{
+		m_AlignmentSize = 0;
+	}
+	else if ( !IsPowerOfTwo( m_AlignmentSize ) )
+	{
+		m_AlignmentSize = 0;
+	}
+}
+
+unsigned int CZipFile::GetAlignment()
+{
+	if ( !m_bForceAlignment || !m_AlignmentSize )
+	{
+		return 0;
+	}
+
+	return m_AlignmentSize;
+}
+
+void CZipFile::SetBigEndian( bool bigEndian )
+{
+	m_Swap.SetTargetBigEndian( bigEndian );
+}
+
+void CZipFile::ActivateByteSwapping( bool bActivate )
+{
+	m_Swap.ActivateByteSwapping( bActivate );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Load pak file from raw buffer
+// Input  : *buffer - 
+//			bufferlength - 
+//-----------------------------------------------------------------------------
+void CZipFile::ParseFromBuffer( void *buffer, int bufferlength )
+{
+	// Throw away old data
+	Reset();
+
+	// Initialize a buffer
+	CUtlBuffer buf( 0, bufferlength +1  );					// +1 for null termination
+
+	// need to swap bytes, so set the buffer opposite the machine's endian
+	buf.ActivateByteSwapping( m_Swap.IsSwappingBytes() );
+
+	buf.Put( buffer, bufferlength );
+
+	buf.SeekGet( CUtlBuffer::SEEK_TAIL, 0 );
+	unsigned int fileLen = buf.TellGet();
+
+	// Start from beginning
+	buf.SeekGet( CUtlBuffer::SEEK_HEAD, 0 );
+
+	unsigned int offset;
+	ZIP_EndOfCentralDirRecord rec = { 0 };
+
+	bool bFoundEndOfCentralDirRecord = false;
+	for ( offset = fileLen - sizeof( ZIP_EndOfCentralDirRecord ); offset >= 0; offset-- )
+	{
+		buf.SeekGet( CUtlBuffer::SEEK_HEAD, offset );
+		buf.GetObjects( &rec );
+		if ( rec.signature == PKID( 5, 6 ) )
+		{
+			bFoundEndOfCentralDirRecord = true;
+
+			// Set any xzip configuration
+			if ( rec.commentLength )
+			{
+				char commentString[128];
+				int commentLength = min( rec.commentLength, sizeof( commentString ) );
+				buf.Get( commentString, commentLength );
+				commentString[commentLength] = '\0';
+				ParseXZipCommentString( commentString );
+			}
+			break;
+		}
+		else
+		{
+			// wrong record
+			rec.nCentralDirectoryEntries_Total = 0;
+		}
+	}
+	Assert( bFoundEndOfCentralDirRecord );
+	
+	// Make sure there are some files to parse
+	int numzipfiles = rec.nCentralDirectoryEntries_Total;
+	if ( numzipfiles <= 0 )
+	{
+		// No files
+		return;
+	}
+
+	buf.SeekGet( CUtlBuffer::SEEK_HEAD, rec.startOfCentralDirOffset );
+
+	// Allocate space for directory
+	TmpFileInfo_t *newfiles = new TmpFileInfo_t[numzipfiles];
+	Assert( newfiles );
+
+	// build directory
+	int i;
+	for ( i = 0; i < rec.nCentralDirectoryEntries_Total; i++ )
+	{
+		ZIP_FileHeader zipFileHeader;
+		buf.GetObjects( &zipFileHeader );
+		Assert( zipFileHeader.signature == PKID( 1, 2 ) );
+		Assert( zipFileHeader.compressionMethod == 0 );
+		
+		char tmpString[1024];
+		buf.Get( tmpString, zipFileHeader.fileNameLength );
+		tmpString[zipFileHeader.fileNameLength] = '\0';
+		Q_strlower( tmpString );
+
+		// can determine actual filepos, assuming a well formed zip
+		newfiles[i].m_Name = tmpString;
+		newfiles[i].filelen = zipFileHeader.compressedSize;
+		newfiles[i].filepos = zipFileHeader.relativeOffsetOfLocalHeader +
+								sizeof( ZIP_LocalFileHeader ) + 
+								zipFileHeader.fileNameLength + 
+								zipFileHeader.extraFieldLength;
+
+		int nextOffset;
+		if ( m_bCompatibleFormat )
+		{
+			nextOffset = zipFileHeader.extraFieldLength + zipFileHeader.fileCommentLength;
+		}
+		else
+		{
+			nextOffset = 0;
+		}
+		buf.SeekGet( CUtlBuffer::SEEK_CURRENT, nextOffset );
+	}
+
+	// Insert current data into rb tree
+	for ( i=0; i<numzipfiles; i++ )
+	{
+		CZipEntry e;
+		e.m_Name = newfiles[i].m_Name;
+		e.m_Length = newfiles[i].filelen;
+		
+		// Make sure length is reasonable
+		if ( e.m_Length > 0 )
+		{
+			e.m_pData = malloc( e.m_Length );
+
+			// Copy in data
+			buf.SeekGet( CUtlBuffer::SEEK_HEAD, newfiles[i].filepos );
+			buf.Get( e.m_pData, e.m_Length );
+		}
+		else
+		{
+			e.m_pData = NULL;
+		}
+
+		// Add to tree
+		m_Files.Insert( e );
+	}
+
+	// Through away directory
+	delete[] newfiles;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Mount pak file from disk
+//-----------------------------------------------------------------------------
+HANDLE CZipFile::ParseFromDisk( const char *pFilename )
+{
+	HANDLE hFile = CreateFile( pFilename, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
+	if ( !hFile )
+	{
+		// not found
+		return NULL;
+	}	
+
+	unsigned int fileLen = CWin32File::FileSeek( hFile, 0, FILE_END );
+	CWin32File::FileSeek( hFile, 0, FILE_BEGIN );
+	if ( fileLen < sizeof( ZIP_EndOfCentralDirRecord ) )
+	{
+		// bad format
+		CloseHandle( hFile );
+		return NULL;
+	}
+
+	// need to get the central dir
+	unsigned int offset;
+	ZIP_EndOfCentralDirRecord rec = { 0 };
+	for ( offset = fileLen - sizeof( ZIP_EndOfCentralDirRecord ); offset >= 0; offset-- )
+	{
+		CWin32File::FileSeek( hFile, offset, FILE_BEGIN );
+		
+		CWin32File::FileRead( hFile, &rec, sizeof( rec ) );
+		m_Swap.SwapFieldsToTargetEndian( &rec );
+
+		if ( rec.signature == PKID( 5, 6 ) )
+		{
+			// Set any xzip configuration
+			if ( rec.commentLength )
+			{
+				char commentString[128];
+				int commentLength = min( rec.commentLength, sizeof( commentString ) );
+				CWin32File::FileRead( hFile, commentString, commentLength );
+				commentString[commentLength] = '\0';
+				ParseXZipCommentString( commentString );
+			}
+			break;
+		}
+		else
+		{
+			// wrong record
+			rec.nCentralDirectoryEntries_Total = 0;
+		}
+	}
+
+	// Make sure there are some files to parse
+	int numZipFiles = rec.nCentralDirectoryEntries_Total;
+	if ( numZipFiles <= 0 )
+	{
+		// No files
+		CloseHandle( hFile );
+		return NULL;
+	}
+
+	CWin32File::FileSeek( hFile, rec.startOfCentralDirOffset, FILE_BEGIN );
+
+	// read entire central dir into memory
+	CUtlBuffer zipDirBuff( 0, rec.centralDirectorySize, 0 );
+	zipDirBuff.ActivateByteSwapping( m_Swap.IsSwappingBytes() );
+	CWin32File::FileRead( hFile, zipDirBuff.Base(), rec.centralDirectorySize );
+	zipDirBuff.SeekPut( CUtlBuffer::SEEK_HEAD, rec.centralDirectorySize );
+
+	// build directory
+	for ( int i = 0; i < numZipFiles; i++ )
+	{
+		ZIP_FileHeader zipFileHeader;
+		zipDirBuff.GetObjects( &zipFileHeader );
+
+		if ( zipFileHeader.signature != PKID( 1, 2 ) ||  zipFileHeader.compressionMethod != 0 )
+		{
+			// bad contents
+			CloseHandle( hFile );
+			return NULL;
+		}
+		
+		char fileName[1024];
+		zipDirBuff.Get( fileName, zipFileHeader.fileNameLength );
+		fileName[zipFileHeader.fileNameLength] = '\0';
+		Q_strlower( fileName );
+
+		// can determine actual filepos, assuming a well formed zip
+		CZipEntry e;
+		e.m_Name = fileName;
+		e.m_Length = zipFileHeader.compressedSize;
+		e.m_SourceDiskOffset = zipFileHeader.relativeOffsetOfLocalHeader +
+								sizeof( ZIP_LocalFileHeader ) + 
+								zipFileHeader.fileNameLength + 
+								zipFileHeader.extraFieldLength;
+		// Add to tree
+		m_Files.Insert( e );
+
+		int nextOffset;
+		if ( m_bCompatibleFormat )
+		{
+			nextOffset = zipFileHeader.extraFieldLength + zipFileHeader.fileCommentLength;
+		}
+		else
+		{
+			nextOffset = 0;
+		}
+
+		zipDirBuff.SeekGet( CUtlBuffer::SEEK_CURRENT, nextOffset );
+	}
+
+	return hFile;
+}
+
+static int GetLengthOfBinStringAsText( const char *pSrc, int srcSize )
+{
+	const char *pSrcScan = pSrc;
+	const char *pSrcEnd = pSrc + srcSize;
+	int numChars = 0;
+	for( ; pSrcScan < pSrcEnd; pSrcScan++ )
+	{
+		if( *pSrcScan == '\n' )
+		{
+			numChars += 2;
+		}
+		else
+		{
+			numChars++;
+		}
+	}
+	return numChars;
+}
+
+
+//-----------------------------------------------------------------------------
+// Copies text data from a form appropriate for disk to a normal string
+//-----------------------------------------------------------------------------
+static void ReadTextData( const char *pSrc, int nSrcSize, CUtlBuffer &buf )
+{
+	buf.EnsureCapacity( nSrcSize + 1 );
+	const char *pSrcEnd = pSrc + nSrcSize;
+	for ( const char *pSrcScan = pSrc; pSrcScan < pSrcEnd; ++pSrcScan )
+	{
+		if ( *pSrcScan == '\r' )
+		{
+			if ( pSrcScan[1] == '\n' )
+			{
+				buf.PutChar( '\n' );
+				++pSrcScan;
+				continue;
+			}
+		}
+
+		buf.PutChar( *pSrcScan );
+	}
+	
+	// Null terminate
+	buf.PutChar( '\0' );
+}
+
+
+//-----------------------------------------------------------------------------
+// Copies text data into a form appropriate for disk
+//-----------------------------------------------------------------------------
+static void CopyTextData( char *pDst, const char *pSrc, int dstSize, int srcSize )
+{
+	const char *pSrcScan = pSrc;
+	const char *pSrcEnd = pSrc + srcSize;
+	char *pDstScan = pDst;
+
+#ifdef _DEBUG
+	char *pDstEnd = pDst + dstSize;
+#endif
+
+	for ( ; pSrcScan < pSrcEnd; pSrcScan++ )
+	{
+		if ( *pSrcScan == '\n' )
+		{
+			*pDstScan = '\r';
+			pDstScan++;
+			*pDstScan = '\n';
+			pDstScan++;
+		}
+		else
+		{
+			*pDstScan = *pSrcScan;
+			pDstScan++;
+		}
+	}
+	Assert( pSrcScan == pSrcEnd );
+	Assert( pDstScan == pDstEnd );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Adds a new lump, or overwrites existing one
+// Input  : *relativename - 
+//			*data - 
+//			length - 
+//-----------------------------------------------------------------------------
+void CZipFile::AddBufferToZip( const char *relativename, void *data, int length, bool bTextMode )
+{
+	// Lower case only
+	char name[512];
+	Q_strcpy( name, relativename );
+	Q_strlower( name );
+
+	int dstLength = length;
+	if ( bTextMode )
+	{
+		dstLength = GetLengthOfBinStringAsText( ( const char * )data, length );
+	}
+	
+	// See if entry is in list already
+	CZipEntry e;
+	e.m_Name = name;
+	int index = m_Files.Find( e );
+
+	// If already existing, throw away old data and update data and length
+	if ( index != m_Files.InvalidIndex() )
+	{
+		CZipEntry *update = &m_Files[ index ];
+		if ( update->m_pData )
+		{
+			free( update->m_pData );
+		}
+
+		if ( bTextMode )
+		{
+			update->m_pData = malloc( dstLength );
+			CopyTextData( ( char * )update->m_pData, ( char * )data, dstLength, length );
+			update->m_Length = dstLength;
+		}
+		else
+		{
+			update->m_pData = malloc( length );
+			memcpy( update->m_pData, data, length );
+			update->m_Length = length;
+		}
+
+		if ( m_hDiskCacheWriteFile != INVALID_HANDLE_VALUE )
+		{
+			update->m_DiskCacheOffset = CWin32File::FileTell( m_hDiskCacheWriteFile );
+			CWin32File::FileWrite( m_hDiskCacheWriteFile, update->m_pData, update->m_Length );
+			free( update->m_pData );
+			update->m_pData = NULL;
+		}
+	}
+	else
+	{
+		// Create a new entry
+		e.m_Length = dstLength;
+		if ( dstLength > 0 )
+		{
+			if ( bTextMode )
+			{
+				e.m_pData = malloc( dstLength );
+				CopyTextData( (char *)e.m_pData, ( char * )data, dstLength, length );
+			}
+			else
+			{
+				e.m_pData = malloc( length );
+				memcpy( e.m_pData, data, length );
+			}
+	
+			if ( m_hDiskCacheWriteFile != INVALID_HANDLE_VALUE )
+			{
+				e.m_DiskCacheOffset = CWin32File::FileTell( m_hDiskCacheWriteFile );
+				CWin32File::FileWrite( m_hDiskCacheWriteFile, e.m_pData, e.m_Length );
+				free( e.m_pData );
+				e.m_pData = NULL;
+			}
+		}
+		else
+		{
+			e.m_pData = NULL;
+		}
+
+		m_Files.Insert( e );
+	}
+}
+
+
+//-----------------------------------------------------------------------------
+// Reads a file from the zip
+//-----------------------------------------------------------------------------
+bool CZipFile::ReadFileFromZip( const char *pRelativeName, bool bTextMode, CUtlBuffer &buf )
+{
+	// Lower case only
+	char pName[512];
+	Q_strncpy( pName, pRelativeName, 512 );
+	Q_strlower( pName );
+
+	// See if entry is in list already
+	CZipEntry e;
+	e.m_Name = pName;
+	int nIndex = m_Files.Find( e );
+	if ( nIndex == m_Files.InvalidIndex() )
+	{
+		// not found
+		return false;
+	}
+
+	CZipEntry *pEntry = &m_Files[ nIndex ];
+	if ( bTextMode )
+	{
+		buf.SetBufferType( true, false );
+		ReadTextData( (char*)pEntry->m_pData, pEntry->m_Length, buf );
+	}
+	else
+	{
+		buf.SetBufferType( false, false );
+		buf.Put( pEntry->m_pData, pEntry->m_Length );
+	}
+
+	return true;
+}
+
+//-----------------------------------------------------------------------------
+// Reads a file from the zip
+//-----------------------------------------------------------------------------
+bool CZipFile::ReadFileFromZip( HANDLE hZipFile, const char *pRelativeName, bool bTextMode, CUtlBuffer &buf )
+{
+	// Lower case only
+	char pName[512];
+	Q_strncpy( pName, pRelativeName, 512 );
+	Q_strlower( pName );
+
+	// See if entry is in list already
+	CZipEntry e;
+	e.m_Name = pName;
+	int nIndex = m_Files.Find( e );
+	if ( nIndex == m_Files.InvalidIndex() )
+	{
+		// not found
+		return false;
+	}
+
+	CZipEntry *pEntry = &m_Files[nIndex];
+
+	void *pData = malloc( pEntry->m_Length );
+	CWin32File::FileSeek( hZipFile, pEntry->m_SourceDiskOffset, FILE_BEGIN );
+	if ( !CWin32File::FileRead( hZipFile, pData, pEntry->m_Length ) )
+	{
+		free( pData );
+		return false;
+	}
+
+	if ( bTextMode )
+	{
+		buf.SetBufferType( true, false );
+		ReadTextData( (const char *)pData, pEntry->m_Length, buf );
+	}
+	else
+	{
+		buf.SetBufferType( false, false );
+		buf.Put( pData, pEntry->m_Length );
+	}
+
+	free( pData );
+
+	return true;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Check if a file already exists in the zip.
+// Input  : *relativename - 
+//-----------------------------------------------------------------------------
+bool CZipFile::FileExistsInZip( const char *pRelativeName )
+{
+	// Lower case only
+	char pName[512];
+	Q_strncpy( pName, pRelativeName, 512 );
+	Q_strlower( pName );
+
+	// See if entry is in list already
+	CZipEntry e;
+	e.m_Name = pName;
+	int nIndex = m_Files.Find( e );
+
+	// If it is, then it exists in the pack!
+	return nIndex != m_Files.InvalidIndex();
+}
+
+
+//-----------------------------------------------------------------------------
+// Purpose: Adds a new file to the zip.
+//-----------------------------------------------------------------------------
+void CZipFile::AddFileToZip( const char *relativename, const char *fullpath )
+{
+#ifndef LUA_SDK
+	FILE *temp = fopen( fullpath, "rb" );
+#else
+	FileHandle_t temp = filesystem->Open( fullpath, "rb" );
+#endif
+	if ( !temp )
+		return;
+
+	// Determine length
+#ifndef LUA_SDK
+	fseek( temp, 0, SEEK_END );
+	int size = ftell( temp );
+	fseek( temp, 0, SEEK_SET );
+#else
+	filesystem->Seek( temp, 0, FILESYSTEM_SEEK_TAIL );
+	int size = filesystem->Tell( temp );
+	filesystem->Seek( temp, 0, FILESYSTEM_SEEK_HEAD );
+#endif
+	byte *buf = (byte *)malloc( size + 1 );
+
+	// Read data
+#ifndef LUA_SDK
+	fread( buf, size, 1, temp );
+	fclose( temp );
+#else
+	filesystem->Read( buf, size, temp );
+	filesystem->Close( temp );
+#endif
+
+	// Now add as a buffer
+	AddBufferToZip( relativename, buf, size, false );
+	
+	free( buf );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Removes a file from the zip.
+//-----------------------------------------------------------------------------
+void CZipFile::RemoveFileFromZip( const char *relativename )
+{
+	CZipEntry e;
+	e.m_Name = relativename;
+	int index = m_Files.Find( e );
+
+	if ( index != m_Files.InvalidIndex() )
+	{
+		CZipEntry update = m_Files[index];
+		m_Files.Remove( update );
+	}
+}
+
+//---------------------------------------------------------------
+//	Purpose: Calculates how many bytes should be added to the extra field
+//  to push the start of the file data to the next aligned boundary
+//  Output: Required padding size
+//---------------------------------------------------------------
+unsigned short CZipFile::CalculatePadding( unsigned int filenameLen, unsigned int pos )
+{
+	if ( m_AlignmentSize == 0 )
+	{
+		return 0;
+	}
+	
+	unsigned int headerSize = sizeof( ZIP_LocalFileHeader ) + filenameLen;
+	return (unsigned short)( m_AlignmentSize - ( ( pos + headerSize ) % m_AlignmentSize ) );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Create the XZIP identifying comment string
+// Output : Length
+//-----------------------------------------------------------------------------
+int CZipFile::MakeXZipCommentString( char *pCommentString )
+{
+	char tempString[XZIP_COMMENT_LENGTH];
+
+	memset( tempString, 0, sizeof( tempString ) );
+	V_snprintf( tempString, sizeof( tempString ), "XZP%c %d", m_bCompatibleFormat ? '1' : '2', m_AlignmentSize );
+	if ( pCommentString )
+	{
+		memcpy( pCommentString, tempString, sizeof( tempString ) );
+	}
+
+	// expected fixed length
+	return XZIP_COMMENT_LENGTH;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: An XZIP has its configuration in the ascii comment
+//-----------------------------------------------------------------------------
+void CZipFile::ParseXZipCommentString( const char *pCommentString )
+{
+	if ( !V_strnicmp( pCommentString, "XZP", 3 ) )
+	{
+		m_bCompatibleFormat = true;
+		if ( pCommentString[3] == '2' )
+		{
+			m_bCompatibleFormat = false;
+		}
+
+		// parse out the alignement configuration
+		if ( !m_bForceAlignment )
+		{
+			m_AlignmentSize = 0;
+			sscanf( pCommentString + 4, "%d", &m_AlignmentSize );
+			if ( !IsPowerOfTwo( m_AlignmentSize ) )
+			{
+				m_AlignmentSize = 0;
+			}
+		}
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Calculate the exact size of zip file, with headers and padding
+// Output : int
+//-----------------------------------------------------------------------------
+unsigned int CZipFile::CalculateSize( void )
+{
+	unsigned int size = 0;
+	unsigned int dirHeaders = 0;
+	for ( int i = m_Files.FirstInorder(); i != m_Files.InvalidIndex(); i = m_Files.NextInorder( i ) )
+	{
+		CZipEntry *e = &m_Files[ i ];
+		
+		if ( e->m_Length == 0 )
+			continue;
+
+		// local file header
+		size += sizeof( ZIP_LocalFileHeader );
+		size += strlen( e->m_Name.String() );
+
+		// every file has a directory header that duplicates the filename 
+		dirHeaders += sizeof( ZIP_FileHeader ) + strlen( e->m_Name.String() );
+
+		// calculate padding
+		if ( m_AlignmentSize != 0 )
+		{
+			// round up to next boundary
+			unsigned int nextBoundary = ( size + m_AlignmentSize ) & ~( m_AlignmentSize - 1 );
+			
+			// the directory header also duplicates the padding
+			dirHeaders += nextBoundary - size;
+
+			size = nextBoundary;
+		}
+
+		// data size
+		size += e->m_Length;
+	}
+
+	size += dirHeaders;
+
+	// All processed zip files will have a comment string
+	size += sizeof( ZIP_EndOfCentralDirRecord ) + MakeXZipCommentString( NULL );
+
+	return size;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Print a directory of files in the zip
+//-----------------------------------------------------------------------------
+void CZipFile::PrintDirectory( void )
+{
+	for ( int i = m_Files.FirstInorder(); i != m_Files.InvalidIndex(); i = m_Files.NextInorder( i ) )
+	{
+		CZipEntry *e = &m_Files[ i ];
+
+		Msg( "%s\n", e->m_Name.String() );
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Iterate through directory
+//-----------------------------------------------------------------------------
+int CZipFile::GetNextFilename( int id, char *pBuffer, int bufferSize, int &fileSize )
+{
+	if ( id == -1 )
+	{
+		id = m_Files.FirstInorder();
+	}
+	else
+	{
+		id = m_Files.NextInorder( id );
+	}
+	if ( id == m_Files.InvalidIndex() )
+	{
+		// list is empty
+		return -1;
+	}
+
+	CZipEntry *e = &m_Files[id];
+
+	Q_strncpy( pBuffer, e->m_Name.String(), bufferSize );
+	fileSize = e->m_Length;
+
+	return id;
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Store data out to disk
+//-----------------------------------------------------------------------------
+void CZipFile::SaveToDisk( FILE *fout )
+{
+	CFileStream stream( fout );
+	SaveDirectory( stream );
+}
+
+#ifndef LUA_SDK
+void CZipFile::SaveToDisk( HANDLE hOutFile )
+{
+	CFileStream stream( hOutFile );
+	SaveDirectory( stream );
+}
+#else
+void CZipFile::SaveToDisk( FileHandle_t fhOutFile )
+{
+	CFileStream stream( fhOutFile );
+	SaveDirectory( stream );
+}
+#endif
+
+//-----------------------------------------------------------------------------
+// Purpose: Store data out to a CUtlBuffer
+//-----------------------------------------------------------------------------
+void CZipFile::SaveToBuffer( CUtlBuffer& buf )
+{
+	CBufferStream stream( buf );
+	SaveDirectory( stream );
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: Store data back out to a stream (could be CUtlBuffer or filestream)
+//-----------------------------------------------------------------------------
+void CZipFile::SaveDirectory( IWriteStream& stream )
+{
+	void *pPaddingBuffer = NULL;
+	if ( m_AlignmentSize )
+	{
+		// get a temp buffer for all padding work
+		pPaddingBuffer = malloc( m_AlignmentSize );
+		memset( pPaddingBuffer, 0x00, m_AlignmentSize );
+	}
+
+	if ( m_hDiskCacheWriteFile != INVALID_HANDLE_VALUE )
+	{
+		FlushFileBuffers( m_hDiskCacheWriteFile );
+	}
+
+	int i;
+	for ( i = m_Files.FirstInorder(); i != m_Files.InvalidIndex(); i = m_Files.NextInorder( i ) )
+	{
+		CZipEntry *e = &m_Files[i];
+		Assert( e );
+
+		// Fix up the offset
+		e->m_ZipOffset = stream.Tell();
+
+		if ( e->m_Length > 0 && ( m_hDiskCacheWriteFile != INVALID_HANDLE_VALUE ) )
+		{	
+			// get the data back from the write cache
+			e->m_pData = malloc( e->m_Length );
+			if ( e->m_pData )
+			{
+				CWin32File::FileSeek( m_hDiskCacheWriteFile, e->m_DiskCacheOffset, FILE_BEGIN );
+				CWin32File::FileRead( m_hDiskCacheWriteFile, e->m_pData, e->m_Length );
+			}
+		}
+
+		if ( e->m_Length > 0 && e->m_pData != NULL )
+		{
+			ZIP_LocalFileHeader hdr = { 0 };
+			hdr.signature = PKID( 3, 4 );
+			hdr.versionNeededToExtract = 10;  // This is the version that the winzip that I have writes.
+			hdr.flags = 0;
+			hdr.compressionMethod = 0; // NO COMPRESSION!
+			hdr.lastModifiedTime = 0;
+			hdr.lastModifiedDate = 0;
+
+			CRC32_Init( &e->m_ZipCRC );
+			CRC32_ProcessBuffer( &e->m_ZipCRC, e->m_pData, e->m_Length );
+			CRC32_Final( &e->m_ZipCRC );
+			hdr.crc32 = e->m_ZipCRC;
+			
+			const char *pFilename = e->m_Name.String();
+			hdr.compressedSize = e->m_Length;
+			hdr.uncompressedSize = e->m_Length;
+			hdr.fileNameLength = strlen( pFilename );
+			hdr.extraFieldLength = CalculatePadding( hdr.fileNameLength, e->m_ZipOffset );
+			int extraFieldLength = hdr.extraFieldLength;
+			
+			// Swap header in place
+			m_Swap.SwapFieldsToTargetEndian( &hdr );
+			stream.Put( &hdr, sizeof( hdr ) );
+			stream.Put( pFilename, strlen( pFilename ) );
+			stream.Put( pPaddingBuffer, extraFieldLength );
+			stream.Put( e->m_pData, e->m_Length );
+
+			if ( m_hDiskCacheWriteFile != INVALID_HANDLE_VALUE )
+			{
+				free( e->m_pData );
+
+				// temp hackery for the logic below to succeed
+				e->m_pData = (void*)0xFFFFFFFF;
+			}
+		}
+	}
+
+	if ( m_hDiskCacheWriteFile != INVALID_HANDLE_VALUE )
+	{
+		CWin32File::FileSeek( m_hDiskCacheWriteFile, 0, FILE_END );
+	}
+
+	unsigned int centralDirStart = stream.Tell();
+	if ( m_AlignmentSize )
+	{
+		// align the central directory starting position
+		unsigned int newDirStart = AlignValue( centralDirStart, m_AlignmentSize );
+		int padLength = newDirStart - centralDirStart;
+		if ( padLength )
+		{
+			stream.Put( pPaddingBuffer, padLength );
+			centralDirStart = newDirStart;
+		}
+	}
+
+	int realNumFiles = 0;
+	for ( i = m_Files.FirstInorder(); i != m_Files.InvalidIndex(); i = m_Files.NextInorder( i ) )
+	{
+		CZipEntry *e = &m_Files[i];
+		Assert( e );
+		
+		if ( e->m_Length > 0 && e->m_pData != NULL )
+		{
+			ZIP_FileHeader hdr = { 0 };
+			hdr.signature = PKID( 1, 2 );
+			hdr.versionMadeBy = 20;				// This is the version that the winzip that I have writes.
+			hdr.versionNeededToExtract = 10;	// This is the version that the winzip that I have writes.
+			hdr.flags = 0;
+			hdr.compressionMethod = 0;
+			hdr.lastModifiedTime = 0;
+			hdr.lastModifiedDate = 0;
+			hdr.crc32 = e->m_ZipCRC;
+
+			hdr.compressedSize = e->m_Length;
+			hdr.uncompressedSize = e->m_Length;
+			hdr.fileNameLength = strlen( e->m_Name.String() );
+			hdr.extraFieldLength = CalculatePadding( hdr.fileNameLength, e->m_ZipOffset );
+			hdr.fileCommentLength = 0;
+			hdr.diskNumberStart = 0;
+			hdr.internalFileAttribs = 0;
+			hdr.externalFileAttribs = 0; // This is usually something, but zero is OK as if the input came from stdin
+			hdr.relativeOffsetOfLocalHeader = e->m_ZipOffset;
+			int extraFieldLength = hdr.extraFieldLength;
+
+			// Swap the header in place
+			m_Swap.SwapFieldsToTargetEndian( &hdr );
+			stream.Put( &hdr, sizeof( hdr ) );
+			stream.Put( e->m_Name.String(), strlen( e->m_Name.String() ) );
+			if ( m_bCompatibleFormat )
+			{
+				stream.Put( pPaddingBuffer, extraFieldLength );
+			}
+
+			realNumFiles++;
+
+			if ( m_hDiskCacheWriteFile != INVALID_HANDLE_VALUE )
+			{
+				// clear out temp hackery
+				e->m_pData = NULL;
+			}
+		}
+	}
+
+	unsigned int centralDirEnd = stream.Tell();
+	if ( m_AlignmentSize )
+	{
+		// align the central directory starting position
+		unsigned int newDirEnd = AlignValue( centralDirEnd, m_AlignmentSize );
+		int padLength = newDirEnd - centralDirEnd;
+		if ( padLength )
+		{
+			stream.Put( pPaddingBuffer, padLength );
+			centralDirEnd = newDirEnd;
+		}
+	}
+
+	ZIP_EndOfCentralDirRecord rec = { 0 };
+	rec.signature = PKID( 5, 6 );
+	rec.numberOfThisDisk = 0;
+	rec.numberOfTheDiskWithStartOfCentralDirectory = 0;
+	rec.nCentralDirectoryEntries_ThisDisk = realNumFiles;
+	rec.nCentralDirectoryEntries_Total = realNumFiles;
+	rec.centralDirectorySize = centralDirEnd - centralDirStart;
+	rec.startOfCentralDirOffset = centralDirStart;
+
+	char commentString[128];
+	int commentLength = MakeXZipCommentString( commentString );
+	rec.commentLength = commentLength;
+
+	// Swap the header in place
+	m_Swap.SwapFieldsToTargetEndian( &rec );
+	stream.Put( &rec, sizeof( rec ) );
+	stream.Put( commentString, commentLength );
+
+	if ( pPaddingBuffer )
+	{
+		free( pPaddingBuffer );
+	}
+}
+
+class CZip : public IZip
+{
+public:
+	CZip( const char *pDiskCacheWritePath, bool bSortByName );
+	virtual ~CZip();
+
+	virtual void			Reset();
+
+	// Add a single file to a zip - maintains the zip's previous alignment state
+	virtual void			AddFileToZip( const char *relativename, const char *fullpath );
+
+	// Whether a file is contained in a zip - maintains alignment
+	virtual bool			FileExistsInZip( const char *pRelativeName );
+
+	// Reads a file from the zip - maintains alignement
+	virtual bool			ReadFileFromZip( const char *pRelativeName, bool bTextMode, CUtlBuffer &buf );
+	virtual bool			ReadFileFromZip( HANDLE hZipFile, const char *relativename, bool bTextMode, CUtlBuffer &buf );
+
+	// Removes a single file from the zip - maintains alignment
+	virtual void			RemoveFileFromZip( const char *relativename );
+
+	// Gets next filename in zip, for walking the directory - maintains alignment
+	virtual int				GetNextFilename( int id, char *pBuffer, int bufferSize, int &fileSize );
+
+	// Prints the zip's contents - maintains alignment
+	virtual void			PrintDirectory( void );
+
+	// Estimate the size of the Zip (including header, padding, etc.)
+	virtual unsigned int	EstimateSize( void );
+
+	// Add buffer to zip as a file with given name - uses current alignment size, default 0 (no alignment)
+	virtual void			AddBufferToZip( const char *relativename, void *data, int length, bool bTextMode );
+
+	// Writes out zip file to a buffer - uses current alignment size 
+	// (set by file's previous alignment, or a call to ForceAlignment)
+	virtual void			SaveToBuffer( CUtlBuffer& outbuf );
+
+	// Writes out zip file to a filestream - uses current alignment size 
+	// (set by file's previous alignment, or a call to ForceAlignment)
+	virtual void			SaveToDisk( FILE *fout );
+	virtual void			SaveToDisk( HANDLE hOutFile );
+
+	// Reads a zip file from a buffer into memory - sets current alignment size to 
+	// the file's alignment size, unless overridden by a ForceAlignment call)
+	virtual void			ParseFromBuffer( void *buffer, int bufferlength );
+	virtual HANDLE			ParseFromDisk( const char *pFilename );
+
+	// Forces a specific alignment size for all subsequent file operations, overriding files' previous alignment size.
+	// Return to using files' individual alignment sizes by passing FALSE.
+	virtual void			ForceAlignment( bool aligned, bool bCompatibleFormat, unsigned int alignmentSize );
+
+	// Sets the endianess of the zip
+	virtual void			SetBigEndian( bool bigEndian );
+	virtual void			ActivateByteSwapping( bool bActivate );
+
+	virtual unsigned int	GetAlignment();
+
+private:
+	CZipFile				m_ZipFile;
+};
+
+static CUtlLinkedList< CZip* > g_ZipUtils;
+
+IZip *IZip::CreateZip( const char *pDiskCacheWritePath, bool bSortByName )
+{ 
+	CZip *pZip = new CZip( pDiskCacheWritePath, bSortByName );
+	g_ZipUtils.AddToTail( pZip );
+
+	return pZip; 
+}
+
+void IZip::ReleaseZip( IZip *pZip )
+{
+	g_ZipUtils.FindAndRemove( (CZip *)pZip );
+
+	delete ((CZip *)pZip);
+}
+
+CZip::CZip( const char *pDiskCacheWritePath, bool bSortByName ) : m_ZipFile( pDiskCacheWritePath, bSortByName )
+{
+	m_ZipFile.Reset();
+}
+
+CZip::~CZip()
+{
+}
+
+void CZip::SetBigEndian( bool bigEndian )
+{
+	m_ZipFile.SetBigEndian( bigEndian );
+}
+
+void CZip::ActivateByteSwapping( bool bActivate )
+{
+	m_ZipFile.ActivateByteSwapping( bActivate );
+}
+
+void CZip::AddFileToZip( const char *relativename, const char *fullpath )
+{
+	m_ZipFile.AddFileToZip( relativename, fullpath );
+}
+
+bool CZip::FileExistsInZip( const char *pRelativeName )
+{
+	return m_ZipFile.FileExistsInZip( pRelativeName );
+}
+
+bool CZip::ReadFileFromZip( const char *pRelativeName, bool bTextMode, CUtlBuffer &buf )
+{
+	return m_ZipFile.ReadFileFromZip( pRelativeName, bTextMode, buf );
+}
+
+bool CZip::ReadFileFromZip( HANDLE hZipFile, const char *pRelativeName, bool bTextMode, CUtlBuffer &buf )
+{
+	return m_ZipFile.ReadFileFromZip( hZipFile, pRelativeName, bTextMode, buf );
+}
+
+void CZip::RemoveFileFromZip( const char *relativename )
+{
+	m_ZipFile.RemoveFileFromZip( relativename );
+}
+
+int	CZip::GetNextFilename( int id, char *pBuffer, int bufferSize, int &fileSize )
+{
+	return m_ZipFile.GetNextFilename( id, pBuffer, bufferSize, fileSize );
+}
+
+void CZip::PrintDirectory( void )
+{
+	m_ZipFile.PrintDirectory();
+}
+
+void CZip::Reset()
+{
+	m_ZipFile.Reset();
+}
+
+unsigned int CZip::EstimateSize( void )
+{
+	return m_ZipFile.CalculateSize();
+}
+
+// Add buffer to zip as a file with given name
+void CZip::AddBufferToZip( const char *relativename, void *data, int length, bool bTextMode )
+{
+	m_ZipFile.AddBufferToZip( relativename, data, length, bTextMode );
+}
+
+void CZip::SaveToBuffer( CUtlBuffer& outbuf )
+{
+	m_ZipFile.SaveToBuffer( outbuf );
+}
+
+void CZip::SaveToDisk( FILE *fout )
+{
+	m_ZipFile.SaveToDisk( fout );
+}
+
+#ifndef LUA_SDK
+void CZip::SaveToDisk( HANDLE hOutFile )
+{
+	m_ZipFile.SaveToDisk( hOutFile );
+}
+#else
+void CZip::SaveToDisk( FileHandle_t fhOutFile )
+{
+	m_ZipFile.SaveToDisk( fhOutFile );
+}
+#endif
+
+void CZip::ParseFromBuffer( void *buffer, int bufferlength )
+{
+	m_ZipFile.Reset();
+	m_ZipFile.ParseFromBuffer( buffer, bufferlength );
+}
+
+HANDLE CZip::ParseFromDisk( const char *pFilename )
+{
+	m_ZipFile.Reset();
+	return m_ZipFile.ParseFromDisk( pFilename );
+}
+
+void CZip::ForceAlignment( bool aligned, bool bCompatibleFormat, unsigned int alignmentSize )
+{
+	m_ZipFile.ForceAlignment( aligned, bCompatibleFormat, alignmentSize );
+}
+
+unsigned int CZip::GetAlignment()
+{
+	return m_ZipFile.GetAlignment();
+}
+
+#endif // SWDS
